sol_name,ref,code
7089-1.sol,question,"contract multiowned { struct PendingState { uint yetNeeded; uint ownersDone; uint index; } event Confirmation(address owner, bytes32 operation); event Revoke(address owner, bytes32 operation); event OwnerChanged(address oldOwner, address newOwner); event OwnerAdded(address newOwner); event OwnerRemoved(address oldOwner); event RequirementChanged(uint newRequirement); modifier onlyowner { if (isOwner(msg.sender)) _ } modifier onlymanyowners(bytes32 _operation) { if (confirmAndCheck(_operation)) _ } function multiowned(address[] _owners, uint _required) { m_numOwners = _owners.length + 1; m_owners[1] = uint(msg.sender); m_ownerIndex[uint(msg.sender)] = 1; for (uint i = 0; i < _owners.length; ++i) { m_owners[2 + i] = uint(_owners[i]); m_ownerIndex[uint(_owners[i])] = 2 + i; } m_required = _required; } function revoke(bytes32 _operation) external { uint ownerIndex = m_ownerIndex[uint(msg.sender)]; if (ownerIndex == 0) return; uint ownerIndexBit = 2**ownerIndex; var pending = m_pending[_operation]; if (pending.ownersDone & ownerIndexBit > 0) { pending.yetNeeded++; pending.ownersDone -= ownerIndexBit; Revoke(msg.sender, _operation); } } function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external { if (isOwner(_to)) return; uint ownerIndex = m_ownerIndex[uint(_from)]; if (ownerIndex == 0) return; clearPending(); m_owners[ownerIndex] = uint(_to); m_ownerIndex[uint(_from)] = 0; m_ownerIndex[uint(_to)] = ownerIndex; OwnerChanged(_from, _to); } function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external { if (isOwner(_owner)) return; clearPending(); if (m_numOwners >= c_maxOwners) reorganizeOwners(); if (m_numOwners >= c_maxOwners) return; m_numOwners++; m_owners[m_numOwners] = uint(_owner); m_ownerIndex[uint(_owner)] = m_numOwners; OwnerAdded(_owner); } function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external { uint ownerIndex = m_ownerIndex[uint(_owner)]; if (ownerIndex == 0) return; if (m_required > m_numOwners - 1) return; m_owners[ownerIndex] = 0; m_ownerIndex[uint(_owner)] = 0; clearPending(); reorganizeOwners(); OwnerRemoved(_owner); } function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external { if (_newRequired > m_numOwners) return; m_required = _newRequired; clearPending(); RequirementChanged(_newRequired); } function isOwner(address _addr) returns (bool) { return m_ownerIndex[uint(_addr)] > 0; } function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) { var pending = m_pending[_operation]; uint ownerIndex = m_ownerIndex[uint(_owner)]; if (ownerIndex == 0) return false; uint ownerIndexBit = 2**ownerIndex; if (pending.ownersDone & ownerIndexBit == 0) { return false; } else { return true; } } function confirmAndCheck(bytes32 _operation) internal returns (bool) { uint ownerIndex = m_ownerIndex[uint(msg.sender)]; if (ownerIndex == 0) return; var pending = m_pending[_operation]; if (pending.yetNeeded == 0) { pending.yetNeeded = m_required; pending.ownersDone = 0; pending.index = m_pendingIndex.length++; m_pendingIndex[pending.index] = _operation; } uint ownerIndexBit = 2**ownerIndex; if (pending.ownersDone & ownerIndexBit == 0) { Confirmation(msg.sender, _operation); if (pending.yetNeeded <= 1) { delete m_pendingIndex[m_pending[_operation].index]; delete m_pending[_operation]; return true; } else { pending.yetNeeded--; pending.ownersDone |= ownerIndexBit; } } } function reorganizeOwners() private returns (bool) { uint free = 1; while (free < m_numOwners) { while (free < m_numOwners && m_owners[free] != 0) free++; while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--; if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0) { m_owners[free] = m_owners[m_numOwners]; m_ownerIndex[m_owners[free]] = free; m_owners[m_numOwners] = 0; } } } function clearPending() internal { uint length = m_pendingIndex.length; for (uint i = 0; i < length; ++i) if (m_pendingIndex[i] != 0) delete m_pending[m_pendingIndex[i]]; delete m_pendingIndex; } uint public m_required; uint public m_numOwners; uint[256] m_owners; uint constant c_maxOwners = 250; mapping(uint => uint) m_ownerIndex; mapping(bytes32 => PendingState) m_pending; bytes32[] m_pendingIndex; }"
7089-1.sol,question,"contract daylimit is multiowned { modifier limitedDaily(uint _value) { if (underLimit(_value)) _ } function daylimit(uint _limit) { m_dailyLimit = _limit; m_lastDay = today(); } function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external { m_dailyLimit = _newLimit; } function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external { m_spentToday = 0; } function underLimit(uint _value) internal onlyowner returns (bool) { if (today() > m_lastDay) { m_spentToday = 0; m_lastDay = today(); } if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) { m_spentToday += _value; return true; } return false; } function today() private constant returns (uint) { return now / 1 days; } uint public m_dailyLimit; uint public m_spentToday; uint public m_lastDay; }"
7089-1.sol,question,"contract multisig { event Deposit(address from, uint value); event SingleTransact(address owner, uint value, address to, bytes data); event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data); event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data); function changeOwner(address _from, address _to) external; function execute(address _to, uint _value, bytes _data) external returns (bytes32); function confirm(bytes32 _h) returns (bool); }"
27167-0.sol,question,"contract MyContract {

        bytes32  public custName;
        bytes32  public custLoc;
        address public docAddress = this;

        function MyContract () {

            custName = ""0xDEFAULT"";
            custLoc  = ""0xDEFAULT"";

        }

        event LogNewCust (address _address, bytes32 _custName, bytes32 _custLoc);

        function AssignAttributes (bytes32 _custName, bytes32 _custLoc)  
            returns (bool isSuccess) {

            custName    = _custName;
            custLoc     = _custLoc;

            LogNewCust(docAddress,custName,custLoc);

            return true;

        }

    }"
33837-0.sol,question,"contract Casino {


    uint minimumBet;
    uint totalBet;
    uint numberOfBets;
    uint maximumAmountsOfBets = 100;
    address[] players;

    struct Player {

        uint amountBet;
        uint numberSelected;
    }


    mapping(address => Player) playerInfo;


    address owner; 


    function Casino(uint _minimumBet) public{  
        

        owner = msg.sender;
        if(_minimumBet !=0) minimumBet = _minimumBet;

        }

        


    function bet(uint number) payable public {

        require(checkPlayerExists(msg.sender) );
        require(number >= 1 && number <= 10);
        require(msg.value >= minimumBet);


        playerInfo[msg.sender].amountBet = msg.value;
        playerInfo[msg.sender].numberSelected = number;
        numberOfBets += 1;
        players.push(msg.sender);
        totalBet += msg.value;

        if(numberOfBets >= maximumAmountsOfBets) generateNumberWinner();


        }



    function checkPlayerExists(address player) public view returns(bool) {

        for( uint i = 0 ; i < players.length; i++){
            if(players[i] == player) return true;
        }
        return false;
    }


    

    function generateNumberWinner() public{

        uint numberGenerated = block.number % 10 + 1; 

        distributePrizes(numberGenerated);
    }


    

    function distributePrizes(uint numberWinner) public {

        address[100] memory winners ; 

        uint count = 0; 

        for(uint i = 0; i < players.length ; i++) {
            address playerAddress = players[i];
            if(playerInfo[playerAddress].numberSelected == numberWinner){
                winners[count] = playerAddress;
                count ++;
            }
            delete playerInfo[playerAddress]; 


        }

        players.length = 0; 

        uint winnerEtherAmount = totalBet / winners.length; 

        for(uint j = 0; j < count; j++) {

            if(winners[j] !=address(0)) 
            winners[j].transfer(winnerEtherAmount);
        }


    }

    
    function() payable private{}



    function kill() private{ 

        if(msg.sender == owner)
            selfdestruct(owner);
    }
}"
10078-0.sol,question,"contract TestContract {
    function foo() returns (uint) {
        uint b = 3+5;
        
    }
}"
9000-0.sol,question,"contract Example {

    uint256 num;
    address parent;

    function Example(uint256 _num, address _parent) {
        num = _num;
        parent = _parent;
    }

    function createChild() {
        uint256 childNum = num + 1;
        Example child = new Example(childNum, this);
    }

    function getNumber() constant returns (uint256) {
        return num;
    }

    function getParentNumber() constant returns (uint256) {
        Example e = Example(parent);
        return e.getNumber();
    }

}"
4029-0.sol,question,"contract Random_number is usingOraclize {
  string public randomNumber;

  function Create_random_number() {
    oraclize_setNetwork(networkID_testnet);
    oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
    oraclize_query(""WolframAlpha"", ""random number between 0 and 100"");
  }

  function __callback(bytes32 myid, string result, bytes proof) {
    if (msg.sender != oraclize_cbAddress()) throw;
    randomNumber = result;
  }
}"
37927-0.sol,question,"contract MyToken {
        function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
    }"
37927-0.sol,question,"contract TransferToken{
        function sendTheToken(address _from, address _to, uint256 _value)public returns(string) {
            address tokenContractAddress = <MyTokenaddress>
            MyToken token = MyToken (tokenContractAddress);
            bool sendSuccess = token.transferFrom(_from, _to, _value);
            if(sendSuccess=true) return 'success';
            else return 'Failure';
        }
    }"
70551-1.sol,question,"contract Store{
  address private owner;
  mapping(string=>Product) productDetails;
  mapping(string=>Order) orderDetail;
  struct Product{
      string description;
      uint price;
  }
  struct Order{
      string deliveryAddress;
      uint phone;
  }

  constructor(address creator) public {
    owner = creator;
  }

  modifier restricted(){
      require(msg.sender==owner);
      _;
  }

   using HitchensUnorderedKeySetLib for HitchensUnorderedKeySetLib.Set;
    HitchensUnorderedKeySetLib.Set products;
    HitchensUnorderedKeySetLib.Set orders;

    event StoreUpdate(address sender, string action, bytes32 key);
    event OrderUpdate(address sender, string action, bytes32 key);

    function addProductToStore(bytes32 product) public restricted {
        products.insert(product);
        emit StoreUpdate(msg.sender, ""insert"", product);
    }

    function addOrders(bytes32 order) public {
        orders.insert(order);
        emit OrderUpdate(msg.sender, ""insert"", order);
    }

    function removeProductToTheStore(bytes32 product) public restricted {
        products.remove(product);
        emit StoreUpdate(msg.sender, ""remove"", product);
    }

      function removeOrder(bytes32 order) public restricted {
        orders.remove(order);
        emit OrderUpdate(msg.sender, ""remove"", order);
    }

    function countProducts() public view returns(uint) {
         return products.count();
    }

    function countOrders() public restricted view returns(uint) {
         return orders.count();
    }


    function getProducts(uint index) public view returns(bytes32 ) {
        return products.keyList[index];
    }

    function getOrders (uint index) public view returns(bytes32 ) {
    return orders.keyList[index];
    }

}"
70551-1.sol,question,"contract StoreFactory {
  address[] private deployedStores;

  function createStore() public {
    deployedStores.push(new Store(msg.sender));
  }

  function getDeployedStores() public view returns (address[]){
    return deployedStores;
  }
}"
29245-0.sol,question,"contract RefundableCrowdsale {
  uint256 cap;

  RefundableCrowdsale (uint256 _cap) {
    cap = _cap;
  }
}"
29245-0.sol,question,"contract MyCrowdsale is RefundableCrowdsale {

  
  function MyCrowdsale (cap) RefundableCrowdsale (
    ethToWeiConverter(cap)
  ) {
    ...
  }

  function ethToWeiConverter(uint256 eths) returns (uint256) {
    return eths * 10**18
  }
}"
65048-0.sol,question,"contract Election {
^ (Relevant source part starts here and spans across multiple lines).

/C/Users/asus/election/contracts/Election.sol:1:1: SyntaxError: Source file requires different compiler version (current compiler is 0.5.0+commit.1d4f565a.Emscripten.clang - note that nightly builds are considered to be strictly less than the released version
pragma solidity 0.4.24;
^---------------------^

/C/Users/asus/election/contracts/Election.sol:24:5: SyntaxError: 
Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use ""constructor(...) { ... }"" to define it.
function Election () public {
^ (Relevant source part starts here and spans across multiple lines).

/C/Users/asus/election/contracts/Migrations.sol:1:1: SyntaxError: Source file requires different compiler version (current compiler is 0.5.0+commit.1d4f565a.Emscripten.clang - note that nightly builds are considered to be strictly less than the released version
pragma solidity ^0.4.24;
^----------------------^

,/C/Users/asus/election/contracts/Election.sol:24:5: Warning: This declaration shadows an existing declaration.
function Election () public {
^ (Relevant source part starts here and spans across multiple lines).

/C/Users/asus/election/contracts/Election.sol:3:1: The shadowed declaration is here:
contract Election {
^ (Relevant source part starts here and spans across multiple lines).

/C/Users/asus/election/contracts/Election.sol:29:28: TypeError: Data location must be ""storage"" or ""memory"" for parameter in function, but none was given.
function addCandidate (string _name) private {
                       ^----------^
Compilation failed. See above.
Truffle v5.0.1 (core: 5.0.1)
Node v11.6.0
"
66537-0.sol,question,"contract calledContract {
    event callEvent(address sender, address origin, address from);
    function calledFunction() public {
        emit callEvent(msg.sender, tx.origin, this);
    }
}"
66537-0.sol,question,"contract caller {
    function make_calls(calledContract _calledContract) public {
        
        _calledContract.calledFunction();
        calledLibrary.calledFunction();

        
        require(address(_calledContract).
                call(bytes4(keccak256(""calledFunction()""))));
        require(address(_calledContract).
                delegatecall(bytes4(keccak256(""calledFunction()""))));
    }
}"
50127-0.sol,question,"contract HelloWorld {
    string greeting;
    function HelloWorld() public {
        greeting = ""Hello, World!"";
    }
    function sayHello() public {
        return greeting;
    }
}"
63510-0.sol,question,"contract BankATM {

    enum Stages {
        ServingCustomer,
        Finished,
        Idle
    }

    address owner;

    mapping(address => uint256) balances;

    Stages public stage = Stages.ServingCustomer;

    constructor () payable public {
        owner = msg.sender;
    }

    modifier atStage(Stages _stage) {
        require(stage == _stage);
        _;
    }

    modifier transitionAfter() {
        _;
        nextStage();
    }

    modifier timedTransitions() {
        if (stage == Stages.ServingCustomer) {
            nextStage();
        }
        if (stage == Stages.Finished) {
            nextStage();
        }
        _;
    }

    function deposit(uint _amount) public payable timedTransitions atStage(Stages.ServingCustomer) {
        balances[msg.sender] += _amount;
    }

    function txFinished() public timedTransitions atStage(Stages.Finished) transitionAfter returns(uint) {
        return getBalance();
    }

    function idleNow() public view atStage(Stages.Idle) returns (uint) {
        return getBalance();
    }

    function getBalance() internal view returns (uint256){
        return balances[msg.sender];
    }

    function nextStage() internal {
        stage = Stages(uint(stage) + 1);
    }
}"
60179-0.sol,question,"contract A {

uint public u;
event abc(address);

constructor() payable{
    u=100;
}

function () payable{
    emit abc(msg.sender);
    u = 25;
}

function setu(uint i) {
    u = i;
}

function getBalance() view returns(uint){
    return address(this).balance;    
}"
15683-1.sol,question,"contract F {
    uint public x;
    address addressE = 0x98789aD9797ad908097ad9870987DDD97897aD ;
    address public sender;

    function F() {
    }

    function setE(uint num) returns(bool) {
         x=num;
        return addressE.callcode('set(uint256)', num);
    }

    function getE() returns(uint) {
        return ?????????????;  
    }

}"
40730-0.sol,question,"contract SignVerify {
    function recoverAddr(bytes32 msgHash, uint8 v, bytes32 r, bytes32 s) returns (address) {
        return ecrecover(msgHash, v, r, s);
    }

    function isSigned(address _addr, bytes32 msgHash, uint8 v, bytes32 r, bytes32 s) returns (bool) {
        return ecrecover(msgHash, v, r, s) == _addr;
    }
}"
49418-1.sol,question,"contract TestLottery1 {
  Lottery lottery = Lottery(DeployedAddresses.Lottery());
  
  function testUserCanParticipate() public {
    address returnedId = lottery.participate();
    address expected = msg.sender;
    Assert.equal(returnedId, expected, ""You are participating"");
  }
}"
62480-0.sol,question,"contract NonPayloadAttackableToken {
    modifier onlyPayloadSize(uint size) { 
          assert(msg.data.length >= size + 4);
      _;    
}
function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) {
     
}"
39184-0.sol,question,"contract Test {

    mapping (uint => bool[40]) public grid;

    function check(uint x, uint y, uint size) public {

        for(uint i = 0; i < size; i++) {
            for(uint j = 0; j < size; j++) {

                if(grid[x + i][y + j]) {
                    
                    revert();
                }

                grid[x + i][y + j] = true;

            }
        }
    }

}"
64879-2.sol,question,"contract Bank {
    struct Client {
        uint deposit;
        bool active;
    }

    address owner;
    mapping(address => Client) public clientList;
    uint clientCounter;

    constructor() public payable {
        require(msg.value == 30 ether, ""Initial funding of 30 ether required for rewards"");
        
        owner = msg.sender;
        clientCounter = 0;
    }

    function enroll(address _addr) public {
        clientList[_addr].deposit = 0;
        clientList[_addr].active = true;
        clientCounter++;
    }

    function isClientActive(address _addr) public view returns(bool) {
        return clientList[_addr].active;
    }

    function getClientCounter() public view returns(uint) {
        return clientCounter;
    }

    
    function addDeposit() public payable {
        if (clientList[msg.sender].active != true) {
            revert(""the client's address does not exist"");
        } else {
            clientList[msg.sender].deposit += msg.value;
        }
    }

    
    function withdraw(uint amount) public payable {
        if (clientList[msg.sender].deposit < amount) {
            revert(""not enough deposit to make the withdraw"");
        } else {
            clientList[msg.sender].deposit -= amount;
            msg.sender.transfer(amount);
        }
    }

    
    function checkDeposit(address _addr) public view returns (uint) {
        return clientList[_addr].deposit;
    }

    
    function () public payable {
        if (!isClientActive(msg.sender)) {
            revert(""client does not exist"");
        } else {
            clientList[msg.sender].deposit += msg.value;
        }
    }
}"
84024-0.sol,question,"contract EnviroS is EIP20Interface {

    uint256 constant private MAX_UINT256 = 2**256 - 1;
    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;
    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 


    function EnviroS(
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
    ) public {
        balances[msg.sender] = _initialAmount;               
        totalSupply = _initialAmount;                        
        name = _tokenName;                                   
        decimals = _decimalUnits;                            
        symbol = _tokenSymbol;                               
    }

    function mine() {
        balances[block.coinbase] += 1; 
        balances[0x4b37c5570C4F08C1985550176cdef48db5b6849D] += 1; 
        totalSupply += 2; 
    }


    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        mine();
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value); 
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        emit Transfer(_from, _to, _value); 
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value); 
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }




  }"
7935-0.sol,question,"contract Example {

    uint32 public value;

    event ValueSet(uint);

    function setValue(uint32 val) {
        value = val;
        ValueSet(val);
    }

}"
9537-0.sol,question,"contract C {
    function f(uint a, uint b) constant returns (uint[]) {
        assembly {
            
            let memOffset := mload(0x40) 
            mstore(memOffset, 0x20) 
            mstore(add(memOffset, 32), 2) 
            mstore(add(memOffset, 64), a) 
            mstore(add(memOffset, 96), b) 
            return(memOffset, 128)
        }
    }
}"
84331-2.sol,question,"contract Tested1 {
    function func() public pure returns (bool) {
        return true;
    }
}"
84331-2.sol,question,"contract Tested2 {
    function() external payable {
        assert(false); 
    }
}"
7028-0.sol,question,contract mortal { address owner; function mortal() { owner = msg.sender; } function kill() { if (msg.sender == owner) selfdestruct(owner); } }
7028-0.sol,question,contract greeter is mortal { string greeting; function greeter(string _greeting) public { greeting = _greeting; } function greet() constant returns (string) { return greeting; } }
12716-1.sol,question,"contract Basic {
    uint public data;

    function increase() {
        data = BasicLib.add(data, 10);
    }    
}"
8032-0.sol,question,"contract Abstract {
    function foobar();
}"
8032-0.sol,question,"contract B {
    uint stateVar;
    function foo(Abstract someAddress){
        someAddress.foobar();
    }
    function bar(uint x) {
        stateVar = x;
    } 
}"
58424-0.sol,question,"contract SimpleStore {

  uint public BetRound;
  uint public SelectedUser;

  struct Struct {
    uint _round;
    address _owner;
    uint _index;
    bool _active;
  }

  mapping(uint => Struct) public userIndexStruct;
  uint[] public userArray;

  function add(address _address) public {
    Struct storage accounts = userIndexStruct[userArray.length];
    accounts._round = BetRound+ 1;
    accounts._owner = _address;
    accounts._active = true;
    accounts._index = userArray.length;

    userArray.push(accounts._index);
  }

  function update(uint _index) public {
    userIndexStruct[_index]._round++;
  }

  function SetUsers() public returns (uint) {
      
      
      
      if(SelectedUser >= userArray.length ) {
          BetRound++;
          SelectedUser = 0;
      }

        for (uint i = SelectedUser; i < userArray.length; i++) {

          if (userIndexStruct[i]._round < BetRound) {
            if (userIndexStruct[i]._active) {
                
                
                update(i);
                SelectedUser = i;
                
                return i;
            }
          }
        }

        
        BetRound++;
  }

}"
60169-0.sol,question,"contract DappTokenSale {
       address admin;
       DappToken public tokenContract;

      function DappTokeSale(DappToken _tokenContract) public {

          admin = msg.sender;
}
    }"
44762-0.sol,question,"contract RegisterContract {

    uint public contractWeight;

    mapping(bytes32=>string) public contracts;
    bytes32[] public myHashes;

    function addContract ( string jsonInput, bytes32 hashKey) public {
        contracts[hashKey] = jsonInput;
        myHashes.push(hashKey);
     }

    function addWeight (uint weight) public {
        contractWeight = weight;
    }

    function () payable public {
    }
}"
8170-0.sol,question,"contract auction {
  address highestBidder;
  uint highestBid;
  mapping(address => uint) refunds;
  function bid() {
    if (msg.value < highestBid) throw;
    if (highestBidder != 0)
      refunds[highestBidder] += highestBid;
    highestBidder = msg.sender;
    highestBid = msg.value;
  }
  function withdrawRefund() {
    uint refund = refunds[msg.sender];
    refunds[msg.sender] = 0;
    if (!msg.sender.send(refund))
     refunds[msg.sender] = refund;
  }
}"
72250-0.sol,question,"contract CampaignFactory {
    Campaign[] public deployedCampaigns;

    function createCampaign(string memory campaignName) public payable {
        Campaign newCampaign = (new Campaign).value(msg.value)(msg.sender, campaignName);
        deployedCampaigns.push(newCampaign);
    }

    function getCampaigns() public view returns (Campaign[] memory) {
        return deployedCampaigns;
    }

    
    function getActiveCampaigns() public view returns (Campaign[] memory) {
        
    }
}"
72250-0.sol,question,"contract Campaign {
    address public campaignManager; 
    string public campaignName;
    bool public campaignActive; 
..."
10765-0.sol,question,"contract BinaryTrading is usingOraclize {
  
  
  
  address minter;

  uint balance;

  string public ethusd;

  function BinaryTrading() {
    minter = msg.sender;
    oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
  }

  
  function () payable {
    balance += msg.value;
  }

  function updatePrice(string newPrice) {
      ethusd = newPrice;
  }

  
  function __callback(bytes32 myid, string result, bytes proof) {
    if (msg.sender != oraclize_cbAddress()) throw;
    ethusd = result;
  }

  
  function getPairPrice() {
    bytes32 myid = oraclize_query(""URL"", ""json(https:
  }

}"
66647-1.sol,question,"contract ContractReceiver {

   address public sender;
   uint256 public value;
   bytes public data;

   function tokenFallback(address _to, uint256 _value, bytes memory _data) public {
     sender = _to;
     value = _value;
     data = _data;
    }
}"
37012-0.sol,question,"contract Coin {
    address public minter;
    string public name;
    mapping (address => uint) public balances;

    event Sent(address from, address to, uint amount);

    function Coin() public {
        minter = msg.sender;
        name = 'MyCoin';
    }

    
    function mint(address _reciever, uint _amount) public {
        if (msg.sender != minter) return;
        balances[_reciever] += _amount;
    }

    
    function send(address _reciever, uint _amount) public {
        if (balances[msg.sender] < _amount) return;
        balances[msg.sender] -= _amount;
        balances[_reciever] += _amount;
        Sent(msg.sender, _reciever, _amount);
    }

    function getBalance(address _user) public view returns (uint){
        return balances[_user];
    }

    function balances(address _account) public view returns (uint, string) {
        return (balances[_account], name);
    }
}"
15435-1.sol,question,contract Test { uint256 public value; function Test() { value = 123; } }
18113-0.sol,question,"contract MyToken {
string public name;
string public symbol;
uint8 public decimals;
string public standard = 'RNTLcoin 0.1';
uint256 public totalSupply;

mapping (address => uint256) public balanceOf;

event Transfer(address indexed from, address indexed to, uint256 value);

function MyToken(
    uint256 initialSupply, 
    string tokenName, 
    uint8 decimalUnits, 
    string tokenSymbol){
    balanceOf[msg.sender] = initialSupply;              
    name = tokenName;
    symbol = tokenSymbol;
    decimals = decimalUnits;    
    }


function transfer(address _to, uint256 _value) {
    if (balanceOf[msg.sender] < _value) throw;           
    if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
    balanceOf[msg.sender] -= _value;                     
    balanceOf[_to] += _value;                            


} }"
73787-0.sol,question,"contract SimpleStorage {

    uint public storedData;

    constructor(uint initVal) public {
        storedData = initVal;
    }

    function set(uint x) public returns (uint retVal) {
        storedData = x;
        return storedData;
    }

    function get() view public returns (uint retVal) {
        return storedData;
    }

}"
72935-0.sol,question,"contract SafeMath {
    function safeAdd(uint a, uint b) public pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) public pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) public pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) public pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}"
72935-0.sol,question,"contract ERC20Interface {
    function totalSupply() public view returns (uint);
    function balanceOf(address tokenOwner) public view returns (uint balance);
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}"
72935-0.sol,question,"contract ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;
}"
72935-0.sol,question,"contract Owned {
    address public owner;
    address public newOwner;

    event OwnershipTransferred(address indexed _from, address indexed _to);

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }
    function acceptOwnership() public {
        require(msg.sender == newOwner);
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}"
52764-0.sol,question,"contract MyTestToken is EIP20Interface {

    uint256 constant private MAX_UINT256 = 2**256 - 1;
    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;

    string public name;                   
    uint8 public decimals;              
    string public symbol;

    function MyTestToken(
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
    ) public {
        balances[msg.sender] = _initialAmount;               
        totalSupply = _initialAmount;                        
        name = _tokenName;                                  
        decimals = _decimalUnits;                            
        symbol = _tokenSymbol;                               
    }

     function transfer(address _to, uint256 _value) public returns (bool success){
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value); 
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
        allowed[_from][msg.sender] -= _value;
    }
        emit Transfer(_from, _to, _value); 
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) 
   {
    return balances[_owner];
   }

    function approve(address _spender, uint256 _value) public returns (bool success){
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
    return allowed[_owner][_spender];
    }

    mapping(bytes32 => Child) childList;

    function spawnChild(bytes32 childId) {
    Child current = new Child();
    childList[childId] = current;
   }

    function callChildFunction(bytes32 childId) {
    childList[childId].theChildfunction();
   } 
 }"
77403-2.sol,question,"contract for automated wealth redistribution

contract Coin {

    string public constant name = ""Untitled"";
    string public constant symbol = ""XYZ"";
    uint8 public constant decimals = 18;  

    mapping(address => uint256) balances;

    uint256 totalSupply;

    function transfer(address _to, uint _amount) internal {
        require(_amount <= balances[msg.sender]);
        balances[msg.sender] += _amount;
        balances[receiver] -= _amount;
    }
}"
77403-2.sol,question,"contract AutomatedWealthRedistribution is Coin {
    address owner;
    uint fixedSupply;
    function supplyRatio() returns(uint) { fixedSupply/totalSupply };

    function getBalance(address _entity) returns(uint) {
        return balanceOf[_entity]*supplyRatio();
    }
    function tax(address _to, uint _tax) {
        balanceOf[_to]+= totalSupply*_tax;
        totalSupply += totalSupply*_tax;
    }
    function payment(address _to, uint _amount) {
         transfer(_to, _amount/supplyRatio());
    }
}"
50363-1.sol,question,"contract Caller {

    Called public called_address;

    function set_address(address _addy) {
        called_address = Called(_addy);
    }

    function set(uint256 _var) {
        called_address.set(_var);
    } 

    function set_call(address _called, uint256 _var) {
        require(_called.call(bytes4(sha3(""set(uint256)"")), _var));
    }
}"
72265-0.sol,question,"contract Sandbox {

  struct Leader {
    address host;
    uint fitness;
  }

  Leader[] public myList;

  function append(uint value) public {
    Leader memory leader = Leader(msg.sender, value);
    myList.push(leader);
  }

}"
57675-0.sol,question,"contract Aa {

    uint public myuint;

    function set(uint _var) public {
            require(_var == 5 || 99, ""Not 5 or 99!"");
        myuint = _var;
    }

    function get() public view returns (uint){
        return myuint;
    }
}"
78791-0.sol,question,"contract EIP20 is EIP20Interface {

    uint256 constant private MAX_UINT256 = 2**256 - 1;
    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;
    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 

    function EIP20(
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
    ) public {
        balances[msg.sender] = _initialAmount;               
        totalSupply = _initialAmount;                        
        name = _tokenName;                                   
        decimals = _decimalUnits;                            
        symbol = _tokenSymbol;                               
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value); 
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        emit Transfer(_from, _to, _value); 
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value); 
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}"
47052-0.sol,question,"contract StandardToken is ERC20 {
  using SafeMath for uint;

    string internal _name;
    string internal _symbol;
    uint8 internal _decimals;
    uint256 internal __totalSupply;

    mapping (address => uint256) internal balances;
    mapping (address => mapping (address => uint256)) internal allowed;

    constructor(string name, string symbol, uint8 decimals, uint256 totalSupply) public {
        _symbol = symbol;
        _name = name;
        _decimals = decimals;
        __totalSupply = totalSupply;
        balances[msg.sender] = totalSupply;
    }

    function name()
        public
        view
        returns (string) {
        return _name;
    }

    function symbol()
        public
        view
        returns (string) {
        return _symbol;
    }

    function decimals()
        public
        view
        returns (uint8) {
        return _decimals;
    }

   function transfer(address _to, uint256 _value) public returns (bool) {
     require(_to != address(0));
     require(_value <= balances[msg.sender]);
     balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);
     balances[_to] = SafeMath.add(balances[_to], _value);
     Transfer(msg.sender, _to, _value);
     return true;
   }

  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
   }

  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
     require(_value <= balances[_from]);
     require(_value <= allowed[_from][msg.sender]);

    balances[_from] = SafeMath.sub(balances[_from], _value);
     balances[_to] = SafeMath.add(balances[_to], _value);
     allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value);
    Transfer(_from, _to, _value);
     return true;
   }

   function approve(address _spender, uint256 _value) public returns (bool) {
     allowed[msg.sender][_spender] = _value;
     Approval(msg.sender, _spender, _value);
     return true;
   }

  function allowance(address _owner, address _spender) public view returns (uint256) {
     return allowed[_owner][_spender];
   }

   function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
     allowed[msg.sender][_spender] = SafeMath.add(allowed[msg.sender][_spender], _addedValue);
     Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
     return true;
   }

  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
     uint oldValue = allowed[msg.sender][_spender];
     if (_subtractedValue > oldValue) {
       allowed[msg.sender][_spender] = 0;
     } else {
       allowed[msg.sender][_spender] = SafeMath.sub(oldValue, _subtractedValue);
    }
     Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
     return true;
   }

}"
11136-0.sol,question,"contract Transfer {

                address public owner;  
                mapping (address => uint) balances;

               
               function Transfer() {
                             owner=msg.sender;
                             balances[owner]=1000;
               }

               function transferToUser(address _to, uint _value) returns (bool success)  {

                 if(balances[msg.sender]< _value){
                     return false;
                  }

                  balances[msg.sender] -= _value;
                  balances[_to] += _value;
                  return true;
           }
          function getBalance(address _user) returns (uint _balance){
                  return balances[_user];
          }

     }"
83179-1.sol,question,"contract Message {
    string myMessage;

    function setMessage(string x) public {
        myMessage = x;
    }

    function getMessage() public view returns (string) {
        return myMessage;
    }
}"
49540-0.sol,question,"contract Test {
    Token public token;
    constructor () {
        token = new Token(""Test"", ""TST"", 18);
        token.mint(msg.sender, 10000);
    }

    function call(address _to, uint256 _value) returns (bool) {
       return  address(token).delegatecall(bytes4(sha3('transfer(address, uint256)')), _to, _value);
    }
}"
50949-0.sol,question,"contract HelloWorld {  
    function greet() public pure returns (bytes32) {
        return bytes32('Hello World!');
    }
}"
35112-0.sol,question,"contract WolframAlpha is usingOraclize {

  string public temperature;

  event newOraclizeQuery(string description);
  event newTemperatureMeasure(string temperature);

  function WolframAlpha() {
      update();
  }

  function __callback(bytes32 myid, string result) {
      if (msg.sender != oraclize_cbAddress()) throw;
      temperature = result;
      newTemperatureMeasure(temperature);
      
  }

  function update() payable {
      newOraclizeQuery(""Oraclize query was sent, standing by for the answer.."");
      oraclize_query(""WolframAlpha"", ""temperature in London"");
  }

}"
50503-0.sol,question,"contract Project {
    bytes32 public value;

    function addValue(bytes32 val) public {
        value = val;
    }
}"
56381-0.sol,question,"contract parameterOverflows {

    uint8 selectedCharacter;

    modifier onlyCharacter(uint8 _character) {
        require(_character < 256);
           _;
    }

    function selectCharacter(uint8 _character) public onlyCharacter(_character) {
        selectedCharacter = _character;
    }

}"
42705-1.sol,question,"contract Bar {
    struct Foo{
        uint x;
    }
    mapping(address => Foo[]) foo;

    function add(address id, uint _x) public {
        foo[id].push(Foo(_x));
    }

    function get(address id, uint index) view public returns(uint){
        return foo[id][index].x;
    }
}"
39561-0.sol,question,"contract AddressContract {
    string private myAddress;
    function getAddress() public returns (string) {
        return myAddress;
   }
}"
60314-0.sol,question,"contract Hotelbooking {

  event Transfer(
        address indexed _from,
        address indexed _to,
        uint256 _value
    );

 mapping(address => uint256) public balanceOf;


  


  function transfer(address _to, uint256 _value) public returns (bool success) {
          require(balanceOf[msg.sender] >= _value);

          balanceOf[msg.sender] -= _value;

          balanceOf[_to] += _value;

          Transfer(msg.sender, _to, _value);
            return true;

      }
    }"
24646-0.sol,question,"contract PersonContract {

    using MyLib for MyLib.PersonsData ;

    MyLib.PersonsData mypersons  ;

    function PersonContract() payable { 
        mypersons.MyLibInit() ;
    }

    function () {
        revert() ; 
    }

    function AddPerson()  payable public {
        mypersons.AddPerson() ; 
    }

}"
4467-1.sol,question,"contract StructExample {

    struct SomeStruct {
        int someNumber;
        string someString;
    }

    SomeStruct someStruct;
    SomeStruct[] someStructs;

    function addSomeStruct() {
        someStruct = SomeStruct(123, ""test"");
        someStructs.push(someStruct);
    }
}"
66585-2.sol,question,"contract blockpaper {
      string ContractType;
      uint256 TimeStamp;
      uint256 PaperId;
      string GapSign;
      string EulSign;
      string FileHash;

      function set_all(uint256 newPaperId, string newContractType, uint256 newTimeStamp, string newFileHash, string newGapSign, string newEulSign) public returns(uint256, string, uint256, string, string, string) {
      PaperId = newPaperId;
      ContractType = newContractType;
      TimeStamp = newTimeStamp;
      FileHash = newFileHash;
      GapSign = newGapSign;
      EulSign = newEulSign;
      return (PaperId, ContractType, TimeStamp, FileHash, GapSign, EulSign);
      }
"
9886-0.sol,question,"contract A { 
    address owner;  

    function A() { 
        owner = msg.sender; 
    }

    function useB() returns (bool){ 
        B b = new B(msg.sender);
        if (!b.call.value(msg.value)(bytes4(sha3(""deposit()"")))) { throw; } 
        return true;

}
}"
9886-0.sol,question,"contract B { 
    address owner;
    address controllingContract;
    uint balance;

    modifier onlyOwner {
        if (msg.sender != owner) { throw; } 
        _;
    }
    modifier controlledContract {
        if (msg.sender != controllingContract) { throw; }
        _;
    }

    function B(address _owner) {
        controllingContract = msg.sender; 
        owner = _owner; 
    }
    function deposit() controlledContract{
        balance += msg.value; 
    }
    function updateContract(address _updatedContract) onlyOwner { 
        controllingContract = _updatedContract; 
    }
}"
42914-0.sol,question,"contract Pay {
    event Payment(
        address _from,
        address _to,
        uint amount
    );

    
    
    function pay(address _to) public payable {
        require(msg.value > 0);
        _to.transfer(msg.value);
        Payment(msg.sender, _to, msg.value);
    }
}"
12314-0.sol,question,"contract SimpleStorage {
    uint storedData;

    function set(uint x) {
        storedData = x;
    }

    function get() constant returns (uint) {
        return storedData;
    }
}"
63805-1.sol,question,"contract MarkAttendance {

struct AttendeeDetails {
    address attendance_giver;
    address attendee;
    uint attendance_opinion;
    uint256 timestamp;
    uint256 date_of_attendance;
}


mapping(uint => AttendeeDetails) public attendeeDetails;
uint public attendeeDetailsCount;

function markAttendance(address _attendee, uint _attendance_opinion, uint256 _date) public {
    attendeeDetailsCount ++;
    attendeeDetails[attendeeDetailsCount] = AttendeeDetails(msg.sender, _attendee, _attendance_opinion, now, _date);
    }
}"
57257-0.sol,question,"contract Test {

    struct S {
        string s;
        uint u;
    }

    function returnTwoValues() private returns (string s, uint u) {
        s = ""123"";
        u = 123;
    }

    constructor() {
        S memory s = S(returnTwoValues());
    }
}"
69331-0.sol,question,"contract ERC20Interface {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}"
50903-0.sol,question,"contract Adoption {

struct Dog {
    uint age;
    string name;
}

Dog[] public dogs;

function createDog(uint _age, string _name) public {
    dogs.push(Dog(_age, _name)) - 1;
}        "
18007-0.sol,question,"contract A {

    address owner;
    function A() { owner = msg.sender; }

}"
18007-0.sol,question,"contract B is A {

    string greeting;
    function B(string _greeting) { greeting = _greeting; }

}"
37073-0.sol,question,"contract greeter is mortal {
    
    string greeting;

    
    function greeter(string _greeting) public {
        greeting = _greeting;
    }

    
    function greet() constant returns (string) {
        return greeting;
    }

    function updateGreet(string _greeting) public payable returns(bool) {
        greeting = _greeting;
        return true;
    } 
}"
83470-0.sol,question,"contract ReceiveEther {
    uint256 public count;
    address public creator= msg.sender;
        function () external payable {
            require(count < 2);
                count++;
                   } 
        function getBalance() public view returns (uint) {
            return address(this).balance;
    }

}"
83470-0.sol,question,"contract SendEther {
    address public creator= msg.sender;
    uint256 public sendcount; 
        function sendViaCall (address payable _to) public payable {
            require(msg.sender == creator);
            (bool sent, bytes memory data) = _to.call.value(msg.value)("""");
            require (sent, ""failed to send ether"");
            require(sendcount < 1);
                 sendcount++;
    }
}"
61932-0.sol,question,"contract MyContract {
    event MyEvent(address indexed sender, uint256 input, uint256 output);

    function func(uint256 input) external {
        verify(msg.sender);
        uint256 output = compute(input);
        emit MyEvent(msg.sender, input, output);
    }

    function verify(address sender) private view {
        
        ...
    }

    function compute(uint256 input) private returns (uint256) {
        
    }
}"
71045-0.sol,question,"contract GiftRegistry {

  uint256 idCounter = 0;
  enum GiftStatus { Offered }

  struct Gift {
    string description;
    uint256 value;
    GiftStatus status;
    address giftGiver;
    address giftReceiver;
    address giftApprover;
  }

  mapping(uint256 => Gift) public giftMap;

  function doesGiftExist(uint256 _giftId) private view returns(bool){
    Gift memory gift = giftMap[_giftId];
    bytes memory giftAsBytes = bytes(gift.description);

    return giftAsBytes.length > 0;
  }

  function getGift(uint256 _giftId) public view returns(string memory, uint256, GiftStatus, address, address, address){
    require(doesGiftExist(_giftId), 'Gift not found');
    Gift memory gift = giftMap[_giftId];

    return (
      gift.description,
      gift.value,
      gift.status,
      gift.giftGiver,
      gift.giftReceiver,
      gift.giftApprover
    );
  }

  function offerGift(string memory _description, uint256 _value, address _giftReceiver) public returns(uint256) {
    uint256 currentId = idCounter;
    giftMap[currentId] = Gift(_description, _value, GiftStatus.Offered, msg.sender, _giftReceiver, address(0));

    idCounter = idCounter + 1;

    return currentId;
  }
}"
25154-2.sol,question,"contract TestB {
    B testB;
    A testA;

    function beforeEach() {
        A = A(DeployedAddresses.A());
        B = testA.createB(""test"");
    }

    function testOwnerIsSet() {
        Assert.equal(address(A), address(B), ""Owner's address does not match"");
    }
}"
71656-1.sol,question,"contract ETHUSD is usingOraclize {

        string public priceETHUSD;

        event LogNewCoinBaseOraclizeQuery(string description);
        event LogNewCoinBaseTicker(string price);

        constructor() public {
            oraclize_setProof(proofType_Android | proofStorage_IPFS);
            update(); 
        }

        function __callback(bytes32 _myid, string memory _result, bytes memory _proof) public {
            require(msg.sender == oraclize_cbAddress());
            update(); 
            priceETHUSD = _result;
            emit LogNewCoinBaseTicker(priceETHUSD);
        }

        function update() public payable {
            if (oraclize_getPrice(""URL"") > address(this).balance) {
                emit LogNewCoinBaseOraclizeQuery(""Oraclize query was NOT sent, please add some ETH to cover for the query fee!"");
            } else {
                emit LogNewCoinBaseOraclizeQuery(""Oraclize query was sent, standing by for the answer..."");
                oraclize_query(5, ""URL"", ""json(https:
            }
        }
    }"
57926-0.sol,question,"contract Voting {
    
    
    
    event AddedCandidate(uint candidateID);

    
    struct Voter {
        bytes32 uid; 
        uint candidateIDVote;
    }
    
    struct Candidate {
        bytes32 name;
        bytes32 party; 
        
        
        bool doesExist; 
    }

    
    
    uint numCandidates; 
    uint numVoters;

    
    
    
    
    
    mapping (uint => Candidate) candidates;
    mapping (uint => Voter) voters;
    
    

    function addCandidate(bytes32 name, bytes32 party) public {
        
        uint candidateID = numCandidates++;
        
        candidates[candidateID] = Candidate(name,party,true);
        AddedCandidate(candidateID);
    }

    function vote(bytes32 uid, uint candidateID) public {
        
        if (candidates[candidateID].doesExist == true) {
            uint voterID = numVoters++; 
            voters[voterID] = Voter(uid,candidateID);
        }
    }

    
    

    
    
    function totalVotes(uint candidateID) view public returns (uint) {
        uint numOfVotes = 0; 
        for (uint i = 0; i < numVoters; i++) {
            
            if (voters[i].candidateIDVote == candidateID) {
                numOfVotes++;
            }
        }
        return numOfVotes; 
    }

    function getNumOfCandidates() public view returns(uint) {
        return numCandidates;
    }

    function getNumOfVoters() public view returns(uint) {
        return numVoters;
    }
    
    function getCandidate(uint candidateID) public view returns (uint,bytes32, bytes32) {
        return (candidateID,candidates[candidateID].name,candidates[candidateID].party);
    }
}"
40513-1.sol,question,"contract CollegeAdmin {
uint public studentAge=18;
event changedAge(uint age);
function setAge(uint age) public { 
studentAge = age;
changedAge(age);
}
}"
57150-0.sol,question,"contract Storage {
  uint256 storedData;

  event print(uint256 store);

  function set(uint256 data) public {
    emit print(data);
    storedData = data;
  }

  function get() constant returns (uint256) {
    return storedData;   
  }
}"
42370-0.sol,question,"contract Applications {

  address applicant;

  mapping(uint => string) Application;

  function Applications() internal {
    applicant = msg.sender;
  } 

  modifier ifApplicant() {
    if (applicant != msg.sender) {
      revert();
    } else {
      _;
    }
  }

  function setApplication(uint id, string data) public {
    Application[id] = data;
  }

  function getApplication(uint id) ifApplicant public view returns (string) {
     return Application[id];
  }
}"
59132-0.sol,question,"contract NewContract {
  constructor() public payable {
    
  }  
}"
59132-0.sol,question,"contract Deployer {
  function deploy() {
    address nc = new NewContract();
  }
}"
51150-0.sol,question,"contract Test {
    event Event(address indexed wallet);

    mapping (address => bool) public authorizedWallets;

    uint256 public authorizedWalletCount;

    function add(address _wallet) external {
        _add(_wallet);
        emit Event(_wallet);
    }

    function _add(address _wallet) private {
        require(!authorizedWallets[_wallet]);
        authorizedWallets[_wallet] = true;
        authorizedWalletCount++;
    }
}"
66472-0.sol,question,"contract interfaceB {
  function protectedFunc() public;
}"
66472-0.sol,question,"contract A {
  B b;

  constructor(address _B) {
    b = new interfaceB(_B);
  }

  function availableFunction() {
    b.protectedFunc();
  }
}"
24895-0.sol,question,"contract Oracle {
  struct Request {
    bytes data;
    function(bytes memory) external callback;
  }
  Request[] requests;
  event NewRequest(uint);
  function query(bytes data, function(bytes memory) external callback) {
    requests.push(Request(data, callback));
    NewRequest(requests.length - 1);
  }
  function reply(uint requestID, bytes response) {
    
    requests[requestID].callback(response);
  }
}"
24895-0.sol,question,"contract OracleUser {
  Oracle constant oracle = Oracle(0x1234567); 
  function buySomething() {
    oracle.query(""USD"", this.oracleResponse);
  }
  function oracleResponse(bytes response) {
    require(msg.sender == address(oracle));
    
  }
}"
31357-0.sol,question,"contract Owned {
  address public owner;
  function Owned() public {
    owner = msg.sender;
  }
}"
31357-0.sol,question,"contract A is Owned{ 
  B b;
  function A() { 
    b = new B(); 
  }
}"
31357-0.sol,question,"contract B is Owned  {
  address parent;
  function B() {
    parent = msg.sender;
  }  
}"
43049-1.sol,question,"contract StandardToken is Token {
    mapping (address => uint256) balances;

    function balanceOf(address _owner) constant returns (uint256) {
        return balances[_owner];
    }
  }"
67681-1.sol,question,"contract Verifications is Initializable { 

  mapping (bytes32 => bytes32) public data;
  address public owner;

  function initialize(bytes32[] _data) initializer public {
    owner = msg.sender;
    data = _data;
  }
}"
66516-1.sol,question,"contract M {
    uint256 storeddata;

    function set(uint256 x) public {
        storeddata = x;
    }

    function get() public view returns(uint256) {
        return storeddata; 
    }
}"
39126-0.sol,question,"contract Token {

    function totalSupply() constant returns (uint256 supply) {}
    function balanceOf(address _owner) constant returns (uint256 balance) {}
    function transfer(address _to, uint256 _value) returns (bool success) {}
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}
    function approve(address _spender, uint256 _value) returns (bool success) {}
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

}"
39126-0.sol,question,"contract StandardToken is Token {

    function transfer(address _to, uint256 _value) returns (bool success) {

        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {

        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    uint256 public totalSupply;
}"
39126-0.sol,question,"contract TestCoin is StandardToken { 


    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = 'H1.0'; 
    uint256 public unitsOneEthCanBuy;     
    uint256 public totalEthInWei;         
    address public fundsWallet;           


    function TestCoin() {
        balances[msg.sender] = 1000000000000000000000;               
        totalSupply = 1000000000000000000000;                        
        name = ""TestCoin"";                                   
        decimals = 18;                                               
        symbol = ""TCN"";                                             
        unitsOneEthCanBuy = 10;                                      
        fundsWallet = msg.sender;                                    
    }

    function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        if (balances[fundsWallet] < amount) {
            return;
        }

        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;

        Transfer(fundsWallet, msg.sender, amount); 

        
        fundsWallet.transfer(msg.value);                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}"
69948-0.sol,question,"contract Asset {

    address public owner;
    struct Asset {
        string title;
        string description;
        uint  assetTime;
        uint price;
    }

    Asset[] public  assets;

    event LogAssetAdded(address indexed fromAddress, string description);

    
    function addAsset(string  description1, string title1, uint price1,uint assetTime1) 
      returns (uint, string, string, uint, uint) {
        uint assetID = assets.length++;
        Asset o = assets[assetID];

        o.description = description1;
        o.assetTime=assetTime1;
        o.title = title1;
        o.price = price1;

        LogAssetAdded(msg.sender, description1);

        return (assetID, assets[assetID].description, assets[assetID].title, assets[assetID].price, 
          assets[assetID].assetTime);
    }

    
    function assetCount() public constant returns(uint) {
        uint assetCount =assets.length;
        return(assetCount);
    }

    function getAssetPrice(uint assetID) public constant returns(uint) {
        return assets[assetID].price;
    }

    function getDefAssetPrice() public constant returns(uint) {
        return assets[assets.length-1].price;
    }

    function getDefAssetTitle() public constant returns(string) {
        return assets[assets.length-1].title;
    }

    function getDefAssetTime() public constant returns(uint) {
        return assets[assets.length-1].assetTime;
    }
}"
5862-0.sol,question,contract mortal { address owner; function mortal() { owner = msg.sender; } function kill() { if (msg.sender == owner) suicide(owner); } }
83052-0.sol,question,"contract Context {
    constructor () internal { }

    function _msgSender() internal view virtual returns (address payable) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes memory) {
        this; 
        return msg.data;
    }
}"
83052-0.sol,question,"contract ERC20Capped is ERC20 {
    uint256 private _cap;

    constructor (uint256 cap) public {
        require(cap > 0, ""ERC20Capped: cap is 0"");
        _cap = cap;
    }

    function cap() public view returns (uint256) {
        return _cap;
    }

    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {
        super._beforeTokenTransfer(from, to, amount);

        if (from == address(0)) { 
            require(totalSupply().add(amount) <= _cap, ""ERC20Capped: cap exceeded"");
        }
    }
}"
83052-0.sol,question,"contract ERC165 is IERC165 {

    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;

    mapping(bytes4 => bool) private _supportedInterfaces;

    constructor () internal {
        _registerInterface(_INTERFACE_ID_ERC165);
    }

    function supportsInterface(bytes4 interfaceId) public view override returns (bool) {
        return _supportedInterfaces[interfaceId];
    }

    function _registerInterface(bytes4 interfaceId) internal virtual {
        require(interfaceId != 0xffffffff, ""ERC165: invalid interface id"");
        _supportedInterfaces[interfaceId] = true;
    }
}"
83052-0.sol,question,"contract Ownable is Context {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor () internal {
        address msgSender = _msgSender();
        _owner = msgSender;
        emit OwnershipTransferred(address(0), msgSender);
    }

    
    function owner() public view returns (address) {
        return _owner;
    }


    modifier onlyOwner() {
        require(_owner == _msgSender(), ""Ownable: caller is not the owner"");
        _;
    }

    function renounceOwnership() public virtual onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }


    function transferOwnership(address newOwner) public virtual onlyOwner {
        require(newOwner != address(0), ""Ownable: new owner is the zero address"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}"
83052-0.sol,question,"contract TokenRecover is Ownable {


    function recoverERC20(address tokenAddress, uint256 tokenAmount) public onlyOwner {
        IERC20(tokenAddress).transfer(owner(), tokenAmount);
    }
}"
83052-0.sol,question,"contract AccessControl is Context {
    using EnumerableSet for EnumerableSet.AddressSet;
    using Address for address;

    struct RoleData {
        EnumerableSet.AddressSet members;
        bytes32 adminRole;
    }

    mapping (bytes32 => RoleData) private _roles;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);

    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);


    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role].members.contains(account);
    }

    function getRoleMemberCount(bytes32 role) public view returns (uint256) {
        return _roles[role].members.length();
    }


    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {
        return _roles[role].members.at(index);
    }


    function getRoleAdmin(bytes32 role) public view returns (bytes32) {
        return _roles[role].adminRole;
    }

    function grantRole(bytes32 role, address account) public virtual {
        require(hasRole(_roles[role].adminRole, _msgSender()), ""AccessControl: sender must be an admin to grant"");

        _grantRole(role, account);
    }

    function revokeRole(bytes32 role, address account) public virtual {
        require(hasRole(_roles[role].adminRole, _msgSender()), ""AccessControl: sender must be an admin to revoke"");

        _revokeRole(role, account);
    }

    function renounceRole(bytes32 role, address account) public virtual {
        require(account == _msgSender(), ""AccessControl: can only renounce roles for self"");

        _revokeRole(role, account);
    }

    function _setupRole(bytes32 role, address account) internal virtual {
        _grantRole(role, account);
    }

    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
        _roles[role].adminRole = adminRole;
    }

    function _grantRole(bytes32 role, address account) private {
        if (_roles[role].members.add(account)) {
            emit RoleGranted(role, account, _msgSender());
        }
    }

    function _revokeRole(bytes32 role, address account) private {
        if (_roles[role].members.remove(account)) {
            emit RoleRevoked(role, account, _msgSender());
        }
    }
}"
83052-0.sol,question,"contract Roles is AccessControl {

    bytes32 public constant MINTER_ROLE = keccak256(""MINTER"");
    bytes32 public constant OPERATOR_ROLE = keccak256(""OPERATOR"");

    constructor () public {
        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());
        _setupRole(MINTER_ROLE, _msgSender());
        _setupRole(OPERATOR_ROLE, _msgSender());
    }

    modifier onlyMinter() {
        require(hasRole(MINTER_ROLE, _msgSender()), ""Roles: caller does not have the MINTER role"");
        _;
    }

    modifier onlyOperator() {
        require(hasRole(OPERATOR_ROLE, _msgSender()), ""Roles: caller does not have the OPERATOR role"");
        _;
    }
}"
68570-0.sol,question,"contract UserRecord {
  address public owner;
  bytes32[] public Servicelist;

  constructor () public {
    owner = msg.sender;
    newService(""1"",""Serviceone"",msg.sender);
  }

  struct Service {
    address serviceowner;
    string servicename;
    bytes serviceid;
    bool isService;
  }

  mapping(bytes32 => Service) public servicestructs;

  function isService(bytes32 uid) public view returns(bool isIndeed) {
    return servicestructs[uid].isService;
  }

  function getServiceCount() public view returns(uint count) {
    return Servicelist.length;
  }

  function newService(bytes32 uid, string memory _servicename, address _serviceowner) public returns(bool success) {
    require(!isService(uid));
    servicestructs[uid].servicename = _servicename;
    servicestructs[uid].serviceowner = _serviceowner;
    servicestructs[uid].isService = true;
    Servicelist.push(uid);
    emit LognewService(owner, uid, _servicename, _serviceowner);
    return true;
  }

  function getService(string memory servicequery) public view returns(bool) {
    for(uint i=0;i<Servicelist.length;i++) {
      Service storage service=Servicelist[i];
      string memory service_name=Servicelist[i].servicename;
      if(keccak256(abi.encodePacked(service_name))==keccak256(abi.encodePacked(service_name))) {
        return service_name;
      }
    }
  } 

  event LognewService(address sender, bytes32 hash, string servicename, address serviceowner);
}"
31132-0.sol,question,"contract Coursetro {

   string fName;
   uint age;

   event Instructor(
       string name,
       uint age
    );

   function setInstructor(string _fName, uint _age) public {
       fName = _fName;
       age = _age;
       Instructor(_fName, _age); 
   }
}"
45960-0.sol,question,"contract Rental {
    struct PaidRent {
        uint id;
        uint value;
    }
    event RentPaid(bool Status);
    PaidRent[] public paidrents;
    function payRent(uint _rent) public payable returns(bool status) {
        owner.send(_rent);
        paidrents.push(PaidRent({
            id : paidrents.length + 1,
            value : _rent
        }));
        RentPaid(true);
        return true;
    }
}"
52215-0.sol,question,"contract myContract {
    foreignContract created;

    function myContract() {
        created = foreignContract(msg.sender);
    }

    function changeNameMycontract(string name) returns(bool, address) {
        return (created.changeName(name), msg.sender);    
    }

    function ReturnName()returns(string) {
        return created.receiveName();
    }
}"
52215-0.sol,question,"contract foreignContract {
    string name;

    function changeName(string Name) returns(bool) {
        name = Name;
        return true;
    }

    function receiveName() returns(string) {
        return name;
    }
}"
41540-1.sol,question,"contract Test {

  
  function test() pure public {

  }
}"
13827-0.sol,question,"contract SGBFactory {

    event FundsReceived(address indexed sender, uint256 amt);
    mapping (address => uint256) public investmentFrom; 
    address public owner;

    modifier onlyOwner {
        if(msg.sender != owner) throw;
        _;
    }

    function SGBFactory() {
        
        owner = msg.sender;
    }

    function() payable {
        investmentFrom[msg.sender] += msg.value;      
        FundsReceived(msg.sender, msg.value);
    }

}"
9225-0.sol,question,"contract Proof { 
    function register(bytes32 hash) { 
        if (hashToDate[hash] != 0) return; 
        hashToDate[hash] = now; 

    } 
    function dateOf(bytes32 hash) constant returns (uint date) { 
        return hashToDate[hash]; 

    } 
    mapping (bytes32 => uint) hashToDate; 
}"
21380-1.sol,question,"contract B is A {
    function doSmth() {
        super.doSmth();
        
    }
}"
49410-1.sol,question,"contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}"
49410-1.sol,question,"contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}"
49410-1.sol,question,"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  function transfer(address _to, uint256 _value) public returns (bool) {
require(_to != address(0));
require(_value <= balances[msg.sender]);


balances[msg.sender] = balances[msg.sender].sub(_value);
balances[_to] = balances[_to].add(_value);
emit Transfer(msg.sender, _to, _value);
return true;
  }

  function balanceOf(address _owner) public view returns (uint256 balance) {
return balances[_owner];
  }

}"
49410-1.sol,question,"contract Ownable {
   address public owner;


   event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  function Ownable() public {
owner = msg.sender;
  }

   modifier onlyOwner() {
require(msg.sender == owner);
_;
  }


  function transferOwnership(address newOwner) public onlyOwner {
require(newOwner != address(0));
emit OwnershipTransferred(owner, newOwner);
owner = newOwner;
  }

}"
49410-1.sol,question,"contract Pausable is Ownable {
   event Pause();
   event Unpause();

  bool public paused = false;

  modifier whenNotPaused() {
require(!paused);
_;
  }

  modifier whenPaused() {
require(paused);
_;
  }

  function pause() onlyOwner whenNotPaused public {
paused = true;
emit Pause();
  }

   function unpause() onlyOwner whenPaused public {
paused = false;
emit Unpause();
  }
 }"
30274-0.sol,question,"contract Some {
   function () payable {
      withdraw();
   }
   function withdraw(){}

   function paybaleFunction() payable{
      withdraw();
   }
}"
77749-0.sol,question,"contract ApprovalContract {
address public sender;
address public receiver;

address public constant approver = 0x5AEDA56215b167893e80B4fE645BA6d5Bab767DE;

constructor() public {

}
function deposit(address _receiver) external payable {
    require(msg.value > 0);
    sender = msg.sender;
    receiver = _receiver;
}

function viewApprover() external pure returns(address){
    return(approver);
}

function viewRe() external pure returns(address){
    return(receiver);
}


function approve() external payable{
    require(msg.sender == approver);

    receiver.transfer(address(this).balance); 

}
}"
71957-0.sol,question,"contract Test1 {

   struct Car {
       string carCreationDate;
       string carOrigin;
       address carOwner;
   }

   mapping(uint => Car) public CarStruct;

   function setNewCar(string memory _carCreationDate, string memory _carOrigin, address _carOwner) public returns(uint) {
       uint carId = uint(keccak256(abi.encodePacked(msg.sender, now)));
       CarStruct[carId].carCreationDate = _carCreationDate;
       CarStruct[carId].carOrigin = _carOrigin;
       CarStruct[carId].carOwner = _carOwner;
       return carId;
   }
}"
71456-0.sol,question,"contract Tester {

  struct Account {
    uint256 balance; 
  }

  mapping (address => Account) public accounts;

  function addBalance() public payable {
    Account storage a = accounts[msg.sender];
    a.balance = a.balance + msg.value;

  }


}"
55688-0.sol,question,"contract test {

    address public receiver;
    uint public amount;

    function test(address _receiver, uint _amount) public {
        receiver = _receiver;
        amount = _amount;
    }

    function () public {
        receiver.transfer(amount);
        }
}"
51236-1.sol,question,"contract Foo {
    uint256 public x;
    MyContract myContract;
    address myContractAddress;

    constructor(address _myContractAddress) public {
        myContractAddress = _myContractAddress;
    }

    function baz() public {
        myContract = MyContract(myContractAddress);
        x = myContract.baz();
    }
}"
56802-0.sol,question,"contract A {
    function go() public pure returns (uint out) {
        out = 1;
    }
}"
56802-0.sol,question,"contract B {
    function go() public pure returns (uint out) {
        out = 2;
    }
}"
56802-0.sol,question,"contract C {
    function go() public pure returns (uint out) {
        out = 3;
    }
}"
59086-0.sol,question,"contract B { 
  function set() {} 
  function f() { 
    set(); 
  } 
}"
59086-0.sol,question,"contract A is B { 
   function set() { }
}"
37013-0.sol,question,"contract MyToken is StandardToken { 

    

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = 'H1.0'; 
    uint256 public unitsOneEthCanBuy;     
    uint256 public totalEthInWei;         
    address public fundsWallet;           

    
    
    function MyToken() {
        balances[msg.sender] = 50000000000000000000000000;               
        totalSupply = 50000000000000000000000000;                        
        name = ""MyToken"";                                   
        decimals = 18;                                               
        symbol = ""MT"";                                             
        unitsOneEthCanBuy = 10;                                      
        fundsWallet = msg.sender;                                    
    }

    function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        if (balances[fundsWallet] < amount) {
            return;
        }

        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;

        Transfer(fundsWallet, msg.sender, amount); 

        
        fundsWallet.transfer(msg.value);                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}"
16798-0.sol,question,"contract Greeter {

    function Greeter() {

    }

    function sayHello() returns(string) {
        return ""hello"";
    }
}"
3234-0.sol,question,"contract TestContract1 {
        uint public n;
        uint public testValue1;
        bytes6 public value;

        function TestContract1(bytes6 val, uint[] testArray) {
                n = testArray.length;
                testValue1 = testArray[0];
                value = val;
        }
}"
42062-0.sol,question,"contract RobustDividendToken {

    string public name = ""Robust Dividend Token"";
    string public symbol = ""DIV"";
    uint8 public decimals = 18;

    uint256 public totalSupply = 1000000 * (uint256(10) ** decimals);

    mapping(address => uint256) public balanceOf;

    function RobustDividendToken() public {
        
        balanceOf[msg.sender] = totalSupply;
        Transfer(address(0), msg.sender, totalSupply);
    }

    uint256 public scaling = uint256(10) ** 8;

    mapping(address => uint256) public scaledDividendBalanceOf;

    uint256 public scaledDividendPerToken;

    mapping(address => uint256) public scaledDividendCreditedTo;

    function update(address account) internal {
        uint256 owed =
            scaledDividendPerToken - scaledDividendCreditedTo[account];
        scaledDividendBalanceOf[account] += balanceOf[account] * owed;
        scaledDividendCreditedTo[account] = scaledDividendPerToken;
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    mapping(address => mapping(address => uint256)) public allowance;

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value);

        update(msg.sender);
        update(to);

        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;

        Transfer(msg.sender, to, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value)
        public
        returns (bool success)
    {
        require(value <= balanceOf[from]);
        require(value <= allowance[from][msg.sender]);

        update(from);
        update(to);

        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        Transfer(from, to, value);
        return true;
    }

    uint256 public scaledRemainder = 0;

    function deposit() public payable {
        
        uint256 available = (msg.value * scaling) + scaledRemainder;

        scaledDividendPerToken += available / totalSupply;

        
        scaledRemainder = available % totalSupply;
    }

    function withdraw() public {
        update(msg.sender);
        uint256 amount = scaledDividendBalanceOf[msg.sender] / scaling;
        scaledDividendBalanceOf[msg.sender] %= scaling;  
        msg.sender.transfer(amount);
    }

    function approve(address spender, uint256 value)
        public
        returns (bool success)
    {
        allowance[msg.sender][spender] = value;
        Approval(msg.sender, spender, value);
        return true;
    }

}"
13805-1.sol,question,"contract ProductContract {  
    using DataSet for *;  
    DataSet.Data d;  
    mapping (uint => uint) IDToVal;  
    function register (uint p_id, uint val) returns (bool registered) {  
        IDToVal[p_id] = val;  
        registered = true;  
    }  
    function getVal (uint p_id) returns (uint v) {  
         return IDToVal[p_id];  
    }  
}"
67214-0.sol,question,"contract HelloWorld {
    uint public balance;

    constructor() public {
        balance = 1000;
    }

    function deposit(uint _value) constant public returns (uint _newValue) {
        balance += _value;
        return balance;
    }

    function get() constant public returns (uint) {
        return balance;
    }
}"
8395-0.sol,question,"contract C {

event EventAdd_One(int a, int b);

event EventAdd_Two(int a, int b);

function add(int a, int b) returns (int) {

    
    EventAdd_One(a, b);

    if (a > 0 && b > 0) {
        return a + b;
        
        EventAdd_Two(a, b);
    } else return 0;
}

}"
73570-0.sol,question,"contract TransactionOrdering { 
 uint256 price; address owner; 

 function buy(uint256 amount) {
   cost = price * amount       
   return cost;                
 }                             

  function setPrice(uint256 _price) {
    
    if (msg.sender == owner)         
      price = _price;                
  }                                  
}"
79772-0.sol,question,"contract Sender {
    event sent(
        address indexed escrowAddress
    );
    
    function sendEth() external payable{
        Escrow escrow = new Escrow();
        
        address payable _payableEscrow = address(uint160(address(escrow)));
        _payableEscrow.transfer(msg.value);
        
        emit sent(_payableEscrow);
    }
}"
79772-0.sol,question,"contract Escrow {
    function getBalance() external view returns(uint256) {
        return address(this).balance;
    }
}"
57183-0.sol,question,"contract Buyer {
        
        uint  amount;
        mapping (address => uint) balances;

    function send(address receiver, uint amount) {
        if (balances[msg.sender] < amount) return;
            
                balances[msg.sender] -= amount;
                balances[receiver] += amount;
                
            
    }

   function getAmount() returns(uint) {
        return(amount);
    }

}"
57183-0.sol,question,"contract Seller{
        string description;

        Buyer bartscontract;

        function SetDescription(string _description) public {
            description = _description;
            
        }
        function getDescription() constant public returns(string) {
            return description;
        }




    }"
65601-0.sol,question,"contract MyToken {
    string public constant name = ""MyToken"";
    string public constant symbol = ""MYT"";
    uint8 public constant decimals = 0;
    uint public _totalSupply = 1000000;
    uint256 public RATE = 1;
    bool public isMinting = false;
    string public constant generatedBy  = ""Togen.io by Proof Suite"";

    using SafeMath for uint256;
    address public owner;

    
    modifier onlyOwner() {
        if(msg.sender != owner) {
            throw;
        }
        _;
    }

    
    mapping(address => uint256) balances;
    
    mapping(address => mapping(address=>uint256)) allowed;

    
    function () payable {
        createTokens();
    }

    
    constructor() public {
        owner = msg.sender; 
        balances[owner] = _totalSupply;
    }

    
    function burnTokens(uint256 _value) onlyOwner {
        require(balances[msg.sender] >= _value && _value > 0);
        _totalSupply = _totalSupply.sub(_value);
        balances[msg.sender] = balances[msg.sender].sub(_value);
    }

    
    function createTokens() payable {
        if(isMinting == true) {
            require(msg.value > 0);
            uint256  tokens = msg.value.div(100000000000000).mul(RATE);
            balances[msg.sender] = balances[msg.sender].add(tokens);
            _totalSupply = _totalSupply.add(tokens);
            owner.transfer(msg.value);
        }
        else {
            throw;
        }
    }

    function endCrowdsale() onlyOwner {
        isMinting = false;
    }

    function changeCrowdsaleRate(uint256 _value) onlyOwner {
        RATE = _value;
    }

    function totalSupply() constant returns(uint256) {
        return _totalSupply;
    }

    
    function balanceOf(address _owner) constant returns(uint256) {
        return balances[_owner];
    }

    
    function transfer(address _to, uint256 _value) returns(bool) {
        require(balances[msg.sender] >= _value && _value > 0);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }

    
    
    
    
    
    
    function transferFrom(address _from, address _to, uint256 _value) returns(bool) {
        require(allowed[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }

    
    
    function approve(address _spender, uint256 _value) returns(bool) {
        allowed[msg.sender][_spender] = _value; 
        Approval(msg.sender, _spender, _value);
        return true;
    }

    
    function allowance(address _owner, address _spender) constant returns(uint256) {
        return allowed[_owner][_spender];
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}"
60052-0.sol,question,"contract Experment2 {
uint public creationTime = now;
struct Record {
  
   
   string name;
   string senderaddress;
   string reciveraddress;
   string scheduletime;
   string scheduledate;
  
   uint time;
}
mapping (uint => Record[]) records;


function setRec (uint id, string name, string senderaddress, string reciveraddress, string scheduletime, string scheduledate, uint time) public {
     records[id].push(Record(name, senderaddress, reciveraddress, scheduletime, scheduledate, time =now));
}

function getrec(uint id , uint index) constant returns(string, string, string, string, string, uint){ {
    var a = records[id][index].name;
    var b = records[id][index].senderaddress;
    var c = records[id][index].reciveraddress;
    var d = records[id][index].scheduletime;
    var e = records[id][index].scheduledate;
    var f = records[id][index].time;

}
return(a,b,c,d,e,f);
}


function get_last_ten(uint id) constant returns (uint[10]){
    
    uint[10] memory lastItem2;
    for(uint i=0;i<10;i++){
        if(records[id].length>i){
          
            lastItem2[i] = records[id][records[id].length-i-1].time;
        }
    }
    return (lastItem2);
}
}"
41241-0.sol,question,"contract CA4 {


mapping(address=>uint16) public balances;

function getBalance() view returns (uint16) {
uint16 mybalance = balances[msg.sender];
return mybalance;
}

function setBalance(uint16 newbalance) public {
balances[msg.sender]=newbalance;
}


}"
19474-0.sol,question,"contract Escrow {

address public buyer;
address public seller;
address public arbiter;

  function Escrow(address _seller, address _arbiter) {
    buyer = msg.sender;
    seller = _seller;
    arbiter = _arbiter;
}

  function payoutToSeller() {
    if(msg.sender == buyer || msg.sender == arbiter) {
      seller.send(this.balance);
    }
}

  function refundToBuyer() {
    if(msg.sender == seller || msg.sender == arbiter) {
      buyer.send(this.balance);
    }
  }

  function getBalance() constant returns (uint) {
    return this.balance;
  }
}"
74083-0.sol,question,"contract Election {
  
  string public candidate;

  
  function Election () public {
   candidate = ""Candidate 1"";
  }
 }"
17094-0.sol,question,"contract Example_bytes {
    bytes[] list;
    function insertHash(bytes ipfsHash) {
       list.push(ipfsHash); 
    }
}"
17094-0.sol,question,"contract Example_string {
    struct hashes{
         string hash;
    }

    hashes[] list;
    function insertHash(string ipfsHash) {
       list.push(hashes{hash: ipfsHash); 
    }
}"
44220-0.sol,question,"contract test {

    function recoverAddr(bytes32 msgHash, uint8 v, bytes32 r, bytes32 s) constant returns (address) {
        bytes memory prefix = ""\x19Ethereum Signed Message:\n32"";
        bytes32 prefixedHash = sha3(prefix, msgHash);
        address signer = ecrecover(prefixedHash, v, r, s);
        return signer;
    }
}"
54913-1.sol,question,"contract SimpleAuction {

  address public beneficiary;
  uint public auctionStart;
  uint public biddingTime;


  address public highestBidder;

  uint public highestBid;


  bool ended;


  event HighestBidIncreased(address bidder, uint amount);

  event AuctionEnded(address winner, uint amount);


  function SimpleAuction(uint _biddingTime, address _beneficiary) {
    beneficiary = _beneficiary;
    auctionStart = now;
    biddingTime = _biddingTime;
  }


  function bid() {

    require(condition, message); (now > auctionStart + biddingTime) ;


    require(condition, message); (msg.value <= highestBid);



    if (highestBidder != 0) {
      highestBidder.send((highestBid),
    }
    highestBidder = msg.sender;
    highestBid = msg.value;
    HighestBidIncreased(msg.sender, msg.value);
  }

  function auctionEnd() {
    require(condition, message); (now <= auctionStart + biddingTime);
    require(condition, message); (ended);
    AuctionEnded(highestBidder, highestBid);

    beneficiary.send(this.balance);
    ended = true;
  }

  function () {
    throw;
  }
}"
84665-0.sol,question,"contract C {
  using A for A.Storage;
  using B for B.Storage;

  A.Storage internal a;
  B.Storage internal b;

  function doIt() public {
    b.myFunc(a);
  }
}"
45877-0.sol,question,"contract Owned {

    address public owner;

    address public newOwner;


    event OwnershipTransferred(address indexed _from, address indexed _to);


    function constructor() public {

        owner = msg.sender;

    }


    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }


    function transferOwnership(address _newOwner) public onlyOwner {

        newOwner = _newOwner;

    }

    function acceptOwnership() public {

        require(msg.sender == newOwner);

        emit OwnershipTransferred(owner, newOwner);

        owner = newOwner;

        newOwner = address(0);

    }

}"
73810-0.sol,question,"contract C {
    bytes1 b10 = 0x6c;
    bytes1 b11 = 0x69;

    function test1() constant returns (bytes1) {
        return b10 & b11; 

    }

    function test2() constant returns (bytes1) {
        return b10 | b11; 
         
         
        
    }

    function test3() constant returns (bytes1) {
        return ~b10;  
         
         
    }

    **function test4() constant returns (bytes1) {
        return b10 << 1;  
         
         
    }
    function test5() constant returns (bytes1) {
        return b10 >> 1;  
         
         
    }**

}"
31221-0.sol,question,"contract Ownable {
  address public owner;


  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  
  function Ownable() {
    owner = msg.sender;
  }


  
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  
  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}"
31221-0.sol,question,"contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) public constant returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}"
31221-0.sol,question,"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));

    
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  
  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }
}"
31221-0.sol,question,"contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) public constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}"
31221-0.sol,question,"contract BurnableToken is StandardToken {

    event Burn(address indexed burner, uint256 value);

    
    function burn(uint256 _value) public {
        require(_value > 0);
        require(_value <= balances[msg.sender]);
        
        

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        Burn(burner, _value);
    }
}"
83843-0.sol,question,"contract SeedsToken is StandardToken {

  string public name = 'SeedsToken';
  string public symbol = 'SEEDS';
  uint public decimals = 10;
  uint public INITIAL_SUPPLY = 10000000000000000000;

  function SeedsToken() {
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
  }

}"
67350-1.sol,question,"contract Migrations {
  address public owner;
  uint public last_completed_migration;

  modifier restricted() {
    if (msg.sender == owner) _;
  }

  constructor() public {
    owner = msg.sender;
  }

  function setCompleted(uint completed) public restricted {
    last_completed_migration = completed;
  }

  function upgrade(address new_address) public restricted {
    Migrations upgraded = Migrations(new_address);
    upgraded.setCompleted(last_completed_migration);
  }
}"
41709-0.sol,question,"contract MyContract {
  uint lastBlockNumber;

  

  function setLastBlockNumber(uint number) {
    lastBlockNumber = number;
  }

  function claim() public {
    if (block.number >= lastBlockNumber + 10) {
      msg.sender.transfer(this.balance);
    }
  }
}"
75935-1.sol,question,"contract SimpleTokenAttack {
    SimpleToken public victim;

    function SimpleTokenAttack(address _addr) public {
        victim =  SimpleToken(_addr);
    }

    function buy() public returns(bool) {
        
    }

    function send() public returns(bool) {
        
    }
}"
79092-0.sol,question,"contract MyContractPersonStruct {
    Person[] public people;

    uint256 public peopleCount;

    struct Person {
        string _firstName;
        string _lastName;
    }

    function addPerson(string memory _firstName, string memory _lastName) public {
        people.push(Person(_firstName, _lastName));
        peopleCount += 1;
    }
}"
50437-1.sol,question,"contract Owned {
    address public owner;

    constructor() public { 
        owner = tx.origin;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function isDeployed() public pure returns(bool) {
        return true;
    }
}"
50437-1.sol,question,"contract Season is Owned {
    uint64 public begin;
    uint64 public end;
    string name;

    Request[] requests;
    mapping(bytes30 => uint) requestServiceNumberToIndex;

    event RequestCreated(bytes30 indexed serviceNumber, uint index);

    constructor(uint64 begin_, uint64 end_, string name_) public {
        begin = begin_;
        end = end_;
        name = name_;
    }

    function createRequest(bytes30 serviceNumber, uint64 date, DeclarantType declarantType, string declarantName, uint64 fairId, uint64[] assortment, uint64 district, uint64 region, string additionalData) public onlyOwner {     
        uint index = requestServiceNumberToIndex[serviceNumber];

        require(index == 0 && (requests.length == 0 || requests[0].serviceNumber != serviceNumber));

        requests.length++;
        index = requests.length - 1;    
        requestServiceNumberToIndex[serviceNumber] = index;

        Request storage request = requests[index];

        request.serviceNumber = serviceNumber;
        request.date = date;
        request.declarantType = declarantType;
        request.declarantName = declarantName;
        request.fairId = fairId;
        request.district = district;
        request.region = region;
        request.assortment = assortment;
        request.additionalData = additionalData;

        emit RequestCreated(serviceNumber, index);
    }

    function getSeasonDetails() public view returns(uint64, uint64, string) {
        return (begin, end, name);
    }

    function getRequestByServiceNumber(bytes30 serviceNumber) public view returns(bytes30, uint64, DeclarantType, string, uint64, uint64[], uint64, uint64, string) {
        return getRequestByIndex(requestServiceNumberToIndex[serviceNumber]);
    }

    function getRequestByIndex(uint index) public view returns(bytes30, uint64, DeclarantType, string, uint64, uint64[], uint64, uint64, string) {
        Request storage request = requests[index];
        bytes30 serviceNumber = request.serviceNumber;
        string memory declarantName = request.declarantName;
        uint64[] memory assortment = getAssortment(request);        
        string memory additionalData = request.additionalData;
        return (serviceNumber, request.date, request.declarantType, declarantName, request.fairId, assortment, request.district, request.region, additionalData);
    }

    function getAssortment(Request request) private pure returns(uint64[]) {
        uint64[] memory memoryAssortment = new uint64[](request.assortment.length);
        for (uint i = 0; i < request.assortment.length; i++) {
            memoryAssortment[i] = request.assortment[i];
        }
        return memoryAssortment;
    }

    struct Request {
        bytes30 serviceNumber;
        uint64 date;
        DeclarantType  declarantType;
        string declarantName;
        uint64 fairId;
        uint64[] assortment;
        uint64 district;
        uint64 region;
        string additionalData;
    }

    enum DeclarantType {
        A,
        B,
        C,
        D
    }
}"
7058-0.sol,question,"contract Test {
    uint x;

    function Test() { 
        x = 0;
    }

    function inc() returns (uint) { 
        x = x + 1;
        return x;
    }

    function get() returns (uint) { 
        return x;
    }
}"
54881-0.sol,question,"contract One {
 ...
}"
54881-0.sol,question,"contract Builder {
    function create(uint8 amount) public returns (address[]) {
        uint8 i = 0;
        address[] contracts;
        while (i++ < amount) {
           address[i] = new One();
        }
        return contracts;
    }
}"
55094-0.sol,question,"contract SimpleAuctions {
    uint  public beneficiary; 
    uint public auctionEnd; 
    address public highestBidder; 
    uint public highestBid; 
    mapping(address => uint) pendingReturns; 
    bool ended; 
    uint valueforbeneficiary;
    event HighestBidIncreased(address bidder, uint amount); 
    event AuctionEnded(address winner, uint amount); 
    function SimpleAuction(uint[] valueforgoods) public pure {
        uint allvalue;
        uint i;
        for (i = 0;i < valueforgoods.length;i++){
            allvalue = allvalue + valueforgoods[i];

             if (valueforgoods[i] > highestBid) {  
                highestBid = valueforgoods[i];
            }
        }
    }
    function bid() public payable {
        require(
            now <= auctionEnd,
            ""Auction already ended.""
        );
        require(
            msg.value > highestBid,
            ""There already is a higher bid.""
        );
        if (highestBid != 0) {
            pendingReturns[highestBidder] += highestBid;
        }
        highestBidder = msg.sender;
        highestBid = msg.value;
        
        emit HighestBidIncreased(msg.sender, msg.value);
    }

    function auctionEnd() public {
        require(now >= auctionEnd, ""Auction not yet ended."");
        require(!ended, ""auctionEnd has already been called."");
        ended = true;
        emit AuctionEnded(highestBidder, highestBid);
        beneficiary.transfer(highestBid);
    }
}"
79279-0.sol,question,"contract ERC20Token {
    string name;
    mapping(address => uint256) public balances;

    function mint() payable public {
        balances[msg.sender] += msg.value;
    }
}"
79279-0.sol,question,"contract MyContract {
    address public token;

    address payable wallet;

    constructor(address payable _wallet, address _token) public {
        wallet = _wallet;
        token = _token;
    }
    function() external payable{
       buyToken();
    }
    function buyToken() public payable {
        ERC20Token _token = ERC20Token(address(token));
        _token.mint();
        wallet.transfer(msg.value);
    }
}"
44729-1.sol,question,"contract TheContract {
    address public mateAddress = OxA

    function () payable public {
        if (msg.sender == mateAddress) {
            
        }
    }

    function checkStatus() {
        if (someCondition) {
            address myAddress = this;
            mateAddress.send(myAddress.balance);
        }
    }
}"
43405-0.sol,question,"contract NullFunction {
  function ccccvKygDv() public pure { }
}"
43405-0.sol,question,"contract NormalFunction {
  function NothingWrongHere() public pure { }
}"
70643-0.sol,question,"contract Savings {
 address owner;
 uint256 deadline;

modifier onlyOwner() {
    require(msg.sender == owner);
    _;
}

function deposit(uint256 amount) public payable {
    require(msg.value == amount);
}

function Savings(uint256 numberOfDays) public payable {
    owner = msg.sender;
    deadline = now + (numberOfDays * 1 days);
}

function withdraw() public onlyOwner  {
    require(now >= deadline);

    msg.sender.transfer(address(this).balance);
  }
}"
44689-0.sol,question,"contract Taxi {

    enum State {IDLE, FINDING_DRIVER, AWAITING_PAYMENT, AWAITING_DESTINATION, COMPLETE}
    State public currentState;
    mapping (address => uint) public balances;
    bytes32 STRING_COMPLETE = ""Complete"";
    bytes32 STRING_PARTIAL = ""Partial"";

    modifier customerOnly() { require(msg.sender == customer); _; }
    modifier driverOnly() { require(msg.sender == driver); _; }
    modifier arbiterOnly() { require(msg.sender == arbiter); _; }
    modifier inState(State expectedState) { require(currentState == expectedState); _; }

    address public customer;
    address public driver;
    address public arbiter;

    function Taxi(address _customer, address _driver, address _arbiter) public {
        customer = _customer;
        driver = _driver;
        arbiter = _arbiter;
    }

    function assignDriver() customerOnly inState(State.IDLE) public {
        
        currentState = State.FINDING_DRIVER;
    }

    function confirmAmount(uint amount) driverOnly inState(State.FINDING_DRIVER) public returns (bool ) {
        if(amount < 0) {
            amount = 20;
        }
        
        if(balances[customer] < amount) {
            return false;
        }
        currentState = State.AWAITING_DESTINATION;
        balances[arbiter] += amount;
        balances[customer] -= amount;
        return true;
    }
}"
82818-0.sol,question,"contract school {
    address public owner;
    address[] public teachers;

    mapping(uint => Class) public classes;

    struct Class {
        uint id;
        address teacher;
        address[] pupils;
    }

    constructor() public{
        owner = msg.sender;
    }

    function addTeacher(address _address) public {
        require(msg.sender == owner);
        teachers.push(_address);
    }

    function addClass(address _teacher, address[] memory _pupils) public {
        require(msg.sender == teachers);
        classes[1] = Class(1, _teacher, _pupils);
    }

}"
82058-0.sol,question,"contract MyContract {
  event Log(address addr);

  fallback() external payable{
    emit Log(address(this));
  }

  function add(uint256 a, uint256 b) public pure returns (uint256) {
    return a + b;
  }
}"
70795-0.sol,question,"contract Test {
    interfaceLib _interface;
    constructor(address i) public {
        _interface = interfaceLib(i);
    }

    uint[] public xs;

    function callLibFunc(uint x, uint y) public view returns(uint) {
        return _interface.callme(x, y);
    }

    function callLibFunc2(uint y) public returns(uint) {
        xs.push(1);
        xs.push(2);
        return _interface.callme2(xs, y);
    }
}"
57191-0.sol,question,"contract Test {
    uint counter = 0;
    function A() public returns (uint256) {
        counter++;
        return counter;
    }

    function B() public view returns (uint256) {
        return A();
    }
}"
52753-0.sol,question,"contract MasterConstituency is Ownable {
    enum ConstituencyType {FEDERAL, STATE}
    uint totalVotes;

    modifier isValidConstituencyType(uint _constituencyType){
        require(uint(ConstituencyType.STATE) >= _constituencyType);
        _;
    }

    modifier isUniqueParty(string _name){
        for (uint x = 0; x < parties.length; x++) {
            if (compareStrings(parties[x].name, _name)) {
                revert();
            }
        }
        _;
    }

    struct Party {
        string name;
        string abbreviation;
    }

    struct Candidate {
        string name;
        uint numVotes;
        bool validCandidate;
    }

    struct Voter {
        bool hasVoted;
        bool validFederalVote;
        bool validStateVote;
        uint federalCandidateVote;
        uint stateCandidateVote;
    }

    Candidate[] candidates;
    Party[] parties;

    mapping(string => Voter) votes;
    mapping(string => address) constituencies;
    mapping(uint => uint) candidateToParty;

    function initialiseConstituency(
        uint _constituencyType,
        string _constituencyCode,
        string _constituencyName) public onlyOwner() isValidConstituencyType(_constituencyType) returns (address) {
        address constituency = new BaseConstituency(_constituencyType, _constituencyName);
        constituencies[_constituencyCode] = constituency;

        return constituency;
    }

    function registerParty(string _name, string _abbreviation) public onlyOwner() isUniqueParty(_name) {
        parties.push(Party(_name, _abbreviation));
    }

    function getConstituencyAddress(string _constituencyCode) public view returns (address) {
        return constituencies[_constituencyCode];
    }

    function compareStrings(string a, string b) public pure returns (bool){
        bytes32 c = keccak256(abi.encodePacked(a));
        bytes32 d = keccak256(abi.encodePacked(b));

        return c == d;
    }
}"
18097-0.sol,question,"contract Organization {



 struct Proposal {
   uint code;
   uint amount;
  string description;
  uint numberOfVotes;
  string name;
}

Proposal[] public proposals;
uint public numberOfProposals;


 event ProposalAdded(uint code, uint amount, string description, int 
 numberOfVotes , string name);


 function addProposal(uint amount, string description , string name) 
 returns (uint) {

proposals.push(Proposal(numberOfProposals,amount,description,0,name));
ProposalAdded(numberOfProposals,amount,description, 0, name);
numberOfProposals++;
return numberOfProposals;

}



 function proposalExists (uint code) returns (bool) {
   for(uint i = 0; i < proposals.length; i++) {
     if (proposals[i].code == code) {
        return true;
      }
    }
     return false;
 }

function numOfProposals() returns (uint){
    return numberOfProposals;
  }

function getProposalName(uint index) returns (string){
    return proposals[index].name;
}

function getProposalDescription(uint index) returns (string){
    return proposals[index].description;
}

function getProposalIndex(string name) returns (uint){
  for(uint i = 0; i < proposals.length; i++) {
      bytes memory a = bytes(proposals[i].name);
      bytes memory b = bytes(name);
    if (a.length == b.length) {
        return i;
    }
  }
  return 1000000;
}

function voteFotProposal(uint index) {
    proposals[index].numberOfVotes++;
  }

function getProposalVotesIndex(uint index) {
    proposals[index].numberOfVotes;
  }


struct Memmber {
  uint id;
  string name;
}

struct Commitee {
  uint id;
  string name;
  string missionStatement;
  uint balance;
  string [] memmbers;
}

event MemmberAdded(uint id, string name);
event CommiteeCreated(string name,string missionStatement );

string [] public memmbersArray;
string[] public comitees;
uint public numOfComitees = 0;
uint public numOfTotalMemmbers = 0;
Commitee [] fullComitees;




  function convertMemmberStrings (bytes32 [] values) internal returns 
  (string []){

        for(uint i=0;i<values.length;i++){
            MemmberAdded(numOfTotalMemmbers, 
            bytes32ToString(values[i]));
            memmbersArray.push(bytes32ToString(values[i]));
            numOfTotalMemmbers++;
    }
    return memmbersArray;
}


function addCommitee 
(string name, string missionStatement , uint funds, bytes32 [] values)
returns (string)
{
  comitees.push(name);
  CommiteeCreated(name,missionStatement );
  fullComitees.push(Commitee(numOfComitees, name, missionStatement, funds, convertMemmberStrings(values)));
  numOfComitees++;
  return name;
}

function getComitees (uint index) returns (string){
  return comitees[index];
}

function numberOfCommitees () returns (uint){
  return numOfComitees;
}

 function bytes32ToString(bytes32 x) constant returns (string) {
    bytes memory bytesString = new bytes(32);
    uint charCount = 0;
    for (uint j = 0; j < 32; j++) {
      byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));
      if (char != 0) {
        bytesString[charCount] = char;
        charCount++;
     }
 }
bytes memory bytesStringTrimmed = new bytes(charCount);
for (j = 0; j < charCount; j++) {
    bytesStringTrimmed[j] = bytesString[j];
}
return string(bytesStringTrimmed);
}

 function uintToBytes(uint v) constant returns (bytes32 ret) {
    if (v == 0) {
      ret = '0';
   }
   else {
    while (v > 0) {
        ret = bytes32(uint(ret) / (2 ** 8));
        ret |= bytes32(((v % 10) + 48) * 2 ** (8 * 31));
        v /= 10;
    }
 }
 return ret;
}


}"
12447-1.sol,question,"contract RouteCoin {

    string public parentContracts;

    address private buyer;   

    address private seller;

    uint private contractStartTime;

    address private finalDestination;  

    uint private contractGracePeriod;

    function RouteCoin(address _finalDestination, uint _contractGracePeriod, string _parentContracts) {
        buyer = msg.sender;
        contractStartTime = now;        
        finalDestination = _finalDestination;
        contractGracePeriod = _contractGracePeriod;
        parentContracts = _parentContracts;
    }
"
55900-1.sol,question,"contract SalesContract {
    address public owner;
    bool public sold = false;
    string public salesDescription = 'Volvo V40 HF 56 32';
    uint price = 2 ether;

    function SalesContract() payable {
        owner = msg.sender;
    }

    function buy() payable {
        if(msg.value >= price) {
            owner.transfer(this.balance);
            owner = msg.sender;
            sold = true;
        } else {
            revert();
        }
    }
}"
45324-0.sol,question,"contract MyToken is ERC721Token { 
  function MyToken() ERC721Token(NAME, SYMB) public payable {
  }
  function purchase(uint256 _tokenId) public payable {
    
  }
}"
23297-0.sol,question,"contract KrakenPriceTicker is usingOraclize {

    string public ETHXBT;

    event newOraclizeQuery(string description);
    event newKrakenPriceTicker(string price);


    function KrakenPriceTicker() {
        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
        update();
    }

    function __callback(bytes32 myid, string result, bytes proof) {
    if (msg.sender != oraclize_cbAddress()) throw;
        ETHXBT = result;
        newKrakenPriceTicker(ETHXBT);
        update();
    }

    function update() payable {
        if (oraclize_getPrice(""URL"") > this.balance) {
            newOraclizeQuery(""Oraclize query was NOT sent, please add some ETH to cover for the query fee"");
    } else {
            newOraclizeQuery(""Oraclize query was sent, standing by for the answer.."");
            oraclize_query(60, ""URL"", ""json(https:
        }
    }

}"
83520-1.sol,question,"contract BuyFrom {
    address payable private token;

    constructor(address payable _token) public {
        token = _token;
    }

    function buyToken(address contributor) external payable {
       InterfaceToken(token).invest(contributor);
    }
}"
60193-0.sol,question,"contract vendorContract {

    uint public vendorID;
    uint public ownerID;
    uint256 public contractValue;
    string public contractDescription;
    string public contractStatus;
    string public paymentStatus;
    address public contractOwner;
    address public contractVendor;
    string constant newcon = ""New"";
    string constant wipcon =  ""WIP"";
    string constant reqcon  = ""Requested"";
    string constant shipcon = ""Shipped"";
    string constant endcon = ""Completed"";
    string constant err = ""Error"";


    modifier isOwner()
    {
        if (msg.sender != contractOwner) throw;
        _ ;
    }

    modifier isVendor()
   {
        if (msg.sender != contractVendor) throw;
        _ ;
    }

    function vendorContract(uint _vid, string _desc) public {
        vendorID = _vid;
        contractStatus=""New"";
        contractOwner=msg.sender;
        contractDescription= _desc;

    }

      function acceptContract(uint256 _cvalue, uint _vidd) public {
        if (vendorID !=  _vidd) {
            contractStatus = err;
            throw;
        }

        contractStatus=wipcon;
        contractValue = _cvalue;
        contractVendor = msg.sender;
        }

    function requestPayment() isVendor {
    paymentStatus=reqcon;
    contractStatus=shipcon;
    }

    function paymentStatus() returns (string) {
    return paymentStatus;
    }


    function payVendor() payable isOwner {   
     if  (!contractVendor.send(contractValue))
        throw;
    
    contractStatus = endcon;


    }

   }"
74271-0.sol,question,"contract  Example {

    constructor () public {}

    function () external payable {}

    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }

    function withdraw() public {
        msg.sender.transfer(address(this).balance);
    }
}"
69620-0.sol,question,"contract A {

   function sendValue(B _externalContract, uint _value) {
     _externalContract.acceptValue(_value);
   }
}"
69620-0.sol,question,"contract B {
   function acceptValue(unit value);
}"
35289-1.sol,question,"contract owned {
    address public owner;

    function owned() public{
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) public {
        owner = newOwner;
    }
}"
35289-1.sol,question,"contract tokenRecipient {
    event receivedEther(address sender, uint amount);
    event receivedTokens(address _from, uint256 _value, address _token, bytes _extraData);

    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData)public{
        Token t = Token(_token);
        require(t.transferFrom(_from, this, _value));
        receivedTokens(_from, _value, _token, _extraData);
    }

    function () public payable {
        receivedEther(msg.sender, msg.value);
    }
}"
35289-1.sol,question,"contract Token {
    mapping (address => uint256) public balanceOf;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
}"
77008-0.sol,question,"contract Storage {
  string Hash;

  function set(string memory x) public {
    Hash = x;
  }

  function get() public view returns (string memory) {
    return Hash;
  }
}"
30064-0.sol,question,"contract HasOwner {
    address public owner;

    function HasOwner() public {
        owner = msg.sender;
    }
}"
69323-1.sol,question,"contract VatValidator is usingOraclize {

    string public isValid;

    event newOraclizeQuery(string description);
    event newVATResult(string price);


    constructor() public {
        
        OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
    }

    function __callback(bytes32 myid, string memory result, bytes memory proof) public {
        require (msg.sender != oraclize_cbAddress());
        isValid = result;
        emit newVATResult(isValid);
        update();
    }

    function update() public payable {

        emit newOraclizeQuery(""Oraclize query was sent, standing by for the answer."");

        oraclize_query(""URL"", ""json(http:

    }
}"
57628-1.sol,question,"contract B {
    function test() public {
        uint startTime = A.START_TIME;
    }
}"
74276-0.sol,question,"contract A {
  address payable public owner;
  uint public block_number;

  constructor () public payable {
    owner = msg.sender;
  }

  function getBalance () public view returns (uint) {
      return address(this).balance;
  }

  function () external payable {
      block_number = block.number; 
  }
}"
74276-0.sol,question,"contract B {
  address payable public owner;
  address payable public contract_a = 0x600F51a64e8A703b759EB3d735132d6C802A0a7b;  

  constructor () public payable {
    owner = msg.sender;
  }

  function () external payable {
      contract_a.transfer(msg.value);
  }
}"
47747-0.sol,question,"contract RFID {

    struct StateStruct {
        bytes32 description;
        mapping(bytes32 => bytes32) sub_state;
    }

    struct ObjectStruct {
        StateStruct state;
        address owner; 
        bool isObject;
    }

    mapping(bytes32 => ObjectStruct) objectStructs;
    bytes32[] public objectList;

    event LogNewObject(address sender, bytes32 indexed id, bytes32 sub_states_types, bytes32 sub_states_values, address owner);
    event LogChangeObjectState(address sender, bytes32 indexed id, bytes32 sub_states_types, bytes32 sub_states_values);
    event LogChangeObjectOwner(address sender, bytes32 indexed id, address newOwner);

    function isObject(bytes32 _id) public view returns(bool isIndeed) {
        return objectStructs[_id].isObject;
    }

    function getObjectCount() public view returns(uint count) {
        return objectList.length;
    }

    

    function newObject(bytes32 _id, uint256 number_of_sub_states, bytes32[10] sub_states_types, bytes32[10] sub_states_values, address _owner) public returns(bool success) {
        require(!isObject(_id));

        uint256 counter=0;
        for(counter; counter < number_of_sub_states; counter++) {

            objectStructs[_id].state.sub_state[sub_states_types[counter]] = sub_states_values[counter];

            emit LogNewObject(msg.sender, _id, bytes32(sub_states_types[counter]), bytes32(sub_states_values[counter]), _owner);

        }

        objectStructs[_id].owner = _owner;
        objectStructs[_id].isObject = true;

        objectList.push(_id);

        return true;
    }

    function changeObjectState(bytes32 _id, uint256 number_of_sub_states, bytes32[10] sub_states_types, bytes32[10] sub_states_values) public returns(bool success) {
        require(isObject(_id));
        uint256 counter=0;
        for(counter; counter < number_of_sub_states; counter++) {

            objectStructs[_id].state.sub_state[sub_states_types[counter]] = sub_states_values[counter];

            emit LogChangeObjectState(msg.sender, _id, bytes32(sub_states_types[counter]), bytes32(sub_states_values[counter]));

        }
        
        
        return true;
    }

    function changeObjectOwner(bytes32 _id, address _newOwner) public returns(bool success) {
        require(isObject(_id));
        objectStructs[_id].owner = _newOwner;
        emit LogChangeObjectOwner(msg.sender, _id, _newOwner);
        return true;
    }

}"
71303-0.sol,question,"contract MyContract {

    address[] public contracts;    
    event ContractCreated(address newAddress);

    constructor() public { }

    function createOtherContract() public {
        OtherContract contract = new OtherContract();
        address contractAddress=address(contract);
        contracts.push(contractAddress);
        emit ContractCreated(contractAddress);
    }
    function getDeployedContracts() public view returns (address[] memory) {
        return contracts;
    }
}"
31636-0.sol,question,"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;
  bytes32 hashed;

  mapping(address => uint256) balances;
  mapping(bytes32 => uint256) dks;

  function transfer(address _to, uint256 _value) returns (bool) {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }

  function dsend(address _sendto, uint256 _amount) payable returns (bool) {
    hashed = keccak256(_sendto);
    balances[msg.sender] = balances[msg.sender].sub(_amount);
    dks[hashed] = dks[hashed].add(_amount);
    Dtransfer(msg.sender, _amount);
    return true;
  }  

  function dreceive(amount) payable returns (bool) {
    hashed = keccak256(msg.sender); 
    dks[hashed] = dks[hashed].sub(amount);
    balances[msg.sender] = balances[msg.sender].add(amount);
    Drec(this, amount);
    return true; 
  }

}"
58182-0.sol,question,"contract SimpleStorage {
uint storedData;

function set(uint x) public {
    storedData = x;
}

function get() public view returns (uint) {
    return storedData;
}
}"
60228-0.sol,question,"contract DappTokenSale {
    address admin;
    DappToken public tokenContract;
    uint256 public tokenPrice;
    uint256 public tokensSold;
    uint256 public decimals;


    event Sell(address _buyer, uint256 _amount);

    function DappTokenSale(DappToken _tokenContract, uint256 _tokenPrice) public {
        admin = msg.sender;
        tokenContract = _tokenContract;
        tokenPrice = _tokenPrice;
    }

    function multiply(uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x);
    }

    function buyTokens(address _receiver, uint256 _amount) public payable {
        _amount = msg.value;
        require(_receiver != address(0));
        require(_amount > 0);
        uint256 tokensToBuy = multiply(_amount, (10 ** decimals)) / 1 ether * tokenPrice;
        require(tokenContract.transfer(msg.sender, tokensToBuy));
        tokensSold += _amount;

        emit Sell(msg.sender, tokensToBuy);
    }

  
    function endSale() public {
            
            require (msg.sender == admin);

             
            require(tokenContract.transfer(admin,tokenContract.balanceOf(this)));


            
            selfdestruct(admin);
    }
}"
18332-0.sol,question,"contract DataStore  {

    event Borrow(uint indexed bookId, address indexed borrower, uint timestamp);

    function borrowEvent(uint id, address borrower) {
        Borrow(id, msg.sender, now);
    }
 }"
74613-0.sol,question,"contract interaction_1 {

    string public description;
    string public user_prediction;
    uint public amount;
    event teamAccepted(string team_1);


    function user_input (string memory team) public payable {
           user_prediction = team;
           emit teamAccepted(user_prediction);

    }
    function get_user_input()view public returns(string memory) {
        return user_prediction;
    }

}"
74613-0.sol,question,"contract interaction_2 {
    function getValue (address addr)public returns (string memory);
}"
30678-0.sol,question,"contract BookStore {

enum BookStatus { Open, Sold, Unsold }

mapping(uint => Book) stores;
uint public count;

struct Book{  
uint bookId;  
string name;    
BookStatus status;
}

function BookStore() {
count = 0;   
}

function addP(string _name) {
count += 1;
Book memory b1= Book(count,_name,BookStatus.Open);
stores[count] = b1;    
}

function updateStatus (uint _bookId) public {
Book storage b1= stores[_bookId];
b1.status = BookStatus.Sold;
}

function getStatus(uint _bookId) public returns (BookStatus) {
Book storage b1= stores[_bookId];
return b1.status;
}

}"
63116-1.sol,question,"contract InterfaceContract is InterfaceTest {
    function testInterface() external pure returns(uint) {
        return 9;
    }
}"
24910-1.sol,question,"contract ContractB {

    uint public supplyB;

    event LogSupplyA(uint supplyA);

    function ContractB () {
        supplyB = 100;
    }

    function deployA() returns (address) {
        ContractA newContract = new ContractA(250);

        newContract.setNewSupply();
        LogSupplyA(newContract.supplyA());

        return newContract;
    }
}"
42060-1.sol,question,"contract CRD2 {
address public beneficiary;
uint public fundingGoal;
uint public amountRaised;

uint public amountToken;

uint public deadline;
uint public price;
token public tokenReward;
mapping(address => uint256) public balanceOf;
bool fundingGoalReached = false;
bool crowdsaleClosed = false;
event GoalReached(address recipient, uint totalAmountRaised);
event FundTransfer(address backer, uint amount, bool isContribution);

event TokenTransfer(address backer, uint amountToken, bool isContribution);


function CRD2(
    address ifSuccessfulSendTo,
    uint fundingGoalInEthers,
    uint durationInMinutes,
    uint etherCostOfEachToken,
    address addressOfTokenUsedAsReward
) {
    beneficiary = 0xAb44F092f1E01E8f91DfE9035A09461B928eDFb7;
    fundingGoal = 0.1 * 1 ether;
    deadline = now + 10 * 1 minutes;
    price = 0.1 * 1 ether;
    tokenReward = token(0x390fc971502fb5236570ba28c81e0Ba71AC55910);
}


function () payable {
    require(!crowdsaleClosed);
    uint amount = msg.value;
    balanceOf[msg.sender] += amount;
    amountRaised += amount;
    tokenReward.transfer(msg.sender, amount / price);
    FundTransfer(msg.sender, amount, true);
}

modifier afterDeadline() { if (now >= deadline) _; }


function checkGoalReached() afterDeadline {
    if (amountRaised >= fundingGoal){
        fundingGoalReached = true;
        GoalReached(beneficiary, amountRaised);
    }
    crowdsaleClosed = true;
}



function safeWithdrawal() afterDeadline {
    if (!fundingGoalReached) {
        uint amount = balanceOf[msg.sender];
        balanceOf[msg.sender] = 0;
        if (amount > 0) {
            if (msg.sender.send(amount)) {
                FundTransfer(msg.sender, amount, false);
            } else {
                balanceOf[msg.sender] = amount;
            }
        }
    }

    if (fundingGoalReached && beneficiary == msg.sender) {
        if (beneficiary.send(amountRaised)) {
            FundTransfer(beneficiary, amountRaised, false);
            TokenTransfer(beneficiary, amountToken, false);
        } else {
            
            fundingGoalReached = false;
        }
    }
}
"
84734-0.sol,question,"contract EthReceiver {
    address payable private owner;

    constructor() public {
        owner = msg.sender;
    }

    receive() external payable {
        require(msg.value > 0, ""No ETH sent."");
    }

    function returnBalance() public view returns(uint) {
        return address(this).balance;
    }
}"
63539-0.sol,question,"contract PayEther {
    mapping(address => bool) payedCustomer;
    uint64 private peopleThatPayed;
    address private owner;

    constructor(uint minimumAmount) public {
        owner = msg.sender;
        peopleThatPayed = 0;
    }

    function pay() payable public {
        require(msg.value > 0, ""Address didn't send enough money."");
        payedCustomer[msg.sender] = true;
        peopleThatPayed++;
    }

    function findHowManyPeoplePayed() view public returns (uint64){
        require(payedCustomer[msg.sender], ""Address never payed!"");
        return peopleThatPayed;
    }
}"
61714-0.sol,question,"contract Back is Ownable {

      using SafeMath for uint;

      modifier affordPay() {
        require(msg.sender.balance > msg.value, ""You don't have enough eth!!"");
        _;
      }

      function back() external affordPay() payable {
        msg.sender.transfer(msg.value);
      }

    }"
15857-2.sol,question,"contract TestToken {

  function testTotalSupplyOfCoin() {
    Token meta = new Token();

    uint expected = 8000000000000;

    Assert.equal(meta.totalSupply(), expected, ""Owner should have 8000000000000 Coins initially"");
  }

}"
63946-0.sol,question,"contract Greeter {
string public greeting;

function Greeter() public {
    greeting = 'Hello';
}

function setGreeting(string _greeting) public {
    greeting = _greeting;
}

function greet() view public returns (string) {
    return greeting;
}"
83441-0.sol,question,"contract ReceiveBalanceContract is Ownable {

    receive() external payable {
        require(msg.sender == address(SendBalanceContract));
    }

    function withdrawBalance() external {

        owner.call.value(address(this).balance)();
    }
}"
83441-0.sol,question,"contract SendBalanceContract {

    constructor(address _nftAddress) public {

        ERC721 candidateContract = ERC721(_nftAddress);
        require(candidateContract.supportsInterface(InterfaceSignature_ERC721)); 
        nonFungibleContract = candidateContract;
    }

    function withdrawBalance() external {
        address nftAddress = address(nonFungibleContract);

        require(msg.sender == owner || msg.sender == nftAddress); 
        bool res = nftAddress.call.value(address(this).balance)(""""); 
    }
}"
34352-1.sol,question,"contract owned {
    address public owner;

    function owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}"
34352-1.sol,question,"contract Token {

    
    function totalSupply() constant public returns (uint256 supply) {}

    
    
    function balanceOf(address _owner) constant public returns (uint256 balance) {}

    
    
    
    
    function transfer(address _to, uint256 _value) public returns (bool success) {}

    
    
    
    
    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}

    
    
    
    
    function approve(address _spender, uint256 _value) public returns (bool success) {}

    
    
    
    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {}

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

}"
34352-1.sol,question,"contract StandardToken is Token {

    function transfer(address _to, uint256 _value) public returns (bool success) {
        
        
        
        
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        
        
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant public returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    uint256 public totalSupply;
}"
47462-0.sol,question,"contract A {
    address public beneficiary;

    function A(address _beneficiary) public {
         beneficiary = _beneficiary;
    }

    function () public payable {
         beneficiary.transfer(msg.value);
    }
}"
19102-0.sol,question,"contract Random {
    
    function getRand(uint blockNumber, uint max) constant internal returns(uint) {
        return(uint(sha3(block.blockhash(blockNumber))) % max);
    }
}"
64789-1.sol,question,"contract ERC20 { 

     function totalSupply()public view returns (uint total_Supply);
    function balanceOf(address who)public view returns (uint256);
    function allowance(address owner, address spender)public view returns (uint);
     function transferFrom(address from, address to, uint value)public returns (bool ok);
     function approve(address spender, uint value)public returns (bool ok);

   function transfer(address to, uint value)public returns (bool ok);

     event Transfer(address indexed from, address indexed to, uint value);
     event Approval(address indexed owner, address indexed spender, uint value);

 }"
64789-1.sol,question,"contract FiatContract {
     function USD(uint _id) constant returns (uint256); }"
64789-1.sol,question,"contract P1 is ERC20 { 
    using SafeMath for uint256;


   FiatContract price = FiatContract(0x8055d0504666e2B6942BeB8D6014c964658Ca591); 

     
     string public constant name = ""P1"";
     
     string public constant symbol = ""P1"";
     uint8 public constant decimals = 8;
     uint public _totalsupply = 1000000000 * (uint256(10) ** decimals);
     address public owner;
     bool stopped = false;
     uint256 public startdate;
     uint256 ico_first;
     uint256 ico_second;
     uint256 ico_third;

 uint256 ico_fourth;
 address central_account;
 mapping(address => uint) balances;
 mapping(address => mapping(address => uint)) allowed;


 enum Stages {
     NOTSTARTED,
     ICO,
     PAUSED,
     ENDED
 }

 Stages public stage;

 modifier atStage(Stages _stage) {
     if (stage != _stage)
         
         revert();
     _;
 }"
28203-1.sol,question,"contract simpleStorage {
    struct BizCard {
        uint id;
        bytes32 name;
        bytes32 email;
        string comment;
    }

    
    uint public count = 0;

    
    mapping (uint => BizCard) cards;

    
    function createCard(uint id, bytes32 name, bytes32 email, string comment) {
        cards[count] = BizCard(id, name, email, comment);
        count++;
    }

    
    function getCard(uint index) constant returns (uint id, bytes32 name, bytes32 email, string comment) {
        id = cards[index].id;
        name = cards[index].name;    
        email = cards[index].email;
        comment = cards[index].comment;
    }

    function getCardById(uint id) constant returns (uint idRet, bytes32 name, bytes32 email, string comment, uint status) {
        for (var i = 0; i < count; i++) {
            if (cards[i].id == id) {
                idRet = cards[i].id;
                name = cards[i].name;
                email = cards[i].email;
                comment = cards[i].comment;
                return;
            }
        }
    }
}"
82027-1.sol,question,"contract TestMyAdvancedToken {

  function testCoinName() public {

    MyAdvancedToken tokenContract = MyAdvancedToken(DeployedAddresses.MyAdvancedToken());

    string memory expected = ""name"";

    Assert.equal(tokenContract.name(), expected, ""Expected name is name"");
  }
}"
23200-0.sol,question,"contract test {
    string stat;
    address owner;

    event statChanged(string _stat);

    function test() {
        stat = ""INIT"";
        owner = msg.sender;
    }

    function() payable {
        stat = ""PAID"";
    }

    function getStat() constant returns (string) {
        return stat;
    }

    function getBalance() constant returns (uint) {
        return this.balance;
    }

    function getOwner() constant returns (address) {
        return owner;
    }

    function send2Owner() {
        owner.transfer(this.balance);
    }

    function update(string _stat) {
        stat = _stat;
        statChanged(_stat);
    }
}"
57293-0.sol,question,"contract ForeignToken {
    function balanceOf(address _owner) constant public returns (uint256);
    function transfer(address _to, uint256 _value) public returns (bool);
}"
57293-0.sol,question,"contract MatoxToken is ERC20 {

    using SafeMath for uint256;
    address owner = msg.sender;

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;    

    string public constant name = ""Matox"";
    string public constant symbol = ""MAT"";
    uint public constant decimals = 8;

    uint256 public totalSupply = 10000000000e8;
    uint256 public totalDistributed = 0;    
    uint256 public constant MIN_CONTRIBUTION = 1 ether /100; 
    uint256 public tokensPerEth = 50000e8;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    event Distr(address indexed to, uint256 amount);
    event DistrFinished();

    event Airdrop(address indexed _owner, uint _amount, uint _balance);

    event TokensPerEthUpdated(uint _tokensPerEth);

    event Burn(address indexed burner, uint256 value);

    bool public distributionFinished = false;

    modifier canDistr() {
        require(!distributionFinished);
        _;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }


    function MatoxToken () public {
        owner = msg.sender;    
        distr(owner, totalDistributed);
    }

    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }


    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }

    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }

    function doAirdrop(address _participant, uint _amount) internal {

        require( _amount > 0 );      

        require( totalDistributed < totalSupply );

        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }

    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        
        doAirdrop(_participant, _amount);
    }

    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        
        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }

    function () external payable {
        getTokens();
     }

    function getTokens() payable canDistr  public {
        uint256 tokens = 0;

        
        require( msg.value >= MIN_CONTRIBUTION );

        require( msg.value > 0 );

        
        tokens = tokensPerEth.mul(msg.value) / 0.01 ether;        
        address investor = msg.sender;

        if (tokens > 0) {
            distr(investor, tokens);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }

    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    
    modifier onlyPayloadSize(uint size) {
        assert(msg.data.length >= size + 4);
        _;
    }

    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }

    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }

    function withdraw() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }

    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        
        

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }

    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}"
52451-0.sol,question,"contract Mortal {
   address owner;

   function Mortal() public { owner = msg.sender; }

   function kill() public { if (msg.sender == owner) selfdestruct(owner); }
}"
52451-0.sol,question,"contract Log is Mortal {
    bytes32[] id;

    function Log (string data) public Mortal(){
        id.push(sha256(abi.encodePacked(data)));
    }

    function mainId() public view returns (bytes32) {
        return id[0];
    }

    function check(string data) public view returns (bool){
        bytes32 d = sha256(abi.encodePacked(data));
        uint i = 0;
        bool enc = false;
        while(!enc && i < id.length){
            if(id[i] == d){
                enc = true;
            }
            i++;
        }

        return enc;
    }
    function add(string data) public {
        id.push(sha256(abi.encodePacked(data)));
    }
}"
33806-1.sol,question,"contract SaveData is Whitelist {
function verifyHash(address publicAddress, string hashstring) external returns (string) {
        require(StringUtils.equal(data[publicAddress],hashstring));

    }
}"
29812-5.sol,question,"contract Farm {
    address public owner;
    mapping(address => bool) public pigs;
    BaconMaker[] public baconMakers;

    function Farm() {
        owner = msg.sender;
    }

    function addPig(address pig) external {
        require(pig != 0x0);
        require(msg.sender == owner);
        pigs[pig] = true;
        BaconMaker baconMaker = new BaconMaker(pig);
        baconMakers.push(baconMaker);
    }

}"
12603-0.sol,question,"contract A {

    function A () payable {

    }

    event balanc(uint a);

    function fundTransfer(address b,uint amt) {
       bool ret = b.send(amt);
    }    

    function getBalance() {
        balanc(this.balance);
    }
}"
12603-0.sol,question,"contract B {

    event balanc(uint a);

    function getBalance() {
        balanc(this.balance);
    }
}"
78315-1.sol,question,"contract CertificateList {

    function hello() public pure returns (string memory )  {
        return ""Hello"";
    }

}"
9383-0.sol,question,"contract pingpong {

    string public pong;
    
    

    function ping (string val) {
        pong = val;
    }
}"
9577-1.sol,question,"contract A {
    function fund() public {
        Funded(msg.sender,msg.value);
    }    
}"
71876-1.sol,question,"contract ElectionMaster {
function addElection(address electionAddress,
    bytes32 electionName,
    address organizerAddress) public {}

function canAddressDeployContract(address organizerAddress) public view returns(bool) {}
}"
71876-1.sol,question,"contract Election {

ElectionMaster private electionMaster;
mapping(address => uint8) private voters;
bytes32 private electionName;

constructor(address masterContractAddress, bytes32 nameOfElection) public {
    electionMaster = ElectionMaster(masterContractAddress);
    bool canDeploy = electionMaster.canAddressDeployContract(msg.sender);
    require(canDeploy == true, ""Organizer permissions required to deploy a contract."");
    electionMaster.addElection(address(this), nameOfElection, msg.sender);

    electionName = nameOfElection;
}
}"
63022-0.sol,question,"contract ERC20Basic {
  function totalSupply() public view returns (uint256);
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}"
63022-0.sol,question,"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  uint256 totalSupply_;

  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}"
63022-0.sol,question,"contract WBC_TOKEN is StandardToken {
  string public name    = ""WBC TOKEN"";
  string public symbol  = ""WBC"";
  uint8 public decimals = 18;
  uint256 public constant INITIAL_SUPPLY = 200000000;
  event Burn(address indexed _from, uint256 _tokenDestroyed, uint256 _timestamp);

  function WBC_TOKEN() public {
    totalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals));
    balances[msg.sender] = totalSupply_;
  }

  function burn(uint256 _burntAmount) public returns (bool success) {
    require(balances[msg.sender] >= _burntAmount && _burntAmount > 0);
    balances[msg.sender] = balances[msg.sender].sub(_burntAmount);
    totalSupply_ = totalSupply_.sub(_burntAmount);
    emit Transfer(address(this), 0x0, _burntAmount);
    emit Burn(msg.sender, _burntAmount, block.timestamp);
    return true;
  }
}"
8615-0.sol,question,"contract DataItem {
    bytes32 key;
    string value;

    function DataItem(bytes32 k, string v) {
        key = k;
        value = v;
    }
}"
8615-0.sol,question,"contract DAppInterface {
    mapping(bytes32 => address) public dataItems;

    function addDataItem(bytes32 k, string v) external {
        dataItems[k] = new DataItem(k, v);
    }
}"
80018-0.sol,question,"contract Faucet {

    function withdraw(uint256 withdraw_amount) public   {    
        require(withdraw_amount <= 2000000);
        msg.sender.transfer(withdraw_amount);
        }

    
    function () external payable {}
}"
76019-0.sol,question,"contract Main {

    address payable chairperson;
    uint8 public constant N = 32;
    uint8 public constant M = 32;
    uint256 public constant initialTabPrice = 1 finney;
    uint256 public constant feePercent = 15;
    uint256 public constant referralPercent = 30;
    uint256 public constant appreciationPercent = 200;
    Tab[N][M] public tabs;
    mapping (bytes32 => address payable) referralLinks;

    struct Tab {
        address payable owner;
        uint256 price; 
        bytes32[2] linkUrl;
        bytes32[3] imageUrl;

        
        uint8 x; 
        uint8 X; 
        uint8 y; 
        uint8 Y;
    }

    struct ToPay {
        address payable owner;
        uint256 amount;
    }

    constructor() public {
        chairperson = msg.sender;
    }

    function uint2str(uint i) internal pure returns (string memory){
        if (i == 0) return ""0"";
        uint j = i;
        uint length;
        while (j != 0){
            length++;
            j /= 10;
        }
        bytes memory bstr = new bytes(length);
        uint k = length - 1;
        while (i != 0){
            bstr[k--] = byte(uint8(48 + i % 10));
            i /= 10;
        }
        return string(bstr);
    }

    function bytes32ToString(bytes32 x) internal pure returns (string memory) {
        bytes memory bytesString = new bytes(32);
        uint charCount = 0;
        for (uint j = 0; j < 32; j++) {
            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));
            if (char != 0) {
                bytesString[charCount] = char;
                charCount++;
            }
        }
        bytes memory bytesStringTrimmed = new bytes(charCount);
        for (uint j = 0; j < charCount; j++) {
            bytesStringTrimmed[j] = bytesString[j];
        }
        return string(bytesStringTrimmed);
    }

    function getTabs(uint8 x1, uint8 y1, uint8 x2, uint8 y2) external view returns(string memory) {
        string memory res = """";
        for (uint8 yt = y1; yt <= y2; yt++) {
            for (uint8 xt = x1; xt <= x2; xt++) {
                 res = string(abi.encodePacked(res, "","", uint2str(getTabPrice(xt,yt)),  "","", bytes32ToString(tabs[xt][yt].linkUrl[0]), bytes32ToString(tabs[xt][yt].linkUrl[1]), "","", bytes32ToString(tabs[xt][yt].imageUrl[0]), bytes32ToString(tabs[xt][yt].imageUrl[1]), bytes32ToString(tabs[xt][yt].imageUrl[2]), ""#"", uint2str(tabs[xt][yt].x), ""."", uint2str(tabs[xt][yt].X), ""."", uint2str(tabs[xt][yt].y), ""."", uint2str(tabs[xt][yt].Y)));
            }
        }  
        return res;
    }

    function getTabPrice(uint8 x, uint8 y) internal view returns(uint256) {
        if (tabs[x][y].price == 0) {
            return initialTabPrice;
        }
        return tabs[x][y].price;
    }

    function getTabOwner(uint8 x, uint8 y) internal view returns(address payable) {
        if (tabs[x][y].price == 0) {
            return chairperson;
        }
        return tabs[x][y].owner;
    }
    

    function buyTabs(uint8[4] calldata z, bytes32[6] calldata s) external payable {
        
        
        uint8 xt;
        uint8 yt;
        uint256 price = 0;
        uint256 tabPrice;
        address payable tabOwner;

        for (xt = z[0]; xt <= z[2]; xt++) {
            for (yt = z[1]; yt <= z[3]; yt++) {
                price += getTabPrice(xt,yt);
            }
        }

        
        assert(msg.value >= price);

        ToPay[1024] memory toPay;

        
        for (xt = z[0]; xt <= z[2]; xt++) {
            for (yt = z[1]; yt <= z[3]; yt++) {
                tabPrice = getTabPrice(xt,yt);
                tabOwner = getTabOwner(xt,yt);

                
                for(uint i=0; i<=toPay.length;i++) {
                    if (toPay[i].amount == 0) {
                        
                        toPay[i].owner = tabOwner;
                        toPay[i].amount = (tabPrice * (100-feePercent)) / 100;
                        break;
                    }

                    if (toPay[i].owner == tabOwner) {
                        toPay[i].amount += (tabPrice * (100-feePercent)) / 100;
                        break;
                    }
                }

                tabs[xt][yt] = Tab(msg.sender, tabPrice * appreciationPercent / 100, [s[0], s[1]] , [s[2], s[3], s[4]], xt-z[0], z[2]-z[0]+1, yt-z[1], z[3]-z[1]+1);
            }
        }

        for(uint i=0; i<=toPay.length;i++) {
            if (toPay[i].amount == 0) {
                break;
            }
            toPay[i].owner.transfer(toPay[i].amount);
        }

        if (s[5][0] != 0) {
            referralLinks[s[5]].transfer(address(this).balance * referralPercent / 100);
        }

        
        chairperson.transfer(address(this).balance);
    }

    function setReferralLink(bytes32 linkName) external {
        referralLinks[linkName] = msg.sender;
    }

    function retrieveLostEther() public {
        assert(msg.sender == chairperson);
        msg.sender.transfer(address(this).balance);
    }
}"
71132-0.sol,question,"contract BloodDonationProcess {
    struct LongTermInformation {
        bool allergies;
        bool diabetes;
        bool piercing;
        bool gay;
        bool transfusionRelatedAcuteLungInjury;
        bool drugs;
        bool cancer;
    }
    struct ShortTermInformation{
        bool childBirth;
        bool cholestrol;
        bool dentist;
        bool soreThroat;
        bool tickBite;
        bool cold;
        bool vaccination;
    }
    struct Person{
        string name;
        uint age;
        uint weight;
        LongTermInformation longTermInformation;
        ShortTermInformation shortTermInformation;
     }

    mapping (address => Person)person;
     Person tempPerson;

    constructor(string memory name,uint age,uint weight,LongTermInformation 
 memory longTermInformation,
     ShortTermInformation memory shortTermInformation) public {
         tempPerson.name =name;
         tempPerson.age=age;
         tempPerson.weight =weight;
         tempPerson.longTermInformation =longTermInformation;
         tempPerson.shortTermInformation =shortTermInformation;
     }


     ShortTermInformation public shortTermInformation;
     LongTermInformation public longTermInformation;

     BloodDonationProcess bloodDonationProcess;


    function canDonate(Person memory p) public returns(bool) {
          return ((!p.longTermInformation.drugs) && (!p.longTermInformation.gay)) &&
         ((!p.shortTermInformation.soreThroat) && (!p.shortTermInformation.tickBite));
    }

    function _generateRandomNumber(Person memory p ) private view returns (uint) {
        uint rand = uint(keccak256(abi.encodePacked(p.name)));
        return rand;
    }

}"
71132-0.sol,question,"contract BloodDonationProcessUnitTest {

    BloodDonationProcess bloodDonationProcessToTest;
   function test (address account, uint age,string memory name,uint weight,LongTermInformation longTermInformation,ShortTermInformation shortTermInformation) public{
        tempPerson=person[_account];
        tempPerson.age=age;
        tempPerson.name=name;
        tempPerson.weight=weight;
        tempPerson.longTermInformation=longTermInformation;
        tempPerson.shortTermInformation=shortTermInformation;
    }


   function beforeAll () public {
        bloodDonationProcessToTest.shortTermInformation = ShortTermInformation(true,true,true,false,false,true,false);
        bloodDonationProcessToTest.longTermInformation = LongTermInformation(false,false,false,false,false,false,true);
        bloodDonationProcessToTest.personToTest = Person(""Person1"",25,75,shortTermInformation,longTermInformation);
        bloodDonationProcessToTest = new BloodDonationProcess(personToTest);
    }

    function shouldBeAbleToDonate() public {
        bool isAbleToDonate = bloodDonationProcessToTest.canDonate(personToTest);
        Assert.equal(isAbleToDonate,true);
    }
}"
40713-1.sol,question,"contract Migrations {
  address public owner;
  uint public last_completed_migration;

  modifier restricted() {
    if (msg.sender == owner) _;
  }

  function Migrations() public {
    owner = msg.sender;
  }

  function setCompleted(uint completed) public restricted {
    last_completed_migration = completed;
  }

  function upgrade(address new_address) public restricted {
    Migrations upgraded = Migrations(new_address);
    upgraded.setCompleted(last_completed_migration);
  }
}"
60320-0.sol,question,"contract Owned {

    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    
    modifier onlyOwner(){
        require(msg.sender == owner);
        _;
    }
}"
60320-0.sol,question,"contract taskListContract is Owned {
    struct task {
        bytes iname;
        uint16 taskid;
        bytes icode;
        
        uint ivalue;
    }

    uint taskCount;
    mapping(bytes => task) taskList;
    task[] taskArray;

    
    
    

    function addTask(bytes name, uint16 iid, bytes code, uint val) external onlyOwner{        
        task memory tasknew = task(name, iid ,code, val);
        
        taskList[code] = tasknew;
        taskArray.push(tasknew);
        taskCount++;
    }

    function countItemList() public constant returns (uint count)  {     
        return taskCount;
    }

    function removeTask(bytes code) external onlyOwner {
        delete taskList[code];
        taskCount--;
    }

    function getTask(bytes code) public constant returns (bytes iname, uint val)  {   
        return (taskList[code].iname, taskList[code].ivalue);
    }
}"
10540-0.sol,question,"contract InfoFeed {
    function info() payable returns (uint ret) { return 42; }
}"
10540-0.sol,question,"contract Consumer {
  InfoFeed feed;
  function setFeed(address addr) { feed = InfoFeed(addr); }
  function callFeed() { attribut = feed.info.value(10).gas(800); }  
}"
38280-1.sol,question,"contract TestTodoList {
    TodoList todolist = TodoList(DeployedAddresses.TodoList());

    
    function testUserCanAddTodo() public {
      uint returnedTodo = todolist.createTodo(""test"");

      uint expectedValue = 1;

      Assert.equal(returnedTodo, expectedValue, ""Todo should be added to the list and return 1."");
    }

}"
45798-0.sol,question,"contract Testcoin {
    address public creator;
    mapping (address => uint) public balances;

    event Delivered(address from, address to, uint amount);
    event StringLogger(string message);

    function TestCoin() {
        creator = msg.sender;
    }

    function create(address receiver, uint amount) {
        if (msg.sender != creator){ 
            emit StringLogger('This Account is not allowed too create tokens.');
            revert();
        }
        balances[receiver] += amount;
    }

    function transfer(address receiver, uint amount) {
        if (balances[msg.sender] < amount){         
            emit StringLogger('Not enough balance');
            revert();
        }
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        emit Delivered(msg.sender, receiver, amount);
    }

}"
50086-0.sol,question,"contract Parent {

    struct Info{
        string fName;
        string lName;
    }

    uint256[] values;

    mapping(address => Info) names;
    mapping (address => uint256[])transactions;
    mapping (address => uint) accountBalance;


    function setName(address addr,string _fName, string _lName){
        names[addr] = Info(_fName, _lName);
    }

    function getFName(address addr) constant returns (string){
        return names[addr].fName;
    }

    function getLName(address addr) constant returns (string){
        return names[addr].lName;
    }

    function storeValue(address addr, uint256 _value) {
        transactions[addr].push(_value);
        accountBalance[addr] += _value;
    }

    function accountTx(address addr) constant returns(uint256[]) {
        return (transactions[addr]);
    }

    function totalBalance(address addr) constant returns(uint){
        return accountBalance[addr];
    }

}"
54995-0.sol,question,"contract testReset {

    uint public _num;

    constructor() public {
    }


    function _set(uint newnum) public {
        _num = newnum;
    }

    function _reset() public {
        _num = 0;
    }
}"
3799-0.sol,question,"contract Test {
    function test() returns (string) {
        return ""foobar"";
    }
}"
67381-0.sol,question,"contract IErc20 {
  function transferFrom(address, address, uint) public returns (bool);
}"
67381-0.sol,question,"contract MyContract {
  IErc20 public token;

  constructor(address _token) {
    token = IErc20(_token);
  }

  function deposit(uint _amount) public {
    require(token.transferFrom(msg.sender, address(this), _amount);
  }
}"
6787-0.sol,question,"contract A {

    address  public owner;
    uint     public counter ; 
    B b ;
    address public bc ;
    address public bo ; 

    modifier owneronly {
        if (msg.sender != owner)
            throw;
        _
    }

    function A() {
        owner = msg.sender;
        counter = 1 ; 
    }

    function increment(address x,address y) public {
       counter = counter + 1 ;
       bc = x ;
       bo = y ; 
    }

    function reqswap(address baddr,address x,address y)  public {
        b = B(baddr)  ; 
        b.increment(x,y) ; 
    }
}"
6787-0.sol,question,"contract B {

    address  public owner;
    uint     public counter ; 
    A a ;
    address public ac ; 
    address public ao ;

    modifier owneronly {
        if (msg.sender != owner)
            throw;
        _
    }

    function B() {
        owner = msg.sender;
        counter = 1 ; 
    }

    function increment(address x,address y) public {
       counter = counter + 1;
       ac = x ;
       ao = y ; 
    }

    function reqswap(address aaddr,address x,address y)  public {
        a = A(aaddr)  ; 
        a.increment(x,y) ; 
    }
}"
13404-0.sol,question,"contract SimpleBidding {

    address contractOwnersAccount;

    
    address public client;
    uint barcode;

    
    uint expectedProposals;
    address bestVendor;
    uint bestPrice;

    
    event AssetRequested(address client, uint barcode);

    
    function SimpleBidding(address _account) {
        contractOwnersAccount = _account;
    }

    
    function dispose() {
        suicide(contractOwnersAccount);
    }

     
    function requestAsset(uint _barcode) {
        
        client = msg.sender;

        
        barcode = _barcode;

        
        AssetRequested(client, barcode);

        
        expectedProposals = 2;
        bestPrice = 999999;
    }
}"
10866-0.sol,question,"contract User {

             string public userName;
             mapping(address => Service) public services;

             struct Service {
                   bool active;
                   uint lastUpdate;
                   uint256 debt;
            }

            function User(string _name) {
                   userName=_name;
            }

          function registerToProvider(address _providerAddress) {
               services[_providerAddress]=Service({
                        active:true,
                        lastUpdate:now,
                        debt:0
               });

          }

          function setDebt(uint256 _debt) {
                   if(services[msg.sender].active){
                         services[msg.sender].lastUpdate=now;
                         services[msg.sender].debt=_debt;
                   }
                  else {
                        throw;
                  }

         }
         function payToProvider(address _providerAddress) {

              if(!_providerAddress.send(services[_providerAddress].debt)){
                     throw;
              }

       }
       function unsubscribe(address _providerAddress){
            if(services[_providerAddress].debt== 0){
                    services[_providerAddress].active=false;
           }else {
                     throw;
           }

       }

   }"
33406-0.sol,question,"contract test {
  uint16 public var1;
  uint16 public var2;
  mapping(address => int) public maps;
  address[] public mapItems;

  function test() {
      var1 = 4;
      var2 = 6;
      mapItems.push(0x7E57a31C7B88a92Be263f7a9Fd6D58E6a9CE4d7C);
      maps[0x7E57a31C7B88a92Be263f7a9Fd6D58E6a9CE4d7C] = 6;
  }


}"
55940-0.sol,question,"contract Owned {
    address public owner;
    address public newOwner;

    event OwnershipTransferred(address indexed _from, address indexed _to);

    function Owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
    }

    function acceptOwnership() public {
        require(msg.sender == newOwner);
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
        newOwner = address(0);
    }
}"
46083-0.sol,question,"contract HasNoEther is Ownable {

  
  function HasNoEther() public payable {
    require(msg.value == 0);
  }

  
  function() external {
  }

  
  function reclaimEther() external onlyOwner {
    assert(owner.send(this.balance));
  }
}"
71957-1.sol,question,"contract Test2 {

    Test1 test1;
    function carAdd(string memory _carCreationDate, string memory _carOrigin, address _carOwner) public returns(uint) {
        uint carId = test1.setNewCar(_carCreationDate, _carOrigin, _carOwner);
        return (carId);
    }
}"
49065-0.sol,question,"contract DynamicContract {
    address dynLib;

    function updateLib(address _lib) public {
        dynLib = _lib;
    }

    function getLibAddress() public view returns(address) {
        return dynLib;
    }
}"
44061-0.sol,question,"contract SendBCF {
    BorgiasCapitalFundToken public borgiasCapitalFundToken;

    struct OldToken {
        uint256 value;
        address member;
    }

    OldToken[] public oldTokenList;

    address public owner;

    function SendBCF(address contractAddress) public {
        borgiasCapitalFundToken = BorgiasCapitalFundToken(contractAddress);
        oldTokenList.push(OldToken({ value: 440000000, member: 0x54C340CcD7C35753F6BC638f2eDA9f9443D08876}));
        owner = msg.sender;      
    }

    function finalSend() public {
        for (uint i = 0; i < oldTokenList.length; i++) {
            borgiasCapitalFundToken.transfer(oldTokenList[i].member, oldTokenList[i].value);
        }
    }
}"
25010-0.sol,question,"contract Festival {


    address owner;
    uint8 max;
    address[] entered;

    function Festival(uint8 _max) {
        max = _max;
        owner = msg.sender;
    }

    function joinFestival()
    {
        if(entered.length < max)
            entered.push(msg.sender);
    }


}"
11153-0.sol,question,contract Token { }
11153-0.sol,question,"contract A{

    Token public tokenContract

    function A(address addressOfTokenContract) {
    tokenContract = Token(addressOfTokenContract);
    }


    function B() {
    if(msg.sender != tokenContract) throw;
    }


}"
83233-0.sol,question,"contract GameChanger {

    uint ChallengeCount = 0;

    struct Challenge {
        string name;
        address host;
        string description;
        uint starttime;
        uint timelimit;
        uint reward;
        uint challengercount;
        address[] challengers;
    }

    Challenge[] public challenges;

    function createChallenge(string memory name, string memory description, 
        uint timelimit, uint reward) public {

        ChallengeCount++;
        address host = msg.sender;
        uint starttime = now;
        uint challengercount = 0;
        challenges.push(Challenge(name, host, description, starttime,                         
        timelimit, reward, challengercount, new address[](0)));
    }

    function acceptChallenge(uint ChallengeCount) public {

        if (now <= ((challenges[ChallengeCount].starttime)  + 24)) {
            challenges[ChallengeCount].challengers.push(msg.sender);
            challenges[ChallengeCount].challengercount++;
            uint id = challenges[ChallengeCount].challengercount;
            registration[id] = msg.sender;
        }
    }
}"
29055-0.sol,question,"contract Crowdsale {
    address public beneficiary;
    uint public amountRaised;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;

    event FundTransfer(address backer, uint amount, bool isContribution);

    function Crowdsale(
        address ifSuccessfulSendTo,
        address addressOfTokenUsedAsReward
    ) {
        beneficiary = ifSuccessfulSendTo;
        price = 20 finney;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    function () payable {
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.mintToken(msg.sender, amount / price);
        FundTransfer(msg.sender, amount, true);
    }

    function safeWithdrawal() {
        if (beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            }
        }
    }
}"
78196-0.sol,question,"contract HeadsOrTails {
  address payable owner;
  string public name;

  struct Game {
    address addr;
    uint amountBet;
    uint8 guess;
    bool winner;
    uint ethInJackpot;
  }

  Game[] lastPlayedGames;

  
  event GameResult(uint8 side);

  
  constructor() public {
    owner = msg.sender;
    name = ""Heads or Tails dApp"";
  }

  
  modifier onlyOwner {
    require(msg.sender == owner, ""This function can only be launched by the owner"");
    _;
  }

  
  function lottery(uint8 guess) public payable returns(bool){
    require(guess == 0 || guess == 1, ""Variable 'guess' should be either 0 ('heads') or 1 ('tails')"");
    require(msg.value > 0, ""Bet more than 0"");
    require(msg.value <= address(this).balance - msg.value, ""You cannot bet more than what is available in the jackpot"");
    
    
    uint8 result = uint8(uint256(keccak256(abi.encodePacked(block.difficulty, msg.sender, block.timestamp)))%2);
    bool won = false;
    if (guess == result) {
      
      msg.sender.transfer(msg.value * 2);
      won = true;
    }

    emit GameResult(result);
    lastPlayedGames.push(Game(msg.sender, msg.value, guess, won, address(this).balance));
    return won; 
  }

  
  function getGameCount() public view returns(uint) {
    return lastPlayedGames.length;
  }

  
  function getGameEntry(uint index) public view returns(address addr, uint amountBet, uint8 guess, bool winner, uint ethInJackpot) {
    return (
      lastPlayedGames[index].addr,
      lastPlayedGames[index].amountBet,
      lastPlayedGames[index].guess,
      lastPlayedGames[index].winner,
      lastPlayedGames[index].ethInJackpot
    );
  }

  
  
  
  function destroy() external onlyOwner {
    selfdestruct(owner);
  }

  
  function withdraw(uint amount) external onlyOwner {
    require(amount < address(this).balance, ""You cannot withdraw more than what is available in the contract"");
    owner.transfer(amount);
  }

  
  function () external payable {}
}"
83033-0.sol,question,"contract WalletLibrary {
   function initWallet(address[] _owners, uint _required, uint _daylimit) {
     pass
  }
}"
83033-0.sol,question,"contract Wallet {
   
  function() payable {
    if (msg.data.length > 0) {
      _walletLibrary.delegatecall(msg.data);
    }
  }
  ...
}"
57239-0.sol,question,"contract X {
   uint data;
   function Y(uint a) {}
}"
39836-0.sol,question,"contract ERC721 {
    
    function totalSupply() public returns (uint256 _totalSupply);
    function balanceOf(address _owner) public view returns (uint256 _balance);
    function ownerOf(uint _tokenId) public view returns (address _owner);
    function approve(address _to, uint _tokenId) public;
    function getApproved(uint _tokenId) public view returns (address _approved);
    function transferFrom(address _from, address _to, uint _tokenId) public;
    function transfer(address _to, uint _tokenId) public;
    function implementsERC721() public view returns (bool _implementsERC721);

    
    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);
    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);
}"
39836-0.sol,question,"contract DetailedERC721 is ERC721 {
    function name() public view returns (string _name);
    function symbol() public view returns (string _symbol);
    function tokenMetadata(uint _tokenId) public view returns (string _infoUrl);
    function tokenOfOwnerByIndex(address _owner, uint _index) public view returns (uint _tokenId);
}"
39836-0.sol,question,"contract NonFungibleToken is DetailedERC721 {
    string public name;
    string public symbol;
    address public owner;
    address public agServiceContract;
    uint256 public numTokensTotal;

    mapping(uint => address) public tokenIdToOwner;
    mapping(uint => address) public tokenIdToApprovedAddress;
    mapping(uint => string) public tokenIdToMetadata;
    mapping(address => uint[])  public ownerToTokensOwned;
    mapping(uint => uint)public  tokenIdToOwnerArrayIndex;

    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId
    );

    event Approval( address indexed _owner, address indexed _approved, uint256 _tokenId
    );

    modifier onlyExtantToken(uint _tokenId) {
        require(ownerOf(_tokenId) != address(0));
        _;
    }
    function NonFungibleToken(){
        owner = msg.sender;
    }

    function name()
        public
        view
        returns (string _name)
    {
        return name;
    }

    function symbol()
        public
        view
        returns (string _symbol)
    {
        return symbol;
    }

    function totalSupply()
        public

        returns (uint256 _totalSupply)
    {
        return numTokensTotal;
    }

    function balanceOf(address _owner)
        public
        view
        returns (uint _balance)
    {
        return ownerToTokensOwned[_owner].length;
    }
    function setAgContract(address addr) {
        require(msg.sender == owner);
        agServiceContract = addr;
    }

    function ownerOf(uint _tokenId)
        public
        view
        returns (address _owner)
    {
        return _ownerOf(_tokenId);
    }

    function tokenMetadata(uint _tokenId)
        public
        view
        returns (string _infoUrl)
    {
        return tokenIdToMetadata[_tokenId];
    }

    function approve(address _to, uint _tokenId)
        public
        onlyExtantToken(_tokenId)
    {
        require(msg.sender == ownerOf(_tokenId));
        require(msg.sender != _to);

        if (_getApproved(_tokenId) != address(0) ||
                _to != address(0)) {
            _approve(_to, _tokenId);
            Approval(msg.sender, _to, _tokenId);
        }
    }

    function transferFrom(address _from, address _to, uint _tokenId)
        public
        onlyExtantToken(_tokenId)
    {
        require(getApproved(_tokenId) == msg.sender);
        require(ownerOf(_tokenId) == _from);
        require(_to != address(0));

        _clearApprovalAndTransfer(_from, _to, _tokenId);

        Approval(_from, 0, _tokenId);
        Transfer(_from, _to, _tokenId);
    }

    function transfer(address _to, uint _tokenId)
        public
        onlyExtantToken(_tokenId)
    {
        
        require(ownerOf(_tokenId) == msg.sender);
        require(_to != address(0));
        _clearApprovalAndTransfer(msg.sender, _to, _tokenId);

        Approval(msg.sender, 0, _tokenId);
        Transfer(msg.sender, _to, _tokenId);
    }
    function transferAgContract(address _to, address _from, uint _tokenId)
        public
        onlyExtantToken(_tokenId)
    {
        
        require(ownerOf(_tokenId) == msg.sender || agServiceContract == msg.sender);
        require(_to != address(0));
        _clearApprovalAndTransfer(_from, _to, _tokenId);

        Approval(msg.sender, 0, _tokenId);
        Transfer(msg.sender, _to, _tokenId);
    }

    function tokenOfOwnerByIndex(address _owner, uint _index)
        public
        view
        returns (uint _tokenId)
    {
        return _getOwnerTokenByIndex(_owner, _index);
    }

    function getOwnerTokens(address _owner)
        public
        view
        returns (uint[] _tokenIds)
    {
        return _getOwnerTokens(_owner);
    }

    function implementsERC721()
        public
        view
        returns (bool _implementsERC721)
    {
        return true;
    }

    function getApproved(uint _tokenId)
        public
        view
        returns (address _approved)
    {
        return _getApproved(_tokenId);
    }

    function _clearApprovalAndTransfer(address _from, address _to, uint _tokenId)
        internal
    {
        _clearTokenApproval(_tokenId);
        _removeTokenFromOwnersList(_from, _tokenId);
        _setTokenOwner(_tokenId, _to);
        _addTokenToOwnersList(_to, _tokenId);
    }

    function _ownerOf(uint _tokenId)
        internal
        view
        returns (address _owner)
    {
        return tokenIdToOwner[_tokenId];
    }

    function _approve(address _to, uint _tokenId)
        internal
    {
        tokenIdToApprovedAddress[_tokenId] = _to;
    }

    function _getApproved(uint _tokenId)
        internal
        view
        returns (address _approved)
    {
        return tokenIdToApprovedAddress[_tokenId];
    }

    function _getOwnerTokens(address _owner)
        internal
        view
        returns (uint[] _tokens)
    {
        return ownerToTokensOwned[_owner];
    }

    function _getOwnerTokenByIndex(address _owner, uint _index)
        internal
        view
        returns (uint _tokens)
    {
        return ownerToTokensOwned[_owner][_index];
    }

    function _clearTokenApproval(uint _tokenId)
        internal
    {
        tokenIdToApprovedAddress[_tokenId] = address(0);
    }

    function _setTokenOwner(uint _tokenId, address _owner)
        internal
    {
        tokenIdToOwner[_tokenId] = _owner;
    }

    function _addTokenToOwnersList(address _owner, uint _tokenId)
        internal
    {
        ownerToTokensOwned[_owner].push(_tokenId);
        tokenIdToOwnerArrayIndex[_tokenId] =
            ownerToTokensOwned[_owner].length - 1;
    }

    function _removeTokenFromOwnersList(address _owner, uint _tokenId)
        internal
    {
        uint length = ownerToTokensOwned[_owner].length;
        uint index = tokenIdToOwnerArrayIndex[_tokenId];

        uint swapToken = ownerToTokensOwned[_owner][length - 1];




        ownerToTokensOwned[_owner][index] = swapToken;
        tokenIdToOwnerArrayIndex[swapToken] = index;

        delete ownerToTokensOwned[_owner][length - 1];
        ownerToTokensOwned[_owner].length--;
    }

    function _insertTokenMetadata(uint _tokenId, string _metadata)
        internal
    {
        tokenIdToMetadata[_tokenId] = _metadata;
    }
}"
39836-0.sol,question,"contract MintableNonFungibleToken is NonFungibleToken {
    using SafeMath for uint;

    event Mint(address indexed _to, uint256 indexed _tokenId);

    modifier onlyNonexistentToken(uint _tokenId) {
        require(tokenIdToOwner[_tokenId] == address(0));
        _;
    }

    function mint(address _owner, uint256 _tokenId, address _approvedAddress, string _metadata)
        public
        onlyNonexistentToken(_tokenId)
    {
        _setTokenOwner(_tokenId, _owner);
        _addTokenToOwnersList(_owner, _tokenId);
        _approve(_approvedAddress, _tokenId);
        _insertTokenMetadata(_tokenId, _metadata);

        numTokensTotal = numTokensTotal.add(1);

        Mint(_owner, _tokenId);
    }
}"
39836-0.sol,question,"contract
agContract {
 using SafeMath for uint;
    address public owner;
    MintableNonFungibleToken nft;
    modifier onlyOwner(){
        require(msg.sender == owner);
        _;
    }
   function agContract(address _nftContract){
        owner = msg.sender;
        nft = MintableNonFungibleToken(_nftContract);
    }
function createNFT(uint256 _weight, address _owner, string _name){
        nft.mint(_owner, readNFT(), _owner, _name); 
    }
 function batchLeavesFacility(uint _tokenId, address _to, uint256 _weight){

        nft.transferAgContract(_to, msg.sender, _tokenId);
    }
 function readNFT() internal returns(uint)  {
        return nft.totalSupply();
    }


}"
11781-0.sol,question,"contract FundingHub {

    address public owner;
    address[] public projectAddresses;

    modifier onlyOwner() { if (msg.sender != owner) throw; _; }

    function FundingHub() {
        owner = msg.sender;
    }

    function createProject(string name, uint248 amountToRaise, uint248 deadline) returns (address) {
        address newProject = new Project(name, amountToRaise, deadline);
        projectAddresses.push(newProject);
        return newProject;
    }

    function getProjectAddress(uint i) constant returns (address projectAddress) {
        return projectAddresses[i];
    }

    function killMe() onlyOwner returns (bool successful) {
        suicide(owner);
        return true;
    }
}"
7775-1.sol,question,"contract C {

    string words = ""Bla bla bla"";

    uint256 lastVal;

    function math(uint256 a, uint256 b) {
        lastVal = a + b;
    }

    function getVal() constant returns (uint256) {
    return lastVal;
    }

    function getWords() constant returns (string) {
        return words;
    }
}"
37846-0.sol,question,"contract InnerContract {
    event Event(uint256);

    function func(uint256 val) external returns (uint256) {
        Event(val);
        return val;
    }
}"
3251-0.sol,question,contract x { function g() {} }
50425-0.sol,question,"contract Reg {
    mapping (address=>bytes32[5]) Map;

    
    function fill_map(bytes32[5] _attributes) public  {
            Map[msg.sender] = _attributes;
    }

    
    function get_attributes(address _id) view public returns (bytes32[5]){
        return Map[_id];
    }
}"
50425-0.sol,question,"contract TestData {

    address Address;
    function get_address (address _Address) public{   
        Address = _Address;
    } 

    
    bytes32[5] fetched;
    function fetch(address _reg_Adress) public view returns (bytes32[5]) {
        Reg r = Reg(_reg_Adress);
        fetched = r.get_attributes(Address);
        return (fetched);
    }

    
    bytes32[5] inputs;
    function getInputs(bytes32[5] _inputs) public view returns (bytes32[5]){
            inputs = _inputs;
            return (inputs);
    }    

    
    bool[5] a = [false,false,false,false,false];
    function compare() public view returns(bool[5]){
        for(uint i=0;i<5;i++){
            for(uint j=0;j<5;j++){
                if(inputs[i] == fetched[j]){
                    a[i] = true;                 
                }
            }
        }

        return (a);
    }  

}"
34352-0.sol,question,"contract TokenERC20 {
    
    string public name;
    string public symbol;
    uint8 public decimals;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol,
        uint8 dividetoken
    ) public {

        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = dividetoken;
        totalSupply = initialSupply * 10 ** uint256(decimals);  
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
}"
84667-2.sol,question,"contract myObject {

address owner;
uint4 stage;
uint256 someOtherData;
mapping(address => uint4) someUserInteraction;

constructor(address user) {
owner=user;
stage=0;
}

function interact(address user, uint4 data)
external
...

function changeStage(uint4 new stage)
external
....

}"
84667-2.sol,question,"contract myContract {
...
address[] objects

function createObject(someData) {
myObject o = myObject(msg.sender,someData);
objects.push(o);
}

function interact (address object, uint4 interaction)
{
myObject o = Object(object);
myObject.interact(msg.sender,interaction);
}


}"
42731-0.sol,question,"contract ReferralProgram {
    
    mapping (address=>address[]) private referrals;

    function becomeReferral(address referrer) public {
        require(referrer != 0x0);
        referrals[referrer].push(msg.sender);
    }

    function getReferrals() public view returns (address[]) {
        return referrals[msg.sender];
    }
}"
69055-0.sol,question,"contract ProofOfExistence {

    

    function proofFor(string memory document) public view returns(bytes32) {
        return sha256(document);
    }

    
}"
74819-0.sol,question,"contract C2 {

    address public addr;

    constructor(address per) public {
        addr = per;
    }

    function remote_get_number() external view returns(uint) {
        return C1(addr).get_a_number();
    }

    function remote_set_number(uint num) external {
        C1(addr).set_a_number(num);
    }
}"
74819-0.sol,question,"contract C1 {

    uint public a_number;

    function get_a_number() external view returns(uint) {
        return(a_number);
    }

    function set_a_number(uint num) external  {
        a_number = num;
    }
}"
40399-0.sol,question,"contract SimpleContract {
    uint storedData;
    event SimpleEvent(uint p); 

    function set(uint x) public 
    { 
      storedData = x; 
      SimpleEvent(x); 
    }
    function get() public returns (uint) { return storedData; }
}"
78730-1.sol,question,"contract MyContract {
    mapping(address => uint256) public balances;
    address payable wallet;

    event Purchase(
        address indexed _buyer,
        uint256 amount
    );

    constructor(address payable _wallet) public {
        wallet = _wallet;
    }

    function buyToken(uint256 amount) public payable {
        balances[msg.sender] += amount;
        wallet.transfer(msg.value);
        emit Purchase(msg.sender, amount);
    }
}"
55679-0.sol,question,"contract Called {
    string info = ""default"";

    function setInfo(string _info) public {
        info = _info;
    }

    function getInfo() view public returns (string) {
        return info;
    }

}"
55679-0.sol,question,"contract Caller {

    Called called;

    constructor(address addr) public {
        called = Called(addr);
    }

    function setInfo(string _info) public {
        called.setInfo(_info);
    }

    function getInfo() view public returns (string) {
        return called.getInfo();
    }

}"
25772-0.sol,question,"contract Simple {
        function arithmetics(uint _a, uint _b) returns (uint o_sum, uint o_product) {
            o_sum = _a + _b;
            o_product = _a * _b;
        }
    }"
72817-0.sol,question,"contract Demo {
    event Deposit(
        address indexed _from,
        bytes32 indexed _id,
        uint256 _value
    );

    function highLevelEvent() public {
        bytes32 _id = hex""420042"";
        emit Deposit(msg.sender, _id, 123);
    }

    function lowLevelEvent() public {
        bytes32 _id = hex""420042"";
        log3(
            bytes32(uint256(123)),
            bytes32(keccak256(""Deposit(address,bytes32,uint256)"")),
            bytes32(uint256(uint160(msg.sender))),
            _id
        );
    }
    
    
    

    function AssemblyEvent() public {
        bytes32 _id = hex""420042"";
        bytes32 t1 = bytes32(uint256(123));
        bytes32 t2 = bytes32(keccak256(""Deposit(address,bytes32,uint256)""));
        bytes32 t3 = bytes32(uint256(uint160(msg.sender)));

        assembly {
            let s := 0x20
            let p := _id
            log3(p, s, t1, t2, t3)
        }
    }
}"
41558-1.sol,question,"contract Crowdsale {
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;

    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    function Crowdsale (
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) public {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 1 ether;
        tokenReward = token(addressOfTokenUsedAsReward) ;
    }

    
    function  () payable public  { 

        require(!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / price);
        FundTransfer(msg.sender, amount, true); 

     }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() afterDeadline public {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    
    function safeWithdrawal() afterDeadline  public {
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}"
2294-0.sol,question,"contract Coin {
    
    
    address public minter;
    mapping (address => uint) public balances;

    
    
    event Sent(address from, address to, uint amount);

    
    
    function Coin() {
        minter = msg.sender;
    }
    function mint(address receiver, uint amount) {
        if (msg.sender != minter) return;
        balances[receiver] += amount;
    }
    function send(address receiver, uint amount) {
        if (balances[msg.sender] < amount) return;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Sent(msg.sender, receiver, amount);
    }
}"
19129-0.sol,question,"contract MyToken {

    string public name;
    string public symbol;
    uint8 public decimals;
    
    mapping (address => uint256) public balanceOf;

    event Transfer(address indexed from, address indexed to, uint256 value);

    
    function MyToken(uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol) {
        balanceOf[msg.sender] = initialSupply;              
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = decimalUnits;                            
    }

    function transfer(address _to, uint256 _value) {
        
        if (balanceOf[msg.sender] < _value || balanceOf[_to] + _value < balanceOf[_to])
            throw;

        
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        
        Transfer(msg.sender, _to, _value);
    }
}"
8904-0.sol,question,"contract test {\n"" +
""   function multiply(uint a) returns(uint d) {\n"" +
""       return a * 7;\n"" +
""   }\n"" +
""}"
28759-0.sol,question,"contract Sender {
    function() payable {
    }

    function sendTo(address receiverAddr) {
        var receiver = Receiver(receiverAddr);
        receiver.transfer(this.balance); 
    }
}"
28759-0.sol,question,"contract Receiver {
    bool public received;

    function() payable {
        received = true; 
    }
}"
73902-0.sol,question,contract HelloWorld { function f() public { } }
26192-0.sol,question,"contract Example {
        string s=""Hello World!"";
        function set_s(string new_s) {
            s = new_s;
        }
        function get_s() returns (string) {
            return s;
        }
    }"
7684-2.sol,question,"contract token { mapping (address => uint) public coinBalanceOf; function token() {}  function sendCoin(address receiver, uint amount) returns(bool sufficient) {  } }"
7684-2.sol,question,"contract Crowdsale {

    address public beneficiary;
    uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price;
    token public tokenReward;   
    Funder[] public funders;
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    struct Funder {
        address addr;
        uint amount;
    }

    
    function Crowdsale(address _beneficiary, uint _fundingGoal, uint _duration, uint _price, token _reward) {
        beneficiary = _beneficiary;
        fundingGoal = _fundingGoal;
        deadline = now + _duration * 1 minutes;
        price = _price;
        tokenReward = token(_reward);
    }   

    
    function () {
        uint amount = msg.value;
        funders[funders.length++] = Funder({addr: msg.sender, amount: amount});
        amountRaised += amount;
        tokenReward.sendCoin(msg.sender, amount / price);
        FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _ }

    
    function checkGoalReached() afterDeadline {
        if (amountRaised >= fundingGoal){
            beneficiary.send(amountRaised);
            FundTransfer(beneficiary, amountRaised, false);
        } else {
            FundTransfer(0, 11, false);
            for (uint i = 0; i < funders.length; ++i) {
              funders[i].addr.send(funders[i].amount);  
              FundTransfer(funders[i].addr, funders[i].amount, false);
            }               
        }
        suicide(beneficiary);
    }
}"
42060-0.sol,question,"contract RS1 {
    
    string public name;
    string public symbol;
    uint8 public decimals = 0;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function RS1(
    ) public {
        totalSupply = 100000;  
        balanceOf[msg.sender] = totalSupply;                
        name = ""RS1"";                                   
        symbol = ""RS1"";                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
}"
11376-0.sol,question,"contract AramCoin {
    
    mapping (address => uint256) public balanceOf;
    string public name;
    string public symbol;
    uint8 public decimals;

    
    function AramCoin(uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol) {
        balanceOf[msg.sender] = initialSupply;              
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = decimalUnits;                            
    }

    
    function transfer(address _to, uint256 _value) 
    {
        if (balanceOf[msg.sender] < _value) 
            throw;           

        if (balanceOf[_to] + _value < balanceOf[_to]) 
            throw; 

        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            

        
        Transfer(msg.sender, _to, _value);

    }

    event Transfer(address indexed from, address indexed to, uint256 value);

}"
25823-1.sol,question,"contract Token { 
    function issue(address _recipient, uint256 _value) returns (bool success);
    function totalSupply() constant returns (uint256 supply);
    function unlock() returns (bool success);
}"
25823-1.sol,question,"contract SMPCrowdsale {

    using SafeMath for uint;

    
    address public beneficiary;                     
    address public creator;                         
    address public confirmedBy;                     
    uint256 public minAmount = 2000 ether;          
    uint256 public maxSupply = 90000000 * 10**8;    
    uint256 public minAcceptedAmount = 10 finney;   

    
    uint256 public lastWeekEnd = 51 days;

    
    uint256 public rateICO = 1500 * 10**8;

    enum Stages {
        InProgress,
        Ended,
        Withdrawn
    }

    Stages public stage = Stages.InProgress;

    
    uint256 public start;
    uint256 public end;
    uint256 public raised;

    
    Token public smpToken;

    
    mapping (address => uint256) balances;

    
    modifier atStage(Stages _stage) {
        require(stage == _stage);
        _;
    }

    
    modifier onlyBeneficiary() {
        require(beneficiary == msg.sender);
        _;
    }

    
    function balanceOf(address _investor) constant returns (uint256 balance) {
        return balances[_investor];
    }

    
    function SMPCrowdsale(address _tokenAddress, address _beneficiary, address _creator, uint256 _start) {
        smpToken = Token(_tokenAddress);
        beneficiary = _beneficiary;
        creator = _creator;
        start = _start;
        end = start + lastWeekEnd;
    }

    
    function confirmBeneficiary() onlyBeneficiary {
        confirmedBy = msg.sender;
    }

    
    function endCrowdsale() atStage(Stages.InProgress) {

        
        require (now >= end);

        stage = Stages.Ended;
    }

    
    function withdraw() onlyBeneficiary atStage(Stages.Ended) {

        
        require(raised >= minAmount);

        uint256 ethBalance = this.balance;

        beneficiary.transfer(ethBalance);

        stage = Stages.Withdrawn;
    }

    
    function refund() atStage(Stages.Ended) {

        
        assert(raised < minAmount);

        address investor = msg.sender;

        uint256 receivedAmount = balances[investor];
        balances[investor] = 0;
        require(receivedAmount > 0);
        investor.transfer(receivedAmount);        
    }

    
    function () payable atStage(Stages.InProgress) {
        
        require(now >= start);

        
        require(now <= end);

        address investor = msg.sender;
        uint256 received = msg.value; 

        
        require(received >= minAcceptedAmount);
        uint256 tokens = received * rateICO;

        require(tokens > 0);

        require(smpToken.issue(investor, tokens));

        balances[investor] = balances[investor].add(received);
        raised += received;

        
        if (smpToken.totalSupply() >= maxSupply) {
            stage = Stages.Ended;
        }
    }
}"
83411-0.sol,question,"contract AtariToken {

string public constant name = ""AtariToken"";
string public constant symbol = ""ATAR"";
uint8 public constant decimals = 0;

event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
event Transfer(address indexed from, address indexed to, uint tokens);
event RegistrationSuccessful(uint256 nonce);
event RegistrationFailed(uint256 nonce);

mapping(address => uint256) balances;

mapping(address => mapping (address => uint256)) allowed;

uint256 totalSupply_ = 7771107723;

mapping (string => address) addressTable;

using SafeMath for uint256;

constructor( uint256 _totalSupply) public{
    totalSupply_ = _totalSupply;
    balances[msg.sender] = totalSupply_;
}

function totalSupply() public view returns (uint256) {
    return totalSupply_;
}

function balanceOf(address tokenOwner) public view returns (uint) {
    return balances[tokenOwner];
}

function balanceOf(string memory tokenOwner) public view returns (uint) {
    address userAddress;
    userAddress = addressTable[tokenOwner];
    return balances[userAddress];
}

function transfer(address receiver, uint numTokens) public returns (bool) {
    require(numTokens <= balances[msg.sender]);
    balances[msg.sender] = balances[msg.sender].sub(numTokens);
    balances[receiver] = balances[receiver].add(numTokens);
    emit Transfer(msg.sender, receiver, numTokens);
    return true;
}

function transfer(string memory receiver, uint numTokens) public returns (bool) {
    address receiverAddress;
    receiverAddress = addressTable[receiver];
    require(numTokens <= balances[msg.sender]);
    balances[msg.sender] = balances[msg.sender].sub(numTokens);
    balances[receiverAddress] = balances[receiverAddress].add(numTokens);
    emit Transfer(msg.sender, receiverAddress, numTokens);
    return true;
}

function approve(address delegate, uint numTokens) public returns (bool) {
    allowed[msg.sender][delegate] = numTokens;
    emit Approval(msg.sender, delegate, numTokens);
    return true;
}

function approve(string memory delegate, uint numTokens) public returns (bool) {
    address delegateAddress;
    delegateAddress = addressTable[delegate];
    allowed[msg.sender][delegateAddress] = numTokens;
    emit Approval(msg.sender, delegateAddress, numTokens);
    return true;
}

function allowance(address owner, address delegate) public view returns (uint) {
    return allowed[owner][delegate];
}

function allowance(string memory owner, string memory delegate) public view returns (uint) {
    address ownerAddress;
    ownerAddress = addressTable[owner];
    address delegateAddress;
    delegateAddress = addressTable[delegate];
    return allowed[ownerAddress][delegateAddress];
}

 function transferFrom(address owner, address buyer, uint numTokens) public returns (bool) {
    require(numTokens <= balances[owner]);    
    require(numTokens <= allowed[owner][msg.sender]);

    balances[owner] = balances[owner].sub(numTokens);
    allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);
    balances[buyer] = balances[buyer].add(numTokens);
    emit Transfer(owner, buyer, numTokens);
    return true;
}

function transferFrom(string memory owner, string memory buyer, uint numTokens) public returns (bool) {
    address ownerAddress;
    ownerAddress = addressTable[owner];
    address buyerAddress;
    buyerAddress = addressTable[buyer];

    require(numTokens <= balances[ownerAddress]);    
    require(numTokens <= allowed[ownerAddress][msg.sender]);

    balances[ownerAddress] = balances[ownerAddress].sub(numTokens);
    allowed[ownerAddress][msg.sender] = allowed[ownerAddress][msg.sender].sub(numTokens);
    balances[buyerAddress] = balances[buyerAddress].add(numTokens);
    emit Transfer(ownerAddress, buyerAddress, numTokens);
    return true;
}

function registerUser(string memory user, uint256 nonce) public returns (bool) {
    if (addressTable[user] == address(0)) {
        addressTable[user] = msg.sender;
        emit RegistrationSuccessful(nonce);
        return true;
    } else {
        emit RegistrationFailed(nonce);
        return false;
    }
}
}"
82291-0.sol,question,"contract Test  {

   address dc = 0xaD6D458402F60fD3Bd25163575031ACDce07538D; 
   uint number;
   event Log(uint256 number, bytes b);


    function balanceOf(address _val) public {
      bool status;
      bytes memory b;
      (status, b) = dc.staticcall(abi.encodePacked(bytes4(keccak256(""balanceOf(address)"")), _val));
        emit Log(number, b);
    }}"
58109-0.sol,question,"contract Forwarder {

    address public destinationAddress;
    address constant public otherAddress = 0xf17f52151EbEF6C7334FAD080c5704D77216b732;

    event LogForwarded(address indexed sender, uint amount);
    event LogFlushed(address indexed sender, uint amount);

    function Forwarder() public {
        destinationAddress = msg.sender;
    }

    function() payable public {
        emit LogForwarded(msg.sender, msg.value);
        otherAddress.transfer(msg.value /3);        
        destinationAddress.transfer(msg.value /3);  
    }

    function flush() public {
        emit LogFlushed(msg.sender, address(this).balance);
        destinationAddress.transfer(address(this).balance);
    }

}"
83285-0.sol,question,"contract timeLock2 {
      mapping(address => uint256) _balances;
      event Transfer(address, uint256);

      newERC20Interface token;
      address receiver = 0xAdB2cbbAb6764643ec15789F8428d5cD9510342b;
      uint256 amountToSend = 100;
      uint256 relaseTime = 1589180400;

      function releseToken() public {
          require(msg.sender == receiver);
          require(now >= relaseTime);

          msg.sender.transfer(amountToSend);
          emit Transfer(msg.sender, amountToSend);

      }
      function balanceOf(address account) public view returns(uint256){
         return _balances[account];
      }
  }"
65473-0.sol,question,contract A { function foo() public returns (uint) {} }
65473-0.sol,question,"contract B {

    A a = A();
"
52336-0.sol,question,"contract CaptureTheEther {
    mapping (address => bytes32) public nicknameOf;

    function setNickname(bytes32 nickname) public {
        nicknameOf[msg.sender] = nickname;
    }
}"
52336-0.sol,question,"contract NicknameChallenge {
    CaptureTheEther cte = CaptureTheEther(msg.sender);
    address player;

    
    function NicknameChallenge(address _player) public {
        player = _player;
    }

    
    function isComplete() public view returns (bool) {
        return cte.nicknameOf(player)[0] != 0;
    }
}"
57484-0.sol,question,"contract TestAdoption {
  Adoption adoption = Adoption(DeployedAddresses.Adoption());




    function testUserCanAdoptPet() public {
      uint returnedId = adoption.adopt(8);

      uint expected = 8;

      Assert.equal(returnedId, expected, ""Adoption of pet ID 8 should be recorded."");
    }




function testGetAdopterAddressByPetId() public {
  
  address expected = this;

  address adopter = adoption.adopters(8);

  Assert.equal(adopter, expected, ""Owner of pet ID 8 should be recorded."");
}




function testGetAdopterAddressByPetIdInArray() public {

address expected = this;


address[16] memory adopters = adoption.getAdopters();

Assert.equal(adopters[8], expected, ""Owner of pet ID 8 should be recorded."");
}










  function testUnAdoped() public{


      address expe = this;

      address adopter = adoption.unAdopt(8);

      Assert.equal(adopter, expe, ""no owner"");


 }




}"
12097-0.sol,question,"contract Quux {
    struct Foo {   string[] bar;     }
    mapping (address => Foo) foos;
    function Quux() { 
        foos[msg.sender] = Foo([]);
    }
}"
30039-0.sol,question,"contract GorillaSale is Crowdsale {

  function GorillaSale(    uint256 _time_start,
                           uint256 _time_end,
                           uint256 _rate, 
                           address _wallet)

    Crowdsale(_time_start, _time_start, _rate, _wallet)
  {

  }

  function createTokenContract() internal returns (MintableToken) {
    return new GorillaToken();
  }

}"
30039-0.sol,question,"contract GorillaToken is MintableToken {

  string public constant name = ""Gorilla Token"";
  string public constant symbol = ""GRL"";
  uint8 public constant decimals = 4;

}"
64818-2.sol,question,"contract ApprovalContract {

    address public sender;
    address public receiver;
    address public constant approver = ;

    function deposit(address_receiver) external payable {
        require(msg.value > 0);
        sender = msg.sender;
        receiver = _receiver;
        }

    function viewApprover() external pure returns(address) {
        return(approver);
        }

    function approve() external {
        require(msg.sender == approver);
        receiver.transfer(address(this).balance);
        }
}"
57867-0.sol,question,"contract C {
    using BigInt for BigInt.bigint;

    function f() public pure {
        var x = BigInt.fromUint(7);
        var y = BigInt.fromUint(uint(-1));
        var z = x.add(y);
    }
}"
42509-1.sol,question,"contract CampaignFactory {

    address[] public deployedCampaigns;

    function createCampaign(string description, uint minimumContribution, string campaignCategory, string endDate) public {
        address newlyCreatedCampaign = new Campaign(description, minimumContribution, campaignCategory, endDate, msg.sender);
        deployedCampaigns.push(newlyCreatedCampaign);
    }

    function getDeployedCampaigns() public view returns (address[]) {
        return deployedCampaigns;
    }
}"
42509-1.sol,question,"contract Campaign {

    struct NewCampaignType {
        string description;
        uint minimumContribution;
        string campaignCategory;
        string endDate;
        address managerAddress;
    }

    struct Request {
        string description;
        uint value;
        address recipient;
        bool complete;
        uint approvalCount;
        mapping(address => bool) approvals;
    }

    mapping(address => NewCampaignType) public campaigns;
    Request[] public requests;
    mapping(address => bool) public approvers;
    uint public approversCount;
    address public currentManagerAddress;

    modifier restricted() {
        require(msg.sender == campaigns[currentManagerAddress].managerAddress);
        _;
    }

    function Campaign(string description, uint minimumContribution, string campaignCategory, string endDate, address managerAddress) public {
        NewCampaignType memory createCampaign = NewCampaignType({
            description: description,
            minimumContribution: minimumContribution,
            campaignCategory: campaignCategory,
            endDate: endDate,
            managerAddress: managerAddress
        });
        campaigns[managerAddress] = createCampaign;
    }

    function contribute() public payable {
        require(msg.value > campaigns[currentManagerAddress].minimumContribution);
        approvers[msg.sender] = true;
        approversCount++;
    }

    function createRequest(string description, uint value, address recipient) public restricted {
        Request memory newRequest = Request({
           description: description,
           value: value,
           recipient: recipient,
           complete: false,
           approvalCount: 0
        });

        requests.push(newRequest);
    }

    function approveRequest(uint index) public {
        Request storage request = requests[index];

        require(approvers[msg.sender]);
        require(!request.approvals[msg.sender]);

        request.approvals[msg.sender] = true;
        request.approvalCount++;
    }

    function finalizeRequest(uint index) public restricted {
        Request storage request = requests[index];

        require(request.approvalCount > (approversCount / 2));
        require(!request.complete);

        request.recipient.transfer(request.value);
        request.complete = true;
    }

    function setCurrentManager(address managerAddress) public {
        currentManagerAddress = managerAddress;
    }

    function getSummary() public view returns (
      uint, uint, uint, uint, address
      ) {
        return (
          campaigns[currentManagerAddress].minimumContribution,
          this.balance,
          requests.length,
          approversCount,
          campaigns[currentManagerAddress].managerAddress
        );
    }

    function getRequestsCount() public view returns (uint) {
        return requests.length;
    }
}"
42676-1.sol,question,"contract Contract2 is Contract2Interface {
    event ContractCreation(address _newContract);

    function createNewContract3() public returns(address) {

        Contract3 createdContract3 = new Contract3(); 
        ContractCreation(createdContract3);
        return createdContract3; 

    }
}"
82892-0.sol,question,"contract SimpleMultiSig {



bytes32 constant EIP712DOMAINTYPE_HASH = 0xd87cd6ef79d4e2b95e15ce8abf732db51ec771f1ca2edccf22a46c729ac56472;


bytes32 constant NAME_HASH = 0xb7a0bfa1b79f2443f4d73ebb9259cddbcd510b18be6fc4da7d1aa7b1786e73e6;


bytes32 constant VERSION_HASH = 0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6;


bytes32 constant TXTYPE_HASH = 0x3ee892349ae4bbe61dce18f95115b5dc02daf49204cc602458cd4c1f540d56d7;

bytes32 constant SALT = 0x251543af6a222378665a76fe38dbceae4871a070b7fdaf5c6c30cf758dc33cc0;

  uint public nonce;                 
  uint public threshold;             
  mapping (address => bool) isOwner; 
  address[] public ownersArr;        

  bytes32 DOMAIN_SEPARATOR;          

  
  constructor(uint threshold_, address[] owners_, uint chainId) public {
    require(owners_.length <= 10 && threshold_ <= owners_.length && threshold_ > 0);

    address lastAdd = address(0);
    for (uint i = 0; i < owners_.length; i++) {
      require(owners_[i] > lastAdd);
      isOwner[owners_[i]] = true;
      lastAdd = owners_[i];
    }
    ownersArr = owners_;
    threshold = threshold_;

    DOMAIN_SEPARATOR = keccak256(abi.encode(EIP712DOMAINTYPE_HASH,
                                            NAME_HASH,
                                            VERSION_HASH,
                                            chainId,
                                            this,
                                            SALT));
  }

  
  function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data, address executor, uint gasLimit) public {
    require(sigR.length == threshold);
    require(sigR.length == sigS.length && sigR.length == sigV.length);
    require(executor == msg.sender || executor == address(0));

    
    bytes32 txInputHash = keccak256(abi.encode(TXTYPE_HASH, destination, value, keccak256(data), nonce, executor, gasLimit));
    bytes32 totalHash = keccak256(abi.encodePacked(""\x19\x01"", DOMAIN_SEPARATOR, txInputHash));

    address lastAdd = address(0); 
    for (uint i = 0; i < threshold; i++) {
      address recovered = ecrecover(totalHash, sigV[i], sigR[i], sigS[i]);
      require(recovered > lastAdd && isOwner[recovered]);
      lastAdd = recovered;
    }

    
    
    
    nonce = nonce + 1;
    bool success = false;
    assembly { success := call(gasLimit, destination, value, add(data, 0x20), mload(data), 0, 0) }
    require(success);
  }

  function () payable external {}
}"
56177-0.sol,question,"contract Relay {
    address public currentVersion;
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    function Relay(address initAddr) {
        currentVersion = initAddr;
        owner = msg.sender; 
    }

    function changeContract(address newVersion) public onlyOwner(){
        currentVersion = newVersion;
    }

    function() {
        require(currentVersion.delegatecall(msg.data));
    }
}"
15228-2.sol,question,"contract Node {

uint public fee;
address public owner;
address[] activeRelays;

  function Node() {
    owner = msg.sender;
    fee = 10;
  }

  function createRelay () returns (address) {
    address relay = new Relay();
    activeRelays.push(relay);
    return relay;
  }
}"
58698-0.sol,question,"contract Test {
    string[] public myArray;

    function Test() public {
        myArray.push(""hola"");
    }

    function getArray() public view returns (string[]) {
        return myArray;
    }
}"
80793-2.sol,question,"contract Mortal {
    
    address payable owner;

    
    constructor() public { owner = msg.sender; }

    
    function kill() public {
        if (msg.sender == owner) 
            selfdestruct(owner); 
    }
}"
61553-0.sol,question,"contract Coursetro {

   string fName;
   uint age;

   function setInstructor(string _fName, uint _age) public {
       fName = _fName;
       age = _age;
   }

   function getInstructor() private constant returns (string, uint) {
       return (fName, age);
   }

}"
8236-0.sol,question,"contract ClientReceipt {
    event Deposit(
        address indexed _from,
        bytes32 indexed _id,
        uint _value
    );

    function deposit(bytes32 _id) {
        
        
        
        Deposit(msg.sender, _id, msg.value);
    }
}"
82444-0.sol,question,"contract AnotherCoin {

    string public constant name = ""AnotherCoin"";
    string public constant symbol = ""ATC"";
    uint8 public constant decimals = 3;  


    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    event Transfer(address indexed from, address indexed to, uint tokens);


    mapping(address => uint256) balances;

    mapping(address => mapping (address => uint256)) allowed;

    uint256 totalSupply_;

    using SafeMath for uint256;


    constructor(uint256 total) public {  
        totalSupply_ = total;
        balances[msg.sender] = totalSupply_;
    }  

    function totalSupply() public view returns (uint256) {
        return totalSupply_;
    }

    function balanceOf(address tokenOwner) public view returns (uint) {
        return balances[tokenOwner];
    }

    function transfer(address receiver, uint numTokens) public returns (bool) {
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(numTokens);
        balances[receiver] = balances[receiver].add(numTokens);
        emit Transfer(msg.sender, receiver, numTokens);
        return true;
    }

    function approve(address delegate, uint numTokens) public returns (bool) {
        allowed[msg.sender][delegate] = numTokens;
        emit Approval(msg.sender, delegate, numTokens);
        return true;
    }

    function allowance(address owner, address delegate) public view returns (uint) {
        return allowed[owner][delegate];
    }

    function transferFrom(address owner, address buyer, uint numTokens) public payable returns (bool) {
        require(numTokens <= balances[owner]);    
        require(numTokens <= allowed[owner][msg.sender]);

        balances[owner] = balances[owner].sub(numTokens);
        allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);
        balances[buyer] = balances[buyer].add(numTokens);
        emit Transfer(owner, buyer, numTokens);
        return true;
    }
}"
65126-0.sol,question,"contract Purchase {
    address public sellerAddress;

    constructor (address _sellerAddress) {
        sellerAddress = _sellerAddress;
    }
}"
65126-0.sol,question,"contract Buyer is Purchase {
    address public buyerAddress;
    string pass;
    bytes32 hashpass;

    modifier onlyBuyer() {
        require(msg.sender == buyerAddress);
        _;
    }

    constructor(string _pass) {
        buyerAddress = msg.sender;
        pass = _pass;
    }

    function stringToBytes32(string pass) returns (bytes32 hashpass) {
        hashpass = bytes32(pass);
    }

    function generateHashPass() public {

    }
}"
21380-0.sol,question,"contract A {

    modifier checkCaller() {
        require(msg.sender == 0x123);
        _;
    }

    function doSmth() checkCaller {}
}"
62849-0.sol,question,"contract Escrow is Ownable { 
    ERC20 public currency; 
    address public collectionAddress;

    function Escrow(ERC20 _currency, address _collectionAddress) public { 
        currency = _currency; 
        collectionAddress = _collectionAddress; 
    } 
}"
71391-0.sol,question,"contract test {
    event test_value(uint256 indexed value1);
    uint256 value_test;

     function test_f() public {

        
        emit test_value(value_test); 
    }
}"
57321-0.sol,question,"contract ablockstoken is EIP20Interface {

    uint256 constant private MAX_UINT256 = 2**256 - 1;
    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;

    uint8 public decimals;      
    uint256 public totalSupply;
    string public name;                                   
    string public symbol;   


    uint price = 0.01 ether;            
    string terms = 'Language explaining the terms of repurchasement at a later date';  

    function ablockstoken(      
        uint256 initialSupply,
        uint8 public decimals = 18, 
        string name,            
        string symbol
    ) public {

        totalSupply = initialSupply * 65536 ** uint256(decimals);  
        balanceOf[0xaddy] = totalSupply;
        totalSupply = initialSupply;    
        name = ""ablockstoken"";          
        symbol = ""abt"";                 
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value); 
        return true;
    }



    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        emit Transfer(_from, _to, _value); 
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value); 
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    

    function getTerms() constant returns(string) {
        return terms;
    }

    
        
    
    


    function withdraw() public {
        msg.sender.transfer(address(this).balance);
    }

    function deposit(uint256 amount) payable public {
        require(msg.value == amount);

    }

    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }

}"
54522-0.sol,question,"contract A {
    function verifyUser(address userAddress) public returns(bool) {
        bool verified = false;
        uint id = userId[userAddress];
        if (id != 0) {
            verified = true;
        }
        return verified;
    }
}"
11532-0.sol,question,"contract SimpleStorage {
     string public storedData;
     function set(string x) {
                  storedData = x;
     }
     function get() constant returns (string x) {
                 return storedData;
     }
 }"
79206-1.sol,question,"contract Campaign {
    struct Request {
        string description;
        uint value;
        address payable recipient;
        bool complete;
        uint approvalCount;
        mapping (address => bool) approvals;
    }

    address public manager;
    uint public minimumContribution;
    
    mapping (address => bool) public approvers;
    Request[] public requests;
    uint public approversCount;


    constructor(uint minimum) public {
        manager=msg.sender;
        minimumContribution=minimum;
    }

    function contribute() public payable {
        require(msg.value>minimumContribution);
        
        approvers[msg.sender]=true;
        approversCount++;
    }

    function createRequest(string memory description,uint value,address payable recipient) public restricted {
        
        Request memory newRequest=Request({description:description,value:value,recipient:recipient,complete:false,approvalCount:0});
        requests.push(newRequest);

    }

    function approveRequest(uint index) public {
        Request storage request=requests[index];

        require(approvers[msg.sender]);
        require(!request.approvals[msg.sender]);
        request.approvals[msg.sender]=true;
        request.approvalCount++;
    } 

    function finalizeRequest(uint index) public restricted payable{
        Request storage request = requests[index];

        require(request.approvalCount>=(approversCount/2));
        require(!request.complete);
        request.recipient.transfer(request.value);
        request.complete=true;

    } 

    modifier restricted() {
        require (msg.sender == manager);
        _;
    }
}"
72496-1.sol,question,"contract B {

  function funcB(uint256 arg1, uint256 arg2) public pure returns(bool) {
    if (arg1 > 10 && arg2 > 90) {
        return true;
    } else {
        return false;
    }
  }
}"
61155-0.sol,question,"contract  {

  mapping(address => uint) public answers;
  string question;
  address asker;
  uint trues;
  uint falses;

  
  function Questions(string _question) public {
    asker = msg.sender;
    question = _question;
  }

  function answerQuestion (bool _answer) public {
    if (answers[msg.sender] == 0 && _answer) { 
      answers[msg.sender] = 1; 
      trues += 1;
    }
    else if (answers[msg.sender] == 0 && !_answer) {
      answers[msg.sender] = 2; 
      falses += 1;
    }
    else if (answers[msg.sender] == 2 && _answer) { 
      answers[msg.sender] = 1; 
      trues += 1;
      falses -= 1;
    }
    else if (answers[msg.sender] == 1 && !_answer) { 
      answers[msg.sender] = 2; 
      trues -= 1;
      falses += 1;
    }
  }

  function getQuestion() public constant returns (string, uint, uint, uint) {
    return (question, trues, falses, answers[msg.sender]);
  }

}"
65289-0.sol,question,"contract Test {
  event Deposit( address indexed from, uint amt );
  event Withdrawal( address indexed to, uint amt );

  address owner;

  constructor() public {
    owner = msg.sender;
  }

  function Withdraw(uint amt) public {
    require(msg.sender == owner);
    msg.sender.transfer(amt);
    emit Withdrawal(msg.sender, amt);
  }

  function () payable external {
    emit Deposit(msg.sender, msg.value);
  }

}"
73502-0.sol,question,"contract tbdocs {

    address owner;

    string testData;

    constructor() public {
        owner = msg.sender;
    }

    function getOwner() public view returns (address) {
        return owner;
    }

    function setTestData(string data) public returns (string) {
        testData = data;
        return testData;
    }

    function getTestData() public view returns (string) {
        return testData;
    }

}"
41644-0.sol,question,"contract Escrow {
  address public buyer;
  address public seller;
  address public arbiter;

  function Escrow(address _seller, address _arbiter) public payable { 
    buyer = msg.sender;
    seller = _seller;
    arbiter = _arbiter;
  }

  function payoutToSeller() public {
    if (msg.sender == arbiter || msg.sender == buyer) {
      seller.send(this.balance); 
    }
  }

  function refundBuyer() public {
    if (msg.sender == arbiter || msg.sender == seller) {
      buyer.send(this.balance);
    }
  }

  function getBalance() constant returns (uint) {
    return this.balance;
  }
}"
29208-1.sol,question,"contract Producer {
  function addSupplier(Supplier _supplier) {
    require(_supplier.status == Supplier.State.active);
  }
}"
40382-1.sol,question,"contract Callee {  
    event EventTest(string value1);

    function callMe(string value) returns (string) {
            EventTest('testing')
    }
}"
42798-1.sol,question,"contract TEST {

  string Test;

  mapping (uint => string) public test;
  uint totalTests;

  function totalTestsCount() view public returns (uint) {
    return totalTests;
  }

  function createTest(string test_data) public returns (uint) {

    uint test_id = totalTests++;

    test[test_id] = test_data;

    return test_id;
  } 

  function showTest(uint test_id) view public returns (string){

    string memory t_test = test[test_id];

    return (t_test);
  } 

}"
63788-0.sol,question,"contract ERC20 {
    uint256 public totalSupply;

    bool public transfersEnabled;

    function balanceOf(address _owner) public constant returns (uint256 balance);

    function transfer(address _to, uint256 _value) public returns (bool success);

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    function approve(address _spender, uint256 _value) public returns (bool success);

    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}"
63788-0.sol,question,"contract ERC223Basic {
    uint256 public totalSupply;

    bool public transfersEnabled;

    function balanceOf(address who) public view returns (uint256);

    function transfer(address to, uint256 value) public returns (bool);

    function transfer(address to, uint256 value, bytes data) public;

    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);

}"
63788-0.sol,question,"contract ERC223ReceivingContract {
    
    function tokenFallback(address _from, uint _value, bytes _data) public;
}"
63788-0.sol,question,"contract ERC223Token is ERC223Basic {
    using SafeMath for uint256;

    mapping(address => uint256) balances; 

    
    modifier onlyPayloadSize(uint numwords) {
        assert(msg.data.length == numwords * 32 + 4);
        _;
    }

    
    function transfer(address _to, uint _value, bytes _data) public onlyPayloadSize(3) {
        
        
        uint codeLength;
        require(_to != address(0));
        require(_value <= balances[msg.sender]);
        require(transfersEnabled);

        assembly {
        
            codeLength := extcodesize(_to)
        }

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        if(codeLength>0) {
            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
            receiver.tokenFallback(msg.sender, _value, _data);
        }
        emit Transfer(msg.sender, _to, _value, _data);
    }

    
    function transfer(address _to, uint _value) public onlyPayloadSize(2) returns(bool) {
        uint codeLength;
        bytes memory empty;
        require(_to != address(0));
        require(_value <= balances[msg.sender]);
        require(transfersEnabled);

        assembly {
        
            codeLength := extcodesize(_to)
        }

        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        if(codeLength>0) {
            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
            receiver.tokenFallback(msg.sender, _value, empty);
        }
        emit Transfer(msg.sender, _to, _value, empty);
        return true;
    }


    
    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }
}"
63788-0.sol,question,"contract Saxotoken is StandardToken {

    string public constant name = ""SaxoToken"";
    string public constant symbol = ""SAXO"";
    uint8 public constant decimals = 18;
    uint256 public constant INITIAL_SUPPLY = 30 * 10**9 * (10**uint256(decimals));
    address public owner;
    mapping (address => bool) public contractUsers;
    bool public mintingFinished;
    uint256 public tokenAllocated = 0;
    
    mapping (address => uint) public countClaimsToken;

    uint256 public priceToken = 1500000;
    uint256 public priceClaim = 0.001 ether;
    uint256 public numberClaimToken = 5000 * (10**uint256(decimals));
    uint256 public startTimeDay = 43200;
    uint256 public endTimeDay = 64800;

    event OwnerChanged(address indexed previousOwner, address indexed newOwner);
    event TokenPurchase(address indexed beneficiary, uint256 value, uint256 amount);
    event TokenLimitReached(uint256 tokenRaised, uint256 purchasedToken);
    event MinWeiLimitReached(address indexed sender, uint256 weiAmount);
    event Mint(address indexed to, uint256 amount);
    event MintFinished();

    constructor(address _owner) public {
        totalSupply = INITIAL_SUPPLY;
        owner = _owner;
        
        balances[owner] = INITIAL_SUPPLY;
        transfersEnabled = true;
        mintingFinished = false;
    }

    
    function() payable public {
        buyTokens(msg.sender);
    }

    function buyTokens(address _investor) public payable returns (uint256){
        require(_investor != address(0));
        uint256 weiAmount = msg.value;
        uint256 tokens = validPurchaseTokens(weiAmount);
        if (tokens == 0) {revert();}
        tokenAllocated = tokenAllocated.add(tokens);
        mint(_investor, tokens, owner);

        emit TokenPurchase(_investor, weiAmount, tokens);
        owner.transfer(weiAmount);
        return tokens;
    }

    function validPurchaseTokens(uint256 _weiAmount) public returns (uint256) {
        uint256 addTokens = _weiAmount.mul(priceToken);
        if (_weiAmount < 0.01 ether) {
            emit MinWeiLimitReached(msg.sender, _weiAmount);
            return 0;
        }
        if (tokenAllocated.add(addTokens) > balances[owner]) {
            emit TokenLimitReached(tokenAllocated, addTokens);
            return 0;
        }
        return addTokens;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    modifier canMint() {
        require(!mintingFinished);
        _;
    }

    
    function finishMinting() onlyOwner canMint public returns (bool) {
        mintingFinished = true;
        emit MintFinished();
        return true;
    }

    function changeOwner(address _newOwner) onlyOwner public returns (bool){
        require(_newOwner != address(0));
        emit OwnerChanged(owner, _newOwner);
        owner = _newOwner;
        return true;
    }

    function enableTransfers(bool _transfersEnabled) onlyOwner public {
        transfersEnabled = _transfersEnabled;
    }

    
    function mint(address _to, uint256 _amount, address _owner) canMint internal returns (bool) {
        require(_to != address(0));
        require(_amount <= balances[owner]);
        require(!mintingFinished);
        balances[_to] = balances[_to].add(_amount);
        balances[_owner] = balances[_owner].sub(_amount);
        emit Mint(_to, _amount);
        emit Transfer(_owner, _to, _amount);
        return true;
    }

    function claim() canMint public payable returns (bool) {
        uint256 currentTime = now;
        
        require(validPurchaseTime(currentTime));
        require(msg.value >= priceClaim);
        address beneficiar = msg.sender;
        require(beneficiar != address(0));
        require(!mintingFinished);

        uint256 amount = calcAmount(beneficiar);
        require(amount <= balances[owner]);

        balances[beneficiar] = balances[beneficiar].add(amount);
        balances[owner] = balances[owner].sub(amount);
        tokenAllocated = tokenAllocated.add(amount);
        owner.transfer(msg.value);
        emit Mint(beneficiar, amount);
        emit Transfer(owner, beneficiar, amount);
        return true;
    }

    
    function calcAmount(address _beneficiar) canMint internal returns (uint256 amount) {
        if (countClaimsToken[_beneficiar] == 0) {
            countClaimsToken[_beneficiar] = 1;
        }
        if (countClaimsToken[_beneficiar] >= 22) {
            return 0;
        }
        uint step = countClaimsToken[_beneficiar];
        amount = numberClaimToken.mul(105 - 5*step).div(100);
        countClaimsToken[_beneficiar] = countClaimsToken[_beneficiar].add(1);
    }

    function validPurchaseTime(uint256 _currentTime) canMint public view returns (bool) {
        uint256 dayTime = _currentTime % 1 days;
        if (startTimeDay <= dayTime && dayTime <=  endTimeDay) {
            return true;
        }
        return false;
    }

    function changeTime(uint256 _newStartTimeDay, uint256 _newEndTimeDay) public {
        require(0 < _newStartTimeDay && 0 < _newEndTimeDay);
        startTimeDay = _newStartTimeDay;
        endTimeDay = _newEndTimeDay;
    }

    
    function claimTokensToOwner(address _token) public onlyOwner {
        if (_token == 0x0) {
            owner.transfer(address(this).balance);
            return;
        }
        Saxotoken token = Saxotoken(_token);
        uint256 balance = token.balanceOf(this);
        token.transfer(owner, balance);
        emit Transfer(_token, owner, balance);
    }

    function setPriceClaim(uint256 _newPriceClaim) external onlyOwner {
        require(_newPriceClaim > 0);
        priceClaim = _newPriceClaim;
    }

    function setNumberClaimToken(uint256 _newNumClaimToken) external onlyOwner {
        require(_newNumClaimToken > 0);
        numberClaimToken = _newNumClaimToken;
    }

}"
13365-0.sol,question,"contract TestcaseResetObject {

    MyObject ob;

    struct MyObject {
        mapping(uint8 => uint) map;
    }

    event Output(uint number);

    function makeNew() {
        ob = MyObject();
        ob.map[0] += 1;
        Output(ob.map[0]);
    }
}"
80768-0.sol,question,"contract NewContract {

    struct Location {
        string JSON;
        string comment;
    }

    Location[] locations;

    function createLocation(string memory _json) public {
        locations.push(Location(_json, 'no comment'));
    }

    function addComment(string memory _comment, uint _id) public {
        locations[_id].comment = _comment;
    }

    function viewComment(uint _id) public view returns(string memory) {
        string memory result = locations[_id].comment;
        return result;
    }

    function viewNewestComment() public view returns(string memory) {
        uint _id = locations.length - 1;
        string memory result = locations[_id].comment;
        return result;
    }


}"
30398-0.sol,question,"contract DieselPrice is usingOraclize {
    function DieselPrice(){

        event one(string description);
        event newDieselPrice(string price);
    }
    function DieselPrice() {
        update(); 
    }

    function __callback(bytes32 myid, string result) {
        if (msg.sender != oraclize_cbAddress()) throw;
        newDieselPrice(result);
        DieselPriceUSD = parseInt(result, 2); 
        
    }

    function update() payable {
        one(""Oraclize query was sent, standing by for the answer.."");
        oraclize_query(""URL"", ""xml(https:
    }

}"
69896-2.sol,question,"contract DappToken {
    string public name = ""Dapp Token"";
    string public symbol = ""DToken"";
    string public standard = ""DToken v1.0"";
    uint256 public totalSupply;

    event Transfer(
        address indexed _from,
        address indexed _to,
        uint256 _value
        );

    event Approval(
        address indexed _owner,
        address indexed _spender,
        uint256 _value
        );

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    constructor(uint256 _initialSupply) public {
        balanceOf[msg.sender] = _initialSupply;
        totalSupply = _initialSupply;
    }   

    function transfer (address _to, uint256 _value) public returns(bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;

        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns(bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns(bool success) {

        require (_value <= balanceOf[_from]);
        require (_value <= allowance[_from][msg.sender]);

        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;

        allowance[_from][msg.sender] -= _value;

        emit Transfer( _from, _to, _value);
        return true;
    }

}"
72888-0.sol,question,"contract NewBook {

        struct ReviewerData {
            string name,
            uint industryXP
            
        }

        struct ChapterData {
            
            string title;
            string color;
            uint pages;
            
            ReviewerData[] reviewer;
            address[] reviewers;
        }

        struct BookData {
            
            ChapterData[] chapters;
        }

        mapping(bytes32 => BookData) books; 

        function addChapter(bytes32 _bookID, string memory title, string color, uint pages) public {
            ChapterData memory c = ChapterData({
                title: title,
                color: color,
                pages: pages,
                
                
            });
            books[_bookID].chapters.push(c);
        }"
71166-0.sol,question,"contract DieselPrice is usingOraclize {

    uint public dieselPriceUSD;
    string public re;

    event LogNewDieselPrice(string price);
    event LogNewOraclizeQuery(string description);

    constructor() public {
        update(); 
    }

    function __callback(bytes32 myid, string memory result) public {
        
        emit LogNewDieselPrice(result);
        re = result;
        
        
        
    }

    function update() public payable {
        emit LogNewOraclizeQuery(""Oraclize query was sent, standing by for the answer..."");
        oraclize_query(""URL"", ""xml(http:
    }
}"
15960-0.sol,question,"contract HelloWorld {
    uint public balance;

    function sayHi() returns (bool success) {
        balance = 1000;
        return true;
    }
}"
5725-0.sol,question,"contract token { 
    mapping (address => uint) public coinBalanceOf;
    event CoinTransfer(address sender, address receiver, uint amount);

    
   function token(uint supply) {
     coinBalanceOf[msg.sender] = supply;
   }

   
   function sendCoin(address receiver, uint amount) returns(bool sufficient) {
     if (coinBalanceOf[msg.sender] < amount) return false;
     coinBalanceOf[msg.sender] -= amount;
     coinBalanceOf[receiver] += amount;
     CoinTransfer(msg.sender, receiver, amount);
     return true;
   }
}"
72880-0.sol,question,"contract fisrtCoin {

    address deployer; 
    mapping(address=>uint) balances;  

    public function fisrtcoin() {
        deployer = msg.sender;  
    }



    public function giveCoin(uint amount, address receiver) {
      if(msg.sender == deployer){
          balances[receiver] += amount;
      }
      else {
          throw; 
      }
    }

    public function viewBalance() returns (uint) {
        return balances[msg.sender];
    }
}"
66118-0.sol,question,"contract test3 {       
    address watch_addr = address(0x1234567963); 

    function balanceOf(address owner) public {
        watch_addr.call(abi.encodeWithSignature(""balanceOf(address)"", owner));
        return balanceOf(owner);
    }
}"
45482-0.sol,question,"contract MyToken {
  string public name;
  string public symbol;
  uint8 public decimals;

  event Transfer(address indexed from, address indexed to, uint256 value);

  
  mapping (address => uint256) public balanceOf;

  function MyToken(uint256 initialSupply, string tokenName, string tokenSymbol, uint8 decimalUnits) public {
    balanceOf[msg.sender] = initialSupply;
    name = tokenName;
    symbol = tokenSymbol;
    decimals = decimalUnits;
  }

  
  function transfer(address _to, uint256 _value) public {
    
    require(balanceOf[msg.sender] >= _value && balanceOf[_to] + _value >= balanceOf[_to]);

    
    balanceOf[msg.sender] -= _value;
    balanceOf[_to] += _value;

    
    Transfer(msg.sender, _to, _value);
  }
}"
53160-1.sol,question,"contract SimplifiedMainContract {

    using Lib for Lib.Store;
    Lib.Store private store;

    function deposit() public payable {
        store.deposit();
    }

    function withdraw() public {
        store.withdraw();
    }

}"
25786-2.sol,question,"contract MetaCoin {
   mapping (address => uint) balances;
   uint testArraySum;

   event Transfer(address indexed _from, address indexed _to, uint256 _value);

   function MetaCoin() {
       balances[tx.origin] = 10000;

   }

   function initialize(uint[] _test_array) returns(bool){
      for(uint i = 0; i < _test_array.length; i++) {
         testArraySum += _test_array[i];
      }
      return true;
   }

   function sendCoin(address receiver, uint amount) returns(bool sufficient) {
       if (balances[msg.sender] < amount) return false;
       balances[msg.sender] -= amount;
       balances[receiver] += amount;
       Transfer(msg.sender, receiver, amount);
       return true;
   }
   function getBalance(address addr) returns(uint) {
       return balances[addr];
   }
}"
84646-0.sol,question,"contract Birthday {
    function celeb() public {
        emit Party.Pinata(222);
    }
}"
9427-2.sol,question,"contract Link {
  using LinkedList for LinkedList.data;
  LinkedList.data public list;
  function Test() {
    list.append(""abc"",""111"");
    list.append(""def"", ""222"");
    list.append(""ghf"", ""333"");
  }

  function get() returns (bytes32, bytes32) {
    return (list.get_head_data());
  }
}"
67624-0.sol,question,"contract Vuln {
    mapping(address => uint256) public balances;

    function deposit() public payable {
        
        balances[msg.sender] += msg.value;
    }

    function withdraw() public {
        
        msg.sender.call.value(balances[msg.sender])("""");

        
        balances[msg.sender] = 0;
    }
}"
10830-0.sol,question,"contract User { 
          string public userName;

          function User(string _name) {
                 userName=_name;
          }

   }"
12346-2.sol,question,"contract strtest { bool ib_equal; function test(string p1,string p2) returns(bool) { return true;  }}"
80729-0.sol,question,"contract SafeMath {
  function safeMul(uint256 a, uint256 b) internal returns (uint256) {
    uint256 c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint256 a, uint256 b) internal returns (uint256) {
    assert(b > 0);
    uint256 c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

  function safeSub(uint256 a, uint256 b) internal returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {
    uint256 c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function assert(bool assertion) internal {
    if (!assertion) {
      throw;
    }
  }
}"
80729-0.sol,question,"contract ERC20 is SafeMath{           
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    address public owner;

    mapping (address => uint256) public balanceOf;
    mapping (address => uint256) public freezeOf;
    mapping (address => mapping (address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);

    event Burn(address indexed from, uint256 value);

    event Freeze(address indexed from, uint256 value);

    event Unfreeze(address indexed from, uint256 value);

    function ERC20(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              
        totalSupply = initialSupply;                        
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = decimalUnits;                            
        owner = msg.sender;
    }

    
    function transfer(address _to, uint256 _value) {
        if (_to == 0x0) throw;                               
        if (_value <= 0) throw; 
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                     
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                            
        Transfer(msg.sender, _to, _value);                   
    }

    
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        if (_value <= 0) throw; 
        allowance[msg.sender][_spender] = _value;
        return true;
    }


    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (_to == 0x0) throw;                                
        if (_value <= 0) throw; 
        if (balanceOf[_from] < _value) throw;                 
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  
        if (_value > allowance[_from][msg.sender]) throw;     
        balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                           
        balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             
        allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value);
        Transfer(_from, _to, _value);
        return true;
    }

    function burn(uint256 _value) returns (bool success) {
        if (balanceOf[msg.sender] < _value) throw;            
        if (_value <= 0) throw; 
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      
        totalSupply = SafeMath.safeSub(totalSupply,_value);                                
        Burn(msg.sender, _value);
        return true;
    }

    function freeze(uint256 _value) returns (bool success) {
        if (balanceOf[msg.sender] < _value) throw;            
        if (_value <= 0) throw; 
        balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      
        freezeOf[msg.sender] = SafeMath.safeAdd(freezeOf[msg.sender], _value);                                
        Freeze(msg.sender, _value);
        return true;
    }

    function unfreeze(uint256 _value) returns (bool success) {
        if (freezeOf[msg.sender] < _value) throw;            
        if (_value <= 0) throw; 
        freezeOf[msg.sender] = SafeMath.safeSub(freezeOf[msg.sender], _value);                      
        balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value);
        Unfreeze(msg.sender, _value);
        return true;
    }

    
    function withdrawEther(uint256 amount) {
        if(msg.sender != owner)throw;
        owner.transfer(amount);
    }

    
    function() payable {
    }
}"
80775-0.sol,question,"contract forwardCryptoUnlockedReward {

 address kovanDAOaddress = 0x765Eb7A0cB7Ecb9cc555e8ad77D13396D1052c3C;
 address payable kovanWETHaddress  = 0xd0A1E359811322d97991E03f863a0C30C2cF029C;

 function() payable external { 

 }

 function forward() public {
     uint balanceToSend =  address(this).balance;
     kovanWETHaddress.transfer( address(this).balance );
     IERC20(kovanWETHaddress).transfer(kovanDAOaddress, balanceToSend);
 }

}"
44805-0.sol,question,"contract Factory is Ownable {

    mapping(string => address) services;

    event DidExecuteService(address contractAddress);

    modifier ValidateString(string str) {
        require(bytes(str).length > 0);
        _;
    }

    function Factory() public {}

    function createService(string name) public onlyOwner ValidateString(name) {
        address assetAddress = new Game();
        services[name] = assetAddress;
    }

    function executeService(string name) public onlyOwner {
        address contractAddress = services[name];
        Service(contractAddress).execute();
        emit DidExecuteService(contractAddress);
    }

    function getContract(string name) public view returns (address) { return services[name]; }

    function countContracts() public view returns (uint) { return 0; }

    function getBalance() public view returns (uint) { return address(this).balance; }
}"
43339-0.sol,question,"contract qualification {

address owner;


function qualification() { owner = msg.sender; }


function kill() { if (msg.sender == owner) selfdestruct(owner); }

}"
43339-0.sol,question,"contract credentials is qualification {

    string studentName;
    string studentEmail;
    string studentUniversity;
    string studentCourse;
    string studentStart;
    string studentEnd;
    string studentClassification;



function credentials(string _name, string _email, string _university, string _course, string _start, string _end, string _classification) public {
    studentName = _name;
    studentEmail = _email;
    studentUniversity = _university;
    studentCourse = _course;
    studentStart = _start;
    studentEnd = _end;
    studentClassification = _classification;
}


function returnQualification() constant returns (string, string, string, string, string, string, string) {
    return (studentName, studentEmail, studentUniversity, studentCourse, studentStart, studentEnd, studentClassification);
}
}"
40194-0.sol,question,"contract Casino is usingOraclize {
   address owner;
   uint public betAmount = 30 finney; 
   uint public totalBet; 
   uint public numberOfBets; 
   
   uint public limitAmountOfBets = 3; 
   uint public numberWinner; 
   address[] public players; 
   mapping(uint => address[]) numberBetPlayers; 
   mapping(address => uint) playerBetsNumber; 

   modifier onEndGame() {
       if(numberOfBets >= limitAmountOfBets) _;
   }

   
   function Casino(uint _betAmount, uint _limitAmountOfBets) {
       owner = msg.sender; 

       if(_betAmount > 0) betAmount = _betAmount;
       if(_limitAmountOfBets > 0) limitAmountOfBets = _limitAmountOfBets;

       oraclize_setProof(proofType_Ledger); 
   }

   
   function checkPlayerExists(address player) public returns(bool) {
       if(playerBetsNumber[player] > 0) return true;
       else return false;
   }

   
   function bet(uint numberToBet) payable {
       require(numberOfBets <= limitAmountOfBets); 
       require(!checkPlayerExists(msg.sender)); 
       require(numberToBet >=1 && numberToBet <= 10); 
       require(msg.value == betAmount); 

       playerBetsNumber[msg.sender] = numberToBet;
       numberBetPlayers[numberToBet].push(msg.sender);

       numberOfBets += 1;
       totalBet += msg.value;

       if(numberOfBets >= limitAmountOfBets) generateNumberWinner();
   }

   
   function generateNumberWinner() payable onEndGame {
       uint numberRandomBytes = 4;
       uint delay = 0;
       uint callbackGas = 200000;

       bytes32 queryId = oraclize_newRandomDSQuery(delay, numberRandomBytes, callbackGas);
   }

   function __calback(bytes32 _queryId, string _result, bytes _proof) oraclize_randomDS_proofVerify(_queryId, _result, _proof) onEndGame {
       assert(msg.sender == oraclize_cbAddress());

       numberWinner = (uint(sha3(_result))%10+1);
       distributePrizes();
   }

   function distributePrizes() onEndGame {
       uint winnerEtherAmount = totalBet / numberBetPlayers[numberWinner].length; 

       for(uint i = 0; i < numberBetPlayers[numberWinner].length; i++) { 
           numberBetPlayers[numberWinner][i].transfer(winnerEtherAmount);
       }

       for(uint j = 1; j <= 10; j++) {
           numberBetPlayers[j].length = 0;
       }

       totalBet = 0;
       numberOfBets = 0;
   }
}"
70386-0.sol,question,"contract hier {

     uint i;
    uint ur=0;
    bytes15[2][20] public UserRole;

    function user_role_assignment(bytes15[] memory a) public
    {
        for(i=0;i<10;i++)    
        {
            if(i%2==0)
            UserRole[ur][0]=a[i];
            else{
            UserRole[ur][1]=a[i];

            ur=ur+1;
            }
        }  
    }

bytes15 public result;

function checkAccess( bytes15 username ) public {

    for(i=0;i<10;i++)    
        { 
            if(UserRole[i][0]==username)
               result = UserRole[i][1];
       }
}

function RESULT() public view  returns(bytes15)
 {

    return result;

}

}"
13023-0.sol,question,"contract Trading {

    address receivingAccount;
    uint deadline;

    struct Asset {
        string name;
        uint price;
        uint barcode;
    }

    struct Stock {
        Asset asset;
        uint count;
    }

    struct Vendor {
        string name;
        address account;
        Stock[] stocks;
    }

    Asset[] assets;
    Vendor[] vendors;

    
    function Trading(address _vendor0, address _vendor1) {
        
        assets.push(Asset(""Asset0"", 12, 1234));
        Asset memory asset1 = Asset(""Asset1"", 34, 5678);
        assets.push(asset1);

        
        Vendor memory vendor0 = Vendor(""Vendor0"", _vendor0, new Stock[](5));
        Vendor memory vendor1 = Vendor(""Vendor1"", _vendor1, new Stock[](5));

        
        vendor0.stocks[0] = Stock(assets[0], 2);
        vendor0.stocks[1] = Stock(assets[1], 2);
        vendors.push(vendor0);

        
        vendor1.stocks[0] = Stock(assets[0], 1);
        vendor1.stocks[1] = Stock(assets[1], 1);

        
        deadline = now + 10 * 1 minutes;
    }  

    function listAssetBarcodes() constant returns (uint[]) {
        uint[] memory barcodes = new uint[](assets.length);
        for (uint i=0; i<assets.length; i++) {
            barcodes[i] = assets[i].barcode;
        }
        return barcodes;
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function dispose() afterDeadline {
        suicide(receivingAccount);
    }
}"
67925-0.sol,question,"contract OriginalContract {
    function originalFunction() external returns (bool) {
        return true;
    }
}"
6200-1.sol,question,"contract token { 
  mapping (uint => mapping (address => uint)) coinBalanceOf;
  event CoinTransfer(uint coinType, address sender, address receiver, uint amount);

  
  function token(uint numCoinTypes, uint supply) {
    for (uint k=0; k<numCoinTypes; ++k) {
    coinBalanceOf[k][msg.sender] = supply;
  }
}


function sendCoin(uint coinType, address receiver, uint amount) returns(bool sufficient) {
  if (coinBalanceOf[coinType][msg.sender] < amount) return false;

  coinBalanceOf[coinType][msg.sender] -= amount;
  coinBalanceOf[coinType][receiver] += amount;

  CoinTransfer(coinType, msg.sender, receiver, amount);

  return true;"
57438-0.sol,question,"contract GroceryFactory is Ownable {
    using SafeMath for uint256;

    address[] public m_arGroceries;
    address public m_aMaintenanceAddress;
    address public m_aFeesAddress;
    uint256 public m_uPrice;

    constructor(address maintenanceAddress, address feesAddress, uint256 price) public payable{
        m_aMaintenanceAddress = maintenanceAddress;
        m_aFeesAddress = feesAddress;
        m_uPrice = price;
    }

    function getMaintenanceAddress() public onlyOwner view returns(address){
        return m_aMaintenanceAddress;
    }

    function setMaintenanceAddress(address maintenanceAddress)public onlyOwner {
        m_aMaintenanceAddress = maintenanceAddress;
    }

    function getFeesAddress() public onlyOwner view returns(address){
        return m_aFeesAddress;
    }

    function setFeesAddress(address feesAddress)public onlyOwner {
        m_aFeesAddress = feesAddress;
    }

    function setPrice(uint256 price) public onlyOwner {
        m_uPrice = price;
    }

    function getPrice() public view returns(uint256){
        return m_uPrice;
    }

    function getGroceriesCount() public onlyOwner view returns(uint){
        return m_arGroceries.length;
    }

    function getPools() public onlyOwner view returns(address[]){
        return m_arGroceries;
    }

    function () external payable {
        createGrocery();
    }

    function createGrocery() public payable returns(address){
        require(msg.sender != address(0), ""Owner is null"");
        require(msg.value == getPrice(), ""Please send the deployment price"");
        require(m_aMaintenanceAddress != address(0), ""Maintenance address is null"");
        require(m_aFeesAddress != address(0), ""Fees address is null"");

        address owner = msg.sender;

        Grocery groc = new Grocery(owner, m_aMaintenanceAddress);
        m_arGroceries.push(groc);

        transferFees();

        return pool;
    }

    function transferFees() private{
        uint256 balance = address(this).balance;

        if(balance > 0){
            m_aFeesAddress.transfer(balance);
        }
    }
}"
51889-0.sol,question,"contract FirstContract {

  bool public isTrue = true;

  function sayHello() public pure returns(bool) {
      return true;
  }

}"
51889-0.sol,question,"contract ServiceContract {

  FirstContract firstContract;

  function ServiceContract (address _firstContract) public {
    firstContract = FirstContract(_firstContract);
  }

  function confirmFirstContract() public view returns(bool) {
      bool x = firstContract.isTrue();
      return x;
  }

  function sayHi() public view returns(bool) {
      bool y = firstContract.sayHello();
      return y;
  }

}"
24488-0.sol,question,"contract HelpLogs {

  event LogFirstHalf(bytes _data);
  event LogSecondHalf(bytes _data);

  function logit(bytes data) external {
    
    
    LogFirstHalf(data);
  }
}"
61484-0.sol,question,"contract Test {

    event Event(address);
    event TestEvent(uint256);
    event Data(bytes);
    event Data1(bytes);
    function show() public returns(uint256){
        emit Event(msg.sender);
        return 100;
    }

    function test(uint256 a)external returns(bytes){

        emit Data(msg.data);
        emit TestEvent(a);
        return msg.data;

    }
    function caller1(address _addr) {
        emit Data1(abi.encodeWithSelector(bytes4(keccak256(""test(uint256)"")),100));
        _addr.call(abi.encodeWithSelector(bytes4(keccak256(""test(uint256)"")),100));
    }
}"
61484-0.sol,question,"contract Call {

    function caller1(address _addr) {
        _addr.call(abi.encodeWithSelector(bytes4(keccak256(""test(uint256)"")),100));
    }
}"
52777-0.sol,question,"contract Courses is Owned {

    struct Instructor {
        uint age;
        string fName;
        string sName;
    }

    mapping (address => Instructor) instructors;
    address[] public instructorAccts;

    function setInstructor(address _address, uint _age, string _fName, string _sName) onlyOwner public {

        var instructor = instructors[_address];

        instructor.age = _age;
        instructor.fName = _fName;
        instructor.sName = _sName;

        instructorAccts.push(_address) -1;
    }
}"
62031-0.sol,question,"contract Child {
   string public a;
   constructor (string arg) public payable { 
       a = arg;
   }
}"
62031-0.sol,question,"contract Factory {
    constructor () public {}
    function createChild(string arg) public payable {
        address issueContract = (new Child).value(msg.value)(arg);
    }
}"
15712-1.sol,question,"contract Zipfs {

IpfsData[] public ipfsrecs;

struct IpfsData {
    bytes32 reviewData;
}

function addIpfs (bytes32 _reviewData) payable returns (bool success) {
    IpfsData memory newIpfsData;
    newIpfsData.reviewData = _reviewData;

    ipfsrecs.push(newIpfsData);
    return true;
}

function getIpfsData() constant returns (bytes32[]) {

    uint length = ipfsrecs.length;
    bytes32[] memory reviews = new bytes32[](length);

    for (uint i=0; i<ipfsrecs.length; i++) {
        IpfsData memory currentIpfsRec;
        currentIpfsRec = ipfsrecs[i];

        reviews[i]=currentIpfsRec.reviewData;


    }
    return (reviews);
}


}"
73986-1.sol,question,"contract SafeMath {
  function safeMul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeSub(uint a, uint b) internal returns (uint) {
    assert(b <= a);
    return a - b;
  }

  function safeAdd(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c>=a && c>=b);
    return c;
  }

  function assert(bool assertion) internal {
    if (!assertion) throw;
  }
}"
73986-1.sol,question,"contract Token {
  
  function totalSupply() constant returns (uint256 supply) {}

  
  
  function balanceOf(address _owner) constant returns (uint256 balance) {}

  
  
  
  
  function transfer(address _to, uint256 _value) returns (bool success) {}

  
  
  
  
  
  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}

  
  
  
  
  function approve(address _spender, uint256 _value) returns (bool success) {}

  
  
  
  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}

  event Transfer(address indexed _from, address indexed _to, uint256 _value);
  event Approval(address indexed _owner, address indexed _spender, uint256 _value);

  uint public decimals;
  string public name;
}"
73986-1.sol,question,"contract StandardToken is Token {

  function transfer(address _to, uint256 _value) returns (bool success) {
    
    
    
    if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
    
      balances[msg.sender] -= _value;
      balances[_to] += _value;
      Transfer(msg.sender, _to, _value);
      return true;
    } else { return false; }
  }

  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
    
    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
    
      balances[_to] += _value;
      balances[_from] -= _value;
      allowed[_from][msg.sender] -= _value;
      Transfer(_from, _to, _value);
      return true;
    } else { return false; }
  }

  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }

  function approve(address _spender, uint256 _value) returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }

  mapping(address => uint256) balances;

  mapping (address => mapping (address => uint256)) allowed;

  uint256 public totalSupply;
}"
73986-1.sol,question,"contract AccountLevels {
  
  
  
  
  function accountLevel(address user) constant returns(uint) {}
}"
73986-1.sol,question,"contract AccountLevelsTest is AccountLevels {
  mapping (address => uint) public accountLevels;

  function setAccountLevel(address user, uint level) {
    accountLevels[user] = level;
  }

  function accountLevel(address user) constant returns(uint) {
    return accountLevels[user];
  }
}"
73986-1.sol,question,"contract EtherDelta is SafeMath {
  address public admin; 
  address public feeAccount; 
  address public accountLevelsAddr; 
  uint public feeMake; 
  uint public feeTake; 
  uint public feeRebate; 
  mapping (address => mapping (address => uint)) public tokens; 
  mapping (address => mapping (bytes32 => bool)) public orders; 
  mapping (address => mapping (bytes32 => uint)) public orderFills; 

  event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user);
  event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);
  event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);
  event Deposit(address token, address user, uint amount, uint balance);
  event Withdraw(address token, address user, uint amount, uint balance);

  function EtherDelta(address admin_, address feeAccount_, address accountLevelsAddr_, uint feeMake_, uint feeTake_, uint feeRebate_) {
    admin = admin_;
    feeAccount = feeAccount_;
    accountLevelsAddr = accountLevelsAddr_;
    feeMake = feeMake_;
    feeTake = feeTake_;
    feeRebate = feeRebate_;
  }

  function() {
    throw;
  }

  function changeAdmin(address admin_) {
    if (msg.sender != admin) throw;
    admin = admin_;
  }

  function changeAccountLevelsAddr(address accountLevelsAddr_) {
    if (msg.sender != admin) throw;
    accountLevelsAddr = accountLevelsAddr_;
  }

  function changeFeeAccount(address feeAccount_) {
    if (msg.sender != admin) throw;
    feeAccount = feeAccount_;
  }

  function changeFeeMake(uint feeMake_) {
    if (msg.sender != admin) throw;
    if (feeMake_ > feeMake) throw;
    feeMake = feeMake_;
  }

  function changeFeeTake(uint feeTake_) {
    if (msg.sender != admin) throw;
    if (feeTake_ > feeTake || feeTake_ < feeRebate) throw;
    feeTake = feeTake_;
  }

  function changeFeeRebate(uint feeRebate_) {
    if (msg.sender != admin) throw;
    if (feeRebate_ < feeRebate || feeRebate_ > feeTake) throw;
    feeRebate = feeRebate_;
  }

  function deposit() payable {
    tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], msg.value);
    Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);
  }

  function withdraw(uint amount) {
    if (tokens[0][msg.sender] < amount) throw;
    tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);
    if (!msg.sender.call.value(amount)()) throw;
    Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);
  }

  function depositToken(address token, uint amount) {
    
    if (token==0) throw;
    if (!Token(token).transferFrom(msg.sender, this, amount)) throw;
    tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);
    Deposit(token, msg.sender, amount, tokens[token][msg.sender]);
  }

  function withdrawToken(address token, uint amount) {
    if (token==0) throw;
    if (tokens[token][msg.sender] < amount) throw;
    tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);
    if (!Token(token).transfer(msg.sender, amount)) throw;
    Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);
  }

  function balanceOf(address token, address user) constant returns (uint) {
    return tokens[token][user];
  }

  function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce) {
    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);
    orders[msg.sender][hash] = true;
    Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender);
  }

  function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) {
    
    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);
    if (!(
      (orders[user][hash] || ecrecover(sha3(""\x19Ethereum Signed Message:\n32"", hash),v,r,s) == user) &&
      block.number <= expires &&
      safeAdd(orderFills[user][hash], amount) <= amountGet
    )) throw;
    tradeBalances(tokenGet, amountGet, tokenGive, amountGive, user, amount);
    orderFills[user][hash] = safeAdd(orderFills[user][hash], amount);
    Trade(tokenGet, amount, tokenGive, amountGive * amount / amountGet, user, msg.sender);
  }

  function tradeBalances(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address user, uint amount) private {
    uint feeMakeXfer = safeMul(amount, feeMake) / (1 ether);
    uint feeTakeXfer = safeMul(amount, feeTake) / (1 ether);
    uint feeRebateXfer = 0;
    if (accountLevelsAddr != 0x0) {
      uint accountLevel = AccountLevels(accountLevelsAddr).accountLevel(user);
      if (accountLevel==1) feeRebateXfer = safeMul(amount, feeRebate) / (1 ether);
      if (accountLevel==2) feeRebateXfer = feeTakeXfer;
    }
    tokens[tokenGet][msg.sender] = safeSub(tokens[tokenGet][msg.sender], safeAdd(amount, feeTakeXfer));
    tokens[tokenGet][user] = safeAdd(tokens[tokenGet][user], safeSub(safeAdd(amount, feeRebateXfer), feeMakeXfer));
    tokens[tokenGet][feeAccount] = safeAdd(tokens[tokenGet][feeAccount], safeSub(safeAdd(feeMakeXfer, feeTakeXfer), feeRebateXfer));
    tokens[tokenGive][user] = safeSub(tokens[tokenGive][user], safeMul(amountGive, amount) / amountGet);
    tokens[tokenGive][msg.sender] = safeAdd(tokens[tokenGive][msg.sender], safeMul(amountGive, amount) / amountGet);
  }

  function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) constant returns(bool) {
    if (!(
      tokens[tokenGet][sender] >= amount &&
      availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount
    )) return false;
    return true;
  }

  function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {
    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);
    if (!(
      (orders[user][hash] || ecrecover(sha3(""\x19Ethereum Signed Message:\n32"", hash),v,r,s) == user) &&
      block.number <= expires
    )) return 0;
    uint available1 = safeSub(amountGet, orderFills[user][hash]);
    uint available2 = safeMul(tokens[tokenGive][user], amountGet) / amountGive;
    if (available1<available2) return available1;
    return available2;
  }

  function amountFilled(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {
    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);
    return orderFills[user][hash];
  }

  function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) {
    bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce);
    if (!(orders[msg.sender][hash] || ecrecover(sha3(""\x19Ethereum Signed Message:\n32"", hash),v,r,s) == msg.sender)) throw;
    orderFills[msg.sender][hash] = amountGet;
    Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);
  }
}"
25069-1.sol,question,"contract Ownable {
  address public owner;

  
  function Ownable() {
    owner = msg.sender;
  }

  
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  
  function transferOwnership(address newOwner) onlyOwner {
    require(newOwner != address(0));
    owner = newOwner;
  }
}"
25069-1.sol,question,"contract Authorizable {

  address[] authorizers;
  mapping(address => uint256) authorizerIndex;

  
  modifier onlyAuthorized {
    require(isAuthorized(msg.sender));
    _;
  }

  
  function Authorizable() {
    authorizers.length = 2;
    authorizers[1] = msg.sender;
    authorizerIndex[msg.sender] = 1;
  }

  
  function getAuthorizer(uint256 authIndex) external constant returns(address) {
    return address(authorizers[authIndex + 1]);
  }

  
  function isAuthorized(address _addr) constant returns(bool) {
    return authorizerIndex[_addr] > 0;
  }

  
  function addAuthorized(address _addr) external onlyAuthorized {
    authorizerIndex[_addr] = authorizers.length;
    authorizers.length++;
    authorizers[authorizers.length - 1] = _addr;
  }
}"
25069-1.sol,question,"contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) constant returns (uint256);
  function transfer(address to, uint256 value) returns (bool);
  
  event Transfer(address from, address to, uint256 value);
}"
25069-1.sol,question,"contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) constant returns (uint256);
  function transferFrom(address from, address to, uint256 value) returns (bool);
  function approve(address spender, uint256 value) returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}"
25069-1.sol,question,"contract BasicToken is ERC20Basic {
  using SafeMath for uint;

  mapping(address => uint256) balances;

  
  modifier onlyPayloadSize(uint256 size) {
     require(msg.data.length >= size + 4);
     _;
  }

  
  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns (bool) {
    
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  
  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }
}"
25069-1.sol,question,"contract TestToken is MintableToken {

  string public name = ""Test Token"";
  
  string public symbol = ""TEST"";
  uint public decimals = 18;

  bool public tradingStarted = false;

  
  modifier hasStartedTrading() {
    require(tradingStarted);
    _;
  }

  
  function startTrading(bool _startStop) onlyOwner {
    
    tradingStarted = _startStop;
  }

  
  function transfer(address _to, uint256 _value) hasStartedTrading returns (bool) {
    super.transfer(_to, _value);
    return true;
  }

   
  function transferFrom(address _from, address _to, uint256 _value) hasStartedTrading returns (bool) {
    super.transferFrom(_from, _to, _value);
    return true;
  }
}"
4387-0.sol,question,"contract NameRegistry {

  function NameRegistry() {
    
  }

  function register(address record, string namespace, string name) returns (bool success) {
    if (names[namespace][name] > 0) {
      return false;
    }

    names[namespace][name] = record;
    return true;
  }

  function lookup(string namespace, string name) returns (address record) {
    return names[namespace][name];
  }

  
  mapping(string => mapping(string => address)) names;
}"
61684-0.sol,question,"contract Helloworld {
    uint private simpleInt;

    function getValue() public view returns (uint) {
        return simpleInt;
    }
}"
11979-0.sol,question,"contract WeatherApiCall is usingOraclize {

   string public weathercondition;
   function WeatherApiCall() {

           OAR = OraclizeAddrResolverI(0x3df0db5bda9d685e41cb4a8834c44f8028957417);
   }

   function __callback(bytes32 myid, string result) {
           if (msg.sender != oraclize_cbAddress()) throw;
           weathercondition=result;
   }
   function update(string to,string datetime) payable returns(bool sufficient) {
          oraclize_query(""URL"", strConcat(""json(http:
          return true;
   } 
}"
56500-0.sol,question,"contract TokenERC20 {

string public name;
string public symbol;
uint8 public decimals = 18;

uint256 public totalSupply;


mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;


event Transfer(address indexed from, address indexed to, uint256 value);


event Approval(address indexed _owner, address indexed _spender, uint256 _value);


event Burn(address indexed from, uint256 value);


function TokenERC20(
    uint256 initialSupply,
    string tokenName,
    string tokenSymbol
) public {
    totalSupply = initialSupply * 10 ** uint256(decimals);  
    balanceOf[msg.sender] = totalSupply;                
    name = tokenName;                                   
    symbol = tokenSymbol;                               
}


function _transfer(address _from, address _to, uint _value) internal {
    
    require(_to != 0x0);
    
    require(balanceOf[_from] >= _value);
    
    require(balanceOf[_to] + _value > balanceOf[_to]);
    
    uint previousBalances = balanceOf[_from] + balanceOf[_to];
    
    balanceOf[_from] -= _value;
    
    balanceOf[_to] += _value;
    emit Transfer(_from, _to, _value);
    
    assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}


function transfer(address _to, uint256 _value) public returns (bool success) {
    _transfer(msg.sender, _to, _value);
    return true;
}


function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    require(_value <= allowance[_from][msg.sender]);     
    allowance[_from][msg.sender] -= _value;
    _transfer(_from, _to, _value);
    return true;
}


function approve(address _spender, uint256 _value) public
    returns (bool success) {
    allowance[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
}


function approveAndCall(address _spender, uint256 _value, bytes _extraData)
    public
    returns (bool success) {
    tokenRecipient spender = tokenRecipient(_spender);
    if (approve(_spender, _value)) {
        spender.receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    }
}


function burn(uint256 _value) public returns (bool success) {
    require(balanceOf[msg.sender] >= _value);   
    balanceOf[msg.sender] -= _value;            
    totalSupply -= _value;                      
    emit Burn(msg.sender, _value);
    return true;
}


function burnFrom(address _from, uint256 _value) public returns (bool success) {
    require(balanceOf[_from] >= _value);                
    require(_value <= allowance[_from][msg.sender]);    
    balanceOf[_from] -= _value;                         
    allowance[_from][msg.sender] -= _value;             
    totalSupply -= _value;                              
    emit Burn(_from, _value);
    return true;
}
}"
83112-1.sol,question,"contract KJToken {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    
    mapping(address => uint256) balances;
    address devAddress;

    
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    event Transfer(address indexed from, address indexed, uint256 value);

    
    mapping(address => mapping (address => uint256)) allowed;
    
    constructor() public {
        name = ""KJtoken"";
        symbol = ""KJ"";
        decimals = 18;
        devAddress = 0x22391dc3a3cD8e9774F426e5405C3440559D0a1e;
        uint initialBalance = 1000000000000000000*1000000; 
        balances[devAddress] = initialBalance;
        totalSupply += initialBalance; 
 
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    
    function transfer(address _to, uint256 _amount) public returns (bool success) {
        if (balances[msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[msg.sender] = _amount;
            balances[_to] += _amount;
            emit Transfer(msg.sender, _to, _amount);
            return true;
        } else {
            return false;
        }
    }
    
    function transferFrom(
    address _from,
    address _to,
    uint256 _amount
) public returns (bool success) {
    if (balances[_from] >= _amount
        && allowed[_from][msg.sender] >= _amount
        && _amount > 0
        && balances[_to] + _amount > balances[_to]) {
        balances[_from] -= _amount;
        allowed[_from][msg.sender] -= _amount;
        balances[_to] += _amount;
        return true;
    } else {
        return false;
    }
}



function approve(address _spender, uint256 _amount) public returns (bool success) {
    allowed[msg.sender][_spender] = _amount;
    emit Approval(msg.sender, _spender, _amount);
    return true;
}

}"
76434-1.sol,question,"contract MaintainableUpgradeabilityProxy is UpgradeabilityProxy {

  
  event ServiceRegistryChanged(address previousRegistry, address newRegistry);

  
  bytes32 private constant ADMIN_SLOT = 0x10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b;

  
  modifier ifMaintainer() {
    if (IServiceRegistry(_serviceRegistry()).getMaintainerRegistryV1().isMaintainer(msg.sender)) {
      _;
    } else {
      _fallback();
    }
  }

  
  constructor(address _implementation, address _serviceReg) UpgradeabilityProxy(_implementation) public {
    assert(ADMIN_SLOT == keccak256(""org.zeppelinos.proxy.admin""));
    _setServiceRegistry(_serviceReg);
  }

  
  function implementation() external view ifMaintainer returns (address) {
    return _implementation();
  }

  
  function changeServiceRegistry(address _newRegistry) external ifMaintainer {
    require(_newRegistry != address(0), ""New registry cannot be address(0)"");
    emit ServiceRegistryChanged(_serviceRegistry(), _newRegistry);
    _setServiceRegistry(_newRegistry);
  }

  
  function upgradeTo(address newImplementation) external ifMaintainer {
    _upgradeTo(newImplementation);
  }

  
  function upgradeToAndCall(address _implementation, bytes data) external payable ifMaintainer {
    _upgradeTo(_implementation);
    
    require(address(this).call.value(msg.value)(data), ""Call failed"");
  }

  
  function _serviceRegistry() internal view returns (address _serviceReg) {
    bytes32 slot = ADMIN_SLOT;
    
    assembly {
      _serviceReg := sload(slot)
    }
  }

  
  function _setServiceRegistry(address _serviceReg) internal {
    bytes32 slot = ADMIN_SLOT;

    
    assembly {
      sstore(slot, _serviceReg)
    }
  }

  
  function _willFallback() internal {
    require(
      !IServiceRegistry(_serviceRegistry()).getMaintainerRegistryV1().isMaintainer(msg.sender),
      ""Maintainer cannot call fallback functions"");
    super._willFallback();
  }
}"
6742-0.sol,question,"contract VendingMachine {

event Unlocked(address machineID, address unlocker);
event MachinePayed(address machineID, uint amount);
event CustomerPayed(address customer, uint amount);

address admin;

struct Machine {
    bool exists;
    bool isFunded;
    address owner;
    address currentBuyer;
    uint minFunding;
    uint escrowBalance;
}

mapping(address => Machine) public machines;

modifier onlyMachines() {
    if (machines[msg.sender].exists)
    _
}

modifier onlyAdmin() {
    if (msg.sender==admin)
    _
}

function () { throw; }

function VendingMachine() {

    admin=msg.sender;
}

function fundMachine(address _machineID) {
    if (msg.value < machines[_machineID].minFunding)
    throw;
    machines[_machineID].currentBuyer=msg.sender;
    machines[_machineID].isFunded = true;
    machines[_machineID].escrowBalance = msg.value;
    Unlocked(_machineID, msg.sender);
}

function executePayment(uint _price) onlyMachines {
    machines[msg.sender].escrowBalance -= _price;
    machines[msg.sender].currentBuyer.call.value(machines[msg.sender].escrowBalance)();
    CustomerPayed(machines[msg.sender].currentBuyer, machines[msg.sender].escrowBalance);
    msg.sender.call.value(_price)();
    MachinePayed(msg.sender, _price);

    
    machines[msg.sender].escrowBalance = 0;
    machines[msg.sender].isFunded = false;

}

function registerMachine(address _machineID, address _owner, uint _minFunding) onlyAdmin {
    machines[_machineID].exists = true;
    machines[_machineID].owner = _owner;
    machines[_machineID].minFunding = _minFunding;
}

function checkAdmin() returns (address){
return admin;
}
}"
25294-0.sol,question,"contract Factory {

    bytes32[] Names;
    address[] newContracts;
    uint public count=0;

    function createContract (bytes32 name) {
        address newContract = new Contract(name);
        count=count+1;
        newContracts.push(newContract);
    } 

    function getName  (uint i) constant returns (address sblcAddress){
        Contract con = Contract(newContracts[i]);
      sblcAddress= address(con);
       return sblcAddress;
    }
}"
25294-0.sol,question,"contract Contract {

    bytes32 public Name;

    function Contract (bytes32 name) {
        Name = name;
    }
}"
83386-0.sol,question,contract Token is ERC20 {}
83386-0.sol,question,"contract Depository {
    function transferFrom(uint amount) external {
        Token token = Token(0xFab46E002BbF0b4509813474841E0716E6730136);
        token.transferFrom(msg.sender, address(this), amount);
    }
}"
83386-0.sol,question,"contract Owner {
    function transfer(uint amount) external {
        Token token = Token(0xFab46E002BbF0b4509813474841E0716E6730136);
        
        token.approve(0xF5c7313cB994A0F8cEee341dC61C15753F775Fcf, amount);

        
        Depository depository = Depository(0xF5c7313cB994A0F8cEee341dC61C15753F775Fcf);
        depository.transferFrom(amount);

    }
}"
70536-0.sol,question,"contract ExchangeContract {
  enum CurrencyType { USD, TWOKEY, BTC, ETH, DAI, USDT, TUSD, EUR, JPY, GBP}

  mapping(uint256 => CurrencyPrice) public priceByCurrencyType;

  struct Price{
    uint price;
    uint decimals;
  }

  struct CurrencyPrice{
    uint currencyInt;
    Price price;
  }

  function updatePrices(CurrencyPrice[] memory _array) public {
    for(uint i=0; i<_array.length; i++){
      priceByCurrencyType[_array[0].currencyInt].price=_array[i].price;
    }
  }
}"
66875-0.sol,question,"contract Adoption {
  address[16] public adopters;
  
  function adopt(uint petId) public returns (uint) {
    
    require(petId >= 0 && petId <= 15);
    
    adopters[petId] = msg.sender;
    
    return petId;
  }
  
  function getAdopters() public view returns (address[16] memory) {
    return adopters;
  }
}"
42762-0.sol,question,"contract Mutex {
 bool locked;


modifier noReentrancy() {
require(!locked);
locked = true;
_;
locked = false;
}

 function Mutex() public payable {
   locked=false;
}

function canBeAttacked() public  returns (uint) {
require(msg.sender.call.value(1 ether)());
return 7;
 }


  function f() public noReentrancy returns (uint) {
require(msg.sender.call());
  return 7;
  }
 }"
42762-0.sol,question,"contract attacker{
      bool again=false;
function attacker() public  {

   }   
      function() public  payable{
             if(!again){
              again=true;
            Mutex(msg.sender).canBeAttacked();
         }
     }
   function payment(Mutex mutex) public {
        mutex.canBeAttacked();
    }
 }"
68159-0.sol,question,"contract Token {
   using SafeMath for uint;
   uint _totalSupply;
   address owner;
   mapping(address => uint) balances;

   event Transfer(address indexed from, address indexed to, uint tokens);

   constructor() public {
       _totalSupply = 1000000 * 10**uint(18);
       owner = msg.sender;
       balances[owner] = _totalSupply;
       emit Transfer(address(0), owner, _totalSupply);
   }

   function totalSupply() public view returns (uint) {
       return _totalSupply.sub(balances[address(0)]);
   }
}"
68159-0.sol,question,"contract Marketplace {

   Token public cashToken;

   constructor(address cashTokenAddress) public {
       cashToken = Token(cashTokenAddress);
   }

   function getTotalSupply() public view returns (uint) {
       return cashToken.totalSupply();
   }
}"
55020-0.sol,question,"contract TestIntToString {
  function getSha256(string str) external pure returns (bytes32) {
    bytes32 hash = sha256(abi.encodePacked(str));

    return hash;
    
    }
}"
7277-0.sol,question,"contract C {
    address[] addrList;

    function addAddr(address addr) {
        addrList.push(addr);
    }

    function deleteAddr(address addr) {

        for(uint256 i = 0; i < addrList.length; i++) {
             if(addr == addrList[i]) {
                 for(uint256 j = i; j < addrList.length; j++) {
                     addrList[j] = addrList[j + 1];
                 }
                 delete addrList[addrList.length - 1];
                 addrList.length--; 
             }
        }
    }
}"
42616-1.sol,question,"contract d8 {
    function myBalance() public  returns (uint myNumber);

}"
42616-1.sol,question,"contract d15 is d8  {
    function getBalance(address addr)  public returns (uint myNumber) {
    return d8(addr).myBalance();
    }
}"
29752-1.sol,question,"contract PastryChef {
    using StringUtils for StringUtils;

    string name;

    function PastryChef(string _name) public {
        require(!StringUtils.isEmptyString(_name)); 
        name = _name;
    }

}"
77160-0.sol,question,"contract Zedd is ERC20 {

    using SafeMath for uint256;
    address owner = msg.sender;

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    mapping (address => bool) public Claimed; 

    string public constant name = ""Zedd"";
    string public constant symbol = ""ZedM"";
    uint public constant decimals = 12;
    uint public deadline = now + 37 * 1 days;
    uint public round2 = now + 32 * 1 days;
    uint public round1 = now + 22 * 1 days;

    uint256 public totalSupply = 300000000e12;
    uint256 public totalDistributed;
    uint256 public constant requestMinimum = 1 ether / 200; 
    uint256 public tokensPerEth = 50000e12;


    
    address multisig = 0x478E1dD0fb8aE01bE6F23a052CCAdd3037FF0c9F
    ;


    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    event Distr(address indexed to, uint256 amount);
    event DistrFinished();

    event Airdrop(address indexed _owner, uint _amount, uint _balance);

    event TokensPerEthUpdated(uint _tokensPerEth);

    event Burn(address indexed burner, uint256 value);

    event Add(uint256 value);

    bool public distributionFinished = false;

    modifier canDistr() {
        require(!distributionFinished);
        _;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    constructor() public {
        uint256 teamFund = 100000000e12;
        owner = msg.sender;
        distr(owner, teamFund);
    }

    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }

    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }

    function Distribute(address _participant, uint _amount) onlyOwner internal {

        require( _amount > 0 );      
        require( totalDistributed < totalSupply );
        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }

    function DistributeAirdrop(address _participant, uint _amount) onlyOwner external {        
        Distribute(_participant, _amount);
    }

    function DistributeAirdropMultiple(address[] _addresses, uint _amount) onlyOwner external {        
        for (uint i = 0; i < _addresses.length; i++) Distribute(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }

    function () external payable {
        getTokens();
     }

    function getTokens() payable canDistr  public {
        uint256 tokens = 0;
        uint256 bonus = 0;
        uint256 countbonus = 0;
        uint256 bonusCond1 = 1 ether / 10;
        uint256 bonusCond2 = 1 ether;
        uint256 bonusCond3 = 5 ether;

        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;

        if (msg.value >= requestMinimum && now < deadline && now < round1 && now < round2) {
            if(msg.value >= bonusCond1 && msg.value < bonusCond2){
                countbonus = tokens * 10 / 100;
            }else if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 15 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 20 / 100;
            }
        }else if(msg.value >= requestMinimum && now < deadline && now > round1 && now < round2){
            if(msg.value >= bonusCond2 && msg.value < bonusCond3){
                countbonus = tokens * 20 / 100;
            }else if(msg.value >= bonusCond3){
                countbonus = tokens * 20 / 100;
            }
        }else{
            countbonus = 0;
        }

        bonus = tokens + countbonus;

         if(tokens > 0 && msg.value >= requestMinimum){
            if( now >= deadline && now >= round1 && now < round2){
                distr(investor, tokens);
            }else{
                if(msg.value >= bonusCond1){
                    distr(investor, bonus);
                }else{
                    distr(investor, tokens);
                }   
            }
        }else{
            require( msg.value >= requestMinimum );
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        
        multisig.transfer(msg.value);
    }

    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    modifier onlyPayloadSize(uint size) {
        assert(msg.data.length >= size + 4);
        _;
    }

    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }

    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }

    function withdrawAll() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }

    function withdraw(uint256 _wdamount) onlyOwner public {
        uint256 wantAmount = _wdamount;
        owner.transfer(wantAmount);
    }

    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }

    function add(uint256 _value) onlyOwner public {
        uint256 counter = totalSupply.add(_value);
        totalSupply = counter; 
        emit Add(_value);
    }


    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}"
15663-0.sol,question,"contract Test {
  uint public myVal;

  function callIt() {
      this.call.gas(50000)(bytes4(sha3(""setMyVal(uint256)"")), 123);
  }

  function setMyVal(uint _newVal) internal {
      myVal = _newVal;
  }
}"
66674-0.sol,question,"contract Name {
    mapping(address=>string) public text;
    string public test;

    function register(string _text) {
        text[msg.sender] = _text;
    }
}"
66674-0.sol,question,"contract Proxy {
    address watch_addr = 0xEB1e2c19bd833b7f33F9bd0325B74802DF187935;
    address user_addr = msg.sender;

    function register(string _text) {
        Name name = Name(watch_addr);
        name.register(_text);
    }
}"
29234-0.sol,question,"contract WithdrawalContract {

    address public richest;
    address public owner;
    uint public mostSent;

    modifier onlyOwner() {
        require (msg.sender != owner);
        _;

    }

    mapping (address => uint) pendingWithdraws;

    function WithdrawalContract () payable {
        richest = msg.sender;
        mostSent = msg.value;
        owner = msg.sender;
    }

    function becomeRichest() payable returns (bool){
        require(msg.value > mostSent);
        pendingWithdraws[richest] += msg.value;
        richest = msg.sender;
        mostSent = msg.value;
        return true;
    }

    function withdraw(uint amount) onlyOwner returns(bool) {
        
        
        
        require(amount < this.balance);
        owner.transfer(amount);
        return true;

    }

    function getBalanceContract() constant returns(uint){
        return this.balance;
    }

}"
71352-3.sol,question,"contract StandardToken is Token {
    function transfer(address _to, uint256 _value) public returns (bool success) {
        
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            emit Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            emit Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }
    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }
    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    uint256 totalTokenSupply;
}"
60920-0.sol,question,"contract Funding {
    function sum(uint input1, uint input2) public returns (uint) {
        return input1 + input2;
    }

    struct patient{
        uint id;
        string fullName;
        mapping(uint => string[]) DoctorAccess;        
    }

    function getPatient(uint patientId, uint doctorId) public returns (string[]) {
        patient p;
        p.id = 1;
        p.fullName=""Saran"";
        p.DoctorAccess[doctorId].push(""Doctor1Key"");
        return p.DoctorAccess[doctorId];
    }
}"
29832-0.sol,question,"contract TokenHappyBirthday
 

{
    
    string public name = ""HappyBirthdayToken"";
    string public symbol = ""HBT"";
    uint8 public decimals = 4;
    
    
    uint256 public totalSupply = 10**8;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function TokenHappyBirthday(
        
    ) public {
        
        
        balanceOf[msg.sender] = totalSupply;                
        
        
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
}"
29832-0.sol,question,"contract HBTCrowdsale {

        
    address public beneficiary; 
    uint256 public minAmount = 1 ether; 
    uint256 public maxAmount = 500000 ether; 
    uint256 public maxSupply = 10**8; 
    uint256 public minAcceptedAmount = 10**15 wei; 

    
    uint256 public rateFirstWeek = 125;
    uint256 public rateSecondWeek = 115;
    uint256 public rateThirdWeek = 105;
    uint256 public rateLastWeek = 100;

    uint256 public rateFirstWeekEnd = 5 minutes; 
    uint256 public rateSecondWeekEnd = 10 minutes;
    uint256 public rateThirdWeekEnd = 15 minutes;
    uint256 public rateLastWeekEnd = 20 minutes;

    enum Stages {
        InProgress,
        Ended,
        Withdrawn
    }

    Stages public stage = Stages.InProgress;

    
    uint256 public start;
    uint256 public end;
    uint256 public raised;

    
    TokenHappyBirthday public hbtToken;

    
    mapping (address => uint256) balances;


    
    modifier atStage(Stages _stage) {
        if (stage != _stage) {
            revert();
        }
        _;
    }


    
    modifier onlyBeneficiary() {
        if (beneficiary != msg.sender) {
            revert();
        }
        _;
    }


    
    function balanceOf(address _investor) constant returns (uint256 balance) {
        return balances[_investor];
    }


    
    function HBTCrowdsale( address _tokenAddress, address _beneficiary , uint256 _start ) {

        
        hbtToken = TokenHappyBirthday(0x14723a09acff6d2a60dcdf7aa4aff308fddc160c);
        beneficiary =  _beneficiary; 0xca35b7d915458ef540ade6068dfe2f44e8fa733c; 
        start = 0; 
        end = start + rateLastWeekEnd;
    }

    
    function toHBT(uint256 _wei) returns (uint256 amount) {
        uint256 rate = 0;
        if (stage != Stages.Ended && now >= start && now <= end) {


            
            if (now <= start + rateFirstWeekEnd) {
                rate = rateFirstWeek;
            }

            
            else if (now <= start + rateSecondWeekEnd) {
                rate = rateSecondWeek;
            }

            
            else if (now <= start + rateThirdWeekEnd) {
                rate = rateThirdWeek;
            }

            
            else if (now <= start + rateLastWeekEnd) {
                rate = rateLastWeek;
            }
        }

        return _wei * rate * 10**4 / 1 ether; 
    }


    
    function endCrowdsale() atStage(Stages.InProgress) {

        
        if (now < end) {
            revert();
        }

        stage = Stages.Ended;
    }


    
    function withdraw() onlyBeneficiary atStage(Stages.Ended) {

        
        if (raised < minAmount) {
            revert();
        }


        
        uint256 ethBalance = this.balance;
        if (!beneficiary.send(ethBalance)) {
            revert();
        }

        stage = Stages.Withdrawn;
    }


    
    function refund() atStage(Stages.Ended) {

        
        if (raised >= minAmount) {
            revert();
        }

        uint256 receivedAmount = balances[msg.sender];
        balances[msg.sender] = 0;

        if (receivedAmount > 0 && !msg.sender.send(receivedAmount)) {
            balances[msg.sender] = receivedAmount;
        }
    }


    
    function () payable atStage(Stages.InProgress) {

        
        if (now < start) {
            revert();
        }

        
        if (now > end) {
            revert();
        }

        
        if (msg.value < minAcceptedAmount) {
            revert();
        }

        uint256 received = msg.value;
        uint256 valueInHBT = toHBT(msg.value);



        
        hbtToken.transfer(msg.sender, valueInHBT);

        if (now <= start + rateFirstWeek) {

        } else {

            
        balances[msg.sender] += received; 
        }

        raised += received;

        
        if (raised >= maxAmount || hbtToken.totalSupply() >= maxSupply) {
            stage = Stages.Ended;
        }
    }
}"
11931-0.sol,question,"contract WeatherApiCall is usingOraclize {

           function WeatherApiCall() {
              OAR = OraclizeAddrResolverI(0x5049063e4a7704ac155e4f1f42a4954bbef5bbde);
           }

           function __callback(bytes32 myid, string result) {
                if (msg.sender != oraclize_cbAddress()) throw;

                }

           function update() payable  {
                  oraclize_query(""URL"", ""json(http:
           }
 }"
25309-0.sol,question,"contract HoneyPot {
  mapping (address => uint) public balances;
  function HoneyPot() payable {
    put();
  }
  function put() payable {
    balances[msg.sender] = msg.value;
  }
  function get() {
    if (!msg.sender.call.value(balances[msg.sender])()) {
      revert();
    }
      balances[msg.sender] = 0;
  }
  function() {
    revert();
  }
}"
21524-2.sol,question,"contract tokenRecipient { function receiveApproval(address _from,    uint256 _value, address _token, bytes _extraData); }"
21524-2.sol,question,"contract RUBY { 
 string public standard = 'RUBY 1.0'; 
 string public name; 
 string public symbol; 
 uint8 public decimals; 
 uint256 public totalSupply; 
 uint256 public balance; 
 address public owner; 
 mapping (address => uint256) public balanceOf; 
 mapping (address => mapping (address => uint256)) public allowance; 
 event Transfer(address indexed from, address indexed to, uint256 value); 
 function RUBY() { 
     balanceOf[msg.sender] = 10000; 
     totalSupply = 10000; 
     name = 'RUBY'; 
     symbol = 'RUBY'; 
     decimals = 8; 
     owner=msg.sender; 
 } 
 modifier onlyOwner { 
     if (msg.sender != owner) throw; 
     _; 
 } 
function getBalance(address _addr) constant returns(uint) {
   return _addr.balance;
}

 function transfer(address _to, uint256 _value) { 
     if (_to == 0x0) throw; 
     if (balanceOf[msg.sender] < _value) throw; 
     if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
     balanceOf[msg.sender] -= _value; 
     balanceOf[_to] += _value; 
     Transfer(msg.sender, _to, _value); 
 } 
 function approve(address _spender, uint256 _value) 
 returns (bool success) { 
     allowance[msg.sender][_spender] = _value; 
     return true; 
 } 
 function approveAndCall(address _spender, uint256 _value, bytes _extraData) 
     returns (bool success) { 
         tokenRecipient spender = tokenRecipient(_spender); 
         if (approve(_spender, _value)) { 
         spender.receiveApproval(msg.sender, _value, this, _extraData); 
         return true; 
     } 
 }
 function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { 
     if (_to == 0x0) throw; 
     if (balanceOf[_from] < _value) throw; 
     if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
     if (_value > allowance[_from][msg.sender]) throw; 
     balanceOf[_from] -= _value; 
     balanceOf[_to] += _value; 
     allowance[_from][msg.sender] -= _value; 
    Transfer(_from, _to, _value); 
     return true; 
 } 
}"
38424-0.sol,question,"contract EthBooking {
    function addBooking(uint listingId) public payable returns(uint bookingId) {
    bookingId =  BookingLibrary.book(ethDB, listingId, msg.sender, msg.value);

    
    return bookingId;
}
}"
60869-0.sol,question,"contract First {
    Second private _oSecond;
    int32 public _nRes1;

    constructor(address oSecond) public payable {
        _oSecond = Second(oSecond);
        _nRes1 = 3;
    }
    function TestError() public {
        _oSecond.State();
        
        _nRes1 = 5;
    }
}"
41651-0.sol,question,"contract Test {

    uint[4] public arr; 
    event TestLog(string logmessage);

    function Test() public {
        arr[0] = 1; 
    }

    function checkArray() public {
        if(arr[0] == 1) { 
            arr[1] = 1;
            arr[0] = 0; 
        }
        TestLog(""some log"");
    }

}"
78973-0.sol,question,"contract Counter {
    uint public _counter = 0;

    function GenNextID() public returns (uint) {
        return _counter++;
    }
}"
40045-0.sol,question,"contract StructArrayInitWrong {
  struct Room {
    address[] players;       
  }  
  Room[] rooms;

  function createRoom() public {
    address[] adr;
    adr.push(msg.sender);
    Room memory room = Room(adr);   
    rooms.push(room);
  }

  function getRoomsLength() view returns (uint) {
    return rooms.length;
  }
}"
59116-0.sol,question,"contract Augur {
     function createYesNoMarket(uint256 _endTime, uint256 _feePerEthInWei, ICash _denominationToken, address _designatedReporterAddress, bytes32 _topic, string _description, string _extraInfo) public afterInitialized payable returns (IMarket _newMarket);
}"
59116-0.sol,question,"contract AugurWrapper {
    Augur universe;
    constructor(address _address) public {
        universe = Augur(_address);
    }
    function myCreateMarket(uint256 _endTime, uint256 _feePerEthInWei, ICash _denominationToken, address _designatedReporterAddress, bytes32 _topic, string _description, string _extraInfo) public {
        return universe.createYesNoMarket(_endTime,_feePerEthInWei,_denominationToken,_designatedReporterAddress, _topic, _description, _extraInfo);
    }
}"
66276-4.sol,question,"contract myContract {
   event Debug(bytes data);
   function myDynamicFunction(uint[2][] myArray) public returns (bytes) {       
       address(this).delegatecall(bytes4(sha3(""myDynamicFunction(uint[2][])"")), myArray);
       return msg.data;
   }
   function () {
       emit Debug(msg.data); 
   }
}"
67868-1.sol,question,"contract BaseToken {

string public name;
string public symbol;
uint8 public decimals = 18;

uint256 public totalSupply;


mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;


clients
event Transfer(address indexed from, address indexed to, uint256 
 value);


 clients
event Approval(address indexed _owner, address indexed _spender, 
uint256 _value);


event Burn(address indexed from, uint256 value);


constructor() public {
    totalSupply = 10000 * 10 ** uint256(decimals);  
    supply with the decimal amount
    balanceOf[msg.sender] = totalSupply;                
    creator all initial tokens
    name = ""BaseToken"";                                   
   name for display purposes
    symbol = ""BASETOKEN"";                               
 symbol for display purposes
}

function getBalance() public pure returns (string memory){
   return  ""some string"";
}


function _transfer(address _from, address _to, uint _value) internal {
    
    require(_to != address(0x0));
    
    require(balanceOf[_from] >= _value);
    
    require(balanceOf[_to] + _value >= balanceOf[_to]);
    
    uint previousBalances = balanceOf[_from] + balanceOf[_to];
    
    balanceOf[_from] -= _value;
    
    balanceOf[_to] += _value;
    emit Transfer(_from, _to, _value);
    
    code. They should never fail
    assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}


function transfer(address _to, uint256 _value) public returns (bool 
 success) {
    _transfer(msg.sender, _to, _value);
    return true;
}


function transferFrom(address _from, address _to, uint256 _value) 
 public returns (bool success) {
    require(_value <= allowance[_from][msg.sender]);     
   allowance
    allowance[_from][msg.sender] -= _value;
    _transfer(_from, _to, _value);
    return true;
}


function approve(address _spender, uint256 _value) public
    returns (bool success) {
    allowance[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
}


function approveAndCall(address _spender, uint256 _value, bytes memory 
 _extraData)
    public
    returns (bool success) {
    tokenRecipient spender = tokenRecipient(_spender);
    if (approve(_spender, _value)) {
        spender.receiveApproval(msg.sender, _value, address(this), 
   _extraData);
        return true;
    }
}


function burn(uint256 _value) public returns (bool success) {
    require(balanceOf[msg.sender] >= _value);   
 has enough
    balanceOf[msg.sender] -= _value;            
 sender
    totalSupply -= _value;                      
    emit Burn(msg.sender, _value);
    return true;
}


function burnFrom(address _from, uint256 _value) public returns (bool 
 success) {
    require(balanceOf[_from] >= _value);                
 targeted balance is enough
    require(_value <= allowance[_from][msg.sender]);    
    allowance
    balanceOf[_from] -= _value;                         
     from the targeted balance
    allowance[_from][msg.sender] -= _value;             
    from the sender's allowance
    totalSupply -= _value;                              
    totalSupply
    emit Burn(_from, _value);
    return true;
}"
42191-0.sol,question,"contract SimpleMultiSig {

  uint public nonce;                
  uint public threshold;            
  mapping (address => bool) isOwner; 
  address[] public ownersArr;        

  function SimpleMultiSig(uint threshold_, address[] owners_) {
    require(owners_.length <= 10 && threshold_ <= owners_.length && threshold_ != 0);

    address lastAdd = address(0); 
    for (uint i=0; i<owners_.length; i++) {
      require(owners_[i] > lastAdd);
      isOwner[owners_[i]] = true;
      lastAdd = owners_[i];
    }
    ownersArr = owners_;
    threshold = threshold_;
  }

  
  function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) {
    require(sigR.length == threshold);
    require(sigR.length == sigS.length && sigR.length == sigV.length);

    
    bytes32 txHash = keccak256(byte(0x19), byte(0), this, destination, value, data, nonce);

    address lastAdd = address(0); 
    for (uint i = 0; i < threshold; i++) {
        address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]);
        require(recovered > lastAdd && isOwner[recovered]);
        lastAdd = recovered;
    }

    
    nonce = nonce + 1;
    require(destination.call.value(value)(data));
  }

  function () payable {}
}"
74046-0.sol,question,"contract ChampTokenSale {
    address admin;
    string public tokenContract;
    uint256 public tokenPrice;
    uint256 public tokensSold;

    event Sell(address _buyer, uint256 _amount);

    constructor (ChampTokenSale _tokenContract, uint256 _tokenPrice) public {
      admin = msg.sender;
      address expected = address(this);
      tokenPrice = _tokenPrice;
    }

    function multiply(uint x, uint y) internal pure returns (uint z) {
      require(y == 0 || (z = x * y) / y == x);
    }

    function buyTokens(uint256 _numberOfTokens) public payable {
      require(msg.value == multiply(_numberOfTokens, tokenPrice));
      require(tokenContract.balanceOf(this)>= _numberOfTokens);
      require(tokenContract.transfer(msg.sender, _numberOfTokens));

      tokensSold += _numberOfTokens;

      emit Sell(msg.sender, _numberOfTokens);
    }

    function endSale() public {
     require(msg.sender == admin);
     require(tokenContract.transfer(admin,  tokenContract.balanceOf(address(this))));


     admin.transfer(address(this).balance);
   }
}"
55935-0.sol,question,"contract SafeMath {
    function safeAdd(uint a, uint b) internal pure returns (uint c) {
        c = a + b;
        require(c >= a);
    }
    function safeSub(uint a, uint b) internal pure returns (uint c) {
        require(b <= a);
        c = a - b;
    }
    function safeMul(uint a, uint b) internal pure returns (uint c) {
        c = a * b;
        require(a == 0 || c / a == b);
    }
    function safeDiv(uint a, uint b) internal pure returns (uint c) {
        require(b > 0);
        c = a / b;
    }
}"
60773-0.sol,question,"contract owned {
    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}"
60773-0.sol,question,"contract TokenERC20 {
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    
    event Burn(address indexed from, uint256 value);

    
    constructor(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        emit Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        emit Burn(_from, _value);
        return true;
    }
}"
31073-0.sol,question,"contract Eternal {

    string engravedText;

    function Eternal(string eT) payable {
        engravedText = eT;
    }

    function getEngravedText() constant returns (string) {
        return engravedText;
    }

}"
48874-0.sol,question,"contract Ownable {
  address public owner;
event OwnershipRenounced(address indexed previousOwner);
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  function Ownable() public {
    owner = msg.sender;
  }

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }
}"
48874-0.sol,question,"contract TestCrowdsale is Ownable {
  using SafeMath for uint256;

mapping(address => bool) public whitelist;


ERC20 public token;


address public wallet = 0x770a682364cbed4374d1eF1fA343AB08561aF376;


uint256 public rate = 10000;


uint256 public weiRaised = 0;


uint256 public openingTime = now;


uint256 public closingTime = now + 60 minutes;


address public tokenWallet = 0xf926F01559E5fF8c1b63BfD6E944c8E93Cb20009;


uint256 public cap = 1 * 10 ** 18;


event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);

function TestCrowdsale (
    uint256 _rate,
    address _wallet,
    ERC20 _token,
    uint256 _openingTime,
    uint256 _closingTime,
    address _tokenWallet,
    uint256 _cap
  )
    public
  {
    require(_rate > 0);
    require(_wallet != address(0));
    require(_token != address(0));
    require(_openingTime >= block.timestamp);
    require(_closingTime >= _openingTime);
    require(_tokenWallet != address(0));
    require(_cap > 0);
    rate = _rate;
    wallet = _wallet;
    token = _token;
    openingTime = _openingTime;
    closingTime = _closingTime;
    tokenWallet = _tokenWallet;
    cap = _cap;
  }


  
  

  function () external payable {
    buyTokens(msg.sender);
  }


  function addToWhitelist(address _beneficiary) external onlyOwner {
    whitelist[_beneficiary] = true;
  }


  function addManyToWhitelist(address[] _beneficiaries) external onlyOwner {
    for (uint256 i = 0; i < _beneficiaries.length; i++) {
      whitelist[_beneficiaries[i]] = true;
    }
  }


  function removeFromWhitelist(address _beneficiary) external onlyOwner {
    whitelist[_beneficiary] = false;
  }

  
  
  
  
  function buyTokens(address _beneficiary) public payable {
uint256 weiAmount = msg.value;
    _preValidatePurchase(_beneficiary, weiAmount);

    uint256 tokens = _getTokenAmount(weiAmount);

    weiRaised = weiRaised.add(weiAmount);
_processPurchase(_beneficiary, tokens);
    emit TokenPurchase(
      msg.sender,
      _beneficiary,
      weiAmount,
      tokens
    );
_forwardFunds();
  }

  
  function remainingTokens() public view returns (uint256) {
    return token.allowance(tokenWallet, this);
  }

  
  function hasClosed() public view returns (bool) {
    
    return block.timestamp > closingTime;
  }

  
  function capReached() public view returns (bool) {
    return weiRaised >= cap;
  }

  
  function transferAnyERC20Token(address tokenAddress, uint256 _value) public onlyOwner returns (bool success) {
        return ERC20(tokenAddress).transfer(owner, _value);
    }


  
  

  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal view {
    require(whitelist[_beneficiary]);
    require(block.timestamp >= openingTime && block.timestamp <= closingTime);
    require(_beneficiary != address(0));
    require(_weiAmount != 0);
    require(weiRaised.add(_weiAmount) <= cap);
  }


 function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
    token.transferFrom(tokenWallet, _beneficiary, _tokenAmount);
  }


  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {
    _deliverTokens(_beneficiary, _tokenAmount);
  }


  function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {
    return _weiAmount.mul(rate);
  }


  function _forwardFunds() internal {
    wallet.transfer(msg.value);
  }
}"
43740-0.sol,question,"contract MyContract is usingOraclize {

    uint public tmp = 0;
    function callThisToStart() {
        oraclize_query(60, ""URL"", """");
    }

    function __callback(bytes32 myid, string result) {
        if (msg.sender != oraclize_cbAddress()) throw;
        doSomething();
        callThisToStart();
    }

    function doSomething() {
        tmp++;
    }

}"
6975-1.sol,question,"contract A {
  A other;
  function Get() constant returns(bytes8[]) {
    bytes8[] stuff;
    return stuff;
  }
  function Copy() {
    bytes8[] stuff = other.Get();
  }
}"
22806-2.sol,question,"contract SimpleSmartAsset is Mortal {

  uint usagePrice;
  Beneficiary[] beneficiaries;
  uint totalWeight; 

  event AssetCreated(uint _usagePrice,
                     address[] addresses,
                     uint[] weights);

  function SimpleSmartAsset(uint _usagePrice,
                            address[] addresses,
                            uint[] weights) {
    owner = msg.sender;
    usagePrice = _usagePrice;

    uint beneficiaryCount = addresses.length;
    for (uint i = 0; i < beneficiaryCount; i++) {

      uint weight = weights[i];

      addBeneficiary(addresses[i], weight);
      totalWeight += weight;
    }

    AssetCreated(_usagePrice, addresses, weights);
  }

  function getUsagePrice() constant returns (uint) {
    return usagePrice;
  }

  event BeneficiaryPaid(address addr, uint amount);

  function pay() payable onlyOwner {
    require(msg.value >= usagePrice);

    uint beneficiaryCount = beneficiaries.length;
    for (uint i = 0; i < beneficiaryCount; i++) {

      Beneficiary memory beneficiary = beneficiaries[i];

      uint weight = beneficiary.weight;
      address addr = beneficiary.addr;

      uint amount = (weight * usagePrice) / totalWeight;

      uint GAS_LIMIT = 4000000;
      addr.transfer.gas(GAS_LIMIT)(amount);
      BeneficiaryPaid(addr, amount);
    }
  }

  struct Beneficiary {
    address addr;
    uint weight;
  }

  function addBeneficiary(address addr, uint weight) onlyOwner {
    beneficiaries.push(Beneficiary({
        addr: addr,
        weight: weight
    }));
  }

}"
41702-0.sol,question,"contract DBKeys {

    struct keyStruct {
        bool keyStatus; 
    }
    mapping(bytes32=>keyStruct) public zkeys;
    function addZkey( bytes32 newkey) public returns (bool) {
    if (zkeys[newkey].keyStatus) {
        return false; 
        }
        zkeys[newkey].keyStatus=true;
        return true;    
    }
    function delZkey(bytes32 newkey) public returns (bool) {
        if (zkeys[newkey].keyStatus) {
            delete zkeys[newkey];
            return true;
        }
        return false;
    }
}"
34654-0.sol,question,"contract TestContact {
    struct Object {
        uint id;
        uint price;
    }

    mapping (uint => Object) private objects; 
    mapping (uint => address) private mapObjectToOwners; 

    function getPrice(uint id) public view returns(uint price) {
        Object storage object = objects[id];
        return object.price;
    }
}"
46494-0.sol,question,"contract Escrow {
  address public owner;
  uint public fee;

  
  mapping (address =>  mapping (address => uint)) public balances;

  function Escrow() public {
    owner = msg.sender;
  }

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  
  function setFee(uint price) onlyOwner external {
    fee = price;
  }

  function start(address payee) payable external {
    balances[msg.sender][payee] = balances[msg.sender][payee] + msg.value;
  }

  function end(address payer, address payee) onlyOwner external {
    uint value = balances[payer][payee];
    
    
    
    
    
    payee.transfer(value)
  }
}"
3511-0.sol,question,"contract one {
    struct A {
        address[] count;
    }
    struct B {
        uint8[] count;
    }

    mapping (address => A) a;
    mapping (address => B) b;

    function add(address c, uint8 g) {
        a[msg.sender].count.push(c);
        b[msg.sender].count.push(g);
    }
}"
52248-0.sol,question,"contract owned {
    address public owner;
    event OwnershipTransferred(address indexed previousOwner, address 
    indexed newOwner);
    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        require(newOwner != address(0));
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}"
52248-0.sol,question,"contract TokenERC20 {
    function totalSupply () public constant returns (uint256 totalSuppy);
    function balanceOf(address _owner) public constant returns (uint256 
    balance);
    function transfer(address _to, uint256 _value) public returns (bool 
    success);
    function transferFrom(address _from, address _to, uint256 _value) 
    public 
    returns (bool success);
    function approve(address _spender, uint256 _value) public returns 
    (bool success);
    function allowance(address _owner, address _spender) public constant 
    returns (uint256 remaining);
    event Transfer(address indexed _from, address indexed _to, uint256 
    _value);
    event Approval(address indexed _owner, address indexed _spender, 
    uint256 _value);
    event FrozenFunds(address target, bool frozen);
    event Burn(address indexed from, uint256 value);
}"
9545-0.sol,question,"contract Forwarder  {
  
  address public destinationAddress;

  
  function Forwarder() {
    destinationAddress = msg.sender;
  }

  
  function() {
    if (!destinationAddress.send(this.balance))
            throw;
    }
}"
59542-0.sol,question,"contract getSchwifty {
  string internal constant seeWhatYouGot = ""I want to see what you got!"";
  string internal contestResult;

  
  function getSchwifty(string _contestResult) public {
    contestResult = _contestResult;
  }

  function showMeWhatYouGot() external pure returns (string) {
    return seeWhatYouGot;  
  }

  function enterContest(string _contestEntry) external view returns (string) {
    
    return contestResult;
  }
}"
84467-1.sol,question,"contract King {
    
    address payable public owner;
    uint public _price;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    constructor () payable public {
        owner = msg.sender;
        _price = msg.value;
    }
    
    function triggerAddress(address payable _addr, uint256 valueInWei) public payable {
    _addr.transfer(valueInWei);  
   }
    
    receive() external payable {
        require(msg.sender == owner, ""Sorry I cannot receive money"");
    }
}"
78462-0.sol,question,"contract Dest {
  function foo(string memory name, string memory symbol, uint256 decimals, uint256 totalSupply, address sender, uint256 value) public {
    
    }

  function bar(address a, address b, address c, address d, uint256 e, address f, address sender, uint256 value) public {
    
  }
}"
78462-0.sol,question,"contract Proxy {
  address private _owner;
  address private _dest;

  constructor(address dest) public {
    _owner = msg.sender;
    _dest = dest;
  }

  function getDest() public view returns(address) {
    return _dest;
  }

  function setDest(address dest) public {
    require(msg.sender == _owner);
    _dest = dest;
  }

  
  function invoke(string memory method, bytes memory data) public payable {
    bytes memory payload = abi.encodePacked(bytes4(keccak256(bytes(method)))), data, abi.encode(msg.sender), abi.encode(msg.value));
    (bool ok, bytes memory response) = _dest.call(payload);
  }
}"
74363-0.sol,question,"contract SimpleStorage {
    uint storeddata;
    function set(uint x) public {
        storeddata = x;
    }
    function get() public view returns(uint) {
        return storeddata;
    }
}"
15228-3.sol,question,"contract Relay {
address public owner;

  function Relay() {
    owner = msg.sender;
  }

  function fundRelay() payable returns (bool) {

  }

  function releaseFunds () {

  }
}"
45981-0.sol,question,"contract ETHTEST2 {
    mapping(address => uint256) public deposits; 

    uint256 public z;
    uint256 public t;

    function sendETHtoContract(uint256 j) public payable {  

        if (j == 1){

            z = j;
            msg.value == t;
            t = 24000000000000000000 wei;
            address(this).transfer(msg.value);
            return;
        }

        if (j == 2){

            z = j;
            t = 12000000000000000000 wei;
            address(this).transfer(msg.value);
            return;
        }

        if (j == 3){

            z = j;
            t = 6000000000000000000 wei;
            address(this).transfer(msg.value);
            return;
        }

        if (j >=4 || j < 0){  
            revert();
            return;
        }

    }

    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }

    function() public payable {
    
    }

}"
61273-0.sol,question,"contract TestSalaries {

    function testEmployeeInsertion() public {
        Salaries salaries = Salaries(DeployedAddresses.Salaries());
        address addr = address(0);
        salaries.addEmployee(address(0), ""Alicia Drake"", ""Lead Engineer"");
        Assert.equal(salaries.employees(addr).name, ""Alicia Drake"");
    }
}"
73801-0.sol,question,"contract Test is ERC721Full {   
   

  function createToken(...) public {
    _mint(msg.sender, id);
  }
}"
13552-0.sol,question,"contract SimpleStorage {

  uint public storedData;
  string public name = ""ahmed"";
  event Print(uint);

  function SimpleStorage(uint initialValue) {
    storedData = initialValue;
  }

  function set(uint x) returns (uint){
    storedData = x;
    Print(storedData);
    return storedData;
  }

  function get() constant returns (uint retVal) {
    return storedData;
  }
}"
72358-0.sol,question,"contract Creation {

    int basiclife = 50;

    struct hero {
        string name;
        int life;
        int lvl;
        int xp;
        int attack;
        int winCount;
        int trophies;
        int lossCount;
    }

    hero[] public heroes; 

    struct enemy {  
        string name;
        int life;
        int lvl;
        int xp;
        int attack;
    }

    enemy[] public enemies;
    mapping (uint => address) public herotoowner;
    mapping (address => uint) public heroCount;
    mapping (uint => address) public monstertoowner;
    uint public monsterCount; 

    function createhero (string memory _name) public {
        require(heroCount[msg.sender] == 0);
        uint id= heroes.push(hero(_name, basiclife, 1, 0, 20, 0, 0, 0))-1;
        herotoowner[id] = msg.sender;
        heroCount[msg.sender]++;
    }

    function enemyRage (int _herolvl) public {
        uint id = enemies.push(enemy(""Rage"", 20*_herolvl, _herolvl, 7*_herolvl, 5*_herolvl)) - 1;
        monstertoowner[id] = msg.sender;
        monsterCount++;
    }

    function enemyDerpina (int _herolvl) public {
        uint id = enemies.push(enemy(""Derpina"", 40*_herolvl, _herolvl, 14*_herolvl, 10*_herolvl)) - 1; 
        monstertoowner[id] = msg.sender;
        monsterCount++;
    }

    function getHerosByOwner (address owner) external view returns (uint) {
        uint result = 999999;
        for (uint i = 0; i < heroes.length; i++) {
            if (herotoowner[i] == owner) {
                result = i;
                break;
            }
        }
        return result;
    }

    function getmonstersByOwner (address owner) external view returns (uint) {
        uint result = 0;
        for (uint i = enemies.length; i > 0; i--) {
            if (monstertoowner[i] == owner) {
                result = i;
                break;
            }
        }
        return result;
    }

    uint nonce=0;

    function randNum (int _num) private returns (int) {  
        int randomnumber = int(keccak256(abi.encodePacked(now, msg.sender, nonce))) % _num;
        if (randomnumber <= 0) {
            randomnumber = (-1)*randomnumber;
        }
        nonce++;
        return randomnumber;
    }

    function attack_hero (uint _heroid, uint _monsterid, int _num) external returns (string memory, int, int, int, int ) {
        hero storage myhero = heroes[_heroid];
        enemy storage monster = enemies[_monsterid];
        int attackofhero = 0;
        if(_num == 0) { 
            attackofhero = randNum(myhero.attack);
        }

        monster.life = monster.life - attackofhero;
        int attackofmonster = randNum(monster.attack);
        myhero.life = myhero.life - attackofmonster;

        if (monster.life <= 0 && myhero.life > 0) {
            myhero.winCount++;
            myhero.xp += monster.xp;
            if (randNum(100) > 50 ){ 
                myhero.trophies++;
            }
            return(""win"", myhero.lvl, myhero.xp, myhero.life, myhero.trophies);
        }

        if (myhero.xp >= 10+2*myhero.lvl){ 
            myhero.lvl++;
            myhero.xp = 0; 
            myhero.life = basiclife*myhero.lvl;  
            myhero.attack = myhero.attack*myhero.lvl;
        }

        if (myhero.life <= 0 ) { 
            myhero.lossCount++; 
            return(""dead"", myhero.lossCount, myhero.life, myhero.lvl, myhero.trophies);
        }
        return(""attack"", myhero.life, attackofhero, monster.life, attackofmonster);
    }

    function resurrection (uint _heroid) public { 
        hero storage myhero = heroes[_heroid];
        myhero.life = basiclife*myhero.lvl;
    }
}"
42104-0.sol,question,"contract CA3 {

    struct  Student {
        uint16  age;
        uint16  income;
        uint16  score;
        uint16  attendance;
        uint128  studentTranscript;
        bytes32  studentAccount;
    }

    struct ShortStudent {
        uint16 age; 
        uint16 income; 
        uint16 score; 
        uint16 attendance; 
        uint128 studentTranscript;
    }

    struct Employee {
        uint16 age;
        uint16 income;
        uint16 timeWorked;
    }
    Student[] public students;
    Employee[] public employees;
    ShortStudent[] public sstudents;
    function setStudent (uint16 _age, uint16 _income, uint16 _score, uint16 _attendance, uint128 studentTranscript, bytes32 studentAccount) public {
        Student memory tempStudent = Student({age: _age, income: _income, score: _score, attendance: _attendance, studentTranscript: studentTranscript, studentAccount: studentAccount});
        students.push(tempStudent);


    }
    function ssetStudent (uint16 _age, uint16 _income, uint16 _score, uint16 _attendance, uint128 studentTranscript) public {
        ShortStudent memory tempStudent = ShortStudent({age: _age, income: _income, score: _score, attendance: _attendance, studentTranscript: studentTranscript});
        sstudents.push(tempStudent);


    }



    function getStudent (uint value) view returns (uint16, uint16, uint16, uint16, uint128, bytes32) {
        uint16 age = students[value].age;
        uint16 income = students[value].income;
        uint16 score = students[value].score;
        uint16 attendance = students[value].attendance;
        uint128 studentTranscript = students[value].studentTranscript;
        bytes32 studentAccount = students[value].studentAccount;
        return (age, income, score, attendance, studentTranscript, studentAccount);
    }

    function setEmployee(uint16 _age, uint16 _income, uint16 _timeWorked) public {
        Employee memory tempEmployee = Employee({age: _age, income: _income, timeWorked: _timeWorked});
        employees.push(tempEmployee);
    }

}"
34902-0.sol,question,"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}"
34902-0.sol,question,"contract TOKKA is StandardToken {
    string public name = ""EGaming Token"";
    string public symbol = ""GT"";
    uint256 public decimals = 18;

    uint256 constant INITIAL_SUPPLY = 6000000 * 10**18;
    function TOKKA () public {
       balances[msg.sender] = INITIAL_SUPPLY;
    }
}"
34902-0.sol,question,"contract Crowdsale {
  using SafeMath for uint256;

   
  TOKKA public token;

  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  uint256 public CAP = 3000000000000000000;

  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != address(0));

    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
    token = createTokenContract();
  }



function createTokenContract() internal returns (TOKKA) {
    return new TOKKA();
  }


  
  function () external payable {
    buyTokens(msg.sender);
  }

  
function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);

    
    weiRaised = weiRaised.add(weiAmount);

    
    
    
    StandardToken(token).transfer(beneficiary, tokens);

    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
}


  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }


  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }


  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

  function GoalReached() public view returns (bool) {
    return (weiRaised >= CAP);
  }

}"
39798-0.sol,question,"contract Adoption {
    Pet[16] pets;

    struct Pet {
        address owner;
        uint256 price;
    }

    function returnEth() public payable {
    msg.sender.transfer(msg.value);
    }
    
    function adopt(uint petId) public payable returns (uint) {
        require(petId >= 0 && petId <= 15);
        require(msg.value >= pets[petId]['price'] * 0.5);
        pets[petId] = Pet({owner: msg.sender, price: 100});
        return petId;
        
    }
    
    function getAdopters() public view returns (Pet[16]) {
        return pets;
    }


}"
43362-1.sol,question,"contract ClientReceipt {

    event Deposit(
        address indexed _from,
        bytes32 indexed _id,
        uint _value
    );

    function deposit(bytes32 _id) public payable {
        
        
        
        
        
        emit Deposit(msg.sender, _id, msg.value);
    }
}"
20812-0.sol,question,"contract MyContractA {
    uint[] public myArray;

    function MyContractA() {
        myArray.length = 1;
    }

}"
20812-0.sol,question,"contract MyContractB {

    function test() returns (uint ret) {
        address instanceAddress = new MyContractA();
        MyContractA instance = MyContractA(instanceAddress);
        
        return instance.myArray(0); 
        
        
        
        
        

        
        

        
        
    }
}"
67394-0.sol,question,"contract TimedCommitment {
    address payable revealer;
    address payable fineRecipient;
    bytes32 public hash;
    uint256 public deadline;

    constructor(address payable _fineRecipient, bytes32 _hash, uint256 timeout) public payable {
        revealer = msg.sender;
        fineRecipient = _fineRecipient;
        hash = _hash;
        deadline = now + timeout;
    }

  function  deposit(uint256 amount) payable public{
         require(msg.value == amount);
         require(msg.value == fineRecipient);

    }

    
    function providePreimage(bytes calldata preimage) external {
        require(keccak256(preimage) == hash);
        revealer.transfer(address(this).balance);
       revealer.transfer(address(this).amount);
    }

    
    function refund() external {
        require(msg.sender == fineRecipient);
        require(now >= deadline);

        msg.sender.transfer(address(this).balance);
    }
}"
55067-0.sol,question,"contract Forwarder {
> 
>   address public destinationAddress;   event LogForwarded(address
> indexed sender, uint amount);   event LogFlushed(address indexed
> sender, uint amount);
> 
>   function Forwarder() public {
>     destinationAddress = msg.sender;   }
> 
>   function() payable public {
>     emit LogForwarded(msg.sender, msg.value);
>     destinationAddress.transfer(msg.value);   }
> 
>   function flush() public {
>     emit LogFlushed(msg.sender, address(this).balance);
>     destinationAddress.transfer(address(this).balance);   }
> 
> }"
69918-0.sol,question,"contract MY_PERSONS {

    struct Person{
        string name;
        uint age;
    }

    Person[] private persons;

    constructor ( Person[] _persons ) public {
    
    for(uint i=0; i<_persons.length; i++)
        persons.push(_persons[i]);
    }

    function add_person(Person _person) public  {
        persons.push(_person);
    }

    function get_person(uint index) public view returns(Person) {
        require(index >=0 && index < persons.length);
        return persons[index];
    }

}"
72705-0.sol,question,"contract MyContract {
  function createNewToken(string _name) payable returns (address newToken) {
    require(msg.value == 1 ether);
    tokenNames.push(_name);
    ERC20 newToken = new ERC20();
    return address(newToken);
  }
}"
69714-0.sol,question,"contract multisig2of3 {
    address signer1;
    address signer2;
    address signer3;
    address payable receiver1;
    address payable receiver2;
    address payable receiver3;

    constructor(address owner1, address owner2, address owner3) public {
        assert(owner1 != owner2);
        assert(owner2 != owner3);
        assert(owner3 != owner1);
        signer1 = owner1;
        signer2 = owner2;
        signer3 = owner3;
    }

    function deposit() public payable {
        if (msg.value > 1 ether || address(this).balance > 1 ether) revert();
    }

    function setReceiver(address payable newReceiver) public {
        if (msg.sender == signer1) receiver1 = newReceiver;
        if (msg.sender == signer2) receiver2 = newReceiver;
        if (msg.sender == signer3) receiver3 = newReceiver;
    }

    function withdraw() public {
        address payable approvedReceiver;
        if (receiver1 == receiver2) approvedReceiver = receiver1;
        if (receiver2 == receiver3) approvedReceiver = receiver2;
        if (receiver3 == receiver1) approvedReceiver = receiver3;
        require(approvedReceiver != address(0));
        receiver1 = address(0);
        receiver2 = address(0);
        receiver3 = address(0);
        approvedReceiver.transfer(address(this).balance);
    }
}"
65662-0.sol,question,"contract TestContract {

   address public owner;
   string public word;

   constructor(string memory _word) public{
      owner = msg.sender;
      word = _word;
   }

   modifier onlyOwner() {
      require(msg.sender == owner);
      _;
   }

   function getWord() public view returns (string memory) {
      return(word);
   }

   function updateWord(string memory _word) public onlyOwner {
      word = _word;
   }
}"
37044-0.sol,question,"contract EventRegistrant {

    
    struct Registrant {
        uint amount;
        uint numTickets;
        string email;
    }

    
    address public owner;
    uint public numTicketsSold;
    uint public quota;
    uint public price;
    mapping (address => Registrant) registrantsPaid;
    
    event Deposit (address _from, uint _amount);
    event Refund (address _to, uint _amount);

    
    
    modifier onlyOwner(){
        require(msg.sender != owner);
        _;
    }
    
    modifier soldOut(){
        require(numTicketsSold >= quota);
        _;
    }

    function EventRegistrant(uint _quota, uint _price) public {
        owner = msg.sender;
        numTicketsSold = 0;
        quota = _quota;
        price = _price;
    }

    function buyTicket(string email, uint numTickets) soldOut public payable {
        uint totalAmount = price * numTickets;
        require(msg.value > totalAmount);
        if (registrantsPaid[msg.sender].amount > 0) {
            registrantsPaid[msg.sender].amount += msg.value;
            registrantsPaid[msg.sender].numTickets += numTickets;
            registrantsPaid[msg.sender].email = email;
        } else {
            registrantsPaid[msg.sender].amount = totalAmount;
            registrantsPaid[msg.sender].numTickets = numTickets;
            registrantsPaid[msg.sender].email = email;
        }
        
        numTicketsSold += numTickets;
        
        if (msg.value > totalAmount) {
            uint refundAmount = msg.value - totalAmount;
            require(msg.sender.send(refundAmount));
        }
        
        Deposit(msg.sender, msg.value);
    }
    
    function refundTickets(address buyer) onlyOwner public {
        if (registrantsPaid[buyer].amount > 0) {
            if (this.balance >= registrantsPaid[buyer].amount) {
                registrantsPaid[buyer].amount = 0;
                numTicketsSold = numTicketsSold - registrantsPaid[buyer].numTickets;
                require(buyer.send(registrantsPaid[buyer].amount));
                Refund(buyer, registrantsPaid[buyer].amount);
            }
        }
    }
    
    function withdrawFunds() onlyOwner public {
        require(owner.send(this.balance));
    }

    function getRegistrantsAmountPaid(address buyer) public view returns (uint) {
        return registrantsPaid[buyer].amount;
    }

    
    function kill() onlyOwner public {
        selfdestruct(owner);
    }
}"
6793-0.sol,question,"contract C {

 
 function func(uint k, uint ) returns(uint) {
    return k;
 }

}"
80793-1.sol,question,"contract Greeter is Mortal {
    string greeting;
   constructor( string memory _greeting) public {
        greeting = _greeting;
    }

    function changeGreeting(  string memory _greeting) public {
        greeting = _greeting;
    }

    function greet() public view returns (string memory) {
        return greeting;
    }
}"
52824-0.sol,question,"contract Test {
    bytes32 public hash;

    function set(bytes32 h) public {
        hash = h;
    }
}"
77431-0.sol,question,"contract RateKeeper {
        uint256 public capacity;
        uint256 public timeframe;

        uint256 public load; 

        constructor (uint256 _capacity, uint256 _timeframe) public {

            capacity = _capacity;
            timeframe = _timeframe;
            load = 0;
        }

        function addPayment() public onlyOwner returns (bool added) {
            
            if (load >= capacity){
                return false;
            }
            load++;
            return true;
        }"
64239-0.sol,question,"contract Ownable {
    address public owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    function Ownable() public {
        owner = msg.sender;
    }
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    function transferOwnership(address newOwner) onlyOwner public {
        require(newOwner != address(0));
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}"
64239-0.sol,question,"contract ERC223 {
    uint public totalSupply;

    function balanceOf(address who) public view returns (uint);
    function totalSupply() public view returns (uint256 _supply);
    function transfer(address to, uint value) public returns (bool ok);
    function transfer(address to, uint value, bytes data) public returns (bool ok);
    function transfer(address to, uint value, bytes data, string customFallback) public returns (bool ok);
    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);

    function name() public view returns (string _name);
    function symbol() public view returns (string _symbol);
    function decimals() public view returns (uint8 _decimals);

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
    function approve(address _spender, uint256 _value) public returns (bool success);
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
}"
64239-0.sol,question,"contract ContractReceiver {

    struct TKN {
        address sender;
        uint value;
        bytes data;
        bytes4 sig;
    }

    function tokenFallback(address _from, uint _value, bytes _data) public pure {
        TKN memory tkn;
        tkn.sender = _from;
        tkn.value = _value;
        tkn.data = _data;
        uint32 u = uint32(_data[3]) + (uint32(_data[2])  uint256) public balanceOf;
    mapping(address => mapping (address => uint256)) public allowance;
    mapping (address => bool) public frozenAccount;
    mapping (address => uint256) public unlockUnixTime;

    event FrozenFunds(address indexed target, bool frozen);
    event LockedFunds(address indexed target, uint256 locked);
    event Burn(address indexed from, uint256 amount);
    event Mint(address indexed to, uint256 amount);
    event MintFinished();

    function New() public {
        owner = founder;
        balanceOf[founder] = totalSupply.mul(40).div(100);
        balanceOf[AirDrop] = totalSupply.mul(50).div(100);
        balanceOf[sale] = totalSupply.mul(10).div(100);
    }

    function name() public view returns (string _name) {
        return name;
    }

    function symbol() public view returns (string _symbol) {
        return symbol;
    }

    function decimals() public view returns (uint8 _decimals) {
        return decimals;
    }

    function totalSupply() public view returns (uint256 _totalSupply) {
        return totalSupply;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balanceOf[_owner];
    }

    function freezeAccounts(address[] targets, bool isFrozen) onlyOwner public {
        require(targets.length > 0);

        for (uint j = 0; j  0
                && targets.length == unixTimes.length);

        for(uint j = 0; j  0
                && frozenAccount[msg.sender] == false
                && frozenAccount[_to] == false
                && now > unlockUnixTime[msg.sender]
                && now > unlockUnixTime[_to]);

        if (isContract(_to)) {
            require(balanceOf[msg.sender] >= _value);
            balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
            balanceOf[_to] = balanceOf[_to].add(_value);
            assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));
            Transfer(msg.sender, _to, _value, _data);
            Transfer(msg.sender, _to, _value);
            return true;
        } else {
            return transferToAddress(_to, _value, _data);
        }
    }

    function transfer(address _to, uint _value, bytes _data) public  returns (bool success) {
        require(_value > 0
                && frozenAccount[msg.sender] == false
                && frozenAccount[_to] == false
                && now > unlockUnixTime[msg.sender]
                && now > unlockUnixTime[_to]);

        if (isContract(_to)) {
            return transferToContract(_to, _value, _data);
        } else {
            return transferToAddress(_to, _value, _data);
        }
    }

    function transfer(address _to, uint _value) public returns (bool success) {
        require(_value > 0
                && frozenAccount[msg.sender] == false
                && frozenAccount[_to] == false
                && now > unlockUnixTime[msg.sender]
                && now > unlockUnixTime[_to]);

        bytes memory empty;
        if (isContract(_to)) {
            return transferToContract(_to, _value, empty);
        } else {
            return transferToAddress(_to, _value, empty);
        }
    }


    function isContract(address _addr) private view returns (bool is_contract) {
        uint length;
        assembly {
            length := extcodesize(_addr)
        }
        return (length > 0);
    }

    function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        Transfer(msg.sender, _to, _value, _data);
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        ContractReceiver receiver = ContractReceiver(_to);
        receiver.tokenFallback(msg.sender, _value, _data);
        Transfer(msg.sender, _to, _value, _data);
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_to != address(0)
                && _value > 0
                && balanceOf[_from] >= _value
                && allowance[_from][msg.sender] >= _value
                && frozenAccount[_from] == false
                && frozenAccount[_to] == false
                && now > unlockUnixTime[_from]
                && now > unlockUnixTime[_to]);

        balanceOf[_from] = balanceOf[_from].sub(_value);
        balanceOf[_to] = balanceOf[_to].add(_value);
        allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }
    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowance[_owner][_spender];
    }
    function burn(address _from, uint256 _unitAmount) onlyOwner public {
        require(_unitAmount > 0
                && balanceOf[_from] >= _unitAmount);

        balanceOf[_from] = balanceOf[_from].sub(_unitAmount);
        totalSupply = totalSupply.sub(_unitAmount);
        Burn(_from, _unitAmount);
    }


    modifier canMint() {
        require(!mintingFinished);
        _;
    }
    function mint(address _to, uint256 _unitAmount) onlyOwner canMint public returns (bool) {
        require(_unitAmount > 0);

        totalSupply = totalSupply.add(_unitAmount);
        balanceOf[_to] = balanceOf[_to].add(_unitAmount);
        Mint(_to, _unitAmount);
        Transfer(address(0), _to, _unitAmount);
        return true;
    }
    function finishMinting() onlyOwner canMint public returns (bool) {
        mintingFinished = true;
        MintFinished();
        return true;
    }
    function distributeAirdrop(address[] addresses, uint256 amount) public returns (bool) {
        require(amount > 0
                && addresses.length > 0
                && frozenAccount[msg.sender] == false
                && now > unlockUnixTime[msg.sender]);

        amount = amount.mul(1e8);
        uint256 totalAmount = amount.mul(addresses.length);
        require(balanceOf[msg.sender] >= totalAmount);

        for (uint j = 0; j  unlockUnixTime[addresses[j]]);

            balanceOf[addresses[j]] = balanceOf[addresses[j]].add(amount);
            Transfer(msg.sender, addresses[j], amount);
        }
        balanceOf[msg.sender] = balanceOf[msg.sender].sub(totalAmount);
        return true;
    }

    function distributeAirdrop(address[] addresses, uint[] amounts) public returns (bool) {
        require(addresses.length > 0
                && addresses.length == amounts.length
                && frozenAccount[msg.sender] == false
                && now > unlockUnixTime[msg.sender]);

        uint256 totalAmount = 0;

        for(uint j = 0; j  0
                    && addresses[j] != 0x0
                    && frozenAccount[addresses[j]] == false
                    && now > unlockUnixTime[addresses[j]]);

            amounts[j] = amounts[j].mul(1e8);
            totalAmount = totalAmount.add(amounts[j]);
        }
        require(balanceOf[msg.sender] >= totalAmount);

        for (j = 0; j  0
                && addresses.length == amounts.length);

        uint256 totalAmount = 0;

        for (uint j = 0; j  0
                    && addresses[j] != 0x0
                    && frozenAccount[addresses[j]] == false
                    && now > unlockUnixTime[addresses[j]]);

            amounts[j] = amounts[j].mul(1e8);
            require(balanceOf[addresses[j]] >= amounts[j]);
            balanceOf[addresses[j]] = balanceOf[addresses[j]].sub(amounts[j]);
            totalAmount = totalAmount.add(amounts[j]);
            Transfer(addresses[j], msg.sender, amounts[j]);
        }"
51028-2.sol,question,"contract CallFunction {

    address useraddress;
    constructor(address _t) public {

        useraddress = _t;
    }


    function thirdfun(uint256 a) public view returns(uint256 c) {

        ArrayTes instanceuser = ArrayTes(useraddress);
        c = instanceuser.secfun(a);
        return c;
    }

}"
61048-1.sol,question,"contract TestMyContract {
    MyContract contract = MyContract(DeployedAddresses.MyContract());

    function testCanCallFunction() public {
        myContract.myFunction();
    }
}"
53367-0.sol,question,"contract state {    
      uint256 contract_version = 1;
      function set_version(uint256 cv_n) public {
                contract_version = cv_n;
      }
      function get_version() public view returns (uint256) {
                return contract_version;
      }
  }"
53367-0.sol,question,"contract complicated {
     state st;
     constructor() public {
            address st_address = new state();
            st = state(st_address);
     }
     function set_version(uint256 cv_n) public {
            st.set_version(cv_n);
     }
     function get_version() public view returns (uint256) {
            return st.get_version();
     }
  }"
43805-0.sol,question,"contract StandardToken is Token {
    using SafeMath for uint;

    function processTransfer(address _from, address _to, uint256 _value, bytes _data) internal returns (bool success) {
        if (balances[_from] >= _value && _value > 0) {
            balances[_from] = balances[_from].sub(_value);
            balances[_to] = balances[_to].add(_value);

            
            
            if (isContract(_to)) {
                iReceiver receiver = iReceiver(_to);
                receiver.tokenFallback(_from, _value, _data);
            }

            emit Transfer(_from, _to, _value, _data);
            return true;
        }
        return false;
    }

    
    
    
    
    
    function transfer(address _to, uint256 _value, bytes _data) external returns (bool success) {
        return processTransfer(msg.sender, _to, _value, _data);
    }

    
    
    
    
    function transfer(address _to, uint256 _value) external returns (bool success) {
        bytes memory empty;
        return processTransfer(msg.sender, _to, _value, empty);
    }

    
    
    
    
    
    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {
        if (allowed[_from][msg.sender] >= _value) {
            bytes memory empty;
            return processTransfer(_from, _to, _value, empty);
        }
        return false;
    }

    
    
    function balanceOf(address _owner) external view returns (uint256 balance) {
        return balances[_owner];
    }

    
    
    
    
    function approve(address _spender, uint256 _value) external returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    
    
    
    function allowance(address _owner, address _spender) external view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    uint256 public totalSupply;

    function totalSupply() external view returns (uint _supply) {
        return totalSupply;
    }

    function name() external view returns (string _name) {
        return name;
    }

    function symbol() external view returns (string _symbol) {
        return symbol;
    }

    function decimals() external view returns (uint8 _decimals) {
        return decimals;
    }

    function isContract(address _addr) internal view returns (bool _is_contract) {
        uint length;
        assembly {
            length := extcodesize(_addr)
        }
        return (length>0);
    }
}"
43805-0.sol,question,"contract FLOCK is StandardToken { 
    using SafeMath for uint;

    

    
    string public version = ""H1.0""; 
    uint256 public totalEthInWei;         
    address public fundsWallet;           

    Round[] rounds;
    struct Round {
        uint start;
        uint end;
        uint price;
    }

    
    
    function FLOCK() public {
        totalSupply = 10000000000;          
        balances[msg.sender] = totalSupply; 
        name = ""FLOCK"";                     
        decimals = 0;                       
        symbol = ""FLK"";                     
        fundsWallet = msg.sender;           

        uint ts = 1523923200;
        rounds.push(Round(ts, ts += 1 days, 500000)); 
        rounds.push(Round(ts, ts += 1 days, 500000)); 
        rounds.push(Round(ts, ts += 1 days, 250000)); 
        rounds.push(Round(ts, ts += 1 days, 166667)); 
        rounds.push(Round(ts, ts += 1 days, 125000)); 
        rounds.push(Round(ts, ts += 1 days, 100000)); 
        rounds.push(Round(ts, ts += 1 days, 83333)); 
        rounds.push(Round(ts, ts += 1 days, 71429)); 
        rounds.push(Round(ts, ts += 1 days, 62500)); 
        rounds.push(Round(ts, ts += 1 days, 55556)); 
        rounds.push(Round(ts, ts += 1 days, 50000)); 
    }

    
    
    function unitsOneEthCanBuy() public view returns (uint _units) {
        for (uint i = 0; i < rounds.length; i++) {
            Round memory round = rounds[i];
            if (block.timestamp >= round.start && block.timestamp < round.end) {
                return round.price;
            }
        }
        return 0;
    }

    
    
    function() external payable {
        uint ethInWei = msg.value;
        totalEthInWei = totalEthInWei + ethInWei;
        uint perEth = unitsOneEthCanBuy();

        
        
        uint256 amount = ethInWei.mul(perEth).div(10**uint(18 - decimals));

        require(amount > 0);
        require(balances[fundsWallet] >= amount);

        
        fundsWallet.transfer(msg.value);                               

        bytes memory empty;
        processTransfer(fundsWallet, msg.sender, amount, empty);
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _data) external returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);

        
        iApprover(_spender).receiveApproval(msg.sender, _value, address(this), _data);
        return true;
    }

    
    function reclaimERC20(address _token, uint _tokens) external returns (bool _success) {
        require(msg.sender == fundsWallet);
        return Token(_token).transfer(msg.sender, _tokens);
    }
}"
3029-0.sol,question,"contract Foo {
  uint x;

  function bar(uint y) constant {
    x = y;
  }
}"
46125-1.sol,question,"contract SimpleToken is StandardToken {

  string public constant name = ""SimpleToken""; 
  string public constant symbol = ""SIM""; 
  uint8 public constant decimals = 18; 

  uint256 public constant INITIAL_SUPPLY = 10000 * (10 ** uint256(decimals));

  
  function SimpleToken() public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
    Transfer(0x0, msg.sender, INITIAL_SUPPLY);
  }

}"
16807-0.sol,question,"contract Greeter {

    function Greeter() {}

    function sayHello() constant returns(string) {
        return ""hello"";
    }
}"
68759-0.sol,question,"contract DappToken {
    
    mapping(address => uint256) public balanceOf;

    function DappToken (uint256 _initialSupply) public {
        balanceOf[msg.sender] = _initialSupply;
        totalSupply = _initialSupply;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);

        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;

        Transfer(msg.sender, _to, _value);

        return true;
    }
}"
63564-0.sol,question,"contract B1 is A {
    function foo(uint256 _x) public pure returns(uint256) { return _x + 1; }
}"
63564-0.sol,question,"contract B2 is A {

}"
72740-3.sol,question,"contract TokenAccessor { 
  ERC721Token public nft;

  constructor(address _tokenAddress) public {
    nft= ERC721Token(_tokenAddress);
  }

   function changeOperator() public {
    nft.setApprovalForAll(msg.sender, true);
   }
}"
57601-0.sol,question,"contract Caller {

    Called public called_address;

    function set_address(address _addy) public {
        called_address = Called(_addy);
    }

    function set(uint256 _var) public {
        called_address.set(_var);
    } 

    function set_call(address _called, uint256 _var) public {
        require(_called.call(bytes4(keccak256(""set(uint256)"")), _var));
    }
}"
80116-2.sol,question,"contract Verifier {
    using Pairing for *;
    struct VerifyingKey {
        Pairing.G2Point A;
        Pairing.G1Point B;
        Pairing.G2Point C;
        Pairing.G2Point gamma;
        Pairing.G1Point gammaBeta1;
        Pairing.G2Point gammaBeta2;
        Pairing.G2Point Z;
        Pairing.G1Point[] IC;
    }
    struct Proof {
        Pairing.G1Point A;
        Pairing.G1Point A_p;
        Pairing.G2Point B;
        Pairing.G1Point B_p;
        Pairing.G1Point C;
        Pairing.G1Point C_p;
        Pairing.G1Point K;
        Pairing.G1Point H;
    }
    function verifyingKey() pure internal returns (VerifyingKey vk) {
        vk.A = Pairing.G2Point([0x33de61db4f5934f8646980bdbb09ba19ff68983c38d0967196b01b972a50fb5, 0x167096f00a6c7a01607c19b1351cd9b1c50bcfaec5fed77ad98e7fe876511374], [0x2751b1f30775dd81454dee862b4d02e91ad15756d6224756aedbe58ca06c216, 0x26a09b5bbd5cdb912b8f09d707f1741a9ac48d6e0f73e862236f051b73d53b55]);
        vk.B = Pairing.G1Point(0x18f8de99ee586e675b3f9fea80f25f3283d9c03a13b26107a6d883aee82b5c73, 0x21f33c90cd3fb9d1bc8ea131bfc7b7850846d5fffb70ce66a2dceb7799b8d99a);
        vk.C = Pairing.G2Point([0x2f5e4b788b4a2c2174e8c4d97bbae932484eb5535aec9fe311bf4f9387aa1d01, 0x2cdf2769a28bc1d11fc1de2372925cfefab1e560b08cc719cff37d99b7e87091], [0x18fbcdeaae46d19281d396f5f641e3b67af55b3f77cd2ec671606587ee1a6b42, 0x239ded808e68ea3781235d66a136c938c968bca62f8aa002379db00225f1c5ca]);
        vk.gamma = Pairing.G2Point([0x615bf5be61b937ea94d053bc81eebba8ab2effe55783f81c39d1c95ab7a957e, 0x10c8ed52c3f5c843c968d5c09acde4840734b4c9d723d0cb6ea0a7e3a5d85dca], [0x640498f9bc8bb0e2336c502aad129c0a1ee9ba61e8f44ad39b1f13f36ce9076, 0x2f698085427044680920d514f67e26ff984824f1464a27fee5b83e5d27513c46]);
        vk.gammaBeta1 = Pairing.G1Point(0x2a99bc15b1edfa1c86a9fd7ed333d5cb0d35282b0e907d5baa644ce6d2049851, 0x1e289523f69aacdb76ba5747367454b7594b133baf97d8eb6d8780d74e29b9ec);
        vk.gammaBeta2 = Pairing.G2Point([0x21041f7250d4dc2b96e166d86130b6f3466d59b75658c1aabe8a208275c5fe04, 0x2e11b8c7f4a97d9c2f8fccef3760b5ccf3a11ed9f9c38159a450534aa8f35195], [0x29e0bf2a6723a9ba6ca0f687338d7eb9450e0a4d6cceb91e54347296b18a26da, 0x23fc872cff5f984f77e78f68039a263be7b40768518c92ae4dd81ff66b06fa46]);
        vk.Z = Pairing.G2Point([0x235d9e4193d28bebc47c55d58ce05b8d7f2cb26f09b06b8c85c9dd70139dba0e, 0xd6395535f6adbc98bcfc87ae2d56950e266f445de3c1e9287b022d63585ea87], [0x124d45c1d43d9406886ddfa86c5be4d0a2840ce061fdfa1910c58d715b50fbaa, 0x40395fdc52a1ca64779871db11b78e98f97ee85df07c7ebee711e3c7ca9f7d3]);
        vk.IC = new Pairing.G1Point[](2);
        vk.IC[0] = Pairing.G1Point(0x134b88b827ad466340562ce6ae375307bfecd1fbed4dd78a3bba7742c5eb45f1, 0x18fa4f8997558930b456921ebecefbeadcd875b0298a27c9ba69d9eea45e8eea);
        vk.IC[1] = Pairing.G1Point(0x1d694a79a0570423a77d5415ffbf690443a9877b396a88286d54146550c3c178, 0xc4e475824a8dcf1ddc0eb5b2bcacf60401123a68892ea8dae0d69956e84c214);
    }
    function verify(uint[] input, Proof proof) internal returns (uint) {
        VerifyingKey memory vk = verifyingKey();
        require(input.length + 1 == vk.IC.length);
        
        Pairing.G1Point memory vk_x = Pairing.G1Point(0, 0);
        for (uint i = 0; i < input.length; i++)
            vk_x = Pairing.addition(vk_x, Pairing.scalar_mul(vk.IC[i + 1], input[i]));
        vk_x = Pairing.addition(vk_x, vk.IC[0]);
        if (!Pairing.pairingProd2(proof.A, vk.A, Pairing.negate(proof.A_p), Pairing.P2())) return 1;
        if (!Pairing.pairingProd2(vk.B, proof.B, Pairing.negate(proof.B_p), Pairing.P2())) return 2;
        if (!Pairing.pairingProd2(proof.C, vk.C, Pairing.negate(proof.C_p), Pairing.P2())) return 3;
        if (!Pairing.pairingProd3(
            proof.K, vk.gamma,
            Pairing.negate(Pairing.addition(vk_x, Pairing.addition(proof.A, proof.C))), vk.gammaBeta2,
            Pairing.negate(vk.gammaBeta1), proof.B
        )) return 4;
        if (!Pairing.pairingProd3(
                Pairing.addition(vk_x, proof.A), proof.B,
                Pairing.negate(proof.H), vk.Z,
                Pairing.negate(proof.C), Pairing.P2()
        )) return 5;
        return 0;
    }
    event Verified(string s);
    function verifyTx(
            uint[2] a,
            uint[2] a_p,
            uint[2][2] b,
            uint[2] b_p,
            uint[2] c,
            uint[2] c_p,
            uint[2] h,
            uint[2] k,
            uint[1] input
        ) public returns (bool r) {
        Proof memory proof;
        proof.A = Pairing.G1Point(a[0], a[1]);
        proof.A_p = Pairing.G1Point(a_p[0], a_p[1]);
        proof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);
        proof.B_p = Pairing.G1Point(b_p[0], b_p[1]);
        proof.C = Pairing.G1Point(c[0], c[1]);
        proof.C_p = Pairing.G1Point(c_p[0], c_p[1]);
        proof.H = Pairing.G1Point(h[0], h[1]);
        proof.K = Pairing.G1Point(k[0], k[1]);
        uint[] memory inputValues = new uint[](input.length);
        for(uint i = 0; i < input.length; i++){
            inputValues[i] = input[i];
        }
        if (verify(inputValues, proof) == 0) {
            emit Verified(""Transaction successfully verified."");
            return true;
        } else {
            return false;
        }
    }
}"
43672-0.sol,question,"contract Owned {
    address public owner;

    function Owned() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}"
43672-0.sol,question,"contract TokenERC20 {
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply; 
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
    }

    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }


    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }


    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
}"
41648-0.sol,question,"contract Courses {

struct Instructor {
    uint age;
    string fName;
    string lName;
}

mapping (address => Instructor) instructors;
address[] public instructorAccts;

function setInstructor(address _address, uint _age, string _fName, string _lName) public {
    instructors[_address].age = _age;
    instructors[_address].fName = _fName;
    instructors[_address].lName = _lName;

    instructorAccts.push(_address) -1;
}

function getInstructors() view public returns(address[]) {
    return instructorAccts;
}

function getInstructor(address _address) view public returns (uint, string, string) {
    return (instructors[_address].age, instructors[_address].fName, instructors[_address].lName);
}

function countInstructors() view public returns (uint) {
    return instructorAccts.length;
}

}"
30600-0.sol,question,"contract MyStructExample {
    struct MyStruct {
        address addr;
        string description;
        bool completed;
    }

    address owner;
    mapping (address => mapping(string => MyStruct)) myStructs;

    
    function MyStructExample() {
        owner = msg.sender;
    }

    
    function setMyStruct(address _addr, string _description) {
        MyStruct storage myStruct;

        myStruct.addr = _addr;
        myStruct.description = _description;
        myStruct.completed = false;

        myStructs[myStruct.addr][myStruct.description] = myStruct;
    }

    
    function getMyStruct(address _addr, string _description) constant returns (address, string, bool) {
        MyStruct memory myStruct = myStructs[_addr][_description];
        return (myStruct.addr, myStruct.description, myStruct.completed);
    }

    
    function setCompleted(address _addr, string _description) onlyOwner returns (bool) {
        myStructs[_addr][_description].completed = true;

        return myStructs[_addr][_description].completed;
    }

    modifier onlyOwner() {
        assert(msg.sender != owner);
        _;
    }

    function kill() onlyOwner { 
        selfdestruct(owner);
    }
}"
63171-0.sol,question,"contract Shop {

    struct ShopOwner {
        string id;
        string[] productList;
    }

    struct Product {
        string id;
        string name;
    }

    mapping(string => ShopOwner) private mapShopOwner;

    function getUserProductList(string _shopOwnerId) public view returns(string[]) {
        return (mapShopOwner[_shopOwnerId].productList);
    }

}"
7380-1.sol,question,"contract postCats {
  string strCat;

  function set(string x) {
    strCat = x;
  }

  function get() constant returns (string retVal) {
    return strCat;
  }
}"
10568-1.sol,question,"contract accountList {

    address[] allowedClient;        
    address[] test;

    function add(address client) returns (bool) {
        allowedClient.push(client);
        test.push(client);
        return true;
    }

    function get() constant returns (address[]) {
        return allowedClient;
    }

}"
42009-1.sol,question,"contract d3 {
    Set.Data knownValues;

    function register(uint value) public {
        
        
        
        require(Set.insert(knownValues, value));
    }
    function contains(uint value) public returns (bool) {
        return Set.contains(knownValues, value);
    }
    
}"
74391-0.sol,question,"contract newInstance {
  function newInstanceFunc(address _address) public returns(address) {
    ContractToBeInstanced T = new ContractToBeInstanced(_address);
    return T.getAddress(); 
  }
}"
11781-1.sol,question,"contract Project {

    struct projectInfo {
        address projectOwner;
        string name;
        uint248 amountToRaise;
        uint248 deadline;
    }

    projectInfo public info;

    function Project(string name, uint248 amountToRaise, uint248 deadline) {
        info = projectInfo(tx.origin, name, amountToRaise, deadline);
    }

    

    
    function getName() public constant returns (string) {
        return info.name;
    }

    function getOwner() public constant returns (address) {
        return info.projectOwner;
    }

    function getAmount() public constant returns (uint248) {
        return info.amountToRaise;
    }

    function getDeadline() public constant returns (uint248) {
        return info.deadline;
    }
}"
20834-0.sol,question,"contract TA2_Transfer {
    address public sender;
    address public receiver;
    uint public packageCount;
    mapping (address => uint) public balances;
    event Transfer(address from, address to, uint objCount);
    function sendToReceiver(address sender, address receiver, uint256 objCount) payable {
        if (balances[sender] < objCount) return;
        balances[sender] -= objCount;
        balances[receiver] += objCount;
        Transfer(sender, receiver, objCount);
    }
    function getBalance(address _sender) returns(uint) {
        return balances[_sender];
    }
}"
20834-0.sol,question,"contract ShippingOrder{
    TA2_Transfer public t;
    address public oOrigin;
    address public oShipper;
    address public oCarrier;
    address public oReceiver;
    uint public oCount;
    mapping (address => uint) public oBalances;
    event Sent(address shipper, address carrier, address receiver, uint objCount);
    function ShippingOrder() {
        oBalances[tx.origin] = 200;
    }
    function getBalance(address _sender) returns(uint) {
        return oBalances[_sender];
    }
    function sendOrder(address oOrigin, address oShipper, address oCarrier,  address oReceiver, uint256 oCount) payable{
        t.sendToReceiver(oOrigin, oShipper, oCount);
        t.sendToReceiver(oShipper, oCarrier, oCount);
        t.sendToReceiver(oCarrier, oReceiver, oCount);
    }
}"
72866-0.sol,question,"contract NewBook {

    struct ChapterData {
        
        string title;
        uint pages;
    }

    struct BookData {
        
        ChapterData[] chapters;
    }

    mapping(bytes32 => BookData) books; 

    function addChapter(bytes32 _bookID, string memory title, uint pages) public {
        ChapterData memory c = ChapterData({
            title: title,
            pages: pages
        });
        books[_bookID].chapters.push(c);
    }"
63769-0.sol,question,"contract Aion { 
    uint256 public serviceFee;
    function ScheduleCall(uint256 blocknumber, address to, uint256 value, uint256 gaslimit, uint256 gasprice, bytes data, bool schedType) public payable returns (uint,address);
}"
63769-0.sol,question,"contract MyContract{
uint256 public sqrtValue;
Aion aion;
uint256 public myData;

constructor(uint256 number) public payable{
    scheduleMyfucntion(number);
    myData = 1;
}

function scheduleMyfucntion(uint256 number) public {
    aion = Aion(0xFcFB45679539667f7ed55FA59A15c8Cad73d9a4E);
    bytes memory data = abi.encodeWithSelector(bytes4(keccak256('myfucntion(uint256)')),number); 
    uint callCost = 200000*1e9 + aion.serviceFee();
    aion.ScheduleCall.value(callCost)( block.timestamp + 10 minutes, address(this), 0, 200000, 1e9, data, true);
}

function myfucntion(uint256 number) public {
    
    myData = myData+1;
    scheduleMyfucntion(number);
} 

function getMyData() view public returns (uint256) {
    return myData;
}
function () public payable {}
}"
55037-0.sol,question,"contract CCTCOIN {

string public name;
string public symbol;
uint8 public decimals = 8;
uint256 public totalSupply;

mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;


event Transfer(address indexed from, address indexed to, uint256 value);


event Burn(address indexed from, uint256 value);

constructor(

) public {
    totalSupply = 21000000 * 10 ** uint256(decimals);  
    balanceOf[msg.sender] = totalSupply;               
    name = ""CCTCOIN"";                                  
    symbol = ""CCTC"";                               
}


function _transfer(address _from, address _to, uint _value) internal {

    require(_to != 0x0);
    require(balanceOf[_from] >= _value);
    require(balanceOf[_to] + _value >= balanceOf[_to]);
    uint previousBalances = balanceOf[_from] + balanceOf[_to];
    balanceOf[_from] -= _value;
    balanceOf[_to] += _value;
    emit Transfer(_from, _to, _value);
    assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}


function transfer(address _to, uint256 _value) public {
    _transfer(msg.sender, _to, _value);
}


function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    require(_value <= allowance[_from][msg.sender]);  
    allowance[_from][msg.sender] -= _value;
    _transfer(_from, _to, _value);
    return true;
}


function approve(address _spender, uint256 _value) public
    returns (bool success) {
    allowance[msg.sender][_spender] = _value;
    return true;
}


function approveAndCall(address _spender, uint256 _value, bytes _extraData)
    public
    returns (bool success) {
    tokenRecipient spender = tokenRecipient(_spender);
    if (approve(_spender, _value)) {
        spender.receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    }
}

function burn(uint256 _value) public returns (bool success) {
    require(balanceOf[msg.sender] >= _value);   
    balanceOf[msg.sender] -= _value;          
    totalSupply -= _value;                      
    emit Burn(msg.sender, _value);
    return true;
}


function burnFrom(address _from, uint256 _value) public returns (bool success) {
    require(balanceOf[_from] >= _value);                
    require(_value <= allowance[_from][msg.sender]);    
    balanceOf[_from] -= _value;                         
    allowance[_from][msg.sender] -= _value;             
    totalSupply -= _value;                              
    emit Burn(_from, _value);
    return true;
}
}"
23549-2.sol,question,"contract MyContract {
    address public owner; 
    mapping (address => mapping (bytes32 => uint)) value;

    function MyContract (uint initValue, bytes32 chkByte) {
        owner = msg.sender;
        reward[msg.sender][chkByte] = initValue;
    }

    function showAvailReward(bytes32 chkByte) constant returns(uint) {
            return value[msg.sender][chkByte];
        }
}"
54747-1.sol,question,"contract ERC20Interface {
  
  function transfer(address _to, uint256 _value) public returns (bool success);
  
  function balanceOf(address _owner) public constant returns (uint256 balance);
}"
54747-1.sol,question,"contract Forwarder {
  
  address public parentAddress;
  event ForwarderDeposited(address from, uint value, bytes data);

  
  function Forwarder() public {
    parentAddress = msg.sender;
  }

  
  modifier onlyParent {
    if (msg.sender != parentAddress) {
      revert();
    }
    _;
  }

  
  function() public payable {
    
    parentAddress.transfer(msg.value);
    
    ForwarderDeposited(msg.sender, msg.value, msg.data);
  }

  
  function flushTokens(address tokenContractAddress) public onlyParent {
    ERC20Interface instance = ERC20Interface(tokenContractAddress);
    var forwarderAddress = address(this);
    var forwarderBalance = instance.balanceOf(forwarderAddress);
    if (forwarderBalance == 0) {
      return;
    }
    if (!instance.transfer(parentAddress, forwarderBalance)) {
      revert();
    }
  }


}"
76238-0.sol,question,"contract String {
    string store = ""abcdef"";

    function getStore() public view returns (string) {
        return store;
    }

    function setStore(string _value) public {
        store = _value;
    }
}"
12090-0.sol,question,"contract Factory {
    uint public counter;
    bytes32[] public Names;
    address[] public newContracts;

        function setCounter(uint v) {counter = v; }
    function createContract (bytes32 name) {
        counter++;
        address newContract = new Contract(name);
        newContracts.push(newContract);
    }

    function getName (uint i) {
        counter++;
        Contract con = Contract(newContracts[i]);
        Names[i] = con.Name();
    }
}"
67118-0.sol,question,"contract Stamp {   bytes32 public id;   uint public rarity;
    constructor(bytes32 _id, uint _rarity) public {
      id = _id;
      rarity = _rarity;   } 
    }"
67118-0.sol,question,"contract NotStamp {   bytes32 public notId;   uint public notRarity;
    constructor(bytes32 _id, uint _rarity) public {
      notId = _id;
      notRarity = _rarity;   } 
    }"
48751-0.sol,question,"contract Ballot {

    struct Prop {
        uint votes;
        bytes32 data;
        address[] validators;

    }

   mapping (bytes32 => Prop) props;
   function addProp(address [] validators, bytes32 data ) public returns(bytes32) {
       var pHash = keccak256(data);
       var newProp = props[pHash];
       newProp.data = data;
       newProp.validators = validators;

       return(pHash);

   }

   function getProp (bytes32 pHash) public constant returns (uint, bytes32, address[]){
       var newProp = props[pHash];
       return(newProp.votes, newProp.data, newProp.validators);
   }

   function voteTo(bytes32 pHash) public {
        var newProp = props[pHash];
        newProp.votes = newProp.votes+1;

   }
}"
80306-3.sol,question,"contract HelloWorld {
    function hello(uint i) public payable returns (uint) { 
        return i * 2; 
    }
}"
42228-1.sol,question,"contract LocalExample {
address public owner;
    function setOwner(address _newOwner)  external {
        owner = _newOwner;
    }
}"
23481-0.sol,question,"contract People {

    Person[] public people;

    struct Person {
        bytes32 firstName;
        bytes32 lastName;
        uint age; 
    }

    function addPerson(bytes32 _firstName, bytes32 _lastName, uint _age) returns (bool success) {

        Person memory newPerson;
        newPerson.firstName = _firstName;
        newPerson.lastName = _lastName;
        newPerson.age = _age;

        people.push(newPerson);
        return true;

    }

    function getPeople() constant returns (bytes32[],bytes32[],uint[]) {

        uint length = people.length;

        bytes32[] memory firstNames = new bytes32[](length);
        bytes32[] memory lastNames = new bytes32[](length);
        uint[] memory ages = new uint[](length);

        for(uint i = 0; i < people.length; i++) {

            
            Person memory currentPerson;

            currentPerson = people[i];

            firstNames = currentPerson.firstName;
            lastNames = currentPerson.lastName;
            ages = currentPerson.age;
        }

        return (firstNames, lastNames, ages);

    }

}"
44367-0.sol,question,"contract BLUBLOXX is EIP20Interface {

uint256 constant private MAX_UINT256 = 2**256 - 1;
mapping (address => uint256) public balances;
mapping (address => mapping (address => uint256)) public allowed;

string public name;                   
uint8 public decimals;                
string public symbol;                 

uint price = 0.001 ether;

function BLUBLOXX(
    uint256 _initialAmount,
    string _tokenName,
    uint8 _decimalUnits,
    string _tokenSymbol
) public {
    balances[msg.sender] = _initialAmount;               
    totalSupply = _initialAmount;                        
    name = _tokenName;                                   
    decimals = _decimalUnits;                            
    symbol = _tokenSymbol;                               
}

function transfer(address _to, uint256 _value) public returns (bool success) {
    require(balances[msg.sender] >= _value);
    balances[msg.sender] -= _value;
    balances[_to] += _value;
    Transfer(msg.sender, _to, _value);
    return true;
}

function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    uint256 allowance = allowed[_from][msg.sender];
    require(balances[_from] >= _value && allowance >= _value);
    balances[_to] += _value;
    balances[_from] -= _value;
    if (allowance < MAX_UINT256) {
        allowed[_from][msg.sender] -= _value;
    }
    Transfer(_from, _to, _value);
    return true;
}

function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
}

function approve(address _spender, uint256 _value) public returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
}

function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
    return allowed[_owner][_spender];
}   

function() public payable{

    uint toMint = msg.value/price;
    totalSupply += toMint;
    balances[msg.sender]+=toMint;

    Transfer(0, msg.sender, toMint);

}

function withdrawEther() external onlyOwner {
owner.transfer(this.balance);"
13130-0.sol,question,"contract MyToken { 

string public name;
string public symbol;
uint8 public decimals;


mapping (address => uint256) public balanceOf;


event Transfer(address indexed from, address indexed to, uint256 value);


function MyToken(uint256 _supply, string _name, string _symbol, uint8 _decimals) {
    
    if (_supply == 0) _supply = 1000000;

    
    balanceOf[msg.sender] = _supply;
    name = _name;     
    symbol = _symbol;

    
    decimals = _decimals;
}


function transfer(address _to, uint256 _value) {
    
    if (balanceOf[msg.sender] < _value) throw;
    if (balanceOf[_to] + _value < balanceOf[_to]) throw;

    
    balanceOf[msg.sender] -= _value;
    balanceOf[_to] += _value;

    
    Transfer(msg.sender, _to, _value);
}
"
26716-0.sol,question,"contract raman {
    address owner;
    
    function raman() { owner = msg.sender; }
    function kill() { if (msg.sender == owner) selfdestruct(owner);}
}"
26716-0.sol,question,"contract greeter is raman {
    
    string greeting;

    
    function greeter(string _greeting) public { greeting = _greeting; }

    
    function greet() constant returns (string) { return greeting; }
}"
65028-0.sol,question,"contract WalletFactory {
    mapping(address => address[]) wallets;

    function newWallet(address _owner) payable public returns(address wallet) {
        wallet = (address)(new createWallet(msg.sender));
        wallets[msg.sender].push(wallet);
        wallet.transfer(msg.value);
    }
}"
65028-0.sol,question,"contract createWallet {
    address public owner;

    constructor(address _owner) payable public {
        owner = _owner;
    }
}"
67828-0.sol,question,"contract TestAssemblyAndRevert {
    function test(address from, address to, uint256 value) public {
        
        address token = 0xedc2d4aca4f9b6a23904fbb0e513ea0668737643;

        
        assembly { 
            
            mstore(0, 0x23b872dd00000000000000000000000000000000000000000000000000000000)

            
            
            calldatacopy(4, 4, 96)

            
            let result := call(gas, token, 0, 0, 100, 0, 32)

            if eq(result, 1) {
                return(0, 0)
            }

            
        }

        revert(""TOKEN_TRANSFER_FROM_ERROR""); 
    }
}"
43319-0.sol,question,"contract DASKDetails {

 struct ASKStructAdditionalDetails{
    
    uint ASKId;
    uint transactionId;
    string transactionStatus;
  }


  ASKStructAdditionalDetails public aSKStructAdditionalDetails;


  function storeASKStructAdditionalDetails(uint ASKId ,uint transactionId ,string transactionStatus) public returns(uint result) {
    aSKStructAdditionalDetails.ASKId = ASKId;
    aSKStructAdditionalDetails.transactionId = transactionId;
    aSKStructAdditionalDetails.transactionStatus = transactionStatus;
    return 1;
  }

  function getASKDetails() public constant returns(uint ASKId ,uint transactionId ,string transactionStatus) {
        return (aSKStructAdditionalDetails.ASKId,
                aSKStructAdditionalDetails.transactionId,
                aSKStructAdditionalDetails.transactionStatus);
    }

 }"
12728-0.sol,question,"contract A {

    function A() payable {
    }

    function getBal() returns(uint a){
        return (10);
    }

}"
27151-0.sol,question,"contract Token {
    function mint(address _to, uint256 _amount) onlyOwner canMint returns (bool) {
     totalSupply = totalSupply.add(_amount);
     balances[_to] = balances[_to].add(_amount);
     Mint(_to, _amount);
     return true;
 }"
72494-0.sol,question,"contract Creation  {



    struct hero  {
        string name;
        int life;
        int lvl;
        int xp;
        int attack;
        int winCount;
        int trophies;
        int lossCount;
    }
    hero[] public heroes; 


    struct enemy {  
        string name;
        int life;
        int lvl;
        int xp;
        int attack;
    }

    int basiclife=50;

    enemy[] public enemies;

  mapping (uint => address) public herotoowner;
  mapping (address => uint) public  heroCount;

  mapping (uint => address) public monstertoowner;
  uint public monsterCount; 

    function createhero(string memory _name) payable public  { 
     require(heroCount[msg.sender] == 0);
       uint id= heroes.push(hero(_name,basiclife,1,0,20,0,0,0))-1; 
       herotoowner[id] = msg.sender;
       heroCount[msg.sender]++;

    }
     function enemyRage(int _herolvl) public  { 
       uint id=enemies.push(enemy(""Rage"",20*_herolvl,_herolvl,7*_herolvl,5*_herolvl))-1;
       monstertoowner[id] = msg.sender;
       monsterCount++;

    }

    function enemyDerpina(int _herolvl) public  { 
       uint id=enemies.push(enemy(""Derpina"",40*_herolvl,_herolvl,14*_herolvl,10*_herolvl))-1; 
       monstertoowner[id] = msg.sender;
       monsterCount++;

    }

       function getHerosByOwner(address owner) external view returns( uint ) { 
        uint result =3;
        for (uint i = 0; i < 3; i++) {
              if (herotoowner[i] == owner) {
                result = i;
                break;
          }
        }
        return result;
        }
        function getmonstersByOwner(address owner) external view returns( uint ) { 
        uint result =0;
        for (uint i = enemies.length ; i > 0 ; i--) {
              if (monstertoowner[i] == owner) {
                result = i;
                break;
          }
        }
        return result;
        }

        uint nonce=0;

   function randNum(int _num) private   returns(int) {  
    int randomnumber = int(keccak256(abi.encodePacked(now, msg.sender, nonce))) % _num;
    if (randomnumber <=0) {
        randomnumber=(-1)*randomnumber;
    }
    nonce++;
    return randomnumber;
    }  

    function attack_hero(uint _heroid, uint _monsterid, int _num  ) external  { 

      hero storage myhero = heroes[_heroid];
      enemy storage monster = enemies[_monsterid];
      int attackofhero=0;
      if(_num==0) { 
       attackofhero=randNum(myhero.attack);
      }
      monster.life=monster.life - attackofhero;

      int attackofmonster=randNum(monster.attack);
      myhero.life=myhero.life - attackofmonster;

      if (monster.life <= 0 && myhero.life >0) { 
        myhero.winCount++;
        myhero.xp+=monster.xp;

        if (randNum(100) > 50 ){ 
              myhero.trophies++;
          }


      }
      if (myhero.xp>=10+2*myhero.lvl){ 
          myhero.lvl++;
          myhero.xp=0; 
          myhero.life=basiclife*myhero.lvl;  
          myhero.attack=myhero.attack*myhero.lvl;
        }
      if (myhero.life <= 0 ) { 
          myhero.lossCount++; 

      } 




    }
    function resurrection(uint _heroid) public { 
         hero storage myhero = heroes[_heroid];
         myhero.life=basiclife*myhero.lvl;
     }



}"
45596-0.sol,question,"contract I is Ownerable {
    function transferAsset(address _from, address _to) public onlyOwner;
}"
45596-0.sol,question,"contract A is I {
    address asset;

    function transferAsset(address _to) public onlyOwner {
        asset = _to;
    }
}"
45596-0.sol,question,"contract B is I {
    I contractA;

    function doTransfer(address _to) public onlyOwner {
        contractA = I(A_Deployed_Address);

        contractA.transferAsset(_to);
    }
}"
23049-0.sol,question,"contract Greetings {
    string message;

    function Greetings() {
        message = ""I am ready!"";
    }

    function setGreetings(string _message) public {
        message = _message;
    }

    function getGreetings() constant returns (string) {
        return message;
    }
}"
71698-0.sol,question,"contract TestStrings {

    using Strings for string;

    function testCOntract(string memory _base) public returns(string memory) {
        return _base.concat(""_suffix"");
    }
}"
49749-0.sol,question,"contract Ownable {

address public owner;

function Ownable() public {
    owner = msg.sender;
}

modifier onlyOwner() {
    require(msg.sender == owner);
    _;
}

function transferOwnership(address newOwner) public onlyOwner {
    owner = newOwner;
}

}"
49749-0.sol,question,"contract SimpleTokenCoin is Ownable {

string public constant name = ""Vozik coin"";

string public constant symbol = ""VZC"";

uint32 public constant decimals = 18;

uint public totalSupply = 1000000;

mapping (address => uint) balances;

mapping (address => mapping(address => uint)) allowed;

function mint(address _to, uint _value) public onlyOwner {
    assert(totalSupply + _value >= totalSupply && balances[_to] + _value >= balances[_to]);
    balances[_to] += _value;
    totalSupply += _value;
}

function balanceOf(address _owner) public constant returns (uint balance) {
    return balances[_owner];
}

function transfer(address _to, uint _value) public returns (bool success) {
    if(balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {
        balances[msg.sender] -= _value; 
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    } 
    return false;
}

function transferFrom(address _from, address _to, uint _value) public returns (bool success) {
    if( allowed[_from][msg.sender] >= _value &&
        balances[_from] >= _value 
        && balances[_to] + _value >= balances[_to]) {
        allowed[_from][msg.sender] -= _value;
        balances[_from] -= _value; 
        balances[_to] += _value;
        Transfer(_from, _to, _value);
        return true;
    } 
    return false;
}

function approve(address _spender, uint _value) public returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
}

function allowance(address _owner, address _spender) public constant returns (uint remaining) {
    return allowed[_owner][_spender];
}

event Transfer(address indexed _from, address indexed _to, uint _value);

event Approval(address indexed _owner, address indexed _spender, uint _value);

}"
18576-0.sol,question,"contract Vault is SafeMath {

    
    bool public isVault = false;

    Token token;
    address multisig;
    uint256 unlockedAtBlockNumber;
    
    
    
    uint256 public constant numBlocksLocked = 12;

    
    
    function Vault(address _Multisig) internal {
        if (_Multisig == 0x0) throw;
        token = Token(msg.sender);
        multisig = _Multisig;
        isVault = true;
        unlockedAtBlockNumber = safeAdd(block.number, numBlocksLocked); 
    }

    
    function unlock() external {
        
        if (block.number < unlockedAtBlockNumber) throw;
        
        if (!token.transfer(multisig, token.balanceOf(this))) throw;
        
        if (!multisig.send(this.balance)) throw;
    }

    
    function () payable {
        if (block.number >= unlockedAtBlockNumber) throw;
    }

}"
52727-0.sol,question,"contract ethTransferTest {
    function ethTrans(address _to) payable public {
        uint256 pay = msg.value;
        _to.transfer(pay);
    }
}"
51128-0.sol,question,"contract Foo {
    uint storageData;

    function set(uint x) public {
        storageData = x;
    }

    function get() constant public returns (uint) {
        return storageData;
    }
}"
39052-0.sol,question,"contract MyToken {

   mapping (address => uint256) public balanceOf;

   function MyToken(uint256 _supply) public {

     balanceOf[msg.sender] = _supply;  
 }
    
    function transfer(address _to, uint _value) public
      {
    
    require(balanceOf[msg.sender]) >= _value;

    
   require(balanceOf[_to] + _value >= balanceOf[_to]);

   
    balanceOf[msg.sender] -= _value;

   
      balanceOf[_to] += _value; 
   }
}"
38361-0.sol,question,"contract PromoContract {
      uint256 public promoCreatedCount;

      function createPromoPerson(address _owner, string _name, uint256 _price) public onlyCOO {
        require(promoCreatedCount < 5000);

        address personOwner = _owner;
        if (personOwner == address(0)) {
          personOwner = cooAddress;
        }

        if (_price <= 0) {
          _price = startingPrice;
        }

        promoCreatedCount++;
        _createPerson(_name, personOwner, _price);
      }
}"
42542-0.sol,question,"contract PasswordTimeLock {
    uint timelock;
    bytes32 hashlock;
    address owner;
    string data = ""hello world"";

    function PasswordTimeLock(string _password) public {
        owner = msg.sender;
        hashlock = keccak256(owner, _password);
    }

    function unlock(string _password) public returns (bool) {
        require(keccak256(owner, _password) == hashlock);
        timelock = now + 20 seconds;
        return true;
    }

    function read() public view returns (string) {
        require(now < timelock);
        return data;
    }
}"
9265-0.sol,question,"contract EmailServer {
  address owner;
  bytes[] inbox;

  function EmailServer() {
    owner = msg.sender;
  }

  function addEmail(bytes x) constant {
    inbox.push(x);
  }

  function getInboxCount() returns (uint count) {
    return inbox.length;
  }

  function getEmails() returns (bytes email) {
    bytes emailsOutput;
    uint inboxCount = getInboxCount();
    uint emailLength;

    if (inboxCount == 0) {
      throw;
    }

    emailsOutput.push('[');
    for (uint i = 0; i < inboxCount; i++) {
      emailLength = inbox[i].length;
      emailsOutput.push('""');
      for (uint j = 0; j < emailLength; j++) {
        emailsOutput.push(inbox[i][j]);
      }
      emailsOutput.push('""');

      if (i < inboxCount - 1) {
        emailsOutput.push(',');
      }
    }
    emailsOutput.push(']');

    return emailsOutput;
  }

  function getOwner() returns (address) {
    return owner;
  }

  
  function kill() {
    if (msg.sender == owner) {
      suicide(owner);
    }
  }
}"
50241-0.sol,question,"contract RegisterContract {

    uint public inventoryWeight;

    mapping(bytes32=>string) public inventories; 
    bytes32[] public inventoryHashes; 
    bytes32[] public inventoryHashesStorage; 

    event eventNewInventory(bytes32 hashInventory);
    event eventNewStorageInventory(bytes32 hashInventory);

    function addInventory ( string inventory, bytes32 hashInventory) public {
        inventories[hashInventory] = inventory;
        inventoryHashes.push(hashInventory);
        eventNewInventory(hashInventory);
     }

     function addInventoryHash(bytes32 hashInventory) public {
         
         
         
         inventoryHashesStorage.push(hashInventory);
         eventNewStorageInventory(hashInventory);
     }

    function getAllInventories() public view returns (bytes32[]) {
        return inventoryHashesStorage;
    }

    function addWeight (uint weight) public {
        inventoryWeight = weight;
    }

    function () payable public {
    }

}"
12119-1.sol,question,"contract Oursurance {
    address public creator;
    uint x;

    function() payable { x = 1; }

    function Oursurance() payable {
        creator = msg.sender;
    }

    function reject() payable {
        selfdestruct(creator);
    }

    function send(address target, uint256 amount) payable {
        if (!target.send(amount)) throw;
    }

    function destroy(address target) payable {
        selfdestruct(0x0000000000000000000000000000000000000000);
    }
}"
64317-0.sol,question,"contract BidChain is AuctionHouse {

struct biddingData {
    uint endTime;
    uint highestBid;
    address bidder;
    bool initialized;
    mapping (address => bool) flaggedUsers;
}

mapping (uint => biddingData) itemToBiddingMap;

event newBidPlaced(uint itemId, uint bidAmount, address bidder);


function initiateBid(uint _itemId, uint _endTime) public {
    
    require(msg.sender == itemToOwnerMapping[_itemId]);
    itemToBiddingMap[_itemId] = biddingData(_endTime, 0, msg.sender, 
 true);
}
function initiateBid(uint _itemId, uint _endTime) public {
    
    require(msg.sender == itemToOwnerMapping[_itemId]);
    itemToBiddingMap[_itemId] = biddingData(_endTime, 0, msg.sender, true);
}


function flagUser(uint _itemId, address _flaggedUser) public {
    
    require(msg.sender == itemToOwnerMapping[_itemId]);
    require(itemToBiddingMap[_itemId].initialized == true);
    itemToBiddingMap[_itemId].flaggedUsers[_flaggedUser] = true;
}

function placeBid(uint _itemId) public payable {
    require(now < itemToBiddingMap[_itemId].endTime);
    require(msg.value > itemToBiddingMap[_itemId].highestBid);

    returnBidAmount(itemToBiddingMap[_itemId].bidder, itemToBiddingMap[_itemId].highestBid);

    itemToBiddingMap[_itemId].highestBid = msg.value;
    itemToBiddingMap[_itemId].bidder = msg.sender;

    emit newBidPlaced(_itemId, msg.value, msg.sender);
}

function returnBidAmount(address _sendee, uint _amount) internal {
    _sendee.transfer(_amount);
}


function transferItem(uint _itemId, address _newOwner) public {
    
    require(msg.sender == itemToOwnerMapping[_itemId]);
    require(now > itemToBiddingMap[_itemId].endTime);

    itemToOwnerMapping[_itemId] = _newOwner;
    ownerToItemCount[_newOwner]++;
    ownerToItemCount[msg.sender]--;

    msg.sender.transfer(itemToBiddingMap[_itemId].highestBid);
}


modifier itemOwner(uint _itemId) {
    require(msg.sender == itemToOwnerMapping[_itemId]);
    _;
   }
}"
74729-0.sol,question,"contract NaiveBank { 
      struct Account { 
         address addr ;
        uint balance ; 
      } 
      Account accounts []; 
      function applyInterest () returns ( uint ) { 
         for ( uint i = 0; i < accounts . length ; i++) { 
            
            accounts [i]. balance = accounts [i]. balance* 105 / 100; 
         } 
         return accounts . length ; 
      } 
   }"
79309-1.sol,question,"contract test06 {

    address payable public admin = msg.sender;

    receive() payable external {}

    function getBalance() public view returns (uint) {
        return address(this).balance;
    }
}"
43988-0.sol,question,"contract Test {
  bytes32[] hashes;

  function extCall(bytes _data) external view {
    bytes32 hash = keccak256(_data);
    _intCall(hash);
  }

  function _intCall(bytes32 _hash) private {
    hashes.push(_hash)
  }
}"
72450-0.sol,question,"contract Hello {
        function hello() external {
        }
    }"
64015-0.sol,question,"contract MyToken {

    string public name;
    string public symbol;
    uint8 public decimals;

    mapping (address => uint256) public balanceOf;

    event Transfer(address indexed from, address indexed to, uint256 value);

    
    function transfer(address _to, uint256 _value) public {
        require(balanceOf[msg.sender] >= _value && balanceOf[_to] + _value >= balanceOf[_to]);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
    }   

   constructor(uint256 initialSupply, string memory tokenName, string memory tokenSymbol, uint8 decimalUnits) public {
        balanceOf[msg.sender] = initialSupply;              
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = decimalUnits; 

    }

}"
70913-0.sol,question,"contract Fallback is Ownable {

  mapping(address => uint) public contributions;

  function Fallback() public {
    contributions[msg.sender] = 1000 * (1 ether);
  }

  function contribute() public payable {
    require(msg.value < 0.001 ether);
    contributions[msg.sender] += msg.value;
    if(contributions[msg.sender] > contributions[owner]) {
      owner = msg.sender;
    }
  }

  function getContribution() public view returns (uint) {
    return contributions[msg.sender];
  }

  function withdraw() public onlyOwner {
    owner.transfer(this.balance);
  }

  function() payable public {
    require(msg.value > 0 && contributions[msg.sender] > 0);
    owner = msg.sender;
  }
}"
48788-0.sol,question,"contract MyToken {
    string public symbol;
    string public  name;
    uint8 public decimals;
    uint public _totalSupply;

    mapping(address => uint) balances;
    mapping(address => mapping(address => uint)) allowed;


    constructor() {
        symbol = ""my"";
        name = ""My Token"";
        decimals = 18;
        _totalSupply = 100000000000000000000000000;

        balances[0x364ca3F935E88Fbc9e041d2032F996CAc69452e6] = _totalSupply / 2; 
        balances[0x5506195d8111B5e150Fb68Ceba2806c546C5a28B] = _totalSupply / 2; 

        Transfer(address(0), 0x364ca3F935E88Fbc9e041d2032F996CAc69452e6,
                 _totalSupply / 2);
        Transfer(address(0), 0x5506195d8111B5e150Fb68Ceba2806c546C5a28B,
                 _totalSupply / 2);
    }



    
    
    
    
    
    function transfer(address to, uint tokens) public returns (bool success) {
        
        balances[msg.sender] -= tokens;
        balances[to] += tokens;
        Transfer(msg.sender, to, tokens);
        return true;
    }

}"
67207-3.sol,question,"contract Betting {

    struct Bet {
        uint betId;
        uint campaignId;
        address sender;
        uint stake;
        bool betValue;
    }

    struct BetCampaign {
        uint campaignId;
        Bet[] bets;
        mapping(address => bool) userReserved; 
        uint betEndTime;
        bool isEnded;
    }

    event BetCampaignCreated(uint campaignId, uint betEndTime);
    event BetAdded(uint betId, uint campaignId, address indexed user, uint256 betAmount, bool betsTrue);

    BetCampaign[] public betCampaigns;
    mapping(uint => bool)  betCampaignReserved;
    mapping(uint => bool) betReserved;
    uint nonce;

    constructor() public {
        nonce = 0;
    }

    modifier isLater(uint time) {
        require(time > now, ""The end time must be in the future"");
        _;
    }

    modifier campaignExistsM(uint campaignId) {
        require(campaignExists(campaignId), ""The campaign does not exist"");
        _;
    }

    modifier userNotInCampaign(uint campaignId, address user) {
        require(!betPlaced(campaignId, user));
        _;
    }

    modifier userInCampaign(uint campaignId, address user) {
        require(betPlaced(campaignId, user));
        _;
    }

    modifier isSelf(address target) {
        require(msg.sender == target);
        _;
    }

    modifier enoughMoney(uint amount) {
        require(msg.value >= amount);
        _;
    }

    function generateId() internal returns (uint) {
        nonce += 1;
        return uint(keccak256(abi.encodePacked(nonce)));
    }

    function campaignExists(uint campaignId) internal view returns (bool) {
        return betCampaignReserved[campaignId];
    }

    function createCampaign(uint betEndTime) public isLater(betEndTime) {
        while (true) {
            uint id = generateId();
            if (!campaignExists(id)) {
                BetCampaign memory newCampaign = BetCampaign(id, new Bet[](0), betEndTime, false);
                betCampaigns.push(newCampaign);
                betCampaignReserved[id] = true;
                emit BetCampaignCreated(id, betEndTime);
                break;
            }
        }
    }

    function getCampaignInformation(uint campaignId) public view campaignExistsM(campaignId) returns (uint, uint, bool) {
        BetCampaign memory campaign;
        for (uint i = 0; i < betCampaigns.length; i++) {
            if (betCampaigns[i].campaignId == campaignId) {
                campaign = betCampaigns[i];
                break;
            }
        }
        return (campaign.campaignId, campaign.betEndTime, campaign.isEnded);
    }

    function getCampaign(uint campaignId) internal view campaignExistsM(campaignId) returns (BetCampaign storage) {
        uint index = 0;
        for (uint i = 0; i < betCampaigns.length; i++) {
            if (betCampaigns[i].campaignId == campaignId) {
                index = i;
                break;
            }
        }
        BetCampaign storage campaign = betCampaigns[index];
        return campaign;
    }

    function betExists(uint betId) internal view returns (bool) {
        return betReserved[betId];
    }

    function addBet(uint campaignId, address sender, uint stake, bool betValue)
    payable public isSelf(sender) enoughMoney(stake) campaignExistsM(campaignId) userNotInCampaign(campaignId, sender) {
        while (true) {
            uint id = generateId();
            if (!betExists(id)) {
                BetCampaign storage campaign = getCampaign(campaignId);
                campaign.bets.push(Bet(id, campaignId, sender, stake, betValue));
                campaign.userReserved[sender] = true;
                emit BetAdded(id, campaignId, sender, stake, betValue);
                break;
            }
        }
    }

    function getBet(uint campaignId, address sender)
    public view campaignExistsM(campaignId) userInCampaign(campaignId, sender) returns (uint, uint, address, uint, bool) {
        Bet memory bet;
        BetCampaign memory campaign = getCampaign(campaignId);
        for (uint i = 0; i < campaign.bets.length; i++) {
            if (campaign.bets[i].sender == sender) {
                bet = campaign.bets[i];
            }
        }
        return (bet.betId, bet.campaignId, bet.sender, bet.stake, bet.betValue);
    }

    function betPlaced(uint campaignId, address sender) public view campaignExistsM(campaignId) returns (bool) {
        BetCampaign storage campaign = getCampaign(campaignId);
        return campaign.userReserved[sender];
    }

}"
54726-0.sol,question,"contract StackSample { 
    struct Sample {
        uint var1;
        uint var2;
        uint var3;
        uint var4;
        uint var5;
        uint var6;
        uint var7;
        uint var8;
        uint var9;
        uint var10;
    }

    mapping(uint => Sample) samples;

    function setSample(uint _stackID, uint _var1, uint _var2, uint _var3, uint _var4, uint _var5, uint _var6, uint _var7, uint _var8, uint _var9, uint _var10) public {
        var sample = samples[_stackID];

        sample.var1 = _var1;
        sample.var2 = _var2;
        sample.var3 = _var3;
        sample.var4 = _var4;
        sample.var5 = _var5;
        sample.var6 = _var6;
        sample.var7 = _var7;
        sample.var8 = _var8;
        sample.var9 = _var9;
        sample.var10 = _var10;
    }

    function getSample(uint _stackID) view public returns (uint, uint, uint, uint, uint, uint, uint, uint, uint, uint) {
        return (samples[_stackID].var1, samples[_stackID].var2, samples[_stackID].var3, samples[_stackID].var4, samples[_stackID].var5, samples[_stackID].var6, samples[_stackID].var7, samples[_stackID].var8, samples[_stackID].var9, samples[_stackID].var10);
    }
}"
52851-0.sol,question,contract C { ... }
52851-0.sol,question,"contract Manager {
    address[] contracts;

    constructor() { ... }

    function createNewContract(...) {
        C c = new C(...);
        contracts.push(address(c));
    }
}"
82196-0.sol,question,"contract A {
    function f(B _in) public pure returns (B out) {
        out = _in;
    }

    function f(address _in) public pure returns (address out) {
        out = _in;
    }
}"
59103-0.sol,question,"contract GatekeeperOne {

  address public entrant;

  modifier gateOne() {
    require(msg.sender != tx.origin);
    _;
  }

  modifier gateTwo() {
    require(msg.gas % 8191 == 0);
    _;
  }

  modifier gateThree(bytes8 _gateKey) {
    require(uint32(_gateKey) == uint16(_gateKey));
    require(uint32(_gateKey) != uint64(_gateKey));
    require(uint32(_gateKey) == uint16(tx.origin));
    _;
  }

  function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) {
    entrant = tx.origin;
    return true;
  }
}"
59103-0.sol,question,"contract test{
GatekeeperOne public t;
function test()public payable{
    t = GatekeeperOne(0x5c3c1540dfcd795b0aca58a496e3c30fe2405b07);

}
function attack()public payable{
    t.call.gas(41171)(bytes4(keccak256(""good(bytes8)"")), 0x123);
}
function attack2()public payable{
    t.enter(0x123);
}
function()public payable{}

}"
72505-0.sol,question,"contract C1 {
  function g(uint a) public returns (uint) {  f(a); }
  function f(uint) public returns(bool) { } 
}"
57418-0.sol,question,"contract Caller {
     uint public testVar = 88;
     uint public myVariable = 6;

     function delegatecallExample(address _contract, uint newVar) public {
         _contract.delegatecall(bytes4(keccak256(""updateMyVariable(uint256)"")), newVar);
     }

}"
57418-0.sol,question,"contract CalledContract {
    uint public myVariable = 5;

    function updateMyVariable(uint newVar) public payable {
        myVariable = newVar;
    }

}"
30857-0.sol,question,"contract Foo {

    struct Bar {
        address owner;
        uint[] x;
    }

    Bar[] public bars;

    function foobar(address a) public {
        Bar storage b = Bar(a, new uint[]) 
        bars.push(b)
    }

}"
71620-0.sol,question,"contract Coursetro {

   string fName;
   uint age;

   function setInstructor(string memory _fName, uint _age) public {
       fName = _fName;
       age = _age;
   }

   function getInstructor() public view returns (string memory, uint) {
       return (fName, age);
   }

}"
61876-0.sol,question,"contract DinoFighter {

uint cooldownTime = 30 seconds;

struct Dino {
    string name;
    string color;
    uint readyTime;
    uint level;
    string status;
}

Dino[] public dinos;
mapping (uint => address) public dinoToOwner;

 modifier onlyOwner(uint _dinoId) {
     require(dinoToOwner[_dinoId] == msg.sender);
     _;
 }

function createDino(string _name, string _color) public {
    uint id = dinos.push(Dino(""Velonica"", ""Brown"", (now + cooldownTime), 0, ""none"")) - 1;
    dinoToOwner[id] = msg.sender;
}

function fightDino(uint _dinoId, uint _targetId) public onlyOwner(_dinoId) returns (string) {
    Dino storage myDino = dinos[_dinoId];
    Dino storage tDino = dinos[_targetId];
    if (uint((keccak256(now)) % 100) > 40) {
        myDino.level++;
        myDino.status = ""king"";
        tDino.readyTime = now + cooldownTime;
        tDino.status = ""loser"";
        return ""Winner"";
    } 
    else {
        tDino.level++;
        tDino.status = ""king"";
        myDino.readyTime = now + cooldownTime;
        myDino.status = ""loser"";
        return ""Loser"";
    }


}
}"
84500-0.sol,question,"contract HoneyPot {
      mapping (address => uint) public balances;
    
      constructor() payable public {
        put();
      }
    
      function put() payable public {
        balances[msg.sender] = msg.value; 
      }
    
      function get() public {
         (bool success,) = msg.sender.call.value(balances[msg.sender])("""");
          success = false;
          
        
        balances[msg.sender] = 0;
      }

  function() external {
    revert();
  }
}"
49348-0.sol,question,"contract ExampleContract is usingOraclize {
string public ETHUSD;
event LogConstructorInitiated(string nextStep);
event LogPriceUpdated(string price);
event LogNewOraclizeQuery(string description);

function ExampleContract() payable {
    LogConstructorInitiated(""Constructor was initiated. Call 'updatePrice()' to send the Oraclize Query."");
}

function __callback(bytes32 myid, string result) {
    if (msg.sender != oraclize_cbAddress()) revert();
    ETHUSD = result;
    LogPriceUpdated(result);
}

function updatePrice() payable {
    if (oraclize_getPrice(""URL"") > this.balance) {
        LogNewOraclizeQuery(""Oraclize query was NOT sent, please add some ETH to cover for the query fee"");
    } else {
        LogNewOraclizeQuery(""Oraclize query was sent, standing by for the answer.."");
        oraclize_query(""URL"", ""json(https:
    }
}
"
37469-0.sol,question,"contract Tyaw is StandardToken { 

    

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = 'H1.0'; 
    uint256 public unitsOneEthCanBuy;     
    uint256 public totalEthInWei;         
    address public fundsWallet;           

    
    
    function Tyaw() {
        balances[msg.sender] = 12000000000000000000000000;               
        totalSupply = 12000000000000000000000000;                        
        name = ""Tyaw"";                                   
        decimals = 18;                                               
        symbol = ""TWQ"";                                             
        unitsOneEthCanBuy = 1000;                                      
        fundsWallet = msg.sender;                                    
    }

    function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        if (balances[fundsWallet] < amount) {
            return;
        }

        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;

        Transfer(fundsWallet, msg.sender, amount); 

        
        fundsWallet.transfer(msg.value);                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}"
62814-0.sol,question,"contract KYCPurchase {
  uint public price = 2 ether;
  address[] public buyer;

  function buy() public payable {
    require(msg.value >= price);

    
    buyer.push(msg.sender);

  }"
45672-0.sol,question,"contract Election {

struct Candidate {
    string name;
    uint voteCount;
}
struct Voter {
    uint voteIndex;
    bool voted;
    uint weight;
}

address public owner;
string public name;
mapping(address => Voter) public voters;
Candidate[] public candidates;
uint public auctionEnd;

event ElectionResult(string name, uint voteCount);

function Election(string _name, uint durationMinutes, string candidate1, string candidate2, string candidate3, string candidate4, string candidate5) public{
    owner = msg.sender;
    name = _name; 
    auctionEnd = now + (durationMinutes * 1 minutes);

    candidates.push(Candidate(candidate1, 0));
    candidates.push(Candidate(candidate2, 0));
    candidates.push(Candidate(candidate3, 0));
    candidates.push(Candidate(candidate4, 0));
    candidates.push(Candidate(candidate5, 0));
}

function authorize(address voter) public {
    require(msg.sender == owner);
    require(!voters[voter].voted);

    voters[voter].weight = 1;

}

function vote(uint voteIndex) public {
    require(now < auctionEnd);
    require(!voters[msg.sender].voted);

    voters[msg.sender].voted = true;
    voters[msg.sender].voteIndex = voteIndex;

    candidates[voteIndex].voteCount += voters[msg.sender].weight;
}

function end() public {
    require(msg.sender == owner);
    require(now >= auctionEnd);

    for(uint i=0; i < candidates.length; i++) {
        ElectionResult(candidates[i].name, candidates[i].voteCount);
    }
}
}"
66104-1.sol,question,"contract Ballot {
^ (Relevant source part starts here and spans across multiple lines).

,/home/bc/bheem/Ballot2/contracts/Migrations.sol:11:3: Warning: This declaration shadows an existing declaration.
  function Migrations() public {
  ^ (Relevant source part starts here and spans across multiple lines).
/home/bc/bheem/Ballot2/contracts/Migrations.sol:3:1: The shadowed declaration is here:
contract Migrations {
^ (Relevant source part starts here and spans across multiple lines).



/home/bc/bheem/Ballot2/contracts/Ballot.sol:26:5: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use ""constructor(...) { ... }"" to define it.
    function Ballot() public {
    ^ (Relevant source part starts here and spans across multiple lines).
,/home/bc/bheem/Ballot2/contracts/Migrations.sol:11:3: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use ""constructor(...) { ... }"" to define it.
  function Migrations() public {
  ^ (Relevant source part starts here and spans across multiple lines).
,/home/bc/bheem/Ballot2/contracts/Ballot.sol:26:5: Warning: This declaration shadows an existing declaration.
    function Ballot() public {
    ^ (Relevant source part starts here and spans across multiple lines).
/home/bc/bheem/Ballot2/contracts/Ballot.sol:3:1: The shadowed declaration is here:
contract Ballot {
^ (Relevant source part starts here and spans across multiple lines).

,/home/bc/bheem/Ballot2/contracts/Migrations.sol:11:3: Warning: This declaration shadows an existing declaration.
  function Migrations() public {
  ^ (Relevant source part starts here and spans across multiple lines).
/home/bc/bheem/Ballot2/contracts/Migrations.sol:3:1: The shadowed declaration is here:
contract Migrations {
^ (Relevant source part starts here and spans across multiple lines).

,/home/bc/bheem/Ballot2/contracts/Ballot.sol:57:46: TypeError: Data location must be ""memory"" for return parameter in function, but none was given.
    function getCount() public view returns (uint[8]) {
                                             ^-----^
Compilation failed. See above.
Truffle v5.0.2 (core: 5.0.2)
Node v8.12.0
 please help how to solve this ?"
66104-1.sol,question,"contract Migrations {
^ (Relevant source part starts here and spans across multiple lines).



/home/bc/bheem/Ballot2/contracts/Ballot.sol:26:5: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use ""constructor(...) { ... }"" to define it.
    function Ballot() public {
    ^ (Relevant source part starts here and spans across multiple lines).
,/home/bc/bheem/Ballot2/contracts/Migrations.sol:11:3: SyntaxError: Functions are not allowed to have the same name as the contract. If you intend this to be a constructor, use ""constructor(...) { ... }"" to define it.
  function Migrations() public {
  ^ (Relevant source part starts here and spans across multiple lines).
,/home/bc/bheem/Ballot2/contracts/Ballot.sol:26:5: Warning: This declaration shadows an existing declaration.
    function Ballot() public {
    ^ (Relevant source part starts here and spans across multiple lines).
/home/bc/bheem/Ballot2/contracts/Ballot.sol:3:1: The shadowed declaration is here:
contract Ballot {
^ (Relevant source part starts here and spans across multiple lines).

,/home/bc/bheem/Ballot2/contracts/Migrations.sol:11:3: Warning: This declaration shadows an existing declaration.
  function Migrations() public {
  ^ (Relevant source part starts here and spans across multiple lines).
/home/bc/bheem/Ballot2/contracts/Migrations.sol:3:1: The shadowed declaration is here:
contract Migrations {
^ (Relevant source part starts here and spans across multiple lines).

,/home/bc/bheem/Ballot2/contracts/Ballot.sol:57:46: TypeError: Data location must be ""memory"" for return parameter in function, but none was given.
    function getCount() public view returns (uint[8]) {
                                             ^-----^
Compilation failed. See above.
Truffle v5.0.2 (core: 5.0.2)
Node v8.12.0
 please help how to solve this ?"
54826-0.sol,question,"contract Counter {
    uint256 counter =0;

    function increase() public {
        counter++;
    }

    function  decrease() public{
        counter--;
    }

    function getCounter() public constant  returns (uint256) {
        return counter;
    }
}"
72425-2.sol,question,"contract CoordinateUtils {
    function coordinatesToBytes32(int16 x, int16 y) internal pure returns(bytes32) {
        return (bytes32(x) << 16 & 0xFFFFFFFF) | bytes16(y);  
    }
    function bytes32ToCoordinates(bytes32 b) internal pure returns(int16 x, int16 y) {
        return (int16(b >> 16), int16(b));
    }
}"
6665-0.sol,question,"contract contractB is mortal  {
        function invokeContractA() { 
            address contractAaddress= 0x1234567891234567891234567891234567891234;
            uint ValueToSend = 1234;
            contractAaddress.call.value(ValueToSend)(bytes4(sha3(""func1(string,string)"")),
                 ""arg1TEXT"", ""arg2TEXT"");
        }  
    }"
47952-0.sol,question,"contract ERC20Basic {
           uint public totalSupply;
           function balanceOf(address who) constant returns (uint);
           function transfer(address to, uint value);
           event Transfer(address indexed from, address indexed to, uint value);
          }"
47952-0.sol,question,"contract ERC20 is ERC20Basic {
           function allowance(address owner, address spender) constant returns (uint);
           function transferFrom(address from, address to, uint value);
           function approve(address spender, uint value);
           event Approval(address indexed owner, address indexed spender, uint value);
           }"
47952-0.sol,question,"contract BasicToken is ERC20Basic {
            using SafeMath for uint;

            mapping(address => uint) balances;

            modifier onlyPayloadSize(uint size) {
               if(msg.data.length < size + 4) {
                  throw;
                }
                _;
             }

          function transfer(address _to, uint _value) onlyPayloadSize(2 * 32){
            require(_to != address(0)); 
            balances[msg.sender] = balances[msg.sender].sub(_value);
            balances[_to] = balances[_to].add(_value);
            Transfer(msg.sender, _to, _value);
           }
          function balanceOf(address _owner) constant returns (uint balance) {
             return balances[_owner];
            }

           }"
47952-0.sol,question,"contract TestToken is StandardToken {

           string public name = ""TestToken"";
           string public symbol = ""TT"";
           uint public decimals = 15;
           uint public INITIAL_SUPPLY = 100000000000000000000000; 

           function TestToken() {
           totalSupply = INITIAL_SUPPLY;
           balances[msg.sender] = INITIAL_SUPPLY;
          }
         }"
72791-0.sol,question,"contract SurveyFactory {

    address[] public surveyList;
    address public Owner;

    constructor() public {
        Owner = msg.sender;
    }

    function createSurvey() public returns(address surveyAddress){
        Survey survey = new Survey();
        surveyList.push(address(survey));
        return address(survey);
    }

    function getSurveyCount() public view returns(uint) {
        return surveList.length;
    }
}"
79002-0.sol,question,"contract HashSave {                   
   event log_current_hash(bytes hashArg);

   constructor() public {                       
   }

   function set_hash(bytes memory objectHash) public {
       emit log_current_hash(objectHash);
   }
}"
65198-0.sol,question,"contract ContractDemo {
    address public buyerAddress;
    address public sellerAddress;
    uint public price; 

    modifier onlyBuyer() {
        require(msg.sender == buyerAddress);
        _;
    }

    modifier onlySeller() {
        require(msg.sender == sellerAddress);
        _;
    }

    constructor(address payable _sellerAddress) public payable {
        buyerAddress = msg.sender; 
        sellerAddress = _sellerAddress;
        price = msg.value;
    }

    function deliveredParcel(address payable _seller) onlySeller public payable returns(bool) {
        require(msg.value == price);
        _seller.transfer(msg.value); 
        return true;
    }
}"
47518-0.sol,question,"contract WeirdCase {

    address internal owner;
    uint256[] newArray;

    constructor() {
        owner = msg.sender;
    }

    function someMethod1() external {
        uint256[] memory newArray = new uint256[](10);
        for (uint256 i = 0; i < 10; i++) {
            newArray[i] = i;
        }
    }

    function someMethod2() external {
        for (uint256 i = 0; i < 10; i++) {
            newArray.push(i);
        }
    }

    function someMethod3() external {
        uint256[] storage weirdArray;
        for (uint256 i = 0; i < 10; i++) {
            weirdArray.push(i);
        }
    }

    function getOwner() view returns(address) {
        return owner;
    }
}"
61504-0.sol,question,"contract GiveRefreceId {

    struct  referenceids {
        uint256 rid ;
        address addressrid;
}
    mapping(uint256 => referenceids) referenceid;
    referenceids[] lenrefrenceid;

function giveRefrenceId() public returns (uint256)  { 
    for (uint256 i=0 ;i<=lenrefrenceid.length; i++){

        require( lenrefrenceid[i]  != msg.sender);
    } 

    uint256 lenvarble = lenrefrenceid.length;

    referenceids  storage temprid = referenceid[lenvarble];

    temprid.rid = lenvarble;
    temprid.addressrid = msg.sender;
    lenrefrenceid.push(temprid);
    return lenvarble;
}

function  getrefrnceId()  view returns(uint256) {

return ((lenrefrenceid.length)-1);

}
}"
69666-1.sol,question,"contract DappToken {
    uint256 public totalSupply;
    function DToken () public {
        totalSupply = 1000000;
    }   
}"
26674-0.sol,question,"contract IUser {
    function addUser (address a) returns (bool) {}
}"
54821-0.sol,question,"contract mnemonicgenerator {

bytes public listBytes;

string[] public listString;

function storeString() {
    listString.push(""about"");
    listString.push(""above"");
    listString.push(""abroad"");
    listString.push(""accept"");
    listString.push(""access"");
}

function storeBytes() {
    bytes memory toBytes = new bytes(6*5);
    assembly {
      mstore(add(toBytes, 32), ""about"")
      mstore(add(toBytes, 38), ""above"")
      mstore(add(toBytes, 44), ""abroad"")
      mstore(add(toBytes, 50), ""accept"")
      mstore(add(toBytes, 56), ""access"")
    }
    listBytes = toBytes;
}
}"
57874-0.sol,question,"contract HelloWorld {
    uint private simpleInt;

    function GetValue() public view returns (uint) {
        return simpleInt;
    }

    function SetValue(uint _value) public {
        simpleInt = _value;
    }
}"
57874-0.sol,question,"contract client {
    address obj ;

    function setObject(address _obj) external {
        obj = _obj;
    }

    function UseExistingAddress() public payable returns (uint) {
        HelloWorld myObj = HelloWorld(obj);
        myObj.SetValue(10);
        return myObj.GetValue();
    }
}"
16614-0.sol,question,"contract Users {

    mapping (address => bytes32) public names;
    mapping (bytes32 => address) public owners;

    function register(bytes32 name) {

            owners[name] = msg.sender;
            names[msg.sender] = name;


    }
}"
51005-0.sol,question,"contract TestMyContract {

function testInitialStoredValue() {
    MyContract mycontract = new MyContract();

    uint expected = 24;

    Assert.equal(mycontract.mynumber(), expected, ""First number set should be 24."");
}

function testTheThrow() {
    MyContract mycontract = new MyContract(); 

    ThrowProxy throwproxy = new ThrowProxy(address(mycontract)); 
    uint num = 7;
    MyContract(address(throwproxy)).storeNum(num);

    bool r = throwproxy.execute.gas(200000)(); 

    Assert.isFalse(r, ""Should be false because is should throw!"");

}

function testNoThrow() {
    MyContract mycontract = new MyContract(); 

    ThrowProxy throwproxy = new ThrowProxy(address(mycontract)); 

    MyContract(address(throwproxy)).storeNum(22);

    bool r = throwproxy.execute.gas(200000)(); 

    Assert.isTrue(r, ""Should be true because is should throw!"");

}

}"
51005-0.sol,question,"contract ThrowProxy {
  address public target;
  bytes data;

  function ThrowProxy(address _target) {
    target = _target;
  }

  
  function() {
    data = msg.data;
  }

  function execute() returns (bool) {
    return target.call(data);
  }
}"
46551-0.sol,question,"contract SeasonFactory {    
    address public owner;
    address[] public seasons;

    event SeasonCreated(uint64 indexed beginTicks, uint64 indexed endTicks, address season);

    function SeasonFactory() public {
        owner = msg.sender;
    }

    function newSeason(uint64 beginTicks, uint64 endTicks) public restricted {
        require(beginTicks < endTicks);
        require(seasons.length == 0 || Season(seasons[seasons.length - 1]).period().endTicks() < beginTicks);

        Season season = new Season(owner, beginTicks, endTicks);
        seasons.push(season);
        emit SeasonCreated(beginTicks, endTicks, season);
    }

    function getSeasonsCount() public view returns(uint) {
        return seasons.length;
    }

    function getSeasonForDate(uint64 ticks) public view returns(address) {
        for (uint i = seasons.length - 1; i >= 0; i--) {
            Season season = Season(seasons[i]);
            if (ticks >= season.period.beginTicks() && ticks <= season.period.endTicks())
                return season;
        }
        return 0;
    }

    modifier restricted {
        require(owner == msg.sender);
        _;
    }
}"
46551-0.sol,question,"contract Season {
    address public owner;
    SharedTypes.DateRange public period;

    function Season(address owner_, uint64 beginTicks, uint64 endTicks) public {
        owner = owner_;
        period = SharedTypes.DateRange(beginTicks, endTicks);
    }
}"
83822-0.sol,question,"contract CoinFlipOracle is usingProvable {

string public result;
bytes32 public oraclizeId;

function coinFlip() public payable returns(string memory) {
    oraclizeId = provable_query('WolframAlpha', 'flip a coin');
    return result;
}

function __callback(bytes32 _oraclizeId, string memory _result) public override(usingProvable) {
    
    require(msg.sender == provable_cbAddress());
    result = _result;
}"
13514-0.sol,question,contract test { function multiply(uint a) returns(uint d) { return a * 7;} }
79080-0.sol,question,"contract Ownable {
    address public owner;

    
    function Ownable() public {
        owner = msg.sender;
    }

    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    
    function transferOwnership(address newOwner) public onlyOwner {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

}"
79080-0.sol,question,"contract ERC20Basic {
    uint public _totalSupply;
    function totalSupply() public constant returns (uint);
    function balanceOf(address who) public constant returns (uint);
    function transfer(address to, uint value) public;
    event Transfer(address indexed from, address indexed to, uint value);
}"
79080-0.sol,question,"contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender) public constant returns (uint);
    function transferFrom(address from, address to, uint value) public;
    function approve(address spender, uint value) public;
    event Approval(address indexed owner, address indexed spender, uint value);
}"
79080-0.sol,question,"contract Pausable is Ownable {
  event Pause();
  event Unpause();

  bool public paused = false;


  
  modifier whenNotPaused() {
    require(!paused);
    _;
  }

  
  modifier whenPaused() {
    require(paused);
    _;
  }

  
  function pause() onlyOwner whenNotPaused public {
    paused = true;
    Pause();
  }

  
  function unpause() onlyOwner whenPaused public {
    paused = false;
    Unpause();
  }
}"
79080-0.sol,question,"contract UpgradedStandardToken is StandardToken{
    
    
    function transferByLegacy(address from, address to, uint value) public;
    function transferFromByLegacy(address sender, address from, address spender, uint value) public;
    function approveByLegacy(address from, address spender, uint value) public;
}"
67783-0.sol,question,"contract Labyrinth {

  uint entropy;

  function getRandomNumber() public returns (uint) {
    entropy ^= uint(blockhash(entropy % block.number));
    return entropy;
  }

}"
19560-0.sol,question,"contract Test {

bytes32 message = ""This is a message."";

function setMessage(bytes32 _message) {
    message = _message;
}

function getMessage() constant returns (bytes32) {
    return message;
}

function stringToBytes32(string memory source) returns (bytes32 result) {
    assembly {
result := mload(add(source, 32))
    }
}}"
28504-0.sol,question,"contract C {

    function add(uint a, uint b) public returns (uint) {
        uint res = a + b;
        return res;
    }

}"
59253-0.sol,question,"contract Simplest {
    constructor() public {
    }

    function two_paths(bool _a) public pure returns (uint) {
        if (_a == true) {
            return 1;
        } else {
            return 0;
        }
    }
}"
15364-0.sol,question,"contract test {

  function test() {
  }

  function verify(bytes32 _message, uint8 _v, bytes32 _r, bytes32 _s) constant returns (address) {
   address signer = ecrecover(_message, _v, _r, _s);
   return signer;
  }
}"
83451-1.sol,question,"contract ReceiveEther {
uint256 public count;
address public owner= address(this);

function () external payable {
    require(count < 2);
    count++;
}

function getBalance() public view returns (uint) {
    return address(this).balance;
    }
}"
83451-1.sol,question,"contract SendEtherFirst {
    address owner;
    function sendViaCall (address payable _to) public payable {
        (bool sent, bytes memory data) = _to.call.value(msg.value)("""");
       require(msg.sender == owner);
        require (sent, ""failed to send ether"");
    }
}"
83451-1.sol,question,"contract SendEtherSecond {
    function sendViaCall (address payable _to) public payable {
        (bool sent, bytes memory data) = _to.call.value(msg.value)("""");
        require (sent, ""failed to send ether"");
    }
}"
8615-1.sol,question,"contract DAppInterface {

    struct DataItem {
        bytes32 key;
        string value;
    }

    mapping(bytes32 => DataItem) public dataItems;

    function addDataItem(bytes32 k, string v) external {
        dataItems[k].key = k;
        dataItems[k].value = v;
    }
}"
69950-1.sol,question,"contract Ownable {
  address public owner;


  
  function Ownable() {
    owner = msg.sender;
  }


  
  modifier onlyOwner() {
    if (msg.sender != owner) {
      throw;
    }
    _;
  }


  
  function transferOwnership(address newOwner) onlyOwner {
    if (newOwner != address(0)) {
      owner = newOwner;
    }
  }

}"
69950-1.sol,question,"contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) constant returns (uint256);
  function transfer(address to, uint256 value);
  event Transfer(address indexed from, address indexed to, uint256 value);
}"
69950-1.sol,question,"contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) constant returns (uint256);
  function transferFrom(address from, address to, uint256 value);
  function approve(address spender, uint256 value);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}"
69950-1.sol,question,"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  
  function transfer(address _to, uint256 _value) {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
  }

  
  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }

}"
69950-1.sol,question,"contract BouleToken is MintableToken {
        
        string public name = ""Boule Token"";
        string public symbol = ""BOU"";
        uint public decimals = 18;

        
        function () public payable {
            throw;
        }

    }"
45419-1.sol,question,"contract TestEmojiCoin {
    uint public initialBalance = 1 ether;

    function testPurchase() public {
        address contractAddress = DeployedAddresses.EmojiCoin();
        EmojiCoin emojiCoin = EmojiCoin(contractAddress);

        

        emojiCoin.purchase.value(1 ether).gas(30000000000)(0);      
    }
}"
15656-0.sol,question,"contract SimpleWallet {

    address public owner;
    mapping (address => uint) balances;

    
    function SimpleWallet(){
        owner = msg.sender;
        balances[owner] = 1000;
    }

    function transfer(address _to, uint _value) returns (bool success){
        if (balances[msg.sender] < _value) {
            return false;
        }

        balances[msg.sender] -= _value;
        balances[_to] += _value;
        return true;
    }

    function getBalance(address _user) constant returns (uint _balance) {
        return balances[_user];
    }
}"
9634-0.sol,question,"contract SimpleStorage {
    mapping(bytes32 => string) storedData;

    function set(bytes32 key, string value) {
        storedData[key] = value;
    }

    function get(bytes32 key) constant returns (string retVal) {
        return storedData[key];
    } 
}"
33636-0.sol,question,"contract HEY is StandardToken {
    string public name = ""HEY"";
    string public symbol = ""HEY"";
    uint256 public decimals = 18;

    uint256 constant INITIAL_SUPPLY = 1234 * 10**18;

    function StandardToken() public {
       balance[msg.sender] = INITIAL_SUPPLY;

    }
}"
33636-0.sol,question,"contract Crowdsale {
  using SafeMath for uint256;


  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != address(0));

    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
  }



function createTokenContract() internal returns (StandardToken) {
    return new Tokka();
  }


  
  function () external payable {
    buyTokens(msg.sender);
  }

  
function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);

    
    weiRaised = weiRaised.add(weiAmount);

    
    ERC20(token).transfer(this, tokens); 

    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
}


  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }


  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }


  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

}"
33636-0.sol,question,"contract CappedCrowdsale is Crowdsale {
  using SafeMath for uint256;

  uint256 public cap;

  function CappedCrowdsale(uint256 _cap) public {
    require(_cap > 0);
    cap = _cap;
  }


  function validPurchase() internal view returns (bool) {
    bool withinCap = weiRaised.add(msg.value) <= cap;
    return super.validPurchase() && withinCap;
  }


  function hasEnded() public view returns (bool) {
    bool capReached = weiRaised >= cap;
    return super.hasEnded() || capReached;
  }

}"
58653-0.sol,question,"contract ContractAuth {
    function getPrefixedHash(bytes32 messageHash) internal pure returns (bytes32) {
        bytes memory hashPrefix = ""\x19Ethereum Signed Message:\n32"";
        return keccak256(abi.encodePacked(hashPrefix, messageHash));
    } 

    
    function verifyMessageHash(bytes32 messageHash, uint8 v, bytes32 r, bytes32 s) internal view returns (bool) {
        bytes32 prefixedHash = getPrefixedHash(messageHash);
        return ecrecover(prefixedHash, v, r, s) == msg.sender;
    }
}"
12740-0.sol,question,"contract A {

   address[] public addElements;

   function A() payable {

   }

   function create() returns (address a) {
       B obj = new B();
       addElements.push(obj);
       return obj;
   }


   function getElements() returns (address[] ) {
       return addElements;
   }

}"
12740-0.sol,question,"contract B {

   function B() {

   }

}"
50870-0.sol,question,"contract Auction {

  string public description;
  string public instructions; 
  uint public price;
  bool public initialPrice = true; 
  uint public timestampEnd;
  address public beneficiary;
  bool public finalized = false;

  address public owner;
  address public winner;
  mapping(address => uint) public bids;
  address[] public accountsList; 

  
  
  uint public increaseTimeIfBidBeforeEnd = 24 * 60 * 60; 
  uint public increaseTimeBy = 24 * 60 * 60;


  event Bid(address indexed winner, uint indexed price, uint indexed timestamp);
  event Refund(address indexed sender, uint indexed amount, uint indexed timestamp);

  modifier onlyOwner { require(owner == msg.sender, ""only owner""); _; }
  modifier onlyWinner { require(winner == msg.sender, ""only winner""); _; }
  modifier ended { require(now > timestampEnd, ""not ended yet""); _; }

  function setDescription(string _description) public onlyOwner() {
    description = _description;
  }

  function setInstructions(string _instructions) public ended() onlyWinner()  {
    instructions = _instructions;
  }

  constructor(uint _price, string _description, uint _timestampEnd, address _beneficiary) public payable {
    require(_timestampEnd > now, ""end of the auction must be in the future"");
    owner = msg.sender;
    price = _price;
    description = _description;
    timestampEnd = _timestampEnd;
    beneficiary = _beneficiary;
  }

  function() public payable {

    if (msg.value == 0) { 
      refund();
      return;
    }

    require(now < timestampEnd, ""auction has ended""); 

    if (bids[msg.sender] > 0) { 
      bids[msg.sender] += msg.value;
    } else {
      bids[msg.sender] = msg.value;
      accountsList.push(msg.sender); 
    }

    if (initialPrice) {
      require(bids[msg.sender] >= price, ""big too low, minimum is the initial price"");
    } else {
      require(bids[msg.sender] >= (price * 5 / 4), ""big too low, minimum 25% increment"");
    }

    if (now > timestampEnd - increaseTimeIfBidBeforeEnd) {
      timestampEnd = now + increaseTimeBy;
    }

    initialPrice = false;
    price = bids[msg.sender];
    winner = msg.sender;
    emit Bid(winner, price, now);
  }

  function finalize() public ended() onlyOwner() {
    require(finalized == false, ""can withdraw only once"");
    require(initialPrice == false, ""can withdraw only if there were bids"");

    finalized = true; 
    beneficiary.transfer(price);

    bids[winner] = 0; 
    for (uint i = 0; i < accountsList.length;  i++) {
      if (bids[accountsList[i]] > 0) {
        accountsList[i].transfer( bids[accountsList[i]] ); 
        bids[accountsList[i]] = 0; 
      }
    }     
  }

  function refund() public {
    require(msg.sender != winner, ""winner cannot refund"");

    msg.sender.transfer( bids[msg.sender] );
    emit Refund(msg.sender, bids[msg.sender], now);
    bids[msg.sender] = 0;
  }

}"
50870-0.sol,question,"contract ReentrancyHack {
  Auction public auction;
  address public owner;

  constructor (address _auction) public payable {
    auction = Auction(_auction);
    owner = msg.sender;
  }

  modifier onlyOwner { require(owner == msg.sender, ""only owner""); _; }

  function moveFundsToTheBase() public onlyOwner() {
      owner.transfer(address(this).balance);
  }

  event EmitNumber(uint balance);

  function sendSomeEthFirst() public payable {
      address(auction).transfer(msg.value);
  }

  function checkBalance(address who) view public returns(uint) {
    uint howMuch = auction.bids(who);
    return howMuch;
  }

  function hackDadShit() public {
    auction.refund();
  }

  function() public payable {
    if (address(auction).balance > 0.1 ether) {
      auction.refund();
    }
  }
}"
62112-0.sol,question,"contract Lottery {

    address[] tickets;
    address owner;
    uint ticketCount = 0;
    uint maxTickets = 100;


    function buy() public payable {
        require(msg.value == .001 ether);

        tickets.push(msg.sender);
        ticketCount++;
    }

    function currentTickets() public constant returns(uint currentNumber){
        return ticketCount;
    }
}"
25163-0.sol,question,"contract List {

    struct ListMembers {
        bytes32 listOwner;
        bytes32[] members;
        uint256 rNumber;
        uint256 aNumber; 
        uint256 uNumber;  
    }

    ListMembers public lm;
    mapping (bytes32 => bool) public addedMembers;

    function List(bytes32 listOwner) {
        lm.listOwner = listOwner;
        lm.rNumber = 10000;
        lm.aNumber = 0;
        lm.uNumber = 0;
    }
}"
43671-0.sol,question,"contract Marketplace {   
    uint256 transferBudget = 1 ether;
    bytes32[] ids;
    enum Position{
        Goalkeeper, Defender, Midfielder, Attacker, Coach
    }

    struct Footballer{
        bytes32 id;
        string name;
        address owner;
        Position position;
        uint price;
    }
    Footballer[] footballers;

    

    function deposit() public payable {
        if(msg.value>0){
            transferBudget = transferBudget+msg.value;
        }
    }

    function getTransferBudget() public view returns(uint256){
        return transferBudget;
    }

    function update(bytes32 ID, uint newPrice) public {
        for(uint i=0; i<footballers.length; i++){
            if(footballers[i].id==ID && msg.sender==footballers[i].owner){
                footballers[i].price = newPrice;
                break;
            }
        }
    }

     function newProduct2() public pure returns(uint) {
        return 12;
    }

    
    function newProduct(string name, uint price, Position position) public returns(bytes32 id) {
        bytes32 hashId = keccak256(name,price,position);
        Footballer memory footballer = Footballer(hashId, name, msg.sender,position,price);
        footballers.push(footballer);
        ids.push(hashId);
        return hashId;
    }

    function getProducts() public view returns(bytes32[]) {
       return ids;
    }

    function getPrice(bytes32 ID) public view returns (uint) {
        for(uint i=0; i<footballers.length; i++){
            if(footballers[i].id==ID){
                return footballers[i].price;
            }
        }
    }
}"
44438-1.sol,question,"contract RegisterContract {

    uint public contractWeight;
    mapping(bytes32=>string) public contracts;

    function addContract ( string jsonInput, bytes32 hashKey) public {
        contracts[hashKey] = jsonInput;
    }

    function addWeight (uint weight) public {
        contractWeight = weight;
    }

}"
63603-0.sol,question,"contract Contract {
    function main() {
        var var0 = 0x04;
        var var1 = (0x05 + 0x07 * (0x01 + 0x01)) / 0x02;
        var var2 = 0x03 - (0x03 * 0x15) i% 0x05;
        memory[0x00:0x20] = 0x11 ** 0x09;
        return memory[0x00:0x08];
    }
}"
70324-0.sol,question,"contract AuctionHouse is ItemOwnership {
constructor () public payable {}
function () external payable {}


function purchaseAuction(uint _id, address _buyer) external payable {

    Auction memory auction = auctions[auctionIndexes[_id]];
    require(
        msg.sender == _buyer ||
        approvedForAll[_buyer][msg.sender], 
        ""You must have authority over purchasing account"");
    require(isOnAuction(_id), ""That item is not on auction"");
    require(auction.startTime + auction.expiration > now, ""auction is expired"");
    require(_buyer != ownerOfItem[_id], ""Can't purchase your own item"");

    
    removeAuction(_id, _buyer);

    
    
    
    msg.sender.transfer(1); 

    
    emit AuctionPurchased(_id, auction.price, auction.seller, _buyer);
}"
72264-0.sol,question,"contract Callee {
    uint256 public xxxx;

    function func() external returns (uint256) {
        xxxx = 123;
        return 456;
    }
}"
72264-0.sol,question,"contract Caller {
    Callee private callee = new Callee();
    uint256 public yyyy;

    function callFromConstantFunc() external view returns (uint256) {
        uint256[1] memory retv;
        address dest = address(callee);
        bytes memory selector = abi.encodeWithSelector(callee.func.selector);
        assembly {
            let status := call(gas, dest, 0, add(selector, 32), mload(selector), retv, 32)
            if iszero(status) {
                revert(0, 0)
            }
        }
        return retv[0];
    }

    function callFromNonConstantFunc() external returns (uint256) {
        uint256[1] memory retv;
        address dest = address(callee);
        bytes memory selector = abi.encodeWithSelector(callee.func.selector);
        assembly {
            let status := call(gas, dest, 0, add(selector, 32), mload(selector), retv, 32)
            if iszero(status) {
                revert(0, 0)
            }
        }
        yyyy = retv[0];
    }

    function xxxx() external view returns (uint256) {
        return callee.xxxx();
    }
}"
49554-0.sol,question,"contract MyContractFactory is Ownable {
    function create(...) onlyOwner public returns (MyContract) {
        return new MyContract(...);
    }
}"
3863-0.sol,question,"contract Time {
  uint time;

  function giveTime() {
    time=now;
  }

  function Timestamp() constant returns (uint block_time) {
    block_time=time;
  }
}"
64755-0.sol,question,"contract PiggyBank {

using SafeMath for uint256;

struct Box {
    address owner;
    uint256 targetFigure;
    uint256 balance;
}

mapping (address =>  mapping (uint16 => Box)) public myBoxes;

event Deposit (
    address indexed _from,
    uint16 indexed _to,
    uint256 indexed _amount
);

event Withdraw (
    uint16 indexed _whichBox,
    address indexed _to,
    uint256 indexed _amount
);

function createBox(uint16 _boxid, uint _targetFigure) public {
    myBoxes[msg.sender][_boxid].owner = msg.sender;
    myBoxes[msg.sender][_boxid].targetFigure = _targetFigure;
    myBoxes[msg.sender][_boxid].balance = 0;
}

function getBoxInfo(uint16 _boxid) onlyOwner(_boxid) public view returns (uint256, uint256) {
    return (myBoxes[msg.sender][_boxid].targetFigure, myBoxes[msg.sender][_boxid].balance);
}

function deposit(uint16 _boxid,uint256 _amount) onlyOwner(_boxid) public payable {
    require(msg.value == _amount);
    myBoxes[msg.sender][_boxid].balance = myBoxes[msg.sender][_boxid].balance.add(msg.value);
    emit Deposit(msg.sender,_boxid, _amount);
}

function withdraw(uint16 _boxid) onlyOwner(_boxid) public payable {
    require(myBoxes[msg.sender][_boxid].targetFigure <= myBoxes[msg.sender][_boxid].balance);
    uint amount = myBoxes[msg.sender][_boxid].balance;
    myBoxes[msg.sender][_boxid].balance = 0 ;
    msg.sender.transfer(amount);
    breakBox(_boxid); 
    emit Withdraw (_boxid, msg.sender, amount);
}

function checkBalance() view public returns (uint){
    return(msg.sender.balance);
}

function breakBox(uint16 _boxid) public {
    delete myBoxes[msg.sender][_boxid];
}

 modifier onlyOwner(uint16 _boxid) {
   require(msg.sender == myBoxes[msg.sender][_boxid].owner);
    _;
}
}"
49493-0.sol,question,"contract bidding {

struct bid {
    string bidderName;
    uint grainId;
    uint bidAmount;
    uint bidTime;
}

mapping (uint => bid) bidInfos;
uint[] public bidIds;

function addBid(
    uint _bidId,
    string _bidderName, 
    uint _grainId, 
    uint _bidAmount
) public {
    var bid_info = bidInfos[_bidId];
    bid_info.bidderName = _bidderName;
    bid_info.grainId = _grainId;
    bid_info.bidAmount=_bidAmount;
    bid_info.bidTime= now;

    bidIds.push(_bidId) -1;
}

function getallBids() view public returns(uint[]) {
    return bidIds;
}

function getBid(uint _bidId) view public returns (string, uint, uint, uint) {
    return (
        bidInfos[_bidId].bidderName, 
        bidInfos[_bidId].grainId,
        bidInfos[_bidId].bidAmount, 
        bidInfos[_bidId].bidTime
    );
}

function getbidcount() view public returns (uint) {
    return bidIds.length;
}
}"
74764-0.sol,question,"contract matching {

    struct User {
        uint time;
        string location;
        string position;
    }
    User[] people; 

    mapping (address => User) user_mapping;
    address[] public userAccounts;

    function Set(address _address, uint _time, string memory _location, string memory _position) public {
        User storage users = user_mapping[_address];

        users.time = _time;
        users.location = _location;
        users.position = _position;

        userAccounts.push(_address) -1;
    }

    function getAccounts()public view returns(address[] memory) {
        return userAccounts;
    }

    function getInfo(address _address) view public returns (uint, string memory, string memory) {
        return (user_mapping[_address].time, user_mapping[_address].location, user_mapping[_address].position);
    }

    function countInfo() view public returns (uint) {
        return userAccounts.length;
    }
    function start() public{
     
    }

}"
25493-1.sol,question,"contract pullother {

function callFunctionInContractOne (address _address) returns (uint) {
    helloworld contractOne = helloworld(_address);
    contractOne.returnint();
}
}"
76280-0.sol,question,"contract Faucet {
    event AccountFunded(address account);

    address public tokenAddress;

    constructor(address _tokenAddress) public payable {
        tokenAddress = _tokenAddress;
    }

    function () external payable {}

    function testBalance(address account) public view returns (uint) {
        return ERC20Basic(tokenAddress).balanceOf(account);
    }

    function transfer(address account) public {
        SafeERC20.safeTransfer(ERC20Basic(tokenAddress), account, 10);
        emit AccountFunded(account);
    }
}"
37730-0.sol,question,"contract Betting is usingOraclize {

    address public owner = msg.sender;
    uint accountbalance;


    event Log(string);
    event error(string error_);
    event beforebetbalanceplayer(uint256);
    event beforebetbalanceowner(uint256);
    event afterbetbalanceplayer(uint256);
    event afterbetbalanceowner(uint256);
    event betamount(uint256);



        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }




mapping (address => uint256) private balanceOf;

  
        function transferamount (address _player, uint256 _amount) public payable {

                balanceOf[_player] = _player.balance;
                balanceOf[owner] = owner.balance;

                beforebetbalanceplayer(balanceOf[_player]);
                beforebetbalanceowner(balanceOf[owner]);

                Log(""Reducing amount from player's account"");
                balanceOf[_player] -= _amount;
                afterbetbalanceplayer(balanceOf[_player]);

                Log(""Adding amount to owner's account"");
                balanceOf[owner] += _amount;
                afterbetbalanceowner(balanceOf[owner]);

                afterbetbalanceplayer(_player.balance);
                afterbetbalanceowner(owner.balance);

            }       




        function getBalance (address _account) constant returns(uint256){
                return _account.balance;

        }




        function()  payable{    

            }
}"
46460-1.sol,question,"contract PubStorageReader {
  uint public storedData;
  PublicStorage publicStorage;

  function PubStorageReader(uint initVal, address publStorageAddr) public {
    storedData = initVal;
    publicStorage = PublicStorage(publStorageAddr);
  }

  function setPublic(uint x) public {
    publicStorage.set(x);
  }

  function getPublic() constant public returns (uint publicRetVal) {
    return publicStorage.get();
  }
}"
7419-1.sol,question,contract testA { function multiply(uint a) returns(uint d) { return a * 5; } }
84646-1.sol,question,"contract Birthday {
    event Pinata(uint candies);

    function celeb() public {
        emit Pinata(123);
    }
}"
67458-0.sol,question,"contract GenericToken is owned{
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    uint256 public sellPrice;
    uint256 public buyPrice;

    mapping (address => bool) public frozenAccount;

    
    event FrozenFunds(address target, bool frozen);

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    
    event Burn(address indexed from, uint256 value);

    
    constructor(
        uint256 initialSupply,
        string memory tokenName,
        string memory tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                    
        name = tokenName;                                       
        symbol = tokenSymbol;                                   
    }

    
    function _transfer(address _from, address _to, uint _value) internal {

        require(_to != address(0x0));                               
        require(balanceOf[_from] >= _value);                        
        require(balanceOf[_to] + _value > balanceOf[_to]);          
        require(!frozenAccount[_from]);                             
        require(!frozenAccount[_to]);                               
        uint previousBalances = balanceOf[_from] + balanceOf[_to];  
        balanceOf[_from] -= _value;                                 
        balanceOf[_to] += _value;                                   
        emit Transfer(_from, _to, _value);                          
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    
    
    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        emit Transfer(address(0), address(this), mintedAmount);
        emit Transfer(address(this), target, mintedAmount);
    }

    
    
    
    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }



    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        emit Burn(msg.sender, _value);
        return true;
    }

    
    
    
    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }

    
    function buy() payable public {
        uint amount = msg.value / buyPrice;                 
        _transfer(address(this), msg.sender, amount);       
    }

    
    
    function sell(uint256 amount) public {
        address myAddress = address(this);
        require(myAddress.balance >= amount * sellPrice);   
        _transfer(msg.sender, address(this), amount);       
        msg.sender.transfer(amount * sellPrice);            
    }


    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        emit Burn(_from, _value);
        return true;
    }
}"
78032-0.sol,question,"contract ShoeStore {
    function () external payable {

    }

    function getBalance() public view returns (uint) {
        return msg.sender.balance;
    }
}"
78032-0.sol,question,"contract StorePurchase {

    ShoeStore private _instance;

    function Store() public {
        _instance = new ShoeStore();
    }

    function getBalance() public view returns (uint) {
        return msg.sender.balance;
    }

    function sendEther() public payable {
        require(msg.sender.balance > 100);
        address(_instance).transfer(2);
    }

    function () external payable {

    }"
40938-3.sol,question,"contract TestLibrary {
    using IntExtended for uint;

    function testIncrement(uint _base) returns (uint) {
        return IntExtended.increment(_base);
    }
}"
78700-1.sol,question,"contract Exchange {
    address public owner;
    constructor() public {
        owner = msg.sender;
   }


ERC721Full public ERC721FullInterface;
IERC20 public IERC20Interface;
struct forSale{
    address owner;
    uint256 tokenId;
    uint256 price;
}
struct PreviousPrice{
    uint256 _price;
}
forSale[] public tokensForSale;
mapping(uint256 => PreviousPrice[])public previousSoldPrice;
address public theErc20;
address public theErc721;
function addAddresses (address _erc20, address _erc721)public returns(bool) {
    require(msg.sender == owner);
    theErc20= _erc20;
    theErc721 = _erc721;
    return(true);
}
event Sale(uint256 _tokenId, uint256 _price, address indexed _seller);
event Sold(uint256 _listId, uint256 _tokenId, uint256 _price, address indexed _seller);

function setForSale(uint256 _tokenId, uint256 _price) external returns(bool){
    require(_price > 0);
    ERC721FullInterface = ERC721Full(theErc721);
    require(ERC721FullInterface.ownerOf(_tokenId) == msg.sender);
    require(ERC721FullInterface.getApproved(_tokenId) == address(this));
    tokensForSale.push(forSale(msg.sender,_tokenId, _price));
    emit Sale(_tokenId, _price, msg.sender);
    return true;
}

function buy(uint256 _listId) external returns(bool){
    IERC20Interface = IERC20(theErc20);
    ERC721FullInterface = ERC721Full(theErc721);
    uint256 tokenId = tokensForSale[_listId].tokenId;
    address seller = tokensForSale[_listId].owner;
    require(ERC721FullInterface.ownerOf(tokenId) == seller);
    require(ERC721FullInterface.getApproved(tokenId) == address(this));

    uint256 priceToPay = tokensForSale[_listId].price;
    uint256 amount = priceToPay *90/100;
    uint256 charge = priceToPay-amount;
    require(IERC20Interface.balanceOf(msg.sender) >= priceToPay);
    require(IERC20Interface.allowance(msg.sender,address(this)) >= priceToPay);
    IERC20Interface.transferFrom(msg.sender,seller,amount);
    IERC20Interface.transferFrom(msg.sender,owner,charge);
    ERC721FullInterface.safeTransferFrom(seller,msg.sender,tokenId);
    previousSoldPrice[tokenId].push(PreviousPrice(priceToPay));
    delete tokensForSale[_listId];
    emit Sold(_listId, tokenId, priceToPay, seller);
    return true;
}

function getPriceForSold(uint256 _tokenId) public view returns(uint256[] memory){
    uint256 theLen = previousSoldPrice[_tokenId].length;
    uint256[] memory actualPrices = new uint256[](theLen);
    for(uint i=0; i <theLen;i++){
        actualPrices[i] = previousSoldPrice[_tokenId][i]._price;
    }
    return actualPrices;

}

function getForSaleLen() public view returns(uint256){
    return tokensForSale.length;
}

}"
83156-0.sol,question,"contract Receive {

    function () external payable {}

    function getBalance() public view returns (uint) {
        return address(this).balance;
    }
}"
83156-0.sol,question,"contract Send {

    function sendViaCall(address payable _to) public payable {

        (bool sent, bytes memory data) = _to.call.value(msg.value)("""");
        require(sent, ""Failed to send Ether"");
    }
}"
24460-0.sol,question,"contract Registry {
    mapping(string => address) ID;
    mapping(address => address) Contract;

    function addID(string _id, address publicAddress) {
        ID[_id] = publicAddress;
    }

    function addContract(address _owner) {
        Contract[_owner] = msg.sender;
    }
}"
24460-0.sol,question,"contract User {
    
    address regAddress = 0xf70ce669d4fa2bdeae1c4c61021627fc4b1d463c;
    address owner = msg.sender;

    function addID(string _id){
        
        Registry registry = Registry(regAddress);
        registry.addID(_id, owner);
    }

    function addContract(address _owner) {
        Registry registry = Registry(regAddress);
        registry.addContract(owner);
    }
}"
72506-0.sol,question,"contract Filter {

    using HitchensUnorderedKeySetLib for HitchensUnorderedKeySetLib.Set;
    HitchensUnorderedKeySetLib.Set filterSet;

    struct FilterStruct {
        string name;
        string tag;
    }


    mapping(bytes32 => FilterStruct) public filters;

    event LogNewFilter(address sender, bytes32 key, string Filternamename);

    function newFilter(bytes32 key, string memory name) public {
        filterSet.insert(key);
        FilterStruct storage f = filters[key];
        f.name = name;


        emit LogNewFilter(msg.sender, key, name);
    }

}"
58653-1.sol,question,"contract TestContractAuth is ContractAuth {

    
    function getPrefixedHashTest(bytes32 messageHash) public pure returns (bytes32) {
        return getPrefixedHash(messageHash);
    }

    
    function verifyMessageHashTest(bytes32 messageHash, uint8 v, bytes32 r, bytes32 s) public view returns (bool) {
        return verifyMessageHash(messageHash, v, r, s);
    }

    function verifyMultipleInputs(uint256 inputNumber, address inputAddress, uint8 v, bytes32 r, bytes32 s) public view returns (bool) {
        bytes32 messageHash = keccak256(abi.encodePacked(inputNumber, inputAddress));
        return verifyMessageHash(messageHash, v, r, s);
    }
}"
37824-0.sol,question,"contract XXPreOrderToken is XXERC20 {

    using SafeMath for uint256;

    uint public _totalSupply = 72500000000000000000000;

    string public constant symbol =""XXPOT"";
    string public constant name = ""PreOrderToken"";
    uint8 public constant decimals = 18;

    
    uint256 public constant RATE = 1000;

    address public owner;

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    function() payable{
        createTokens();
    }

    function XXPreOrderToken() {
        balances[msg.sender] = _totalSupply;
        owner = msg.sender;
    }

    function createTokens() payable {
        require(msg.value > 0);

        uint256 tokens = msg.value.mul(RATE);
        balances[msg.sender] = balances[msg.sender].add(tokens);
        _totalSupply = _totalSupply.add(tokens);

        owner.transfer(msg.value);
    }

    function totalSupply() constant returns (uint256 totalSupply) {
        return _totalSupply;
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function transfer(address _to, uint256 _value) returns (bool success) {
        require(
            balances[msg.sender] >= _value
            && _value > 0
            );
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        require(
            allowed[_from][msg.sender] >= _value
            && balances[_from] >= _value
            && _value > 0
            );
            balances[_from] = balances[_from].sub(_value);
            balances[_to] = balances[_to].add(_value);
            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
            Transfer(_from, _to, _value);
            return true;
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}"
80574-0.sol,question,"contract receive{
function dep() external payable{
    
    }
}"
80574-0.sol,question,"contract send {
    receive rc = receive (address(0x0DCd2F752394c41875e259e00bb44fd505297caF)); 
    function snd(uint256 amount) public payable {
        rc.dep.transfer(amount);
    }
    function fallback() external payable{}
}"
38106-0.sol,question,"contract A {
    C c = new C();

    function A() payable public {}

    function execute(address _bAddress) payable public {
        B b = new B(_bAddress);
        b.execute(address(c));
    }    

    function getFunds() constant public returns (uint) {
        return c.getFunds();
    }
}"
38106-0.sol,question,"contract B {
    address client;
    address authorizedAgent;

    modifier isClient() {
        if (msg.sender != client) {
            revert();
        }
        _;
    }    

    modifier isAuthorizedAgent() {
        if (msg.sender != authorizedAgent) {
            revert();
        }
        _;
    }    

    modifier isAuthorizedEntity() {
        if (msg.sender != client && msg.sender != authorizedAgent) {
            revert();
        }
        _;
    }    

    function B(address _agent) payable public {
        client = msg.sender;
        authorizedAgent = _agent;
    }    

    function depositFunds() payable public {}    

    function getFunds() isAuthorizedEntity constant public returns (uint) {
        return this.balance;
    }    

    function execute(address _c) isAuthorizedAgent payable public {
        _c.transfer(this.balance);
    }
}"
38106-0.sol,question,"contract C {
    function C() payable public {}

    function depositFunds() payable public {}    

    function getFunds() constant public returns (uint) {
        return this.balance;
    }
}"
57472-0.sol,question,"contract FatherContract {
    function createChild() public {        
        new ChildContract();
    }
}"
57472-0.sol,question,"contract ChildContract {
    constructor() public {
        
    }
}"
29812-0.sol,question,"contract BaconMaker {
    address public pig;
    address public owner;

    function BaconMaker(address _pig) public {
        require(_pig != 0x0);
        owner = msg.sender;
        pig = _pig;
    }
}"
61281-0.sol,question,"contract randomizePairs {

    uint population_size;
    mapping(address => bool) inPopulation;
    mapping(uint => address[]) pair;
    mapping(address => uint) inPair;
    bytes32 entropy;
    mapping(uint => uint) iterationMemory;

    function commit() {
        require(inPopulation[msg.sender] == true);
        require(inPair[msg.sender] == 0);

        uint[] memorize;
        uint pairNumber = uint64(sha3(sha3(block.blockhash(block.number), entropy), now)) % (population_size / 2);

        if(pair[pairNumber].length < 2) {
            pair[pairNumber].push(msg.sender);
            inPair[msg.sender] = pairNumber;
        }
        else {
            memorize.push(pairNumber); 
            for(uint i = 0; i < 100; i++) {
                pairNumber = (pairNumber + i) % (population_size / 2); 
                if(pair[pairNumber].length == 2) {
                    if(iterationMemory[pairNumber] != 0) {
                        memorize.push(iterationMemory[pairNumber]); 
                        pairNumber = iterationMemory[pairNumber] - i; 
                    }
                }
                else {
                    pair[pairNumber].push(msg.sender);
                    inPair[msg.sender] = pairNumber;
                    break; 
                }
            }
            
            for(uint m = 0; m < memorize.length; m++) {
                iterationMemory[mem[m]] = pairNumber;
            }
    }
    }
}"
46130-3.sol,question,"contract BasicToken {

  
  using SafeMath for uint256;

  
  uint256 public totalSupply;

  
  mapping(address => uint256) balances;

  mapping(address => string) Payload;

  
  
  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }

  
  
  function PayloadOf(address _owner) constant returns (string payload) {
    return Payload[_owner];
  }

  
  
  
  
  
  
  function transfer(address _from, address _to, uint256 _value, string Pl_value) public returns (bool) {
    require(_to != address(0));

    
    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);

    Payload[_to] = Pl_value;

    return true;
  }

}"
50986-1.sol,question,"contract C {  
bytes32 public temp;  
function hashingsha3 (bytes s)   {  
temp= sha3(s);  
}  
function hashingsha256 (bytes s) {  
temp= sha256(s);  
}  
function kec (bytes s)  {  
temp= keccak256(s);  
}  
}"
41558-0.sol,question,"contract TokenERC20 {
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
}"
66273-0.sol,question,"contract SimplePaymentChannel {
    address public sender;     
    address public recipient;  
    uint256 public expiration; 
    closes.

    function SimplePaymentChannel(address _recipient, uint256 duration)
        public
        payable
    {
        sender = msg.sender;
        recipient = _recipient;
        expiration = now + duration;
    }

    function isValidSignature(uint256 amount, bytes signature)
        internal
        view
        returns (bool)
    {
        bytes32 message = prefixed(keccak256(this, amount));

        
        return recoverSigner(message, signature) == sender;
    }

    
    
    
    function close(uint256 amount, bytes signature) public {
        require(msg.sender == recipient);
        require(isValidSignature(amount, signature));

        recipient.transfer(amount);
        selfdestruct(sender);
    }

    
    function extend(uint256 newExpiration) public {
        require(msg.sender == sender);
        require(newExpiration > expiration);

        expiration = newExpiration;
    }

    
    
    function claimTimeout() public {
        require(now >= expiration);
        selfdestruct(sender);
    }

    function splitSignature(bytes sig)
        internal
        pure
        returns (uint8, bytes32, bytes32)
    {
        require(sig.length == 65);

        bytes32 r;
        bytes32 s;
        uint8 v;

        assembly {
            
            r := mload(add(sig, 32))
            
            s := mload(add(sig, 64))
            
            v := byte(0, mload(add(sig, 96)))
        }

        return (v, r, s);
    }

    function recoverSigner(bytes32 message, bytes sig)
        internal
        pure
        returns (address)
    {
        uint8 v;
        bytes32 r;
        bytes32 s;

        (v, r, s) = splitSignature(sig);

        return ecrecover(message, v, r, s);
    }

    
    function prefixed(bytes32 hash) internal pure returns (bytes32) {
        return keccak256(""\x19Ethereum Signed Message:\n32"", hash);
    }
}"
45846-0.sol,question,"contract Foo {
    bool public lastVal = false;

    function fooFunc(bool x) public returns (bool) {
        lastVal = x;
        return !x;
    }
}"
45846-0.sol,question,"contract Bar {
    bool public barBool = false;
    Foo myFoo;

    function Bar(address _myFooAddr) public {
        myFoo = Foo(_myFooAddr);
    }

    function barFunc() public {
        barBool = myFoo.fooFunc(barBool);
    }
}"
63653-0.sol,question,"contract ArrayTest {
  uint[2] a;

  event ReverseLoop(uint n);
  event NormalLoop(uint n);

  constructor() public {
    a[0] = 1;
    a[1] = 2;
  }

  function reverseLoop() external {
    for (uint i = a.length-1; i >= 0; i--) {
        emit ReverseLoop(a[i]);
    }
  }

  function normalLoop() external {
    for (uint i = 0; i < a.length; i++) {
        emit NormalLoop(a[i]);
    }
  }
}"
83869-0.sol,question,"contract Redpack {
    address public owner;

    uint public minPackAmount = 1 * (10 ** 18); 
    uint public maxPackAmount = 10000 * (10 ** 18); 
    uint public constant LIMIT_AMOUNT_OF_PACK = 100000 * (10 ** 18);

    uint public minPackCount = 1; 
    uint public maxPackCount = 10000; 

    uint public totalPackAmounts = 0; 
    uint public numberOfPlayers = 0; 
    address[] public players; 

    struct Player {
        uint id; 
        address owner; 
        uint amount; 
        uint balance; 
        uint count; 
        uint amountPerPack; 
        bool isRandom; 
        uint[] randomAmount; 
        uint randomFactor; 
        address[] hunterList; 
        mapping(address => uint) hunterInfo; 
    }

    
    mapping(uint => Player) public playerInfo;

    
    function() public payable {}
    
    
    
    
    


    
    
    
    constructor (uint _minPackAmount, uint _maxPackAmount) public {
        owner = msg.sender;

        if(_minPackAmount > 0) minPackAmount = _minPackAmount;
        if(_maxPackAmount > 0 && _maxPackAmount <= LIMIT_AMOUNT_OF_PACK)
            maxPackAmount = _maxPackAmount;
    }

    function kill() public {
        if(msg.sender == owner) selfdestruct(owner);
    }

    
    function getPlayerInfo() public view returns (
        uint nTotalPackAmounts,
        uint nNumberOfPlayers,
        address[] playerList
    ) {
        return (
        totalPackAmounts,
        numberOfPlayers,
        players
        );
    }

    
    
    

    event redpackCreated(uint id);
    event redpackWithdraw(uint amount);

    
    
    
    
    function toll(uint count, bool isRandom) public payable {
        require(msg.value >= minPackAmount && msg.value <= maxPackAmount, ""amount out of range(1..10000"");
        require(count >= minPackCount && count <= maxPackCount, ""1, 10000"");

        uint id = numberOfPlayers;
        playerInfo[id].amount = msg.value;
        playerInfo[id].balance = msg.value;
        playerInfo[id].count = count;
        playerInfo[id].isRandom = isRandom;
        playerInfo[id].id = id;
        if (isRandom) {
            uint total = 0;
            for (uint i = 0; i < count; i++) {
                playerInfo[id].randomAmount[i] = uint(keccak256(abi.encodePacked(now, msg.sender, i))) % 100;
                total += playerInfo[id].randomAmount[i];
            }
            playerInfo[id].randomFactor = 100 / total; 
        } else {
            playerInfo[id].amountPerPack = msg.value / count; 
        }

        totalPackAmounts += msg.value;
        numberOfPlayers++; 
        players.push(msg.sender); 

        emit redpackCreated(id);
    }

    
    
    function withdrawBalance(uint id) public {
        require(msg.sender == playerInfo[id].owner, ""not the owner."");
        require(playerInfo[id].balance > 0, ""balance is 0."");
        require(playerInfo[id].balance <= totalPackAmounts, ""not enough budget."");

        msg.sender.transfer(playerInfo[id].balance);
        totalPackAmounts -= playerInfo[id].balance;

        emit redpackWithdraw(playerInfo[id].balance);
    }

    
    
    
    
    
    
    
    
    function getPackInfo(uint id) public view returns (
        uint amount,
        uint balance,
        uint count,
        uint amountPerPack,
        bool isRandom
    ) {
        Player storage player = playerInfo[id];
        return (
        player.amount,
        player.balance,
        player.count,
        player.amountPerPack,
        player.isRandom
        );
    }

    
    
    

    event redpackGrabbed(uint amount);

    
    
    
    function checkHunterExists(uint _id, address _hunter) public view returns(bool) {
        for (uint256 i = 0; i < playerInfo[_id].hunterList.length; i++){
            if(playerInfo[_id].hunterList[i] == _hunter) return true;
        }
        return false;
    }

    
    
    function hunting(uint id) public payable {
        
        require(playerInfo[id].balance > 0, ""redpack is empty"");
        require(playerInfo[id].count > playerInfo[id].hunterList.length, ""exceed number of redpacks"");
        require(!checkHunterExists(id, msg.sender), 'already grabbed');

        if(playerInfo[id].isRandom) {
            
            uint index = playerInfo[id].hunterList.length;
            uint value = playerInfo[id].randomFactor * playerInfo[id].randomAmount[index] * playerInfo[id].amount;
            if (playerInfo[id].hunterList.length + 1 >= playerInfo[id].count) {
                
                hunted(id, playerInfo[id].balance);
                playerInfo[id].balance = 0;

            } else {
                hunted(id, value);
                playerInfo[id].balance -= value;
            }
        } else {
            
            if (playerInfo[id].balance > playerInfo[id].amountPerPack) {
                
                if (playerInfo[id].balance < playerInfo[id].amountPerPack * 2) {
                    hunted(id, playerInfo[id].balance);
                    playerInfo[id].balance = 0; 
                } else {
                    
                    hunted(id, playerInfo[id].amountPerPack);
                    playerInfo[id].balance -= playerInfo[id].amountPerPack;
                }
            } else {
                
                hunted(id, playerInfo[id].balance);
                playerInfo[id].balance = 0;
            }
        }
    }
    function hunted(uint _id, uint _amount) internal {
        require(_amount <= totalPackAmounts, ""grab: not enough budget."");
        msg.sender.transfer(_amount);
        totalPackAmounts -= _amount;
        playerInfo[_id].hunterList.push(msg.sender);

        emit redpackGrabbed(_amount);
    }

    
    
    

}"
55890-1.sol,question,"contract ContractB {

    ERC20 public token;

    constructor(ERC20 _token) public {
        token = _token;
    }

    function burn() internal {
        token.balances[address(token)] = 0;
        token.totalSupply_ = 0;
    }
}"
51236-0.sol,question,"contract MyContract is Migratable {
    uint256 public x;

    function initialize(uint256 _x) isInitializer(""MyContract"", ""0"") public {
        x = _x;
    }

    function baz() public returns (uint256) {
        decrement();
        return x;
    }

    function increment() public {
        x += 1;
    }

    function decrement() public {
        x -= 1;
    }
}"
60295-0.sol,question,"contract SimpleCounter {
    int counter;

    constructor() public {
        counter = 0;
    }

    function getCounter() public view returns (int){
        return counter;
    }

    function increment() public {
        counter += 1;
    }

    function decrement() public {
        counter -= 1;
    }
}"
66472-1.sol,question,"contract B {
  using Roles for Roles.Role;
  Roles.Role private adminRole;

  constructor(address _adminRole) public {
    adminRole.add(_adminRole);
  }

  function protectedFunc() public {
    require(adminRole.has(msg.sender), ""DOES_NOT_HAVE_ADMIN_ROLE"");
    ...
  }

}"
63809-1.sol,question,"contract Auction {
    
    
    struct Item { 
        uint itemId;          
        uint[] itemTokens;    
    }

    
    struct Person { 
        uint remainingTokens; 
        uint personId;        
        address addr;         
    }

    mapping(address => Person) tokenDetails; 
    Person [4] bidders;

    Item [3] public items;       
    address[3] public winners;   
    address public beneficiary;  
    uint bidderCount=0;          

    
    function Auction() public payable{                     
        beneficiary = msg.sender;                          
        uint[] memory emptyArray; 
        items[0] = Item({itemId:0,itemTokens:emptyArray});
        items[1] = Item({itemId:1,itemTokens:emptyArray}); 
        items[2] = Item({itemId:2,itemTokens:emptyArray}); 
    }

    function register() public payable{
        bidders[bidderCount].personId = bidderCount;
        bidders[bidderCount].addr = addr;                  
        bidders[bidderCount].remainingTokens = 5;          
        tokenDetails[msg.sender]=bidders[bidderCount];
        bidderCount++; 
    }

    function bid(uint _itemId, uint _count) public payable{
        if (tokenDetails[msg.sender].remainingTokens < _count) return; 
        if (_itemId > 2) return;                                       
        (tokenDetails[msg.sender].remainingTokens - _count);           
        bidders[tokenDetails[msg.sender].personId].remainingTokens= tokenDetails[msg.sender].remainingTokens; 
        Item storage bidItem = items[_itemId]; 
        for(uint i=0; i<_count;i++) { 
            bidItem.itemTokens.push(tokenDetails[msg.sender].personId); 
        }
    }

    function revealWinners() public {
         for (uint id = 0; id < 3; id++) { 
             Item storage currentItem=items[id]; 
             If (currentItem.itemTokens.length != 0);
                 uint randomIndex = (block.number / currentItem.itemTokens.length)% currentItem.itemTokens.length; 
                 uint winnerId = currentItem.itemTokens[randomIndex];
                 return winnerId;                                      
            }
        }
    }"
80532-0.sol,question,"contract Tickets {
  struct Ticket {
    uint serie;
    uint number;
    uint datetime;
  }

  Ticket[] tickets;

  function addTicket(Ticket memory newTicket) public returns(bool success) {
    tickets.push(newTicket);
    return true;
  }

  function getTickets() public view returns(Ticket[] memory) {
    return tickets;
  }
}"
25491-0.sol,question,"contract ManagerDb {

    struct ManagerStruct {
        bytes32 firstname;
        bytes32 lastname;
        bytes32 email;
        uint index;
    }

    mapping ( address => ManagerStruct ) Managers;
    address[] public managerIndex; 

    function insertManager(
        address managerAddress,
        bytes32 firstName,
        bytes32 lastName,
        bytes32 email
    )
        returns (bool)
    {

        ManagerStruct memory newManager;
        newManager.firstname = firstName;
        newManager.lastname = lastName;
        newManager.email = email;
        newManager.index = managerIndex.push(managerAddress)-1;

        Managers[managerAddress] = newManager;
        return true;
    }

    
    function getArrayData() constant returns (bytes32[] _data1) {

        uint arrLength = managerIndex.length;
        bytes32[] memory arrData1 = new bytes32[](arrLength);
        for (uint i=0; i <= arrLength; i++){
            address addr = managerIndex[i];
            ManagerStruct ms = Managers[addr];
            arrData1[i] = ms.firstname;
        }

        return (arrData1);
    }
}"
58508-0.sol,question,"contract ContractA {
    ContractB public BB;

    
    constructor () public {
        BB = ContractB(msg.sender);
    }

    function () public payable {
        require(msg.value > 0);

        BB.destination().transfer(msg.value);
        BB.logDeposit(msg.sender, msg.value);
    }
}"
40592-0.sol,question,"contract Casino is usingOraclize {
   address owner;
   uint public betAmount = 30 finney; 
   uint public totalBets; 
   uint public numberOfBets; 
   
   uint public limitAmountOfBets = 2; 
   uint public numberWinner; 
   bool public gameStatus;
   uint public stage = 0;
   uint public winnerEtherAmount;
   mapping(uint => address[]) public numberBetPlayers; 
   mapping(address => uint) public playerBetsNumber; 

   uint public numberLengths;

   modifier onEndGame() {
       if(numberOfBets >= limitAmountOfBets) _;
   }

   
   function Casino(uint _betAmount, uint _limitAmountOfBets) {
       owner = msg.sender; 

       if(_betAmount > 0) betAmount = _betAmount;
       if(_limitAmountOfBets > 0) limitAmountOfBets = _limitAmountOfBets;

       oraclize_setProof(proofType_Ledger); 
   }

   
   function checkPlayerExists(address player) constant public returns(bool) {
       if(playerBetsNumber[player] > 0) return true;
       else return false;
   }

   
   function bet(uint numberToBet) payable {
       require(numberOfBets <= limitAmountOfBets); 
       require(!checkPlayerExists(msg.sender)); 
       require(numberToBet >=1 && numberToBet <= 10); 
       require(msg.value == betAmount); 
       gameStatus = true;

       playerBetsNumber[msg.sender] = numberToBet;
       numberBetPlayers[numberToBet].push(msg.sender);

       numberOfBets += 1;
       totalBets += msg.value;

       if(numberOfBets >= limitAmountOfBets) generateNumberWinner();
   }

   
   function generateNumberWinner() payable onEndGame {
       gameStatus = false;
       stage = 1;
       uint numberRandomBytes = 7;
       uint delay = 0;
       uint callbackGas = 200000;

       oraclize_newRandomDSQuery(delay, numberRandomBytes, callbackGas);
   }

   function __callback(bytes32 _queryId, string _result, bytes _proof) {
       stage = 2;
       require (msg.sender == oraclize_cbAddress());

       if (oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) != 0) {
           stage = 9;
       }
       else {
           numberWinner = uint(sha3(_result)) % 10;
           
           distributePrizes();
       }
   }

   function distributePrizes() internal onEndGame {
       stage = 3;

       if(numberBetPlayers[numberWinner].length > 0) {
           winnerEtherAmount = totalBets / numberBetPlayers[numberWinner].length; 

           for(uint i = 0; i < numberBetPlayers[numberWinner].length; i++) { 
               numberBetPlayers[numberWinner][i].transfer(winnerEtherAmount);
           }
       }

       for(uint j = 1; j <= 10; j++) {
           if(numberBetPlayers[j].length > 0) delete numberBetPlayers[j];
       }

       totalBets = 0;
       numberOfBets = 0;
   }
}"
57472-1.sol,question,"contract FatherContract {
    function createChild(bytes contractDataInfo) public {        
        
        
    }
}"
7740-1.sol,question,"contract C {

    string words = ""Bla bla bla"";

    uint256 lastVal;

    function math(uint256 a, uint256 b) returns (uint256) {
        lastVal = a + b;
        return lastVal;
    }

    function getWords() constant returns (string) {
        return words;
    }
}"
40751-0.sol,question,"contract CollegeAdmin {
uint8 public studentAge=21;
uint16 public studentIncome=15000;
uint8 public studentScore=4;
uint8 public studentAttendance=96;
address public buyer;
address public owner;
event changedAge(uint age);

function CollegeAdmin() public {
owner = msg.sender;
}
function setAge(uint8 age) public {
buyer=msg.sender;
studentAge = age;
changedAge(age);
}

}"
24465-0.sol,question,"contract HumanStandardToken is StandardToken {

function () {
    
    throw;
}




string public name;                   
uint8 public decimals;                
string public symbol;                 
string public version = 'H0.1';       

function HumanStandardToken(
    uint256 _initialAmount,
    string _tokenName,
    uint8 _decimalUnits,
    string _tokenSymbol
    ) {
    balances[msg.sender] = _initialAmount;               
    totalSupply = _initialAmount;                        
    name = _tokenName;                                   
    decimals = _decimalUnits;                            
    symbol = _tokenSymbol;                               
}


function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);

    
    
    
    if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
    return true;
}
}"
80004-0.sol,question,"contract DataEntityContract {


    DataEntity DE;

    constructor(string memory _name,string[] memory _relatedEntities, string memory _date, string memory _fileName, string memory _annotations) public
    {
        DE = DataEntity(_name, 'URN', _fileName, new string[](0), _relatedEntities, 'references', _annotations, msg.sender, _date);
    }

    struct DataEntity {
        
        string dataEntityName;
        string rawFileURN;
        string fileName;
        string[] nameChangeHistory;
        string[] sources;
        string references;
        string annotations;
        address createdUpdateBy;
        string when;
    }

    function editDE() public {
        DE.annotations = ""edited"";
    }

    function getAnnotations() public view returns(string memory) {
        return (DE.annotations);
    }

}"
80004-0.sol,question,"contract FlattenedDEC
{
    address owner;
    string public name;
    mapping (string => address) dataEntities;
    string[] public dataEntityNames;
    uint count = 0;
    uint public DataEntitiesCount = 0;
    mapping(uint => Lineage) public lineageInfo;
    mapping(uint => DE) public DataEntities;

    event DataEntityEdited(
        string name,
        string comments,
        address editedBy
    );

    constructor() public
    {
        name = ""DataEntityCatalogue Master Contract"";
        owner = msg.sender;
    }

    function createNewDataEntity(string memory _name, string[] memory _dataEntities, string memory _date, string memory _fileName, string memory _annotations) public returns(address _new){
        DataEntityContract instance = new DataEntityContract(_name,_dataEntities, _date, _fileName, _annotations);
        return address(instance);
    }

    function editDE(string memory _name) public{
        DataEntityContract de = DataEntityContract(dataEntities[_name]);
        de.editDE();
        emit DataEntityEdited(_name, ""edited"", msg.sender);
    }"
37865-0.sol,question,"contract TokenERC20 {

string public name;
string public symbol;
uint8 public decimals = 0;

uint256 public totalSupply;


mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;


event Transfer(address indexed from, address indexed to, uint256 value);


event Burn(address indexed from, uint256 value);


function TokenERC20(
    uint256 initialSupply,
    string tokenName,
    string tokenSymbol
) public {
    totalSupply = initialSupply * 10 ** uint256(decimals);  
    balanceOf[msg.sender] = totalSupply;                
    name = tokenName;                                   
    symbol = tokenSymbol;                               
}


function _transfer(address _from, address _to, uint _value) internal {
    
    require(_to != 0x0);
    
    require(balanceOf[_from] >= _value);
    
    require(balanceOf[_to] + _value > balanceOf[_to]);
    
    uint previousBalances = balanceOf[_from] + balanceOf[_to];
    
    balanceOf[_from] -= _value;
    
    balanceOf[_to] += _value;
    Transfer(_from, _to, _value);
    
    assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}


function transfer(address _to, uint256 _value) public {
    _transfer(msg.sender, _to, _value);
}


function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    require(_value <= allowance[_from][msg.sender]);     
    allowance[_from][msg.sender] -= _value;
    _transfer(_from, _to, _value);
    return true;
}


function approve(address _spender, uint256 _value) public
    returns (bool success) {
    allowance[msg.sender][_spender] = _value;
    return true;
}


function approveAndCall(address _spender, uint256 _value, bytes _extraData)
    public
    returns (bool success) {
    tokenRecipient spender = tokenRecipient(_spender);
    if (approve(_spender, _value)) {
        spender.receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    }
}


function burn(uint256 _value) public returns (bool success) {
    require(balanceOf[msg.sender] >= _value);   
    balanceOf[msg.sender] -= _value;            
    totalSupply -= _value;                      
    Burn(msg.sender, _value);
    return true;
}


function burnFrom(address _from, uint256 _value) public returns (bool success) {
    require(balanceOf[_from] >= _value);                
    require(_value <= allowance[_from][msg.sender]);    
    balanceOf[_from] -= _value;                         
    allowance[_from][msg.sender] -= _value;             
    totalSupply -= _value;                              
    Burn(_from, _value);
    return true;
}
}"
37865-0.sol,question,"contract Owned {

address public owner;   

event TransferOwnerShip(address oldaddr, address newaddr);


modifier onlyOwner {require(msg.sender == owner);_;}


function Owned() public {
    owner = msg.sender;
}

function transferOwnership(address newOwner) onlyOwner public {
    address oldaddr = owner;
    owner = newOwner;
    TransferOwnerShip(oldaddr, owner);
}
}"
37865-0.sol,question,"contract Escrow is Owned {

token public tokenReward; 
uint256 public salesVolume; 
uint256 public sellingPrice; 
uint256 public deadline;     
bool public isOpened;     

mapping(address => uint256) public balanceOf;


event EscrowStart(uint salesVolume, uint sellingPrice, uint deadline, address beneficiary);
event ConfirmedPayment(address addr, uint amount);


function Escrow(
    address addressOfTokenUsedAsReward,
    uint256 _salesVolume,
    uint256 priceInEther

) public {
    tokenReward = token(addressOfTokenUsedAsReward);
    salesVolume = _salesVolume;
    sellingPrice = priceInEther * 1 ether;
}


function () public payable {
    
    require(!isOpened || now >= deadline);

    
    uint amount = msg.value;
    require(amount < sellingPrice);

    
    tokenReward.transfer(msg.sender, salesVolume);
    isOpened = false;
    ConfirmedPayment(msg.sender, amount);

}


function start(uint256 _durationInMinutes) public {
    require(tokenReward == address(0) || salesVolume == 0 || sellingPrice == 0 || deadline !=0);
    if(tokenReward.balanceOf(this) >= salesVolume){
        deadline = now + _durationInMinutes * 1 minutes;
        isOpened = true;
        EscrowStart(salesVolume, sellingPrice, deadline, owner);
    }

}

function getRemainingTime() public constant returns(uint min){
    if(now < deadline) {
        min = (deadline - now) / (1 minutes);
    }
}

function close() public {
    
   tokenReward.transfer(owner, tokenReward.balanceOf(this));
   
   selfdestruct(owner);
}

}"
63733-1.sol,question,"contract AjTokenSale {
address admin;
AjToken public tokenContract;
uint256 public tokenPrice;
uint256 public tokensSold;

event Sell(address _buyer, uint256 _amount);

function AjTokenSale(AjToken _tokenContract, uint256 _tokenPrice) public {
    
    admin = msg.sender;
    
    tokenContract = _tokenContract;
    
    tokenPrice = _tokenPrice;
}    



function multiply(uint x, uint y) internal pure returns(uint z) {

    require (y == 0 || (z = x * y)/y == x);

}


function buyTokens(uint256 _numberOfTokens) public payable {
    

    require(msg.value == multiply(_numberOfTokens , tokenPrice));

    

    require(tokenContract.balanceOf(this) >= _numberOfTokens);

    
    require(tokenContract.transfer(msg.sender, _numberOfTokens));
    
    tokensSold += _numberOfTokens;
    
    Sell(msg.sender, _numberOfTokens); 
}



function endSale() public {
    
    require(msg.sender == admin);       
    
    require(tokenContract.transfer(admin, tokenContract.balanceOf(this))); 
    admin.transfer(address(this).balance);

}

}"
54929-0.sol,question,"contract A {

    uint private a;

    function setA(uint _a) external { a = _a; }
    function getA() external view returns(uint) { return a; }
}"
54929-0.sol,question,"contract B {
    A a;

    constructor() public {
        a = new A();

        a.setA(2);
    }

    function getterA() public view returns(uint) { a.getA(); }
}"
1059-0.sol,question,"contract Simple {
    string32 message public;

    function Simple() {
        message = msg.sender;
    }
}"
29127-0.sol,question,"contract Token {

  

  function transfer(address _to, uint256 _value) returns (bool success) {}

  
}"
17015-0.sol,question,"contract WeatherApiCall is usingOraclize {


      
      enum oraclizeState { ForWeatherCondition, ForDistance }

      
      event LOG_OraclizeCallbackForDistance(
                string result,
                bytes proof
      );

      event LOG_OraclizeCallbackForWeatherCondition(
                string result,
                bytes proof
      );

       
       
       
      struct oraclizeCallback {
                
                  oraclizeState oState;
      }
      
      mapping (bytes32 => oraclizeCallback) public oraclizeCallbacks;

      address  public user;
      string public places1;
      string public from1;
      string public to1;
      uint public persons1;
      string public datetime1;          

      
      function WeatherApiCall() {
              OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
              oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
              user=msg.sender;
      }
      
      function distanceRetrieve(string places,string from,string to,uint persons,string datetime) payable returns(bool sufficient) {

            places1=places;
            from1=from;
            to1=to;
            persons1=persons;
            datetime1=datetime;


          
            bytes32 queryId = oraclize_query(10,""URL"",strConcat(""json(http:
          
            oraclizeCallbacks[queryId] = oraclizeCallback(oraclizeState.ForDistance);
           
            return true;
      }

      function weatherconditionRetrieve(string to,string datetime) payable returns(bool sufficient) {



               bytes32 queryId =  oraclize_query(30,""URL"", strConcat(""json(http:
               oraclizeCallbacks[queryId] = oraclizeCallback(oraclizeState.ForWeatherCondition);
               return true;
      }
      
      function __callback(bytes32 myid, string result,bytes proof) {

                 if (msg.sender != oraclize_cbAddress()) throw;
                 oraclizeCallback memory o = oraclizeCallbacks[myid];
                 if (o.oState == oraclizeState.ForDistance) {
                               LOG_OraclizeCallbackForDistance(result,proof);
                             
               }
                 else if(o.oState == oraclizeState.ForWeatherCondition) {
                               LOG_OraclizeCallbackForWeatherCondition(result,proof);
                 }

      }


}"
9705-0.sol,question,"contract Call {
  ...
  function () payable {
    
    
    
  }
}"
71636-0.sol,question,"contract Proxy {

    address public implement;
    
    
    uint public total;  

    function changeImpl(address _impl) public returns(bool) {
        implement = _impl;
        return true;
    }

    
    
    function add(uint a, uint b) external {
        address _impl = implement;
        assembly {
            let ptr := mload(0x40)
            calldatacopy(ptr, 0, calldatasize)
            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)
        }
    }
}"
71636-0.sol,question,"contract ImplContract {

    address public implement;
    uint public total;

    function add(uint a, uint b) public returns(uint) {
        total = a + b;
        return total;
    }
}"
79965-4.sol,question,"contract Migrations {
  address public owner;
  uint public last_completed_migration;

  constructor() public {
    owner = msg.sender;
  }

  modifier restricted() {
    if (msg.sender == owner) _;
  }

  function setCompleted(uint completed) public restricted {
    last_completed_migration = completed;
  }
}"
22969-0.sol,question,"contract token { function transfer(address receiver, uint amount){ receiver; amount; } }"
22969-0.sol,question,"contract Crowdsale {
address public beneficiary;
uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price;
token public tokenReward;
mapping(address => uint256) public balanceOf;
bool fundingGoalReached = false;
event GoalReached(address beneficiary, uint amountRaised);
event FundTransfer(address backer, uint amount, bool isContribution);
bool crowdsaleClosed = false;




function Crowdsale(
    address ifSuccessfulSendTo,
    uint fundingGoalInEthers,
    uint durationInMinutes,
    uint weiCostOfEachToken,
    token addressOfTokenUsedAsReward
) {
    beneficiary = ifSuccessfulSendTo;
    fundingGoal = fundingGoalInEthers * 1 ether;
    deadline = now + durationInMinutes * 1 minutes;
    price = weiCostOfEachToken * 1 wei;
    tokenReward = token(addressOfTokenUsedAsReward);
}


function () payable {
    if (crowdsaleClosed) throw;
    uint amount = msg.value;
    balanceOf[msg.sender] = amount;
    amountRaised += amount;
    tokenReward.transfer(msg.sender, amount / price);
    FundTransfer(msg.sender, amount, true);
}

modifier afterDeadline() { if (now >= deadline) _; }


function checkGoalReached() afterDeadline {
    if (amountRaised >= fundingGoal){
        fundingGoalReached = true;
        GoalReached(beneficiary, amountRaised);
    }
    crowdsaleClosed = true;
}


function safeWithdrawal() afterDeadline {
    if (!fundingGoalReached) {
        uint amount = balanceOf[msg.sender];
        balanceOf[msg.sender] = 0;
        if (amount > 0) {
            if (msg.sender.send(amount)) {
                FundTransfer(msg.sender, amount, false);
            } else {
                balanceOf[msg.sender] = amount;
            }
        }
    }

    if (fundingGoalReached && beneficiary == msg.sender) {
        if (beneficiary.send(amountRaised)) {
            FundTransfer(beneficiary, amountRaised, false);
        } else {
            
            fundingGoalReached = false;
        }
    }
}
"
62859-1.sol,question,"contract Origin {

struct OriginInfo
{
    string airportName;
    uint32 checkInTime; 
    uint8 bagWeight;
    address clientAddress;
    bool itsHere;
}
mapping (uint256 => OriginInfo) origins;
uint256 public originNonce;

constructor() public
{
    originNonce = 1;
}

function insertOrigin(string _airportName, uint32 _checkInTime, uint8 _bagWeight) 
    public 
{
    origins[originNonce] = OriginInfo(_airportName, _checkInTime, _bagWeight, msg.sender, true);
    originNonce += 1;

    recoverOrigin(originNonce);
}

function recoverOrigin(uint256 _originId) 
    private view 
    returns (string, uint32, uint8, address, bool) 
{
    OriginInfo memory origin = origins[_originId];
    return (
        origin.airportName,
        origin.checkInTime, 
        origin.bagWeight, 
        origin.clientAddress, 
        origin.itsHere
    );
}
}"
62859-1.sol,question,"contract Travel{


struct TravelInfo {
    uint test;
    
}

mapping(uint => Travel) travels;
uint public travelsRegistryCount;

function addOrigin (string _airportName, uint32 _checkInTime, uint8 _bagWeight) public {
    insertOrigin(_airportName, _checkInTime, _bagWeight);

}
}"
48008-0.sol,question,"contract MyContract {
  function info() external view returns(uint min, uint max) {
    return(1, 2);
  }
}"
48008-0.sol,question,"contract Launchpad {

 function launch() public returns(address) {
   MyContract myContractAddress = new MyContract();
   return myContractAddress;
 }

}"
83589-0.sol,question,"contract AtariToken is ERC20Interface {

    string public constant name = ""AtariToken"";
    string public constant symbol = ""ATAR"";
    uint8 public constant decimals = 0;

    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    event Transfer(address indexed from, address indexed to, uint tokens);
    event RegistrationSuccessful(uint256 nonce);
    event RegistrationFailed(uint256 nonce);

    mapping(address => uint256) balances;

    mapping(address => mapping (address => uint256)) allowed;

    uint256 totalSupply_ = 7777100000;

    mapping (string => address) addressTable;

    using SafeMath for uint256;

    constructor() public{
        balances[msg.sender] = totalSupply_;
    }

    function totalSupply() public override view returns (uint256) {
        return totalSupply_;
    }

    function balanceOf(address tokenOwner) public override view returns (uint) {
        return balances[tokenOwner];
    }

    function balanceOf(string memory tokenOwner) public view returns (uint) {
        address userAddress;
        userAddress = addressTable[tokenOwner];
        return balances[userAddress];
    }

    function transfer(address receiver, uint numTokens) public override returns (bool) {
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(numTokens);
        balances[receiver] = balances[receiver].add(numTokens);
        emit Transfer(msg.sender, receiver, numTokens);
        return true;
    }

    function transfer(string memory receiver, uint numTokens) public returns (bool) {
        address receiverAddress;
        receiverAddress = addressTable[receiver];
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(numTokens);
        balances[receiverAddress] = balances[receiverAddress].add(numTokens);
        emit Transfer(msg.sender, receiverAddress, numTokens);
        return true;
    }

    function approve(address delegate, uint numTokens) public override returns (bool) {
        allowed[msg.sender][delegate] = numTokens;
        emit Approval(msg.sender, delegate, numTokens);
        return true;
    }

    function approve(string memory delegate, uint numTokens) public returns (bool) {
        address delegateAddress;
        delegateAddress = addressTable[delegate];
        allowed[msg.sender][delegateAddress] = numTokens;
        emit Approval(msg.sender, delegateAddress, numTokens);
        return true;
    }

    function allowance(address owner, address delegate) public override view returns (uint) {
        return allowed[owner][delegate];
    }

    function allowance(string memory owner, string memory delegate) public view returns (uint) {
        address ownerAddress;
        ownerAddress = addressTable[owner];
        address delegateAddress;
        delegateAddress = addressTable[delegate];
        return allowed[ownerAddress][delegateAddress];
    }

     function transferFrom(address owner, address buyer, uint numTokens) public override returns (bool) {
        require(numTokens <= balances[owner]);    
        require(numTokens <= allowed[owner][msg.sender]);

        balances[owner] = balances[owner].sub(numTokens);
        allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);
        balances[buyer] = balances[buyer].add(numTokens);
        emit Transfer(owner, buyer, numTokens);
        return true;
    }

    function transferFrom(string memory owner, string memory buyer, uint numTokens) public returns (bool) {
        address ownerAddress;
        ownerAddress = addressTable[owner];
        address buyerAddress;
        buyerAddress = addressTable[buyer];

        require(numTokens <= balances[ownerAddress]);    
        require(numTokens <= allowed[ownerAddress][msg.sender]);

        balances[ownerAddress] = balances[ownerAddress].sub(numTokens);
        allowed[ownerAddress][msg.sender] = allowed[ownerAddress][msg.sender].sub(numTokens);
        balances[buyerAddress] = balances[buyerAddress].add(numTokens);
        emit Transfer(ownerAddress, buyerAddress, numTokens);
        return true;
    }

    function registerUser(string memory user, uint256 nonce) public returns (bool) {
        if (addressTable[user] == address(0)) {
            addressTable[user] = msg.sender;
            emit RegistrationSuccessful(nonce);
            return true;
        } else {
            emit RegistrationFailed(nonce);
            return false;
        }
    }
}"
51072-0.sol,question,"contract Ive {

    address public creator;
    address public owner;


    mapping (address=>bool) allowedVisitors;
    address[] allowedVisitorsList;

    struct Client {
        address wallet;
        string apellido1;
        string apellido2;
        string apellidoCasada;
        string nombre1;
        string nombre2;
        string fechaNacimiento;
        address modifiedBy;
    }

    Client[] private clients;

    event OwnerAssigned(
        address creator,
        address owner
    );

    event VisitorAllowed(
        address owner,
        address newVisitor
    );

    event VisitorDisallowed(
        address owner,
        address newVisitor
    );

    modifier onlyAllowed() {
        if(allowedVisitors[msg.sender] == false)
            revert(""Account is not allowed to obtain client info"");
        _;
    }

    modifier onlyCreator() {
        if(msg.sender != creator)
            revert(""Only creator can execute this action"");
        _;
    }

    modifier onlyOwner() {
        if(msg.sender != owner)
            revert(""Only owner can execute this function"");
        _;
    }

    constructor () public {
        creator = msg.sender;
        owner = msg.sender;
    }

    function setClientInfo (
        string apellido1,
        string apellido2,
        string apellidoCasada,
        string nombre1,
        string nombre2,
        string fechaNacimiento
    ) 
        external returns (uint) 
    {
        Client memory newClient;

        newClient.apellido1 = apellido1;
        newClient.apellido2 = apellido2;
        newClient.apellidoCasada = apellidoCasada;
        newClient.nombre1 = nombre1;
        newClient.nombre2 = nombre2;
        newClient.fechaNacimiento = fechaNacimiento;
        newClient.modifiedBy = msg.sender;

        clients.push(newClient);

        return clients.length;
    }

    function getClientsLength () view public returns (uint) {
        return clients.length;
    }

    function setOwner(address _owner) onlyOwner external {
        owner = _owner;
        allowVisitor(_owner);
        
    }

    function obtainOwner() view external returns (address){
        return owner;
    }

    function allowVisitor(address visitor) public {
        if(!allowedVisitors[visitor]) {
            allowedVisitors[visitor] = true;
            allowedVisitorsList.push(visitor);
            emit VisitorAllowed(msg.sender, visitor);
        }
    }

    function isAllowedAccount(address account) view public returns (bool) {
        return allowedVisitors[account];
    }

    function disallowVisitor(address account) onlyOwner external {
        allowedVisitors[account] = false;
        emit VisitorDisallowed(msg.sender, account);
    }

    function getVisitorsLength() view public returns (uint) {
        return allowedVisitorsList.length;
    }

    function obtainClient(uint32 index) view onlyAllowed public returns (string, string, string, string) {
        return (clients[index].nombre1, clients[index].apellido1, clients[index].fechaNacimiento, clients[index].apellido2);
    }

    function getAllowedVisitors() view onlyOwner public returns (address[]) {
        return allowedVisitorsList;
    }

}"
84117-0.sol,question,"contract MyContract {

  struct MyStruct {
      address param1;
      address param2;
      address param3;
  }

  function init(address owner) public {}

  function init(MyStruct memory myStruct) public {}
}"
59790-0.sol,question,"contract ChainList  {

  struct  data  {
    uint   ownernumber;
    uint   id;
  }

  uint value;
  mapping (uint256 => data) public  datamatching;

  function storedata (uint _ownernumber, uint _id) public {
    var  persondata  = datamatching[value];
    persondata .ownernumber = _ownernumber;
    persondata. id  =  _id;
  }

  function getData(uint256 userId) returns (uint, uint){
    return (datamatching[userId].ownernumber, datamatching[userId].id);
  }
}"
64170-0.sol,question,"contract property {

    uint public value;
    string public location;
    
    constructor(uint  _value, string _location) public {
          value = _value;
          location = _location;          
    }

    function setval(uint _value) public{
        value = _value;

    }

function getloc1() public pure returns(memory string) {,<--- getting error here
    return location;
  }
}"
45881-0.sol,question,"contract SaveMyNumber {

    uint storedNumber;

    function set(uint x) public {
        storedNumber = x;
    }
}"
63443-1.sol,question,"contract childContract is parentContract {
    

    function getNum2() public view returns(uint) {
        return num;
    }
    function getNum3() public view returns(uint) {
        return getNum();
    }
    function getNum4() public view returns(uint) {
        return parentContract.getNum();
    }
}"
34170-0.sol,question,"contract Test {
    event Log(address addr);

    function logMe () public {
        Log(msg.sender);
    }
}"
81999-3.sol,question,"contract SimpleStorage {
    string public data;
    event MyEvent(
        uint256 indexed id,
        uint256 indexed date,
        string indexed value
    );
    uint256 nextId;

    function setData(string calldata _data) external {
        data = _data;
        emit MyEvent(nextId, now, ""Cazzo"");
        nextId++;
    }

    function getData() external view returns (string memory) {
        return data;
    }
}"
84408-2.sol,question,"contract Certify {

struct Record {
    uint mineTime;
    uint blockNumber;
    string instituteName;
    string recipientName;
    string courseName;
    string marks;
    string dateOfCompletion;
}

mapping (bytes32 => Record) private docHashes;

constructor() public {

}


function addDocHash(bytes32 hash, string memory insti, string memory reci, string memory course, string memory grade, string memory doc ) public {
    Record memory newRecord = Record(now, block.number,insti,reci,course,grade,doc);
    docHashes[hash] = newRecord;
}


function findDocHash(bytes32 hash) public view returns(uint, uint, string memory, string memory, string memory, string memory, string memory) {
    return (docHashes[hash].mineTime, docHashes[hash].blockNumber, docHashes[hash].instituteName, 
                docHashes[hash].recipientName, docHashes[hash].courseName, docHashes[hash].marks, docHashes[hash].dateOfCompletion);
}
}"
15824-0.sol,question,"contract EventTest {                
  event NumberEvent(uint indexed number);   

  function triggerEvent(uint val) returns (uint) { 
    NumberEvent(val);
    return 123;
  }                                 
}"
29127-1.sol,question,"contract StandardToken is Token {

  function transfer(address _to, uint256 _value) returns (bool success) {
    
    
    
    if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {
    
      balances[msg.sender] -= _value;
      balances[_to] += _value;
      Transfer(msg.sender, _to, _value);
      return true;
    } else { return false; }
  }"
2171-1.sol,question,"contract ECRecoverTest is Test {
  function testRecovery() {
    bytes32 foobar = 0x38d18acb67d25c8bb9942764b62f18e17054f66a817bd4295423adf9ed98873e;
    uint8 v = 0x00;
    bytes32 r = 0x723841761d213b60ac1cbf063207cbeba6c2725bcaf7c189e63f13d93fc1dc07;
    bytes32 s = 0x789d1dd423d25f0772d2748d60f7e4b81bb14d086eba8e8e8efb6dcff8a4ae02;

    log_address(ecrecover(foobar, v, r, s));
  }
}"
50266-0.sol,question,"contract try {
    mapping (address=>bytes32[10]) Map;

    function try(){}

    function fill_map(bytes32[10] _attributes) public  {
            Map[msg.sender].push(_attributes);
    }

    function get_map(address id) view public returns (bytes32[10]){
      return Map[id];
    }

}"
78669-0.sol,question,"contract SimpleAuction {

    address public beneficiary;
    uint public auctionEnd;

    address public highestBidder1;
    uint public highestBid1;

    address public highestBidder2;
    uint public highestBid2;

    uint public proportion;
    uint public bid1;
    uint public bid2;

    mapping(address => uint) pendingReturns;

    bool ended;


    constructor (uint _biddingTime) public {
        beneficiary = msg.sender;
        auctionEnd = now + _biddingTime;
    }

    function () public payable{
        makebid(proportion);
    }


    function makebid(uint var1) public payable {

        proportion = var1;
        bid1 = var1 * msg.value;
        bid2 = 1 - var1 * msg.value;
        require(now <= auctionEnd);

        require(bid1 > highestBid1);

        if (highestBid1 != 0) {
            pendingReturns[highestBidder1] += highestBid1;
        }
        highestBidder1 = msg.sender;
        highestBid1 = bid1;

    }

        require(bid2 > highestBid2);

        if (highestBid2 != 0) {
            pendingReturns[highestBidder2] += highestBid2;
        }
        highestBidder2 = msg.sender;
        highestBid2 = bid2;

    }"
17889-0.sol,question,"contract owned {
    function owned() { owner = msg.sender; }
    address owner;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
}"
17889-0.sol,question,"contract mortal is owned {

    function close() onlyOwner {
        selfdestruct(owner);
    }
}"
17889-0.sol,question,"contract priced {

    modifier costs(uint price) {
        if (msg.value >= price) {
            _;
        }
    }
}"
17889-0.sol,question,"contract Mutex {
    bool locked;
    modifier noReentrancy() {
        require(!locked);
        locked = true;
        _;
        locked = false;
    }

    function f() noReentrancy returns (uint) {
        require(msg.sender.call());
        return 7;
    }
}"
25154-1.sol,question,"contract B {
    address owner
    string public name;

    function B(address _owner, string _name) {
        owner = _owner;
        name = _name;
    }
}"
51743-0.sol,question,"contract TokenHeaven is StandardToken {

    function () {
        throw;
    }

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = 'H1.0';    

    function TokenHeaven() {
        balances[msg.sender] = 180000000000000000000000000;
        totalSupply = 180000000000000000000000000;
        name = ""TokenHeaven"";
        decimals = 18;
        symbol = ""THV"";
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}"
41669-0.sol,question,"contract PayTest {
function() public payable {
}

function withdraw() {
    msg.sender.transfer(4000000000 wei);
}"
32990-0.sol,question,"contract A {
    address owner;
    uint randomVariable;

    function A(uint _randomVariable) {
        owner = msg.sender;
        randomVariable = _randomVariable;
    }
}"
32990-0.sol,question,"contract B is A {
    address owner;
    uint randomVariable2;

    function B(uint _randomVariable2) {
        owner = msg.sender;
        randomVariable2 = _randomVariable2;
    }

    function changeOwner(address _newOwner) {
        owner = _newOwner;
    }
}"
46354-2.sol,question,"contract ShahzadTestCoin is StandardToken { 

    

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = 'H1.0'; 
    uint256 public unitsOneEthCanBuy;     
    uint256 public totalEthInWei;         
    address public fundsWallet;           

    
    
    function ShahzadTestCoin() {
        balances[msg.sender] = 1000000000000000000000;               
        totalSupply = 1000000000000000000000;                        
        name = ""ShahzadTestCoin"";                                   
        decimals = 18;                                               
        symbol = ""STCN"";                                             
        unitsOneEthCanBuy = 10;                                      
        fundsWallet = msg.sender;                                    
    }

    function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        require(balances[fundsWallet] >= amount);

        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;

        Transfer(fundsWallet, msg.sender, amount); 

        
        fundsWallet.transfer(msg.value);                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}"
63013-0.sol,question,"contract AccessControlListContract {
    mapping(address => mapping(string=> mapping(address => string[]))) _userAccessGrants;
    mapping(address => mapping(address => mapping(string => string[]))) _targetAccessGrants;

    
    function grantAccess(address userAddress, string documentHash, address targetUserAddress, string permission) public {
        _userAccessGrants[userAddress][documentHash][targetUserAddress].push(permission); 
        _targetAccessGrants[targetUserAddress][userAddress][documentHash].push(permission);       
    }

    function checkAccess(address requestorAddress, address userAddress, string documentHash) public view returns (string[]) {
        return _targetAccessGrants[requestorAddress][userAddress][documentHash];
    }
}"
8042-0.sol,question,"contract token {
    mapping (address => uint256) public voteWeight;
    uint public numberOfDelegationRounds;

    function balanceOf(address member) constant returns (uint256 balance) {
        if (numberOfDelegationRounds < 3)
            return 0;
        else
            return this.voteWeight(member);
    }
}"
66530-1.sol,question,"contract Locations {

    function doSomething() public pure returns (uint[] memory) {

    uint[] memory localMemoryArray1 = new uint[](3);
    localMemoryArray1[0] = 4;
    localMemoryArray1[1] = 5;
    localMemoryArray1[2] = 6;

    uint[] memory localMemoryArray2 = localMemoryArray1;
    localMemoryArray1[0] = 10; 
    return localMemoryArray2;
  }
}"
80105-0.sol,question,"contract MyContract {
    function myFunction() public pure returns(uint256 myNumber, string memory myString) {
        return (23456, ""Hello!%"");
    }
}"
62419-1.sol,question,"contract DappTokenSale {
    address admin;
    **DappToken public tokenContract;**
    uint256 public tokenPrice;
    uint256 public tokensSold;

function DappTokenSale(DappToken _tokenContract, uint256 _tokenPrice) public {
    admin = msg.sender;
    tokenContract = _tokenContract;
    tokenPrice = _tokenPrice;
}
}"
82038-0.sol,question,"contract Tester {
    uint256 public gasUsed;

    function transfer(IERC20Token _token, address _to, uint256 _value) public {
        uint256 bgn = gasleft();
        require(_token.transfer(_to, _value));
        uint256 end = gasleft();
        gasUsed = bgn - end;
    }
}"
33021-0.sol,question,"contract Human is TokenERC20 {

    uint256 public etherRate;

    
    function Human() TokenERC20(10, ""Human"", ""HUM"") payable public {
        etherRate = 1000;
    }

    function () payable public {
        buy();
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != 0x0);                               
        require (balanceOf[_from] >= _value);               
        require (balanceOf[_to] + _value > balanceOf[_to]); 
        balanceOf[_from] -= _value;                         
        balanceOf[_to] += _value;                           
        Transfer(_from, _to, _value);
    }

    
    function buy() payable public {
        uint amount = msg.value * etherRate;               
        _transfer(this, msg.sender, amount);              
    }

    
    
    function sell(uint256 amount) public {
        require(this.balance >= amount / etherRate);      
        _transfer(msg.sender, this, amount);              
        msg.sender.transfer(amount / etherRate);          
    }
}"
69226-1.sol,question,"contract AccessControl {
    mapping (address => bool) authorized;

    function getSomething () public view returns (string) { 
        require(authorized[msg.sender]);
        return ""hello"";
    }
}"
68257-0.sol,question,"contract HelloWorld {      
    uint256 counter = 5;

    function add() public {  
        counter++;
    }   
    function subtract() public { 
        counter--;
    }   
    function getCounter() public view returns (uint256) {
        return counter;
    } 
}"
49104-0.sol,question,"contract GuessTheRandomNumberChallenge {
    uint8 answer;

    function GuessTheRandomNumberChallenge() public payable {
        require(msg.value == 1 ether);
    }

    function guess(uint8 n) public payable {
        require(msg.value == 1 ether);

        
    }
}"
57034-1.sol,question,"contract Crowdsale {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  
  ERC20 public token;

  
  address public wallet;

  
  
  
  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  event TokenPurchase(
    address indexed purchaser,
        address indexed beneficiary,
    uint256 value,
    uint256 amount
  );

  
  constructor(uint256 _rate, address _wallet, ERC20 _token) public {
    require(_rate > 0);
    require(_wallet != address(0));
    require(_token != address(0));

    rate = 8 * (10**8);
    wallet = 0xF76075Cf3B674fB9656E393e9e17091B01243666;
    token = token = ERC20(0x0f26c1c05f1bbBC7Eff0488F1a98619e8a9758cf);
  }

  
  
  

  
  function () external payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address _beneficiary) public payable {

    uint256 weiAmount = msg.value;
    _preValidatePurchase(_beneficiary, weiAmount);

    
    uint256 tokens = _getTokenAmount(weiAmount);

    
    weiRaised = weiRaised.add(weiAmount);

    _processPurchase(_beneficiary, tokens);
    emit TokenPurchase(
      msg.sender,
      _beneficiary,
      weiAmount,
      tokens
    );

    _updatePurchasingState(_beneficiary, weiAmount);

    _forwardFunds();
    _postValidatePurchase(_beneficiary, weiAmount);
  }

  
  
  

  
  function _preValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    require(_beneficiary != address(0));
    require(_weiAmount != 0);
  }

  
  function _postValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _deliverTokens(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    token.safeTransfer(_beneficiary, _tokenAmount);
  }

  
  function _processPurchase(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    _deliverTokens(_beneficiary, _tokenAmount);
  }

  
  function _updatePurchasingState(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _getTokenAmount(uint256 _weiAmount)
    internal view returns (uint256)
  {
    return _weiAmount.mul(rate);
  }

  
  function _forwardFunds() internal {
    wallet.transfer(msg.value);
  }
}"
63254-1.sol,question,"contract getSchwifty {
  struct myData
  {
    string actualData;
    bool dataFlag;
  }

  mapping(string=>myData) records;

  function addData(string id, string hashData) public {
    if (records[id].dataFlag != true)
    {
        records[id].actualData = hashData;
        records[id].dataFlag = true;
    }
  }

  function getData(string id) external view returns (string) {
        if (records[id].dataFlag == true)
           return records[id].actualData;
        else
           return ""NULL"";
  }

}"
51277-0.sol,question,"contract Ownable {
  address public owner;


  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  
  function Ownable() public {
    owner = msg.sender;
  }


  
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}"
51277-0.sol,question,"contract TOKKA is StandardToken {
    string public name = ""Test Token"";
    string public symbol = ""TT"";
    uint256 public decimals = 18;

    uint256 constant INITIAL_SUPPLY = 50000000 * 10**18;
    function TOKKA () public {
       balances[msg.sender] = INITIAL_SUPPLY;
    }
}"
51277-0.sol,question,"contract Crowdsale is Ownable {
  using SafeMath for uint256;

   
  TOKKA public token;

  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate ;

  
  uint256 public weiRaised;

  
  uint256 public CAP = 68254061116636440000000;

  bool crowdsaleClosed = false;

  

  uint256 public PreIcobonusEnds = 1535731200;

  uint256 public StgOnebonusEnds = 1538323200;
  uint256 public StgTwobonusEnds = 1541001600;
  uint256 public StgThreebonusEnds = 1543593600;
  uint256 public StgFourbonusEnds = 1546272000;




  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != address(0));

    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;

    

    



    token = createTokenContract();
  }



function createTokenContract() internal returns (TOKKA) {
    return new TOKKA();
  }


  
  function () external payable {
    buyTokens(msg.sender);
  }

  
function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());
    require(!crowdsaleClosed);

    



    if (now <= PreIcobonusEnds) {
            rate = 667;
         } 

     else if (now <= StgOnebonusEnds && now > PreIcobonusEnds) {
            rate = 641;
         }  

        else if (now <= StgTwobonusEnds && now > StgOnebonusEnds ) {
            rate = 616;
         }  


         else if (now <= StgThreebonusEnds && now > StgTwobonusEnds ) {
            rate = 590;
         } 
         else if (now <= StgFourbonusEnds && now > StgThreebonusEnds ) {
            rate = 564;
         }
        else{
            rate = 513;
        }



    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);

    
    weiRaised = weiRaised.add(weiAmount);

    
    
    
    StandardToken(token).transfer(beneficiary, tokens);

    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
}


  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }


  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }


  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

  function GoalReached() public view returns (bool) {

    return (weiRaised >= CAP);
  }

  function Pause() public onlyOwner
  {
       

        
        require(weiRaised >= CAP);

        crowdsaleClosed = true;
  }

  function Play() public onlyOwner
  {
       

        
        require(crowdsaleClosed == true);

        crowdsaleClosed = false;
  }

}"
38361-1.sol,question,"contract TestCryptoSportsToken {
    PromoContract promoContract = PromoContract (DeployedAddresses.PromoContract ());
    

    
    function testCreatePromoPerson() public {
      promoContract.createPromoPerson(""0xf7ca47eabf0e98af942fa45a5e8cdc05b7100eb4"", ""Test Person"", 1);


    }
}"
76678-0.sol,question,"contract BurnEth {

    function burnEth() public payable {
        address(0).transfer(msg.value);
    }
}"
65849-0.sol,question,"contract store {
    string public storage_;

    function store_it(string memory s) public {
        storage_=s;
    }
}"
16049-0.sol,question,"contract Forwarder {
  
  address public destinationAddress;

  
  function Forwarder() {
    destinationAddress = msg.sender;
  }

  
  function() payable {
        if (!destinationAddress.send(msg.value))
            throw;
  }

  
  function flush() {
    if (!destinationAddress.send(this.balance))
          throw;
  }
}"
50323-1.sol,question,"contract patient {

    doctor doctor_obj;

    function patient(address _doctor_contract) {
        doctor_obj = doctor(_doctor_contract);
    }

    function check_if_doctor(address _ddoctor) returns(bool) {

        return doctor_obj.doctor_exist(_ddoctor);
    }

    function add_doc(address _d, string _s) {
        doctor_obj.add_doctors(_d, _s);
    }

    function A() payable {

    }
}"
70077-1.sol,question,"contract MyContract {
enum State { Waiting, Ready, Active }
State public state;

constructor() public {
    state = State.Waiting;
}

function activate() public {
    state = State.Active;
}

function isActive() public view returns(bool) {
    return state == State.Active;
}
}"
41075-1.sol,question,"contract ERC20 {
  function transfer(address _recipient, uint256 _value) public returns (bool success);
}"
41075-1.sol,question,"contract Airdrop {
  function drop(ERC20 token, address[] recipients, uint256[] values) public {
    for (uint256 i = 0; i < recipients.length; i++) {
      token.transfer(recipients[i], values[i]);
    }
  }
}"
29120-1.sol,question,"contract C {
    Set.Data knownValues;

    function register(uint value)external {
        require(Set.insert(knownValues, value));
    }
}"
9741-0.sol,question,"contract A {  
   int private x;          
   function save(int _x) {
       x = _x;
   }
   function get() returns (int) {
       return x;
   }
}"
9741-0.sol,question,"contract B {    
   A private a;    
   function B(address _a) {
       a = A(_a);
   }    
   function doStuff() {
       a.save(42);
   }
   function getStuff()  returns (int) {
       return a.get();
   }
}"
9741-0.sol,question,"contract C {
   B private b;    
   function C(address _b) {
       b = B(_b);
   }
   function calculateTheMeaning() {
      b.doStuff();
   }
   function getTheAnswer() returns (int) {
      return b.getStuff();
   }
}"
51100-0.sol,question,"contract TokenERC20 {
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        emit Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        emit Burn(_from, _value);
        return true;
    }
}"
61271-0.sol,question,"contract Election {
  
  address public owner;

  constructor() public {
    owner = msg.sender;
    addCandidate(""NOTA"");
    addCandidate(""BJP"");
    addCandidate(""CONGRESS"");
    addCandidate(""JDS"");
    addCandidate(""others"");
    addCandidate(""jdu"");
    addCandidate(""amma-party"");

  }

  
  address[] validVoters;

  
  mapping(address => bool) voters;

  
  event LogAccess(address indexed by, string method, string desc);

  
  struct Candidate {
    int id;
    string name;
    int voteCount;
    address[] votersList;
  }

  
  string[] candidateNames;

  
  int[] candidateIds;

  

  mapping(int => Candidate) public candidates;

  
  int candidateId = 100;

  
  function addCandidate(string name) private {
    candidateId++;
    address[] memory votedPeople;
    candidates[candidateId] = Candidate(candidateId, name, 0, votedPeople);
    candidateIds.push(candidateId);
    candidateNames.push(name);

  }

  
  function getCandidateIds() public view returns(int[]) {
    return candidateIds;
  }

  
  function getCandidateNames() public view returns(string[]) {
    return candidateNames;
  }

  
  function addVoters(address voter) public {
    require(msg.sender == owner);
    validVoters.push(voter);
  }

  
  function deleteVoter(address voter) public {
    require(msg.sender == owner);
    for (uint i = 0; i < validVoters.length; i++) {
      if (validVoters[i] == voter) {
        delete validVoters[i];
      }
    }
  }

  
  function isValidVoter(address voter, string method) private returns(bool) {
    for (uint i = 0; i < validVoters.length; i++) {
      if (validVoters[i] == voter) {
        emit LogAccess(voter, method, ""successful access(eligible to vote)"");
        return true;
      }

    }
    emit LogAccess(voter, method, ""access failed(not eligible to vote)"");
    return false;
  }

  
  function vote(int _candidateId) public {
    if (isValidVoter(msg.sender, ""vote"")) {
      
      require(!voters[msg.sender]);

      
      require(_candidateId > 0 && _candidateId <= candidateId);

      
      voters[msg.sender] = true;

      
      candidates[_candidateId].voteCount++;

      
      candidates[_candidateId].votersList.push(msg.sender);

    }

  }

  function getVotersList(int id) public view returns(address[]) {
    require(msg.sender == owner);
    return candidates[id].votersList;
  }
}"
35203-0.sol,question,"contract ContractFactory {
    address[] public deployed;

    function createSubContract() public {
        deployed.push(new SubContract());
    }
}"
35203-0.sol,question,"contract SubContract {
    uint public var1;
    uint public var2;

    function SubContract() public {
        var1 = 1;
        var2 = 10000;
    }
}"
68843-0.sol,question,"contract Election {
  struct Candidates {
    string name;
    uint voteCount;
  }

  struct voter {
    bool authorized;
    bool voted;
    uint vote;
  }

  address public owner;
  string public electionName;

  mapping(address => voter) public voters;
  Candidate[] public candidates; 
  uint public totalVotes;

  modifier ownerOnly() {
    require(msg.sender == owner);

    _;
  }

  function electionName(string _name) public {
    owner = msg.sender;
    electionName = _name;
  }

  function addCandidate(string _name) ownerOnly public {
    candidates.push(Candidate(_name, 0));
  }

  function getNumCandidate() public view returns(uint) {
    return candidates. length;
  }

  function authorize( address _person) ownerOnly public{
    voters[_person].authorized = true;
  }

  function vote(uint voteIndex) public {
    require(!voters[msg.sender].voted);
    require(voters[msg.sender].authorized);

    voters[msg.sender].voted = true;
    voters[msg.sender].voteIndex = _voteIndex;

    candidates[_voteIndex].voteCount += 1;
    selfdestruct(owner);
  }
}"
7259-0.sol,question,"contract Wallet {

        
        event PreExecute(address to, uint value, uint gas);
        event Execute(address to, uint value, uint balanceAfter, uint spentGas);
        event ExceededExecuteWithValue(address to, uint value);
        event FailedExecute(address to, uint value, uint balanceAfter);

        
        
        address owner;

        function Wallet() {
            
            
            owner = msg.sender;
        }

        
        function execute(address _to, uint _value, uint _gas, bytes _data) external {

            uint balanceBefore;
            uint balanceAfter;
            bool success;

            if(msg.sender != owner) {
                throw;
            }

            if(_value > this.balance) {
                ExceededExecuteWithValue(_to, _value);
                return;
            }

            balanceBefore = this.balance;

            
            if(_value > 0) {
                success = _to.call.value(_value)(_data);
            } else {
                success = _to.call(_data);
            }

            balanceAfter = this.balance;

            if(success) {
                Execute(_to, _value, balanceAfter, (balanceBefore - balanceAfter) - _value);
            } else {
                FailedExecute(_to, _value, balanceAfter);
            }
        }

        
        function() {
            
            if (msg.value > 0) {
                Deposit(msg.sender, msg.value);
            }
        }

    }"
73468-0.sol,question,"contract Fundraiser {
    mapping(address=>uint) balances;

    function withdrawCoins(){ 
      uint withdrawAmount = balances[msg.sender];
      Wallet wallet = Wallet(msg.sender);
      wallet.payout.value(withdrawAmount)();
      balances[msg.sender] = 0;
    }

    function getBalance() constant returns (uint) {
        return address(this).balance;
    }

    function contribute() payable {
        balances[msg.sender] += msg.value;
    }

    function() payable {

    }
}"
2164-0.sol,question,"contract C {
    uint someVariable;
    uint[] data;
    function f() {
        uint[] x = data;
        x.push(2);
    }
}"
83185-0.sol,question,"contract ReceiveEther {

uint256 public count;

function () external payable {
    require(count < 2);
    count++;
}


function getBalance() public view returns (uint) {
    return address(this).balance;

}
}"
83185-0.sol,question,"contract SendEther {
    function sendViaCall (address payable _to) public payable {
        (bool sent, bytes memory data) = _to.call.value(msg.value)("""");
        require (sent, ""failed to send ether"");
    }
}"
82951-0.sol,question,"contract MyContract {
  address internal constant UNISWAP_ROUTER_ADDRESS = 0xcDbE04934d89e97a24BCc07c3562DC8CF17d8167; 

  IUniswapV2Router01 public uniswapRouter;

  constructor() public {
    uniswapRouter = IUniswapV2Router01(UNISWAP_ROUTER_ADDRESS);
  }

  function swapEthForTokenWithUniswap(uint ethAmount, address tokenAddress) public onlyOwner {
    
    require(ethAmount <= address(this).balance, ""Not enough Eth in contract to perform swap."");

    
    address[] memory path = new address[](2);
    path[0] = uniswapRouter.WETH();
    path[1] = tokenAddress;

    
    
    uniswapRouter.swapExactETHForTokens.value(ethAmount)(0, path, address(this), now + 15);
  }

  function depositEth() external payable {
    
  }
}"
51172-0.sol,question,"contract Foo {
    uint storageData;
    Bar bar;
    address barContractAddress;

    constructor(address _barContractAddress) public {
        barContractAddress = _barContractAddress;
    }

    function set(uint x) public {
        storageData = x;
    }

    function get() view public returns (uint) {
        return storageData;
    }

    function baz() public returns (uint) {
        bar = Bar(barContractAddress);
        storageData = bar.baz(storageData);
    }

}"
60671-0.sol,question,"contract Shopping {

    struct Article {
        uint id; 
        address seller;
        address buyer;
        string name;
        string description;
        uint256 price;
    }

    
    mapping(uint256 => Article) public articles; 
    uint articleCounter;

    function buyArticle(uint _id ) public payable {
        Article  storage article = articles[_id];
        require( article.buyer == 0x0);                                      
        require(msg.sender != article .seller]);
    }
}"
8421-0.sol,question,"contract HelloWorld {
    struct Items {
       address id;
       string data;
    }

    mapping(address => Items) items;

    function getItem(address key) returns (string) {
      return items[key].data;
    }

    function addItem (address key, string data) returns (bool) {
        Items item = items[key];
        item.data = data;
    }

   }"
69803-0.sol,question,"contract owned {
  address public owner;
  constructor () public {
    owner=msg.sender;
  }

  modifier onlyOwner {
    require (msg.sender == owner);
    _;
  }
}"
69803-0.sol,question,"contract EdCoin is owned {
  string public name;
  string public symbol;
  uint8 public decimals = 18;
  uint256 public totalSupply;

  mapping (address => bool) public frozenAccount;
  mapping (address => uint256) public balanceOf;

  event Transfer (address indexed from, address indexed to, uint256 value);
  event FrozenFunds (address target, bool frozen);
  event Burn(address indexed from, uint256 value);

  constructor(
    uint256 initialSupply,
    string memory tokenName,
    string memory tokenSymbol
  ) public {
    totalSupply = initialSupply * 10 ** uint256(decimals);  
    balanceOf[msg.sender] = totalSupply;                
    name = tokenName;                                   
    symbol = tokenSymbol;                               
  }

  function _transfer (address _from, address _to, uint _value) internal {
    require(_to != address(0x0));
    require(!frozenAccount[_to]);
    require(!frozenAccount[_from]);
    require(balanceOf[_from] >= _value);
    require(balanceOf[_to] + _value >= balanceOf[_to]);
    uint previousBalances = balanceOf[_from] + balanceOf[_to];
    balanceOf[_from] -= _value;
    balanceOf[_to] += _value;
    emit Transfer(_from, _to, _value);
    assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
  }

  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    require (_to != address(0x0));                          
    require (balanceOf[_from] >= _value);
    require (balanceOf[_to] + _value >= balanceOf[_to]);
    require(!frozenAccount[_from]);
    require(!frozenAccount[_to]);                           
    _transfer(_from, _to, _value);
    return true;
  }

  function transferN (address _to, uint256 _value) public returns (bool success) {
    require (_to != address(0x0));  
    require(balanceOf[msg.sender] >= _value);

    balanceOf[msg.sender] -= _value;
    balanceOf[_to] += _value;

    emit Transfer(msg.sender, _to, _value);

    return true;
  }

  function burn(uint256 _value) public returns (bool success) {
    require(balanceOf[msg.sender] >= _value);   
    balanceOf[msg.sender] -= _value;            
    totalSupply -= _value;                      
    emit Burn(msg.sender, _value);
    return true;
  }

  function burnFrom(address _from, uint256 _value) public returns (bool success) {
    require(balanceOf[_from] >= _value);                
    balanceOf[_from] -= _value;                         
    totalSupply -= _value;                              
    emit Burn(_from, _value);
    return true;
  }

  function freezeAccount(address target, bool freeze) public {
    frozenAccount[target] = freeze;
    emit FrozenFunds(target, freeze);
  }

  function distributeToken(address[] memory addresses, uint256[] memory _value) public returns (bool success) {
    for( uint256 i=1;i<addresses.length;i++){
      _transfer(addresses[0], addresses[i], _value[i]);
    }
    return true;
  }

  function mintToken(address target, uint256 mintedAmount) onlyOwner public {
    balanceOf[target] += mintedAmount;
    totalSupply += mintedAmount;
    emit Transfer(address(0), address(this), mintedAmount);
    emit Transfer(address(this), target, mintedAmount);
  }
}"
78492-2.sol,question,"contract MonsterFood {

ERC721 public nonFungibleContract;

bool public isMonsterFood = true;

uint32 potionDuration = uint32(6 hours);

event PotionCreated(uint code);
event PotionDeleted(uint code);

constructor(address _nftAddress, address _backendAddress) public {
    ownerAddress = msg.sender;
    ERC721 candidateContract = ERC721(_nftAddress);
    nonFungibleContract = candidateContract;
    backendAddress = _backendAddress;
}

modifier onlyOwner() {
    require(msg.sender == ownerAddress);
    _;
}

modifier onlyCore() {
    require(msg.sender == address(nonFungibleContract));
    _;
}

function setTokenContract(address _nftAddress) external onlyOwner
{
    ERC721 candidateContract = ERC721(_nftAddress);
    nonFungibleContract = candidateContract;
}

uint[] public cdPricesGrow = [
    10000 szabo,
    20000 szabo,
    30000 szabo,
    40000 szabo,
    50000 szabo,
    55000 szabo,
    60000 szabo,
    65000 szabo,
    70000 szabo,
    80000 szabo,
    85000 szabo,
    90000 szabo,
    108000 szabo,
    120000 szabo
    ];



uint[] public cdPricesRest = [
    10000 szabo,
    20000 szabo,
    30000 szabo,
    40000 szabo,
    50000 szabo,
    55000 szabo,
    60000 szabo,
    65000 szabo,
    70000 szabo,
    80000 szabo,
    85000 szabo,
    90000 szabo,
    108000 szabo,
    120000 szabo
];


struct Potion {
    uint16 code;
    uint256 priceWei;
    uint8 potionEffect;
    bool exists;
}

uint256 public feedingFee = 5 finney;

function setFeedingFee(uint256 val) external onlyOwner {
    feedingFee = val;
}

address public ownerAddress;

mapping (uint16 => Potion) codeToPotionIndex;

function setOwner(address newOwner) public onlyOwner{
    require(newOwner != address(0));
    ownerAddress = newOwner;
}



function setPotionDuration(uint newDuration) external onlyOwner{
    require(newDuration > 0);
    potionDuration = uint32(newDuration);
}

function createPotion(uint _priceWei, uint _code, uint _potionEffect) external onlyOwner returns(uint) {
    require(_code > 2 && _potionEffect > 0);
    require(_code == uint(uint16(_code)));

    Potion memory _potion = Potion({
        priceWei: _priceWei,
        code: uint16(_code),
        potionEffect: uint8(_potionEffect),
        exists: true
    });

    codeToPotionIndex[uint16(_code)] = _potion;

    emit PotionCreated(_potion.code);
    return _potion.code;
}

function feedMonster(address originalCaller, uint foodCode, uint p1, uint p2, uint p3) onlyCore public payable
returns(uint p1_, uint p2_, uint p3_)
{
    require(foodCode == 1 || foodCode == 2);
    require(originalCaller != address(0));
    bool free = originalCaller == backendAddress;

    MonsterLib.Monster memory mon = MonsterLib.decodeMonsterBits(p1, p2, p3);

    if(foodCode == 1) 
    {
        applyGrow(originalCaller, mon, free);
    } 
    else if(foodCode == 2)
    {
        applyCDR(originalCaller, mon, free);
    }

    

    (p1_, p2_, p3_) = MonsterLib.encodeMonsterBits(mon);
}




function applyCDR(address originalCaller, MonsterLib.Monster monster, bool free) internal
{
    require(monster.cooldownEndTimestamp > now);
    require(monster.cooldownEndTimestamp > monster.cooldownStartTimestamp);
    uint totalPriceWei = cdPricesRest[monster.activeRestCooldownIndex];
    uint totalCdLength = monster.cooldownEndTimestamp - monster.cooldownStartTimestamp;
    uint remainingCdLength = monster.cooldownEndTimestamp - now;

    uint price = 0;
    if(!free)
    {
        price = (10000 * remainingCdLength / totalCdLength) * totalPriceWei / 10000;
        price += feedingFee;
        require(msg.value >= price);
    }

    monster.cooldownEndTimestamp = uint64(now);
    monster.activeRestCooldownIndex = 0;
    monster.activeGrowCooldownIndex = 0;

    originalCaller.transfer(msg.value - price);
}

function applyGrow(address originalCaller, MonsterLib.Monster monster, bool free)  internal 
{
    require(monster.level < 1);
    require(monster.cooldownEndTimestamp > monster.cooldownStartTimestamp);

    uint totalPriceWei = cdPricesGrow[monster.activeRestCooldownIndex];
    uint totalCdLength = monster.cooldownEndTimestamp - monster.cooldownStartTimestamp;

    uint remainingCdLength = 0;
    if(monster.cooldownEndTimestamp > now)
    {
        remainingCdLength = monster.cooldownEndTimestamp - now;
    }

    uint price = 0;

    if(!free)
    {
        price = (10000 * remainingCdLength / totalCdLength) * totalPriceWei / 10000;
        price += feedingFee;
        require(msg.value >= price);
    }

    monster.level = 1;
    monster.cooldownEndTimestamp = uint64(now);
    monster.activeRestCooldownIndex = 0;
    monster.activeGrowCooldownIndex = 0;

    originalCaller.transfer(msg.value - price);

}


function getPotion(uint256 _potionCode)
    external
    view
    returns (
    uint256 priceWei,
    uint256 potionEffect,
    bool exists
) {
    Potion storage _potion = codeToPotionIndex[uint16(_potionCode)];
    require(_potion.exists);
    exists = _potion.exists;
    priceWei = _potion.priceWei;
    potionEffect = _potion.potionEffect;
}


function deletePotion(uint _code) public onlyOwner {
    delete codeToPotionIndex[uint16(_code)];
    emit PotionDeleted(_code);
}

function withdrawBalance() external {
    address nftAddress = address(nonFungibleContract);

    require(
        msg.sender == ownerAddress ||
        msg.sender == nftAddress
    );
    
    nftAddress.transfer(address(this).balance);
}}"
37846-1.sol,question,"contract OuterContract {
    InnerContract pInnerContract;

    function func(uint256 val) external returns (uint256) {
        return pInnerContract.func(val) + 1;
    }
}"
59474-0.sol,question,"contract sample {
 string public name = ""ZeonLab"";
 function set(string _name) {
    name = _name;
 }

 function get() constant returns (string) {
   return name;
 }
}"
76563-0.sol,question,"contract C {
  struct S {address a;}
  function F(S calldata) external pure returns (uint256) {return 0;}
}"
30073-0.sol,question,"contract Coursetro {

string fName;
uint age;

function setInstructor(string _fName, uint _age) public {
    fName = _fName;
    age = _age;
}

function getInstructor() public constant returns (string, uint) {
    return (fName, age);
}
}"
36631-0.sol,question,"contract Echos is AccessControl {

    event logPrintedCertificate(address contractAddress, string _name, string _course);

    function printCertificate (string _name, string _course) public canAccess(""printCertificate"") whenNotPaused returns (address _certificateAddress) {

        
        address certificateAddr ess = new EchosCertificate(_name, _course);

        
        logPrintedCertificate(certificateAddress, _name, _course);

        return certificateAddress;
    }

    
    function invalidateCertificate(address _certificateContract) external canAccess(""printCertificate"") {
        EchosCertificate certContract = EchosCertificate(_certificateContract);
        certContract.invalidate();
    }

}"
1318-0.sol,question,"contract Sample {

struct Participant {
    address etherAddress;
    uint amount;
}

Participant[] public participants;
uint public amountRaised;

function() {
    enter();
}

function enter() {
    uint amount = msg.value;
    uint n = participants.length;

    participants.length += 1;
    participants[n].etherAddress = msg.sender;
    participants[n].amount = amount;

    amountRaised += amount;
}

}"
12119-0.sol,question,"contract MyContract {
    address public creator;

    function MyContract() {
        creator = msg.sender;
    }

    function reject() {
        selfdestruct(creator);
    }

    function send(address target, uint256 amount) {
        if (!target.send(amount)) throw;
    }
       function destroy(address target) {

        selfdestruct(0x0000000000000000000000000000000000000000);
    }
}"
44805-1.sol,question,"contract Service is Ownable {

    using SafeMath for uint256;

    event DidMakePayment(address player, uint256 value);
    event DidAddFunds(uint amount, uint balance);

    function Service() public {}

    function execute() payable public onlyOwner {
        uint amount = address(this).balance;
        
        owner.transfer(amount);
        emit DidMakePayment(owner, amount);
    }

    function addFunds() payable { emit DidAddFunds(msg.value, address(this).balance); }

    function getBalance() public view returns (uint256) { return address(this).balance; }
}"
16058-0.sol,question,"contract Test_Uint {
    uint public something;

    function Test_Uint() {
        something = 42;
    }
}"
24003-2.sol,question,"contract ZonoToken is StandardToken {
  string public name = 'ZONO';
  string public symbol = 'ZONO';
  address public owner = 0x683821afb3f4f4fafffdb259254ae870a091e3b4;
  uint public decimals = 0;
  uint public INITIAL_SUPPLY = 100;

  function ZonoToken() {
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
  }

  function() payable { deposit(); }

  function deposit() payable {
    owner.transfer(msg.value);
    uint newTokens = (msg.value * 10) / 1 ether;
    balances[msg.sender] = balances[msg.sender] + newTokens;
  }
}"
9756-2.sol,question,"contract ExtraBalToken {
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            
        Transfer(msg.sender, _to, _value);                   
    }

    
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                 
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  
        if (_value > allowance[_from][msg.sender]) throw;   
        balanceOf[_from] -= _value;                          
        balanceOf[_to] += _value;                            
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    
    function () {
        throw;     
    }

    uint constant D160 = 0x10000000000000000000000000000000000000000;

    address public owner;

    function ExtraBalToken() {
        owner = msg.sender;
    }

    bool public sealed;
    
    
    function fill(uint[] data) {
        if ((msg.sender != owner)||(sealed))
            throw;

        for (uint i=0; i<data.length; i++) {
            address a = address( data[i] & (D160-1) );
            uint amount = data[i] / D160;
            if (balanceOf[a] == 0) {   
                balanceOf[a] = amount;
                totalSupply += amount;
            }
        }
    }

    function seal() {
        if ((msg.sender != owner)||(sealed))
            throw;

        sealed= true;
    }

}"
17214-1.sol,question,"contract Testing {


  function Testing() payable {
  }

  event asking (address sender, uint q);
  event responding (address sender, uint r);


  function query(uint q){
    asking(msg.sender, q);
  }

  function response(uint r){
    responding(msg.sender, r);
  }
}"
30462-0.sol,question,"contract DieselPrice is usingOraclize {
        event one(string description);
        event newDieselPrice(string price);


        function DieselPrice() {
            update(); 
        }

        function __callback(bytes32 myid, string result) {
            require(msg.sender != oraclize_cbAddress()); 
            newDieselPrice(result);
            
            
        }

        function update() payable {
            one(""Oraclize query was sent, standing by for the answer.."");
            oraclize_query(""URL"", ""xml(https:
        }

    }"
79751-0.sol,question,"contract MyERC20TokenSale {
address payable admin;
MyERC20Token public tokenContract;
uint256 public tokenPrice;
uint256 public tokensSold;

event Sell(address _buyer, uint256 _amount);

constructor(MyERC20Token _tokenContract, uint256 _tokenPrice) public {
    admin = msg.sender;
    tokenContract = _tokenContract;
    tokenPrice = _tokenPrice;
}

function multiply(uint x, uint y) internal pure returns (uint z) {
    require(y == 0 || (z = x * y) / y == x);
}

function buyTokens(uint256 _numberOfTokens) public payable {
    require(msg.value == multiply(_numberOfTokens, tokenPrice));
    require(tokenContract.balanceOf(address(this)) >= _numberOfTokens);
    require(tokenContract.transfer(msg.sender, _numberOfTokens));

    tokensSold += _numberOfTokens;

    emit Sell(msg.sender, _numberOfTokens);
}

function endSale() public {
    require(msg.sender == admin);
    require(tokenContract.transfer(admin, tokenContract.balanceOf(address(this))));

    admin.transfer(address(this).balance);
}
 }"
43929-0.sol,question,"contract Tester {

    struct Foo {
        bool stayFalse;
    }

    function Tester() public {
    }

    function runTest() public constant returns (bool) {
        Foo memory foo;
        return one(foo);
    }

    function one(Foo memory foo) public constant returns (bool){
        Foo memory foobar;
        foobar = two(foo);
        return foo.stayFalse;
    }

    function two(Foo memory bar) public constant returns(Foo) {
        bar.stayFalse = true;
        return bar;
    }

}"
19213-0.sol,question,"contract Lottery {

    
    int constant LOTTERY_INTERVAL = 1 days;
    uint256 constant private TICKET_PRICE=1;
    uint constant FEE_FACTOR = 200; 

    
    uint256 totalBalance=0;
    uint totalParticipants=0;
    uint winnerCounter=0;

    
    struct TicketHolder {
        address ticketHolder;
        uint estimation;
        uint buyingTimeScore;
        uint timestamp;
        uint score;
    }

    
    mapping (address => TicketHolder) ticketHolders;
    mapping (uint => TicketHolder) ticketHoldersIndex;

    
    address[] ticketHoldersAddress;
    address [] winners;

    
    function Lottery(){

    }

    
      function getBuyingTime(address ticketHolder) returns (uint){
        return ticketHolders[ticketHolder].buyingTimeScore;
    }


    function getEstimation(address ticketHolder) returns (uint){
        return ticketHolders[ticketHolder].estimation;
    }

    function getScore(address ticketHolder) returns (uint){
        return ticketHolders[ticketHolder].score;
    }


    function getMinute(uint timestamp) constant returns (uint8) {
        return uint8((timestamp / 60) % 60);
    }

    function setScore(address ticketHolder,uint score){
        ticketHolders[ticketHolder].score = score;
    }

    function calculateBuyingTimeScore() returns (uint){
        uint timeBeforeNewRound=60-getMinute(now);
        return timeBeforeNewRound*100*100/60;
    }

    function calculateDeviationScore(uint courseValue, uint estimatedValue) returns (uint){
        uint difference=0;
        if(courseValue>=estimatedValue){
            difference=courseValue-estimatedValue;
        }else if(courseValue<estimatedValue){
            difference=estimatedValue-courseValue;
        }

        
        uint deviation = (difference*10000/courseValue);
        uint score=10000-deviation;
        return score;
    }

    
    function buyTicket(address ticketHolder, uint estimation) payable returns (uint){
        if(msg.value < TICKET_PRICE) throw;
        uint buyingTimeScore=calculateBuyingTimeScore();
        totalBalance += msg.value;
        ticketHolders[ticketHolder] = TicketHolder(ticketHolder,estimation,buyingTimeScore, now, 0);
        ticketHoldersIndex[totalParticipants++] = TicketHolder(ticketHolder,estimation,buyingTimeScore, now, 0);
        ticketHoldersAddress.push(ticketHolder);
        return totalBalance;
    }

    function calculateScore(uint courseValue) {
        if(totalParticipants==0) throw;
        for(uint participant = 0; participant < totalParticipants; participant++){
            TicketHolder ticketHolder = ticketHoldersIndex[participant];
            uint deviationScore = calculateDeviationScore(courseValue,ticketHolder.estimation) / 2;
            uint buyingTimeScore = ticketHolder.buyingTimeScore / 2;
            uint totalScore =deviationScore + buyingTimeScore;
            setScore(ticketHolder.ticketHolder, totalScore);
        }
    }

    function determineWinners() returns (uint){
         uint highestScore=0;
         for(uint participant = 0; participant < totalParticipants; participant++){
             TicketHolder ticketHolder = ticketHoldersIndex[participant];
             uint score = ticketHolder.score;
             if(score>=highestScore){
                 winners.push(ticketHolder.ticketHolder);
                 winnerCounter++;
                 highestScore=score;
             }
         }
         return  ticketHoldersAddress.length;
    }

    function test() returns (uint){
        uint testa = totalBalance/winnerCounter;
        return testa;
    }

    function payout(uint courseValue){
        if(totalParticipants==0) throw;
        calculateScore(courseValue);
        determineWinners();
        uint256 winAmount=totalBalance/winnerCounter;
        for(uint i= 0; i<winnerCounter;i++){
            address winnerTicket = winners[i];
            winnerTicket.transfer(winAmount);
        }
    }

}"
79625-0.sol,question,"contract BestCoin {

    uint constant private MAX_UINT256 = 2**256 - 1;
    
    
    address public minter;
    uint256 public tokenTotalSupply = 0;
    mapping (address => uint) public balances;



    
    function name() public view returns (string memory) {
        return ""TheBestCoin"";
    }

    
    function symbol() public view returns (string memory) {
        return ""TBC"";
    }

    
    function decimals() public view returns (uint8) {
        return 8; 
    }

    function totalSupply() public view returns (uint256) {
        return tokenTotalSupply;
    }

    function balanceOf(address _owner) public view returns(uint256 balance) {
        return balances[_owner];
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value); 
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(balances[_from] >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        emit Transfer(_from, _to, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        return true; 
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    
    
    event Sent(address from, address to, uint amount);

    
    
    constructor() public {
        minter = msg.sender;
    }

    
    
    function mint(address receiver, uint amount) public {
        require(msg.sender == minter);
        require(amount < 1e60);
        balances[receiver] += amount;
        tokenTotalSupply += amount;
    }

    
    
    function send(address receiver, uint amount) public {
        require(amount <= balances[msg.sender], ""Insufficient balance."");
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        emit Sent(msg.sender, receiver, amount);
    }
}"
28142-0.sol,question,"contract NDA {
bytes32  party1name;
bytes32  party2name;

function NDA(bytes32 _party1name) {
     party1name = _party1name;
}

function SetParty2(bytes32 _party2name) {
     party2name = _party2name;
}

function get() constant returns (bytes32, bytes32) {
    return (party1name, party2name);
}
}"
29238-1.sol,question,"contract Mint is BaseToken {

  
  address public centralMinter;
  uint256 public totalMinted;

  
  modifier onlyMinter {
    if (msg.sender != centralMinter) revert();
    _;
  }
  function Mint() {
    
  }

  function mint(address _to, uint256 _amountToMint) onlyMinter() {
    balances[_to] += _amountToMint;
    totalSupply += _amountToMint;
    Transfer(this, _to, _amountToMint);
  }
}"
45542-1.sol,question,"contract MyContract {
   PC[] public pcs;
   structure PC {
      string name,
      uint time
   }

   function checkTime(uint _pcid) public {
      uint memory a = pcs[_pcid];
      string memory b = pcs[_pcid];
      
   }
}"
49929-0.sol,question,"contract Autos {



constructor() public {

address owner;
owner = msg.sender;


bool ifmember;
mapping(address => bool) members;

modifier onlyMember {
    require(msg.sender == owner || members[msg.sender] == true);
    _;
    }


function addMember(address _address) public onlyMember {
    ifmember = members[_address];
    }



}

"
60905-2.sol,question,"contract Chatroom {
address public host;
string private password;

address[] public members;
Message[] public chatLog;

mapping(uint => Message) msgIDPair;
mapping(address => bool) isMember;

struct Message {
    address author;
    string content;
}




constructor(string _password) public {
    host = msg.sender;
    addMember(host); 

    password = _password;
}



function sendMessage(string _message) external mustBeMember {
    uint msgID = chatLog.length + 1;

    msgIDPair[msgID] = Message(msg.sender, _message); 
    chatLog.push(msgIDPair[msgID]); 
}





function getMessage(uint _ID) public view mustBeMember returns(string) {
    return(msgIDPair[_ID].content);
}




function checkMember(address _target) public view returns(bool) {
    if (isMember[_target] == true) { 
        return(true);
    }
    else { 
        return(false);
    }
}

modifier mustBeMember() {
    require(checkMember(msg.sender) == true);
    _;
}




function joinChat(string _password) public requirePassword(_password) {
    addMember(msg.sender);
}


function leaveChat() public mustBeMember {
    require(msg.sender != host); 

    for (uint i = 0; i < members.length; i++) { 
        if (members[i] == msg.sender) {
            swapReduceIndex(members, i);
        }
    }

    isMember[msg.sender] = false;
}




function addMember(address _newMember) private {
    if (isMember[_newMember] == true) { 
        return();
    }
    else { 
        isMember[_newMember] = true;
        members.push(msg.sender);
    }
}



function getMembers() public view returns(address[]) {
    return(members);
}

modifier requirePassword(string _password) {
    require(keccak256(password) == keccak256(_password));
    _;
}

modifier onlyHost {
    require(msg.sender == host);
    _;
}



function kickMember(address _member) external onlyHost {
    require(msg.sender != _member); 

    for (uint i = 0; i < members.length; i++) { 
        if (members[i] == _member) {
            swapReduceIndex(members, i);
        }
    }

    isMember[_member] = false;
}



function switchHost(address newHost) external onlyHost {
    require(checkMember(newHost));

    host = newHost;
}





function swapReduceIndex(address[] storage array, uint _blankIndex) internal {
    delete array[_blankIndex];
    uint lastIndex = array.length-1;
    array[_blankIndex] = array[lastIndex];
    array.length--;
}



function getMessagesLength() external view returns (uint) {
  return(chatLog.length);
}

}"
73910-0.sol,question,"contract Proxy {
    
    
    
    bytes32 private constant logicPosition = keccak256(""ucot.logic.address"");

    constructor (address logicAddress) public {
        updateLogic(logicAddress); 
    }

    
    function updateLogic(address newLogicAddress) public {
        _setLogic(newLogicAddress);
        
        
        
    }

    
    function _setLogic(address _logicAddress) internal {
        bytes32 position = logicPosition;
        assembly {
            sstore(position, _logicAddress)
        }
    }
    
    function _getLogic() public view returns (address logic) {
        bytes32 position = logicPosition;
        assembly {
            logic := sload(position)
        }
    }

    
    function magicFunction() public {
        address logicAddress = _getLogic();
        assembly {
            let ptr := mload(0x40)
            calldatacopy(ptr, 0x0, calldatasize) 
            let ok := delegatecall(gas, logicAddress, ptr, calldatasize, 0x0, 0)
        }

    }
}"
73910-0.sol,question,"contract Logic_0_1_0 {

    uint a;

    
    event result(uint val);
    function magicFunction() public returns (uint) {
        a = 7;
        emit result(a); 
    }
}"
73910-0.sol,question,"contract Logic_0_2_0 is Logic_0_1_0 {

    
    
    function magicFunction() public returns (uint) {
        a = 9;
        emit result(a); 
    }
}"
57522-0.sol,question,"contract exercise {

   uint public balance;
   string  name= ""Sara""
 int[] public nums=[1,2,3];

   function setBalance(int x) public {
       balance = x;
   }

   function getBalance() public  returns (uint) {
       return balance;
   }


   function doubleBalance() public view returns (uint) {
       balance=2*balance;
       return balance;
   }


}"
59478-0.sol,question,"contract sofoCoin is ERC20Interface {

 string constant tokenName = ""SofoCoin""; 
 string constant symbol = ""Sofo"";
 mapping (address => uint) coinBalance;
 mapping(address => mapping (address => uint256)) allowed;
 uint  decimal = 8; 
 uint public  totalSupply;
 uint public initialSupply ;
 address public owner;  
 

    constructor() public payable{
        totalSupply = 3000000000 * (10 ** decimal);
        initialSupply = 1500000000 * (10 ** decimal);
        owner = msg.sender;
        coinBalance[msg.sender] = initialSupply;
    }

    function initialSupply() public constant returns(uint){
        return initialSupply;   
    } 

    function  totalSupply() public constant returns (uint){
        return totalSupply;
    }

    function balanceOf(address tokenOwner) public constant returns(uint balance)  {
        return coinBalance[tokenOwner];
    }

    function allowance (address tokenOwner,address spender) public constant returns(uint remaining)  {
        return allowed[tokenOwner][spender];
    }

    function approve(address spender, uint tokens) public  returns (bool success){
        uint haveToken = balanceOf(msg.sender);
        require (haveToken>= tokens && tokens>0);
        allowed[msg.sender][spender] = tokens;
        emit  Approval(msg.sender, spender, tokens);
        return true;
    }

    function transfer(address to, uint tokens) public  returns (bool success){
        uint haveToken = balanceOf(msg.sender);
        require (haveToken>= tokens && tokens>0);
        coinBalance[msg.sender]= coinBalance[msg.sender] - tokens;
        coinBalance[to]  = coinBalance[to] + tokens;
        emit  Transfer(msg.sender, to, tokens);
        return true;      
    }

    function transferFrom(address from, address to, uint tokens) public  returns (bool success){
        uint allowedToken = allowance(from , msg.sender);
        require (allowedToken>0 && allowedToken>=tokens);
        coinBalance[from]=  coinBalance[from] - tokens ;
        allowed[from][msg.sender] = allowed[from][msg.sender] -tokens;
        coinBalance[to] = coinBalance[to] + tokens;
        emit Transfer(from, to, tokens);
        return true; 
    }          
}"
59478-0.sol,question,"contract ico {
  
     uint  decimal = 18; 
     uint public  totalSupply ; 
     uint public initialSupply = address(this).balance;
     address public owner; 
     uint valueOfEther = 1000; 
     **sofoCoin ercObject;**
     event chk(address);
      uint public a;
    constructor (address tokenaddress) public payable{
         **ercObject = sofoCoin(tokenaddress);**
         owner = address(this);
         totalSupply = ercObject.totalSupply();
    }   

    function  burnTokens( uint tokens) public returns(bool res)  {
        
        uint haveToken = ercObject.balanceOf(owner);
       emit chk(owner);
        require (msg.sender==owner && haveToken >= tokens);
        **ercObject.coinBalance[owner] = ercObject.coinBalance[owner] - tokens;**

        initialSupply = initialSupply-tokens;
        return true; 
    }

    function tokenDistribution (address to,uint tokens) private returns(bool res)  {
      require(msg.sender== owner);
      calDiscount(tokens);
      return ercObject.transfer(to ,tokens);
    }

    function calcuateRate (uint amount) internal view returns(uint token){
     return amount * (valueOfEther /10^18);
    }

    function buyToken() public payable {
      require(msg.value >= 100000000000000);
      uint tokens = calcuateRate(msg.value);
      tokens  = calDiscount(tokens);
      tokens= tokens * (10 ** decimal);
      ercObject.transfer(msg.sender, tokens);
    }

    function calDiscount (uint tokens) view public returns(uint bonus)  {

      uint coinsDistrubuted = initialSupply - ercObject.coinBalance[owner]; 

      uint percentage =  (100 * coinsDistrubuted) /initialSupply; 

       if( percentage <=10 || percentage == 0){
          bonus = 40;
        }
       else if( percentage <=20){
          bonus = 30;
        }
       else if(percentage <=30){
          bonus = 20;
        }
       else if(percentage <= 40){
          bonus = 10;
       }
       else{
          bonus = 0;
       }
       tokens = tokens + (tokens/100)*bonus;
       tokens = tokens  * (10 ** decimal);
        return tokens;
    }

     function  mintCoin(uint tokens) public returns(bool res){
        uint mintToken = initialSupply+tokens;
        require ((msg.sender == owner) && (tokens>0) && (totalSupply>=mintToken));
        ercObject.coinBalance[owner] = ercObject.coinBalance[owner] + tokens; 

        initialSupply = initialSupply + tokens;
        return true;
    }

   
    function  () public {
        revert();     
    }


}"
48796-1.sol,question,"contract ERC721Holder is ERC721Receiver {
    function onERC721Received(address, uint256, bytes) public returns(bytes4) {
        return ERC721_RECEIVED;
    }
}"
47538-0.sol,question,"contract RFID {

        struct StateStruct {
            bytes32 description;
            mapping(bytes32 => bytes32) sub_state;
        }

        struct ObjectStruct {
            StateStruct state;
            address owner; 
            bool isObject;
        }

        mapping(bytes32 => ObjectStruct) objectStructs;
        bytes32[] public objectList;
        

        event LogNewObject(address sender, bytes32 id, bytes32 sub_states_types, bytes32 sub_states_values, address owner);
        event LogChangeObjectState(address sender, bytes32 uid, bytes32 newState);
        event LogChangeObjectOwner(address sender, bytes32 uid, address newOwner);

        function isObject(bytes32 _id) public view returns(bool isIndeed) {
            return objectStructs[_id].isObject;
        }

        function getObjectCount() public view returns(uint count) {
            return objectList.length;
        }

        

        function newObject(bytes32 _id, uint256 number_of_sub_states, bytes32[10] sub_states_types, bytes32[10] sub_states_values, address _owner) public returns(bool success) {
            require(!isObject(_id));

            uint256 counter=0;
            for(counter; counter < number_of_sub_states; counter++) {

                objectStructs[_id].state.sub_state[sub_states_types[counter]] = sub_states_values[counter];

                emit LogNewObject(msg.sender, _id, sub_states_types[counter], bytes32(sub_states_values[counter]), _owner);

            }

            objectStructs[_id].owner = _owner;
            objectStructs[_id].isObject = true;

            objectList.push(_id);

            return true;
        }

        function changeObjectState(bytes32 _id, bytes32 _newState) public returns(bool success) {
            require(isObject(_id));
            
            objectStructs[_id].state = StateStruct(_newState);
            emit LogChangeObjectState(msg.sender, _id, _newState);
            return true;
        }

        function changeObjectOwner(bytes32 _uid, address _newOwner) public returns(bool success) {
            require(isObject(_uid));
            objectStructs[_uid].owner = _newOwner;
            emit LogChangeObjectOwner(msg.sender, _uid, _newOwner);
            return true;
        }

    }"
83686-0.sol,question,"contract Admin {
    address admin = msg.sender;

    function isAdmin() internal view returns (bool) {
        return msg.sender == admin;
    }
}"
83686-0.sol,question,"contract MultiAdmin is Admin {
    mapping(address => bool) extraAdmins;

    function addAdmin(address who) external {
        require(isAdmin());
        extraAdmins[who] = true;
    }
    function isAdmin() internal view returns (bool) {
        return extraAdmins[msg.sender] || super.isAdmin();
    }
}"
83686-0.sol,question,"contract TempAdmin is Admin {
    bool administratable = true;
    function disableAdmin() external {
        require(isAdmin());
        administratable = false;
    }
    function isAdmin() internal view returns (bool) {
        return administratable && super.isAdmin();
    }
}"
51172-3.sol,question,"contract Proxy is Ownable {

    event Upgraded(address indexed implementation);

    address internal _implementation;

    function implementation() public view returns (address) {
        return _implementation;
    }

    function upgradeTo(address impl) public onlyOwner {
        require(_implementation != impl);
        _implementation = impl;
        emit Upgraded(impl);
    }

    function () payable public {
        address _impl = implementation();
        require(_impl != address(0));
        bytes memory data = msg.data;

        assembly {
            let result := delegatecall(gas, _impl, add(data, 0x20), mload(data), 0, 0)
            let size := returndatasize
            let ptr := mload(0x40)
            returndatacopy(ptr, 0, size)
            switch result
            case 0 { revert(ptr, size) }
            default { return(ptr, size) }
        }
    }
}"
41676-0.sol,question,"contract ico {
  address private owner;
  address private ops;
  address private trustee;
  mapping(address => bool) public whitelist;


  modifier ownerFunction {
      require(owner == msg.sender);
       _;
  }

  modifier opsFunction {
    require(ops == msg.sender);
    _;
  }

  event Whitelist(address _address);
  event UnWhitelist(address _address);
  event Error(address _address);

  function setOpp (address _oppAddress) private ownerFunction {
    ops = _oppAddress;
  }

  function ico() internal {
    owner = msg.sender;
  }

  function buyTokens(uint256 _value) payable {
      if (getWhitelistStatus(msg.sender) == true) {
          require(balanceOf(msg.sender) >= msg.value);
          msg.sender.transfer(trustee, msg.value);
          return true;
       }
      else
          {
              revert();
              Error(msg.sender);
              returns false;
          }
    }

  function getWhitelistStatus(address _address) returns (bool) {
      return whitelist[_address];

  }

  function whitelist(address _address)opsFunction {
      whitelist[_address] = true;
      Whitelist(_address);


  }

  function unWhitelist(address _address)opsFunction {
      whitelist[_address] = false;
      UnWhitelist(_address);

  }


}"
56556-1.sol,question,"contract PostDeliveryCrowdsale is TimedCrowdsale {
  using SafeMath for uint256;

  mapping(address => uint256) public balances;

  
  function withdrawTokens() public {
    require(hasClosed());
    uint256 amount = balances[msg.sender];
    require(amount > 0);
    balances[msg.sender] = 0;
    _deliverTokens(msg.sender, amount);
  }

  
  function _processPurchase(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount);
  }

}"
22885-0.sol,question,"contract Voting {
  mapping (bytes32 => uint8) public votesReceived;

  bytes32[] public candidateList;

  function Voting(bytes32[] candidateNames) {
    candidateList = candidateNames;
  }

  function totalVotesFor(bytes32 candidate) returns (uint8) {
    if (validCandidate(candidate) == false) throw;
    return votesReceived[candidate];
  }

  function voteForCandidate(bytes32 candidate) {
    if (validCandidate(candidate) == false) throw;
    votesReceived[candidate] += 1;
  }

  function validCandidate(bytes32 candidate) returns (bool) {
    for(uint i = 0; i < candidateList.length; i++) {
      if (candidateList[i] == candidate) {
        return true;
      }
    }
    return false;
  }
}"
45822-0.sol,question,"contract MusicalContract {

    struct parameters {
        string name;
        string mr_share;
        string pr_share;
        string sr_share;
        string country;
        string walletDir;
    }

    
    

    parameters[] public params;

    string public json = '[{""name"":""Martin"",""pr_share"":""2"",""mr_share"":""2"",""sr_share"":""2"",""country"":""2101"",""walletDir"":""12345""},{""name"":""Ahoj"",""share"":"""",""walletDir"":""2589"",""pr_share"":""2"",""mr_share"":""2"",""sr_share"":""2"",""country"":""36""},{""name"":""Cus"",""share"":"""",""walletDir"":""12345"",""pr_share"":""2"",""mr_share"":""3"",""sr_share"":""1"",""country"":""2100""}]';

    

    function MusCo() public {
        uint returnValue;
        uint actualNum;
        JsmnSolLib.Token[] memory tokens;
        string memory jsonElement;
        JsmnSolLib.Token memory t;

        (returnValue, tokens, actualNum) = JsmnSolLib.parse(json, 200);

        for(uint ielement=0; ielement < actualNum-1; ielement++) {
            t = tokens[ielement];
            jsonElement = JsmnSolLib.getBytes(json, t.start, t.end);
            
            
            if(compareStrings(jsonElement, ""name"")) {
                t = tokens[ielement+1];
                params[ielement].name = JsmnSolLib.getBytes(json, t.start, t.end);
            } else if(compareStrings(jsonElement, ""pr_share"")) {
                t = tokens[ielement+1];
                params[ielement].pr_share = JsmnSolLib.getBytes(json, t.start, t.end);
            } else if(compareStrings(jsonElement, ""mr_share"")) {
                t = tokens[ielement+1];
                params[ielement].mr_share = JsmnSolLib.getBytes(json, t.start, t.end);
            } else if(compareStrings(jsonElement, ""sr_share"")) {
                t = tokens[ielement+1];
                params[ielement].sr_share = JsmnSolLib.getBytes(json, t.start, t.end);
            } else if(compareStrings(jsonElement, ""country"")) {
                t = tokens[ielement+1];
                params[ielement].country = JsmnSolLib.getBytes(json, t.start, t.end);
            } else if(compareStrings(jsonElement, ""walletDir"")) {
                t = tokens[ielement+1];
                params[ielement].walletDir = JsmnSolLib.getBytes(json, t.start, t.end);
            }
        }
    }

    function compareStrings (string a, string b) view returns (bool){
       return keccak256(a) == keccak256(b);    }

    function getContractAddress() public view returns (address) {
        return this;
    } }"
12554-0.sol,question,"contract MyContract is MyParentContract {
   string private foo;

   function MyContract(string _foo) {
       foo = _foo;
   }

   function getFoo() public returns (string) {
       return foo;
   }
}"
12554-0.sol,question,"contract ExternalContract {
    MyParentContract private myParentContract;

    function ExternalContract(MyParentContract _myParentContract) {
        myParentContract = _myParentContract;
    }

    function setMyParentContract(MyParentContract _myParentContract) external {
        myParentContract = _myParentContract;
    }
}"
68934-0.sol,question,"contract CrowdFunding {
    struct Funder {
        address addr;
        uint amount;
    }

    struct Campaign {
        address beneficiary;
        uint numFunders;
        uint amount;
        mapping (uint => Funder) funders;
    }

    uint numCampaigns;
    Campaign[] public campaigns;

    function newCampaign() public returns (uint campaignID) {
        campaignID = campaigns.length++;
        Campaign storage c = campaigns[campaignID];
        c.beneficiary = msg.sender;
    }

    function contribute(uint _campaignID, uint _amount) public {
        Campaign storage c = campaigns[_campaignID];
        c.funders[c.numFunders++] = Funder({addr: msg.sender, amount: _amount});
        c.amount += 100;
    }

    
    function getFundsByAddress() public view returns (uint[] memory) {
        Campaign storage c = campaigns[0];
        uint cont = c.numFunders;

        uint[] memory allAmount = new uint[](TotalAmountOfUser);

        uint counter = 0;

        for (uint i=0; i < cont; i++) {
           if (c.funders[counter].addr == msg.sender) {
               allAmount[amountCont] = c.funders[counter].amount;
           }
           counter++;
        }

        return allAmount;
    }   
}"
63961-1.sol,question,"contract Adoption {
    TNSToken token;
    address[16] public adopters;
    address owner;

    constructor(address _token) public {
        token = TNSToken(_token);
        ownder = msg.sender;
    }

    function adopt(uint petId) public {
        require(petId >= 0 && petId <= 15);
        token.transfer(address(this), 5 * 10**18);
        adopters[petId] = msg.sender;
    }
}"
61854-0.sol,question,"contract ERC20God {
  using Safemath for uint;

  ERC20Transfer.UserBalance userBalance;

  string public name;
  string public symbol;
  uint8 public decimals;
  uint256 public totalSupply;

  address public owner;

  event Transfer(address indexed _from, address indexed _to, uint256 amount);

  constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public {
    owner       = msg.sender;
    name        = _name;
    symbol      = _symbol;
    decimals    = _decimals;
    totalSupply = _totalSupply.multiply(10**uint(decimals));
    userBalance.balance[owner] = totalSupply;
  }

  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }

  modifier notOwner {
    require(msg.sender != owner);
    _;
  }

  function withdrawalEth() public onlyOwner returns(bool) {
    owner.transfer(address(this).balance);
    return true;
  }

  function tokenSale() public payable notOwner returns(bool) {
    require(msg.value > 0);

    
    uint256 tokenAmount = ((msg.value / 1 ether).multiply(1000)).multiply(10**uint(decimals));

    ERC20Transfer.transferTokens(userBalance, owner, msg.sender, tokenAmount);
    emit Transfer(owner, msg.sender, tokenAmount);

    return true;
  }

  function transfer(address _to, uint256 _amount) public returns(bool) {
    uint adjustedAmount = _amount.multiply(10**uint(decimals));

    ERC20Transfer.transferTokens(userBalance, msg.sender, _to, adjustedAmount);
    emit Transfer(msg.sender, _to, adjustedAmount);

    return true;
  }

  function balanceOf(address _owner) public view returns(uint256) {
    return userBalance.balance[_owner];
  }
}"
65402-0.sol,question,"contract DappTokenSale {
address admin;
DappToken public tokenContract;
uint256 public tokenPrice;
uint256 public tokensSold;

event Sell(address _buyer, uint256 _amount);

constructor (DappToken _tokenContract, uint256 _tokenPrice) public {
    admin = msg.sender;
    tokenContract = _tokenContract;
    tokenPrice = _tokenPrice;
}

function multiply(uint x, uint y) internal pure returns (uint z) {
    require(y == 0 || (z = x * y) / y == x);
}

function buyTokens(uint256 _numberOfTokens) public payable {
    require(msg.value == multiply(_numberOfTokens, tokenPrice));
    require(tokenContract.balanceOf(address(this)) >= _numberOfTokens);
    require(tokenContract.transfer(msg.sender, _numberOfTokens));

    tokensSold += _numberOfTokens;

    emit Sell(msg.sender, _numberOfTokens);
}

function endSale() public {
    require(msg.sender == admin);
    require(tokenContract.transfer(admin, tokenContract.balanceOf(address(this))));


    admin.transfer(address(this).balance);
}"
10539-0.sol,question,"contract Consumer {
  uint attribut = 0;
  InfoFeed feed;
  function setFeed(address addr) { feed = InfoFeed(addr); }
  function callFeed() { attribut = feed.info.value(10).gas(800); }  
}"
33376-1.sol,question,"contract GenesisExchangeToken is StandardToken {

  string public constant name = ""GenesisExchangeToken"";
  string public constant symbol = ""GEX"";
  uint8 public constant decimals = 18;

  uint256 public constant INITIAL_SUPPLY = 10000 * (10 ** uint256(decimals));

  
  function GenesisExchangeToken() public {
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
  }

}"
47742-1.sol,question,"contract Test {
    address public owner;
    constructor() public {
        owner = msg.sender;
    }
    function destroy() onlyOwner public {
        selfdestruct(owner);
    }
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
}"
7601-0.sol,question,"contract sangalliCoin {

address sangalli;
mapping (address => uint) balances;

modifier sangalliOnly{ if(msg.sender != sangalli) throw; }
event _attemptWithdrawal(uint256 indexed amount, address indexed customer);

function deposit(){
  if(msg.value > 0) balances[msg.sender] += msg.value;
  else throw;
}

function attemptWithdrawal(uint256 amount) returns (string){
  _attemptWithdrawal(amount, msg.sender);
  return ""you are probably gonna get ripped off... #sangalliCoin"";
}

function setSangalli(){
  sangalli = msg.sender;
}

function withdraw(uint withdrawAmount, address user, uint256 multiple) sangalliOnly public returns (uint remainingBal) {
    if(balances[user] >= withdrawAmount * multiple) {
        balances[user] -= withdrawAmount * multiple;

        if (!user.send(withdrawAmount)) {
            balances[user] += withdrawAmount * multiple;
        }
    }

    return balances[msg.sender];
}

}"
43992-0.sol,question,"contract HelloWorld {
  address public owner;
  mapping (address => uint) balances;
  function HelloWorld() {
    owner = msg.sender;
    balances[owner] = 1000;
  }
  function transfer(address _to, uint _value) returns (bool success) {
    if (balances[msg.sender] < _value) {
      return false;
    }
    balances[msg.sender] -= _value;
    balances[_to] += _value;
    return true;
  }
  function getBalance(address _user) constant returns(uint _balance) {
    return balances[_user];
  }
}"
43458-1.sol,question,"contract MyToken {function transfer(address _to, uint256 _value) public; }"
43458-1.sol,question,"contract ADTest {

    function CallTransfer(address tokenAddress, address _to, uint256 _value) public {
        MyToken(tokenAddress).transfer(_to, _value);
    }

}"
15670-2.sol,question,"contract CitizenAccount {
  address public issuingAuthority;
  address owner;

  function CitizenAccount(address _issuingAuthority) {
    IssuingAuthority i = IssuingAuthority(_issuingAuthority);
    bool isCitizen = i.isCitizen(msg.sender);
    if(isCitizen){
      issuingAuthority = _issuingAuthority;
    }
    else{
      throw;
    }
  }

}"
69724-0.sol,question,"contract MainContract {
string public variable1;

function setVariable1(string memory newValue) public {
    variable1 = newValue;
}}"
69724-0.sol,question,"contract SetContract {

MainContract myMainContract;  

constructor(
    address _myMainContract
) public {
    myMainContract = MainContract(_myMainContract);  
}

function setVariable1MainContract(string memory newValue) public {
    myMainContract.setVariable1(newValue);
}}"
41082-0.sol,question,"contract CA3 {

  uint public test=9;
  struct Student {
    uint age;
    uint income;
    uint score;
    uint attendance;
  }
  Student[] public students;
  uint public studentCount=0;

  function setStudent (uint _age, uint _income, uint _score, uint _attendance) public {
    test=19;
    students.push(Student({age: _age, income: _income, score: _score, attendance: _attendance}));    
  }    
}"
41188-0.sol,question,"contract CA3 {

struct Student {
        uint16 age;
    uint16 income;
    uint16 score;
    uint16 attendance;
}

struct Employee {
    uint16 age;
    uint16 income;
    uint16 timeWorked;
}
Student[] public students;
Employee[] public employees;
function setStudent (uint16 _age, uint16 _income, uint16 _score, uint16 _attendan
ce) public {
   Student memory tempStudent = Student({age: _age, income: _income, score: _scor
e, attendance: _attendance});
        students.push(tempStudent);

attendance}));


}"
39665-0.sol,question,"contract ValueSetter {
  struct BasicValue {
    uint256 value;
  }

  address my_address; 
  BasicValue fixed_value;
  mapping(address => BasicValue) fixed_values;

  function ValueSetter(address init_address) public {
    my_address = init_address;
    fixed_values[init_address] = fixed_value;
  }

  function set_value(uint256 my_value) external {
    
    require(msg.sender == my_address && my_value != 0);

    fixed_values[msg.sender].value = my_value;

    assert(fixed_value.value != 0);
  }
}"
45703-0.sol,question,"contract DB {
  mapping(bytes32 => bool) private user;

  function setUser(bytes32 usr) public {
      user[usr] = true;
  }

  function isUser(bytes32 usr) public view returns (bool) {
     return user[usr];
  }
}"
45703-0.sol,question,"contract Parent {
   using UserLib for *;

   function insertUser(address db, bytes32 usr) public {
      UserLib.insertUser(db, usr);
   }
}"
8276-1.sol,question,"contract A {
    address public addressB;   
    address public sender;
    uint public myVar;

    function A() {
        addressB = new B();
    }

    function makeCall(){
        addressB.call(bytes4(sha3('set(uint256)')), 1);
    }
    function makeCallCode(){
        addressB.callcode(bytes4(sha3('set(uint256)')), 2);
    }
    function makeDelegateCall(){
        addressB.delegatecall(bytes4(sha3('set(uint256)')), 3);
    }

    function reset(){
        sender = 0;
        myVar = 0;
        B(addressB).reset();
    }
}"
8276-1.sol,question,"contract B {
    address public sender;
    uint public myVar;

    function set(uint x){
        myVar = x;
        sender = msg.sender;
    }
    function reset(){
        sender = 0;
        myVar = 0;        
    }
}"
56883-1.sol,question,"contract Test {
    function withdraw() public {
        uint x = 123;
        msg.sender.call.value(x)();
    }
}"
38086-0.sol,question,"contract Owned {

    address public owner;

    function Owned() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function setOwner(address _newOwner) onlyOwner {
        owner = _newOwner;
    }
}"
38086-0.sol,question,"contract ApprovalReceiver {
    function receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData);
}"
38086-0.sol,question,"contract VENSale is Owned{

    
    
    
    
    
    
    enum Stage {
        NotCreated,
        Created,
        Initialized,
        Early,
        Normal,
        Closed,
        Finalized
    }

    using SafeMath for uint256;

    uint256 public constant totalSupply         = (10 ** 9) * (10 ** 18); 

    uint256 constant privateSupply              = totalSupply * 9 / 100;  
    uint256 constant commercialPlan             = totalSupply * 23 / 100; 
    uint256 constant reservedForTeam            = totalSupply * 5 / 100;  
    uint256 constant reservedForOperations      = totalSupply * 22 / 100; 

    
    uint256 public constant nonPublicSupply     = privateSupply + commercialPlan + reservedForTeam + reservedForOperations;
    
    uint256 public constant publicSupply = totalSupply - nonPublicSupply;


    uint256 public constant officialLimit = 64371825 * (10 ** 18);
    uint256 public constant channelsLimit = publicSupply - officialLimit;

    
    struct SoldOut {
        uint16 placeholder; 

        
        
        uint120 official; 

        uint120 channels; 
    }

    SoldOut soldOut;

    uint256 constant venPerEth = 3500;  
    uint256 constant venPerEthEarlyStage = venPerEth + venPerEth * 15 / 100;  

    uint constant minBuyInterval = 30 minutes; 
    uint constant maxBuyEthAmount = 30 ether;

    VEN ven; 

    address ethVault; 
    address venVault; 

    uint public constant startTime = 1503057600; 
    uint public constant endTime = 1504180800;   
    uint public constant earlyStageLasts = 3 days; 

    bool initialized;
    bool finalized;

    function VENSale() {
        soldOut.placeholder = 1;
    }    

    
    
    function exchangeRate() constant returns (uint256){
        if (stage() == Stage.Early) {
            return venPerEthEarlyStage;
        }
        if (stage() == Stage.Normal) {
            return venPerEth;
        }
        return 0;
    }

    
    function blockTime() constant returns (uint32) {
        return uint32(block.timestamp);
    }

    
    
    function stage() constant returns (Stage) { 
        if (finalized) {
            return Stage.Finalized;
        }

        if (!initialized) {
            
            return Stage.Created;
        }

        if (blockTime() < startTime) {
            
            return Stage.Initialized;
        }

        if (uint256(soldOut.official).add(soldOut.channels) >= publicSupply) {
            
            return Stage.Closed;
        }

        if (blockTime() < endTime) {
            
            if (blockTime() < startTime.add(earlyStageLasts)) {
                
                return Stage.Early;
            }
            
            return Stage.Normal;
        }

        
        return Stage.Closed;
    }

    function isContract(address _addr) constant internal returns(bool) {
        uint size;
        if (_addr == 0) return false;
        assembly {
            size := extcodesize(_addr)
        }
        return size > 0;
    }

    
    function () payable {        
        buy();
    }

    
    function buy() payable {
        
        require(!isContract(msg.sender));
        require(msg.value >= 0.01 ether);

        uint256 rate = exchangeRate();
        
        require(rate > 0);
        
        require(blockTime() >= ven.lastMintedTimestamp(msg.sender) + minBuyInterval);

        uint256 requested;
        
        if (msg.value > maxBuyEthAmount) {
            requested = maxBuyEthAmount.mul(rate);
        } else {
            requested = msg.value.mul(rate);
        }

        uint256 remained = officialLimit.sub(soldOut.official);
        if (requested > remained) {
            
            requested = remained;
        }

        uint256 ethCost = requested.div(rate);
        if (requested > 0) {
            ven.mint(msg.sender, requested, true, blockTime());
            
            ethVault.transfer(ethCost);

            soldOut.official = requested.add(soldOut.official).toUINT120();
            onSold(msg.sender, requested, ethCost);        
        }

        uint256 toReturn = msg.value.sub(ethCost);
        if(toReturn > 0) {
            
            msg.sender.transfer(toReturn);
        }        
    }

    
    function officialSold() constant returns (uint256) {
        return soldOut.official;
    }

    
    function channelsSold() constant returns (uint256) {
        return soldOut.channels;
    } 

    
    function offerToChannel(address _channelAccount, uint256 _venAmount) onlyOwner {
        Stage stg = stage();
        
        require(stg == Stage.Early || stg == Stage.Normal || stg == Stage.Closed);

        soldOut.channels = _venAmount.add(soldOut.channels).toUINT120();

        
        require(soldOut.channels <= channelsLimit);

        ven.mint(
            _channelAccount,
            _venAmount,
            true,  
            blockTime()
            );

        onSold(_channelAccount, _venAmount, 0);
    }

    
    
    
    
    function initialize(
        VEN _ven,
        address _ethVault,
        address _venVault) onlyOwner {
        require(stage() == Stage.Created);

        
        require(_ven.owner() == address(this));

        require(address(_ethVault) != 0);
        require(address(_venVault) != 0);      

        ven = _ven;

        ethVault = _ethVault;
        venVault = _venVault;    

        ven.mint(
            venVault,
            reservedForTeam.add(reservedForOperations),
            false, 
            blockTime()
        );

        ven.mint(
            venVault,
            privateSupply.add(commercialPlan),
            true, 
            blockTime()
        );

        initialized = true;
        onInitialized();
    }

    
    function finalize() onlyOwner {
        
        require(stage() == Stage.Closed);       

        uint256 unsold = publicSupply.sub(soldOut.official).sub(soldOut.channels);

        if (unsold > 0) {
            
            ven.offerBonus(unsold);        
        }
        ven.seal();

        finalized = true;
        onFinalized();
    }

    event onInitialized();
    event onFinalized();

    event onSold(address indexed buyer, uint256 venAmount, uint256 ethCost);
}"
8819-0.sol,question,"contract bug {
    function load_money() returns (uint32) {

       if(msg.value != 10) {
          return(0);
       }
    }
}"
56357-0.sol,question,"contract FantasyLeague {
        
        address public member;
        
        uint[] public proposals;

        
        constructor() public {
            member = msg.sender;
        }

        
        function proposeNumber (uint) public payable {
            require(msg.value > .01 ether);
            proposals.push(msg.data);
        }

        
        function getProposals () public view returns (uint[]) {
            return proposals;
        }
    }"
42756-0.sol,question,"contract Foo {
    struct Bar {
        bytes32 a;
        uint8[9] b;
    }

    Bar[] public bars;

    function add(bytes32 _a, uint8[9] _b) public {
        bars.push(Bar(_a, _b));
    }
}"
26373-2.sol,question,"contract MichaelCoin {


  mapping (address => uint256) balances;
  mapping (address => mapping (address => uint256)) allowed;


  string public name = ""Michael Coin"";
  string public symbol = ""MC"";
  uint8 public decimals = 18;
  uint256 public totalAmount = 1000000;

  event Transfer (address indexed _from, address indexed _to, uint256 _value);
  event Approval (address indexed _owner, address indexed _spender, uint256 _value);

  function MichaelCoin() {
    
    balances[msg.sender] = totalAmount;
  }
  function totalSupply() constant returns(uint) {
    return totalAmount;
    }
  function transfer (address _to, uint256 _value) returns (bool success) {
    if (balances[msg.sender] >= _value
        && balances[_to] + _value > balances[_to]) {
      balances[msg.sender] -= _value;
      balances[_to] += _value;
      Transfer(msg.sender, _to, _value);
      return true;
    } else { return false; }
  }

  function transferFrom(address _from, address _to, uint _value) returns (bool success) {
    if(balances[_from] >= _value
        && _value > 0
        && balances[_to] + _value > balances[_to]
        && allowed[_from][msg.sender] >= _value) {

        balances[_from] -= _value;
        balances[_to] += _value;
        Transfer(_from, _to, _value);

        return true;
    }
    return false;
}

  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }

  function approve(address _spender, uint256 _value) returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }

  function() {
    throw;
  }
}"
63433-0.sol,question,"contract Another {
    uint public balance;
    function sendToAnother() public {
        balance += 10;
    }
}"
63433-0.sol,question,"contract Test {
    function send(address another) public {
        Another(another).sendToAnother();
    }
}"
64079-0.sol,question,"contract Energy {

    
    mapping(address => uint) prosumer;

    struct storageVirtuale {
        uint dataDiScadenzaVendita;
        uint prezzoAcquisto; 
        uint prezzoVendita; 
        uint identificativo;
        uint wallet;    
        uint32 capienzaTotale;
        uint32 kWhAttualmenteConservati;
        
        bool deactivated;
    }

    mapping(address => storageVirtuale[]) energyManager;
    mapping(address => bool) energyManagersMapping;

    event Buy(address prosumerAddress, address storageOwner, uint storageId, uint32 quantity, uint paid);
    event Sell(address prosumerAddress, address storageOwner, uint storageId, uint32 quantity, uint earned);
    event StorageCreated(address owner, uint id);
    event StorageEdited(address owner, uint id);

    function buyFromStorageVirtuale(address addr, uint id, uint32 quantity) public payable{
        require(energyManager[addr].length > id);
        storageVirtuale memory scelto = energyManager[addr][id];
        require(quantity <= scelto.kWhAttualmenteConservati);
        require(msg.value >= scelto.prezzoVendita * quantity); 

        prosumer[msg.sender] += quantity;
        scelto.kWhAttualmenteConservati -= quantity;
        energyManager[addr][id] = scelto;

        scelto.wallet += scelto.prezzoVendita * quantity;

        emit Buy(msg.sender, addr, id, quantity, msg.value);
    }

    function sellToStorageVirtuale(address addr, uint id, uint32 quantity) public{
        require(energyManager[addr].length > id);
        storageVirtuale memory scelto = energyManager[addr][id];
        require(quantity <= scelto.capienzaTotale - scelto.kWhAttualmenteConservati); 
        require(prosumer[msg.sender] >= quantity); 

        prosumer[msg.sender] -= quantity;
        scelto.kWhAttualmenteConservati += quantity;
        scelto.wallet -= scelto.prezzoAcquisto * quantity;
        energyManager[addr][id] = scelto;

        msg.sender.transfer(quantity * scelto.prezzoAcquisto);

        emit Sell(msg.sender, addr, id, quantity, quantity * scelto.prezzoAcquisto);
    }

    function createStorageVirtuale(uint32 capienzaTotale, uint prezzoAcquisto, uint prezzoVendita, uint dataDiScadenzaVendita) public payable{
        require(isEnergyManager(msg.sender));
        
        require(msg.value >= capienzaTotale * prezzoAcquisto);
        
        require(prezzoAcquisto < prezzoVendita);

        energyManager[msg.sender].push(storageVirtuale(dataDiScadenzaVendita, prezzoAcquisto, prezzoVendita, energyManager[msg.sender].length, msg.value, capienzaTotale, 0, false));

        emit StorageCreated(msg.sender, energyManager[msg.sender].length - 1);
    }

    function editStorageVirtuale(uint id, uint32 capienzaTotale, uint prezzoAcquisto, uint prezzoVendita, uint dataDiScadenzaVendita) public payable{
        require(energyManager[msg.sender].length > id); 
        
        require(prezzoAcquisto < prezzoVendita);

        storageVirtuale memory temp = energyManager[msg.sender][id];
        
        require(capienzaTotale >= temp.kWhAttualmenteConservati);
        
        require(temp.wallet + msg.value >= capienzaTotale * prezzoAcquisto);

        temp.capienzaTotale = capienzaTotale;
        temp.prezzoAcquisto = prezzoAcquisto;
        temp.prezzoVendita = prezzoVendita;
        temp.dataDiScadenzaVendita = dataDiScadenzaVendita;
        temp.wallet += msg.value;

        energyManager[msg.sender][id]=temp;

        emit StorageEdited(msg.sender, id);
    }

    function getPossessedkWh(address he) public view returns(uint){
        return prosumer[he];
    }

    function givekWh(uint quantity) public {
        prosumer[msg.sender] += quantity;
    }

    function disableStorageVirtuale(uint id) public {
        require(energyManager[msg.sender].length > id);
        energyManager[msg.sender][id].deactivated = true;
    }

    function withdrawFromStorageVirtuale(uint id, uint maxWei) public{
        require(energyManager[msg.sender].length > id);
        storageVirtuale memory temp = energyManager[msg.sender][id];
        uint toWithraw = temp.wallet - ((temp.capienzaTotale - temp.kWhAttualmenteConservati) * temp.prezzoAcquisto);
        if(maxWei <= toWithraw){
            msg.sender.transfer(1000);
        } else {
            msg.sender.transfer(1);
        }
    }

    function getAllStorageVirtuale(address toCheck) public view returns(uint){
        return energyManager[toCheck].length;
    }

    function getStorageVirtuale(address addr, uint id) public view returns(uint, uint, uint, uint, uint, uint32, uint32, bool){
        require(energyManager[addr].length > id);
        storageVirtuale storage temp = energyManager[addr][id];
        return(temp.dataDiScadenzaVendita, temp.prezzoAcquisto, temp.prezzoVendita, temp.identificativo, temp.wallet, temp.capienzaTotale, temp.kWhAttualmenteConservati, temp.deactivated);
    }

    function addEnergyManager(address toAdd) public {
        require(isEnergyManager(msg.sender));
        energyManagersMapping[toAdd] = true;
    }

    function isEnergyManager(address toCheck) public view returns(bool){
        return energyManagersMapping[toCheck];
    }

    
    constructor() public{
        energyManagersMapping[msg.sender] = true;
    }

    function () external payable{

    }

    function pay() public payable{

    }
}"
8561-1.sol,question,contract TestMultiply { uint testVal; function Test(uint testValue){ testVal=testValue;}function multiply(uint a) returns(uint d) { return a * 7 *testVal; } }
38281-0.sol,question,"contract EtherTransfer {

    address public owner;

    function transfer() public {
    owner = 0x627306090abaB3A6e1400e9345bC60c78a8BEf57;
    owner.transfer(1000000000000000000);
    }

    function() payable public {}

function kill() public {
        if (msg.sender == owner)
        selfdestruct(owner);
    }

}"
42422-0.sol,question,"contract Users {
    struct User {
        string firstName;
        string lastName;
    }
    mapping(address => User) public users;

    function getFirstName() public view returns (string) {
        User memory user = users[msg.sender];
        return user.firstName;
    }

    function setFirstName(newName) public {
        User memory user = users[msg.sender];
        user.firstName = newName;
    }
}"
8299-0.sol,question,"contract Migrations {
  address public owner;
  uint public last_completed_migration;

  modifier restricted() {
    if (msg.sender == owner) _
  }

  function Migrations() {
    owner = msg.sender;
  }

  function setCompleted(uint completed) restricted {
    last_completed_migration = completed;
  }

  function upgrade(address new_address) restricted {
    Migrations upgraded = Migrations(new_address);
    upgraded.setCompleted(last_completed_migration);
  }
}"
54874-0.sol,question,"contract University {
    address public owner;
    address public student;
    address firstName;
    address lastName;
    bytes32 Studies;
    uint age;
    uint DateOfBirth;
    bytes32 public caCertificate;
    bytes32 ipfs_hash;
    constructor() public {
        owner = msg.sender;
    }
    modifier onlyOwner()  {
        if (msg.sender == owner) _;
    }
    modifier onlyOwnerOrStudent() {
        if (msg.sender == owner || msg.sender == student) _;
    }
    function setstudent () public;

function getStudent () public;

event student(
    bytes32 firstNameName,
    bytes32 lastName,
    bytes32 Studies,
    uint age,
    uint DateOfBirth,
    bytes32 ipfs_hash
    );

function checkStudentExists() public constant returns (bool) {
    if (student == firstName && student == lastName) return true;
}

function setIPFSHash(bytes32 _ipfs_hash) public onlyOwnerOrStudent {
    ipfs_hash = _ipfs_hash;
}"
68621-1.sol,question,"contract mContract {

function verify(string memory _user, string memory _passwd) public view {
require(
      (keccak256(bytes(userMap[_user].user)) == keccak256(bytes(_user))) &&
      (keccak256(bytes(userMap[_user].passwd)) == keccak256(bytes(_passwd))),
      ""Invalid""
);
}"
11543-1.sol,question,"contract AddressList {  
    mapping(address => uint) MemberAddresses;

    function registerAddress(uint var) { 
        MemberAddresses[msg.sender] = var;
    }  
}"
72606-0.sol,question,"contract Parent {
    address[] public registry;

    function createChild () public {
        address newChild = address(new Child());
        registry.push(newRecord);
    }
 }"
72606-0.sol,question,"contract Record {
    string public uid;
 }"
57297-0.sol,question,"contract sample_call {
    function call() public pure {
        uint a;
        sample v;   

        a = v.add_var(0x22); 
    }
}"
57297-0.sol,question,"contract sample {
    function add_var(uint a) public pure returns(uint) {
    return a + 0x55;
    }
}"
44608-0.sol,question,"contract Token {
    uint totalSupply;

    function Token() public {
        totalSupply = 0;
    }

    function mint() public{
        
    }
}"
70034-0.sol,question,"contract Factory {

    
    
    
    address Admin;

    constructor () public {
        Admin = msg.sender;
    }    

    function createNewContract(string memory Name, string memory Type, uint Fee) public returns(YourContract) {
        address YourContract = address(new YourContract(Name, Type, Fee));
    }"
59683-0.sol,question,"contract TechnoBit is ERC20 {

    using SafeMath for uint256;
    address owner = msg.sender;

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;    

    string public constant name = ""Techno Bit"";
    string public constant symbol = ""TBIT"";
    uint public constant decimals = 8;

    uint256 public totalSupply = 10000000000e8;
    uint256 public totalDistributed =  1000000000e8;    
    uint256 public constant MIN_CONTRIBUTION = 1 ether / 100; 
    uint256 public tokensPerEth = 20000000e8;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    event Distr(address indexed to, uint256 amount);
    event DistrFinished();

    event Airdrop(address indexed _owner, uint _amount, uint _balance);

    event TokensPerEthUpdated(uint _tokensPerEth);

    event Burn(address indexed burner, uint256 value);

    bool public distributionFinished = false;

    modifier canDistr() {
        require(!distributionFinished);
        _;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }


    function TechnoBit () public {
        owner = msg.sender;    
        distr(owner, totalDistributed);
    }

    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }


    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        emit DistrFinished();
        return true;
    }

    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);        
        balances[_to] = balances[_to].add(_amount);
        emit Distr(_to, _amount);
        emit Transfer(address(0), _to, _amount);

        return true;
    }

    function doAirdrop(address _participant, uint _amount) internal {

        require( _amount > 0 );      

        require( totalDistributed < totalSupply );

        balances[_participant] = balances[_participant].add(_amount);
        totalDistributed = totalDistributed.add(_amount);

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        
        emit Airdrop(_participant, _amount, balances[_participant]);
        emit Transfer(address(0), _participant, _amount);
    }

    function adminClaimAirdrop(address _participant, uint _amount) public onlyOwner {        
        doAirdrop(_participant, _amount);
    }

    function adminClaimAirdropMultiple(address[] _addresses, uint _amount) public onlyOwner {        
        for (uint i = 0; i < _addresses.length; i++) doAirdrop(_addresses[i], _amount);
    }

    function updateTokensPerEth(uint _tokensPerEth) public onlyOwner {        
        tokensPerEth = _tokensPerEth;
        emit TokensPerEthUpdated(_tokensPerEth);
    }

    function () external payable {
        getTokens();
     }

    function getTokens() payable canDistr  public {
        uint256 tokens = 0;

        
        require( msg.value >= MIN_CONTRIBUTION );

        require( msg.value > 0 );

        
        tokens = tokensPerEth.mul(msg.value) / 1 ether;        
        address investor = msg.sender;

        if (tokens > 0) {
            distr(investor, tokens);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }

    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    
    modifier onlyPayloadSize(uint size) {
        assert(msg.data.length >= size + 4);
        _;
    }

    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(msg.sender, _to, _amount);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        emit Transfer(_from, _to, _amount);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }

    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }

    function withdraw() onlyOwner public {
        address myAddress = this;
        uint256 etherBalance = myAddress.balance;
        owner.transfer(etherBalance);
    }

    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        
        

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        emit Burn(burner, _value);
    }

    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}"
35914-1.sol,question,"contract XYZCoinCrowdsale is Crowdsale {

  function XYZCoinCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) 
   
    {          
  }

  
  
  function createTokenContract() internal returns (MintableToken) {
    return new XYZCoin();
  }

}"
39679-1.sol,question,"contract TestAdoption {
    Adoption adoption = Adoption(DeployedAddresses.Adoption());

    
    function testUserCanAdoptPet() public {
      uint returnedId = adoption.adopt(8);
      uint expected = 8;
      Assert.equal(returnedId, expected, ""Adoption of pet ID 8 should be recorded."");
    }

    
    function testGetAdopterAddressByPetId() public {
        
        address expected = this;
        address adopter = adoption.adopters(8);
        Assert.equal(adopter, expected, ""Owner of pet ID 8 should be recorded."");
    }

    
    function testGetAdopterAddressByPetIdInArray() public {
        
        address expected = this;

        
        address[16] memory adopters = adoption.getAdopters();

        Assert.equal(adopters[8], expected, ""Owner of pet ID 8 should be recorded."");
    }

}"
65200-0.sol,question,"contract init {
    address owner;
    address[] public userAddresses;
    function init() {
        owner = msg.sender;
    }

    function getaddresses(address rec) public {
        userAddresses.push(rec);
    } 

    function seneth(uint value) public {
        for (uint i = 0; i < userAddresses.length; i++) {
            userAddresses[i].transfer(value);
        }
    }
}"
20888-0.sol,question,"contract ERC20 {
    
    

    function allowance(address _owner, address _spender) constant returns (uint remaining);
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);


    function approve(address _spender, uint256 _amount) returns (bool success) {
        if ((_amount != 0) && (allowed[msg.sender][_spender] != 0)) {
            return false;
        }
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }

    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) returns (bool success) {
        if (balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) {
            balances[msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(msg.sender, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

    function transferFrom(address _from, address _to, uint256 _amount)
    returns (bool success) {
        if (
        balances[_from] >= _amount
        && allowed[_from][msg.sender] >= _amount 
        && _amount > 0
        && balances[_to] + _amount > balances[_to]) {
            balances[_from] -= _amount;
            allowed[_from][msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(_from, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

    uint public totalSupply = 0;
    mapping(address => uint256) balances;
    mapping(address => mapping (address => uint256)) allowed;

    function balanceOf(address _owner) constant returns (uint balance){
        return balances[_owner];
    }
}"
20888-0.sol,question,"contract MyFriendToken is ERC20{
    string public token_name;
    string public symbol;
    uint8 public decimals;

    address public owner;

    bool purchase_OK = true;

    address friend1 = address(0x112233...);
    address friend2 = address(0x112222...);

    

    function isMyFriend(address myFriendAddress) returns (bool){
        if(myFriendAddress != friend1 && myFriendAddress != friend2) {
            return false;
        }
        return true;
    }


    function purchase_ko() {
        if(msg.sender != owner){ throw;}
        purchase_OK = false;
    }

    function purchase_ok()  {
        if(msg.sender != owner){ throw;}
        purchase_OK = true;
    }

    function MyFriendToken(){
        owner = msg.sender;
        token_name = ""MyFriendToken"";
        symbol = ""MFT"";
        decimals = 18;
    }


    function kill() {
        if (msg.sender == owner) {
            selfdestruct(owner);
        }
    }

    function() payable {
        if(!purchase_OK){throw;}
        if(!isMyFriend(msg.sender)) {throw;}

        owner.transfer(msg.value);
        uint256 MyFriendToken = (msg.value * 1000);
        totalSupply += MyFriendToken;
        balances[msg.sender] += MyFriendToken;
    }
}"
44614-1.sol,question,"contract Greeter {
    string public greeting;

    function Greeter() {
        greeting = 'Hello';
    }

    function setGreeting(string _greeting) public {
        greeting = _greeting;
    }

    function greet() constant returns (string) {
        return greeting;
    }
}"
66708-0.sol,question,"contract Bank {
    address public owner;
    mapping(address => uint) private customerBalance;
    event fallbackCalled(address, uint256);
    event deposit(address, uint256);

    constructor() public {
        owner = msg.sender;
    }

    
    function depositFunds(uint _value) external payable returns(bool) {
        require(_value > 0, ""values not greater then zero"");
        customerBalance[msg.sender] += _value;
        emit deposit(msg.sender, _value);
        return true;
    }

    
    function getCustomerBalance() public view returns(uint) {
        return customerBalance[msg.sender];
    }

    function () external payable {
        emit fallbackCalled(msg.sender, msg.value);
    }
}"
3564-0.sol,question,"contract Greeter {

    using foo for string;
    string name = ""lary"";

    function say() constant returns (string) {
        return name.greet();
    }
}"
70342-0.sol,question,"contract Session {

      address public creator;  

      string sessionName;
      string description;
      uint startTime;
      uint endTime;
      address[] lecturer;
      address[] attendes; 

      int[] result; 
      mapping(address => int) public attendes_feedback; 
      modifier onTime(uint _startTime){
            require(now < _startTime);
            _;
      }
      constructor (string memory _sessionName, string memory _description, uint _startTime,uint _endTime,address[] memory   _lecturer,address[] memory  _attendes) public onTime(_startTime){

              sessionName =  _sessionName;
              description = _description;
              startTime = _startTime;
              endTime = _endTime;
              attendes = _attendes;
              lecturer = _lecturer;
              initAttendes(attendes);
      } 

    function initAttendes(address[] memory _attendes) private{
           for(uint i=0 ; i < _attendes.length ; i++){
            attendes_feedback[_attendes[i]] = -1;
        }
    }

    function Time() public view returns (bool){
       return (now >=  startTime  && now <= endTime);          
     }

    modifier checkTime(){
        require(Time());
        _;
      }
    function take_feedback(address _voter,uint8 _feedback)  public checkTime {
          require(attendes_feedback[_voter] != 0);
          attendes_feedback[_voter] = _feedback;
          result[_feedback]++;
    }

  function seeResult() public view returns(int[] memory){
          return result;
  }

 }"
70342-0.sol,question,"contract Organization {

     address creator;
     event sessionnCreated(string name,address sessionAddress ,address creator);

     
     function createdSession(
      string memory _sessionName,
      string memory _description,
      uint _startTime,
      uint _endTime,
      address[] memory _lecturer,
      address[] memory _attendes
     ) public   returns(address) {

        Session sessionAddress = new Session(_sessionName , _description , _startTime , _endTime, _lecturer,_attendes );
        emit sessionnCreated(_sessionName,address(sessionAddress),creator);
        return address(sessionAddress);
     }
}"
69331-1.sol,question,"contract VoblaCrowdsaleTemp11 is ReentrancyGuard {

    using SafeMath for uint256;

    address private _wallet; 
    uint256 private fundingGoal; 
    uint256 private amountRaised;
    uint256 private price;
    token private tokenReward;  

    uint256 private deadline;
    uint256 private minimum;

    bool crowdsaleClosed = false;

    
    constructor(
        address ifSuccessfulSendTo, 
        uint fundingGoalInEthers, 
        uint etherCostOfEachToken, 
        uint256 durationInMinutes,  
        address addressOfTokenUsedAsReward 
    ) public payable {
        require(etherCostOfEachToken > 0);
        require(durationInMinutes > 0);
        require(ifSuccessfulSendTo != address(0));
        require(address(addressOfTokenUsedAsReward) != address(0));

        amountRaised = 0; 
        _wallet = ifSuccessfulSendTo; 
        fundingGoal = fundingGoalInEthers*10**18; 
        price = etherCostOfEachToken*10**18; 
        tokenReward = token(addressOfTokenUsedAsReward); 
        deadline = now + durationInMinutes * 1 minutes;
    }

    
    function () public payable {
        require(!crowdsaleClosed);
        crowdsaleClosed = _isDeadlineReached(deadline);
        require(!crowdsaleClosed);
        require(msg.sender != address(0));

        uint256 amount = msg.value; 
        require(amount > 0);

        crowdsaleClosed = _isGoalReached(amount);

        uint256 tokens = amount.mul(price);

        amountRaised = amountRaised.add(amount);

        tokenReward.transfer(msg.sender, tokens);

        _wallet.transfer(amount);
    }

    function _isGoalReached(uint256 weiAmount) internal view returns(bool) {
        return (amountRaised.add(weiAmount) >= fundingGoal);
    }

    function _isDeadlineReached(uint256 time) internal view returns(bool) {
        return (now >= time);
    }
}"
69825-1.sol,question,"contract EncryptedData {
   bytes[] data;
   string public decryptedData[];

   function addData(bytes data_) { 
       data.push(data_);
   }

   function decrypt(bytes key) public {
       for (uint i = 0; i < data.length; i++) {  
           decryptedData.push(decryptDataSomehow(data[i], key));
       }
   }
}"
42951-0.sol,question,"contract TOKKA is StandardToken {
    string public name = ""New Commercial Token"";
    string public symbol = ""NCT"";
    uint256 public decimals = 18;

    uint256 constant INITIAL_SUPPLY = 6000000 * 10**18;
    function TOKKA () public {
       balances[msg.sender] = INITIAL_SUPPLY;
    }
}"
42951-0.sol,question,"contract Crowdsale is Ownable {
  using SafeMath for uint256;

   
  TOKKA public token;

  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  uint256 public CAP = 3000000000000000000;

  bool crowdsaleClosed = false;

  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != address(0));

    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
    token = createTokenContract();
  }



function createTokenContract() internal returns (TOKKA) {
    return new TOKKA();
  }


  
  function () external payable {
    buyTokens(msg.sender);
  }

  
function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());
    require(!crowdsaleClosed);


    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);

    
    weiRaised = weiRaised.add(weiAmount);

    
    
    
    StandardToken(token).transfer(beneficiary, tokens);

    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
}


  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }


  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }


  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

  function GoalReached() public view returns (bool) {

    return (weiRaised >= CAP);
  }

  function Pause() public onlyOwner
  {
       

        
        require(weiRaised >= CAP);

        crowdsaleClosed = true;
  }

  function Play() public onlyOwner
  {
       

        
        require(crowdsaleClosed == true);

        crowdsaleClosed = false;
  }

}"
8179-0.sol,question,"contract Auction {
    uint public startTime;
    uint public endTime;
    uint public highestBid;
    address highestBidder;
    mapping (address => uint) deposits;
    uint constant minVal = 1000000000000000000; 

    modifier depositCheck {
        if(msg.value < minVal || msg.value % minVal != 0 || now > endTime){
            throw;
        }
        _
    }       
    modifier bidCheck(uint bid) {
        if(bid <= deposits[msg.sender] && bid % minVal == 0 && bid > highestBid && now < endTime) {
            _
        }
        else {
            throw;
        }
    }       
    modifier withdrawCheck {
        if(msg.sender == highestBidder) {
            throw;
        }
        else {
            _
        }
    }

    function Auction(uint duration){
        startTime = now;
        endTime = now + 864000000; 
    }       

    function deposit() depositCheck {
        if(deposits[msg.sender] == 0) {
            deposits[msg.sender] = msg.value;
        }
        else {
            deposits[msg.sender] += msg.value;
        }
    }    
    function bid(uint bid) bidCheck(bid) {
        highestBid = bid;
        highestBidder = msg.sender;
    }       
    function withdraw() withdrawCheck {
        uint refund = deposits[msg.sender];
        deposits[msg.sender] = 0;
        if (!msg.sender.send(refund)) {
            deposits[msg.sender] = refund;
        }
    }
    function claimPrize() {
        if(now > endTime && msg.sender == highestBidder) {
            
        }
    }
}"
77201-0.sol,question,"contract TestABC {
    function totalSupplyTest() public {
        bool a = true;
        bool b = true;
        Assert.equal(a, b, ""message ABC"");
    }
}"
60673-0.sol,question,"contract ReadBool {
    bool public flag;

    function read_bool() public constant returns (bool) {
        return flag;
    }
}"
57013-0.sol,question,"contract Test is ITest {
    address public balance;

    
    function balance() public returns (address) {
        return balance;
    }
}"
7327-0.sol,question,"contract C {

    uint256 a;
    uint256 b;

    function setA(uint256 aval) {
        a = aval;
    }

    function setB(uint256 bval) {
        b = bval;
    }

    function getA() constant returns (uint256) { 
        return a;
    }

    function getB() constant returns (uint256) {
        return b;
    }
}"
15622-1.sol,question,"contract Node is MetaCoin {

uint public fee;
address public owner;
address[] public publicRelays;

  function Node() {
    owner = msg.sender;
    fee = 10;
  }

  function createRelay () returns (address){
    address relay = new Relay();
    publicRelays.push(relay);
    return relay;
  }
}"
70975-1.sol,question,"contract MyERC721Token is ERC721Token {

  function createNewToken(...) {
    _mint(msg.sender, index);
  }
}"
61048-0.sol,question,"contract MyContract {

    function myFunction() public onlyOwner {
        dummy();
    }
}"
64742-0.sol,question,"contract RegisterCandidate {
    
    struct Address {
        string addressLine;
        string district;
        string state;
        uint pincode;     
    }

    
    struct Candidate {
        uint id;
        string name;
        Address addr;
        uint voteCount;
        uint age;
    }
    
    mapping(uint => Candidate) public candidates;
    mapping(uint => Address) public addresses;
    
    uint public candidatesCount;

    function addCandidate (string _name,uint _age,string _address,string _district,string _state,uint _pincode) public {
        candidatesCount ++;
        addresses[candidatesCount] = Address(_address,_district,_state,_pincode);
        candidates[candidatesCount] = Candidate(candidatesCount, _name,addresses[candidatesCount], 0, _age);
    }

}"
74209-0.sol,question,"contract Election {
      
          struct Candidate {
          uint id;
          string name;
          uint voteCount;
     }


mapping(uint => Candidate) public candidates;

uint public candidatesCount;

 constructor() public {
    addCandidate(""Candidate 1"");
    addCandidate(""Candidate 2"");
}

function addCandidate (string  memory _name) private {
    candidatesCount ++;
    candidates[candidatesCount] = Candidate(candidatesCount, _name, 0);
}
 }"
24641-0.sol,question,"contract UserBasic {
    struct Record {
        bytes32 _id;
        address _addedBy;
        uint _dateAdded;
        bytes32 _transactionHash;
        bytes32 _type;
        bytes32 _hash;
        bytes32 _signature;
    }
    
    mapping(bytes32 => bytes32[]) typeRecords;
    
    mapping(bytes32 => Record) idRecord;
    
    function addRecord(bytes32 _type, bytes32 _id) {
        typeRecords[_type].push(_id);
        var _new = Record(_id, tx.origin, now, """", _type, """", """");
        idRecord[_id] = _new;
    }
}"
15613-0.sol,question,"contract Color {


address public contracts;
string public color;


function Color(address _c, string _color) {
    contracts = _c;
    color = _color;
}


function getContracts() constant returns(address contractAddress) {
    return contracts;
}

function getColor() constant returns(string color) {
    return color;
}

function setlastDirAddress(address c) {
        contracts = c;
    }


function setColor(string clr) {
        color= clr;

}

}"
46888-0.sol,question,"contract FunctionTest {
    bool public foo = true;
    string public name;
    uint256 public counter = 0;

    function setName() public {
        
    }

    function writeToStorage() {
        foo = !foo;
    }

    function readFromStorageConstant() public constant returns (bool) {
        return foo;
    }

    function readFromStorageView() public view returns (bool) {
        return foo;
    }
}"
78675-1.sol,question,"contract Guarded {
     ...
     bool locked = false; 

     function withdraw() external {             
         require(!locked, ""Reentrant call detected!"");
         locked = true;

         
         (bool success, ) = msg.sender.call.value(balanceOfPayment1[msg.sender])("""");
         require(success, ""Transfer failed."");
         balanceOfPayment1[msg.sender] = 0;

         
         (bool success, ) = msg.sender.call.value(balanceOfPayment2[msg.sender])("""");
         require(success, ""Transfer failed."");
         balanceOfPayment2[msg.sender] = 0;

         locked = false;
    }
}"
60840-0.sol,question,"contract CrowdFunding {

    struct Investor {

        address addr;

        uint amount;

    }

    address public owner;

    uint public numInvestors;

    uint public deadline;

    string public status;

    bool public ended;

    uint public goalAmount;

    uint public totalAmount;

    mapping (uint => Investor) public Investors;

    modifier onlyOwner () {

        require(msg.sender == owner);

        _;

    }

    constructor(uint _duration, uint _goalAmount) public {

        owner = msg.sender;

        deadline = now + _duration;

        goalAmount = _goalAmount;

        status = ""Funding"";

        ended = false;

        numInvestors = 0;

        totalAmount = 0;

    }

    function fund() public payable {

        require(!ended);

        Investor storage inv = Investors[numInvestors++];

        inv.addr = msg.sender;

        inv.amount = msg.value;

        totalAmount += inv.amount;

    }


function checkGoalReached () public onlyOwner {

        require(!ended);

        require(now >= deadline);

        if(totalAmount >= goalAmount) {

        status = ""Campaign Succeeded"";

        ended = true;

        require(!owner.send(address(this).balance));

        uint i = 0;

        status = ""Campaign Failed"";

        ended = true;

        while(i <= numInvestors) {

            require(!Investors[i].addr.send(Investors[i].amount));

            i++;

          } 

  }

    }

    function kill() public onlyOwner {

        selfdestruct(owner);

    }

}"
62344-0.sol,question,"contract PrivilegesContract is SuperAdminContract {

    struct Privilege {
        uint Id;
        string Name;
    }

    uint private privilegeId;
    mapping(uint => string) private Privileges;

    function Add(string name) public EnsureSuperAdmin returns (uint) {
        Privileges[privilegeId] = name;
        privilegeId = privilegeId +1;
        return privilegeId;
    }
}"
70327-0.sol,question,"contract EtherGame {
    mapping(address => uint256) public balances;

    function depositFunds() public {
        balances[msg.sender] += msg.value;
        }

    function call_amount() public returns(uint256) {
        return this.balance;
    }
}"
64881-1.sol,question,"contract second {
    uint calculationResult;
    address public linkedContract;

    function changeContract(address newContract) public {
        linkedContract = newContract;
    }

    function delegatedCalculation(uint firstNumber, uint secondNumber) public {

    }
}"
69964-0.sol,question,"contract MyToken is StandardToken {
string public name = ""MyTok"";
string public symbol = ""MTK"";
uint8 public decimals = 2;
uint public INITIAL_SUPPLY = 5000;

function MyToken () public {
    totalSupply__ = INITIAL_SUPPLY;
    balances[msg.sender]= INITIAL_SUPPLY;
    emit Transfer(0x0,msg.sender,totalSupply_);

    }
}"
54580-1.sol,question,"contract EternalStorage {

    mapping(bytes32 => uint256) internal uintStorage;
    mapping(bytes32 => string) internal stringStorage;
    mapping(bytes32 => address) internal addressStorage;
    mapping(bytes32 => bytes) internal bytesStorage;
    mapping(bytes32 => bool) internal boolStorage;
    mapping(bytes32 => int256) internal intStorage;

}"
54580-1.sol,question,"contract UpgradeabilityOwnerStorage {
  
    address private _upgradeabilityOwner;

    
    function upgradeabilityOwner() public view returns (address) {
        return _upgradeabilityOwner;
    }

    
    function setUpgradeabilityOwner(address newUpgradeabilityOwner) internal {
        _upgradeabilityOwner = newUpgradeabilityOwner;
    }

}"
54580-1.sol,question,"contract Proxy {

    
    function () public payable {
        address _impl = implementation();
        require(_impl != address(0));
        bytes memory data = msg.data;

        assembly {
            let result := delegatecall(gas, _impl, add(data, 0x20), mload(data), 0, 0)
            let size := returndatasize

            let ptr := mload(0x40)
            returndatacopy(ptr, 0, size)

            switch result
            case 0 { revert(ptr, size) }
            default { return(ptr, size) }
        }
    }

    
    function implementation() public view returns (address);
}"
54580-1.sol,question,"contract UpgradeabilityStorage {
  
    string internal _version;

    
    address internal _implementation;

    
    function version() public view returns (string) {
        return _version;
    }

    
    function implementation() public view returns (address) {
        return _implementation;
    }
}"
43868-0.sol,question,"contract Storage {

    struct Block {
        address landlord;
        uint sellPrice;
    }
    Block[101][101] public blocks; 

    function setBlockOwner(uint8 _x, uint8 _y, address _newOwner) external {
        blocks[_x][_y].landlord = _newOwner;
    } 
    function getBlockOwner(uint8 _x, uint8 _y) external view returns (address) {
        return blocks[_x][_y].landlord;
    } 
}"
43868-0.sol,question,"contract MyContract {

    struct Block {
        address landlord;
        uint sellPrice;
    }
    Block[101][101] public blocks; 

    Storage strg;

    function setStorage(address addr) public { strg = Storage(addr); }

    function setNewBlockOwner(uint8 _x, uint8 _y, address _newOwner) public returns (bool) {  
        
        blocks[_x][_y].landlord = _newOwner;        
        return true;
    }

    
    function setBlockOwnerForArea(uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, address _newOwner) {
        for (uint8 ix=fromX; ix<=toX; ix++) {
            for (uint8 iy=fromY; iy<=toY; iy++) {
                setNewBlockOwner(ix, iy, _newOwner);
            }
        }
    }
}"
76206-0.sol,question,"contract MyFaucet {
  function () external payable {}

  function requestDrip() public {
    msg.sender.transfer(0.01 * 1000000000000000000);
  }
}"
71875-1.sol,question,"contract Calc {
     function add(uint a, uint b) public view returns(uint) {  
         return a + b;
     }  
}"
7490-0.sol,question,contract greeter is mortal { string greeting; function greeter(string _greeting) public { greeting = _greeting; } function changeMessage(string myMsg) returns (string){ greeting = myMsg; return myMsg; } function greet() returns (string) { return greeting; } }
33350-1.sol,question,"contract owned {
    address public owner;
    address constant public ledger = 0xd7b4754A023B92F811EF98b2bd1cD8d531905E5a;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}"
33350-1.sol,question,"contract MyCoin {
    
    string public name = ""MyCoin"";
    string public symbol = ""XYZ"";
    uint8 public decimals = 18;
    
    uint256 public totalSupply;
    uint256 initialSupply = 50000000;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    constructor() public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[this] = totalSupply;                
        
        
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }


    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
}"
56934-0.sol,question,"contract SmartMsgData {
    
    event onDeposit(int128 id, address person, uint amount);

    function bytesToBytes16(bytes b, uint offset) private pure returns (bytes16) {
      bytes16 out;

      for (uint i = 0; i < 16; i++) {
        out |= bytes16(b[offset + i] & 0xFF) >> (i * 8);
      }
      return out;
    }

    function () payable external {
        require(msg.value > 0);
        require(msg.data.length == 16); 

        

        int128 id = int128(bytesToBytes16(msg.data, 0));
        address person = msg.sender;
        uint amount = msg.value;

        
        emit onDeposit(id, person, amount);
    }
}"
66279-0.sol,question,"contract TrojanSecret {

uint memberCount;

string public name;
string public symbol;

mapping (string => address) Trojans;
mapping (string => string) secrets;
mapping (string => address[]) access;
mapping (string => uint) balance;
uint amount_for_unlock;



constructor() public{
        name   = ""Secrets""; 
        symbol = ""S"" ;
        amount_for_unlock = 1 ether;

}

function registerTrojan(string name) public returns(bool){
    if( Trojans[name] == address(0))  
    {
        memberCount ++;
        Trojans[name] = msg.sender;
        return True;
    } else {
        return false;
    }
}
function unregisterTrojan(string name) public {
    require( Trojans[name] != address(0));
    Trojans[name] = address(0);
    memberCount --;
}
function setSecret(string name,string message) public {
   require (Trojans[name] != address(0)&& Trojans[name] == msg.sender);
   secrets[name] = message;
}
function getSecret(string name) public view returns(string){
    require( Trojans[name] != address(0));
    bool flag = false;

    for(uint i = 0; i < access[name].length;i++)
    {
        if(access[name][i] == msg.sender){
            flag = true;
            break;

        }
    }
     if(flag){
         return secrets[name];
     }
     return ""message is locked"";
}

}"
82952-0.sol,question,"contract NewContract {

    struct Location {
        string JSON;
    }

    Location[] locations;

    function createLocation(string memory _json) public {
        locations.push(Location(_json));
    }

    function viewLocation(uint _id) public view returns(string memory) {
        string memory result = locations[_id].JSON;
        return result;
    }
}"
71917-0.sol,question,"contract Names {

    uint lastId;
    mapping(uint => string) public numberedNames;

    constructor() public {
        lastId = 0;
    }

    function setName(string memory name) public {
        numberedNames[lastId] = name;
        lastId++;
    }
}"
20875-2.sol,question,"contract Token {
 mapping (address => uint) public balances;

 function Token() {
     balances[msg.sender] = 1000000;
 }

 function transfer(address _to, uint _amount) {
     if (balances[msg.sender] < _amount) {
         throw;
     }

     balances[msg.sender] -= _amount;
     balances[_to] += _amount;
 }
}"
74228-0.sol,question,"contract eth_rate is usingProvable {
  string public ETHUSD;
   event LogConstructorInitiated(string nextStep);
   event LogPriceUpdated(string price);
   event LogNewProvableQuery(string description);

   constructor() public {
       emit LogConstructorInitiated(""Constructor was initiated. Call 'updatePrice()' to send the Provable Query."");
   }

   function __callback(bytes32  myid, string memory result) public {
       if (msg.sender != provable_cbAddress()) revert();
        ETHUSD = result;
        emit LogPriceUpdated(result);
   }

   function updatePrice()public  payable {
       if (provable_getPrice(""URL"") > msg.sender.balance) {
           emit LogNewProvableQuery(""Provable query was NOT sent, please add some ETH to cover for the query fee"");
       } else {
           emit LogNewProvableQuery(""Provable query was sent, standing by for the answer.."");
           provable_query(""URL"", ""json(https:
       }
   }
}"
72644-0.sol,question,contract Target {}
72644-0.sol,question,"contract Deployer {
  function deploy() external returns (Target) {
    return new Target();
  }
}"
67761-0.sol,question,"contract dapMultisig {

    
    struct Transaction {
        uint id;
        address destination;
        uint value;
        bytes data;
        TxnStatus status;
        address[] confirmed;
        address creator;
    }

    struct tokenTransaction {
        uint id;
        tokenInterface token;
        address reciever;
        uint value;
        address[] confirmed;
        TxnStatus status;
        address creator;
    }

    struct Log {
        uint amount;
        address sender;
    }

    enum TxnStatus { Unconfirmed, Pending, Executed }

    
    modifier onlyOwner () {
        bool found;
        for (uint i = 0;i<owners.length;i++){
            if (owners[i] == msg.sender){
                found = true;
            }
        }
        if (found){
            _;
        }
    }

    
    event WalletCreated(address creator, address[] owners);
    event TxnSumbitted(uint id, uint value);
    event TxnConfirmed(uint id, uint len);
    event TxnExecuted(TxnStatus status, uint amt);
    event topUpBalance(uint value);
    event LogAmount(uint256 value);
    event tokenTxnConfirmed(uint id, address owner);
    event tokenTxnExecuted(address token, uint256 value, address reciever);
    
    bytes32 public name;
    address public creator;
    uint public allowance;
    address[] public owners;
    Log[] logs;
    Transaction[] transactions;
    tokenTransaction[] tokenTransactions;
    uint public approvalsreq;


    function createWallet(uint _approvals, address[] _owners, bytes32 _name) public payable {
        name = _name;
        creator = msg.sender;
        allowance = msg.value;
        owners = _owners;
        approvalsreq = _approvals;
        emit WalletCreated(msg.sender, _owners);
    }

    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
    

    function getOwners() external view returns (address[]){
        return owners;
    }

    function getTxnNum() external view returns (uint){
        return transactions.length;
    }

    function getTxn(uint _id) external view returns (uint, address, uint, bytes, TxnStatus, address[], address){
        Transaction storage txn = transactions[_id];
        return (txn.id, txn.destination, txn.value, txn.data, txn.status, txn.confirmed, txn.creator);
    }

    function getLogsNum() external view returns (uint){
        return logs.length;
    }

    function getLog(uint logId) external view returns (address, uint){
        return(logs[logId].sender, logs[logId].amount);
    }

    function getTokenTxnNum() external view returns (uint){
        return tokenTransactions.length;
    }

    function getTokenTxn(uint _id) external view returns(uint, address, address, uint256, address[], TxnStatus, address){
        tokenTransaction storage txn = tokenTransactions[_id];
        return (txn.id, txn.token, txn.reciever, txn.value, txn.confirmed, txn.status, txn.creator);
    }

    

    function topBalance() external payable {
        require (msg.value > 0 wei);
        allowance += msg.value;

        
        uint loglen = logs.length++;
        logs[loglen].amount = msg.value;
        logs[loglen].sender = msg.sender;
        emit topUpBalance(msg.value);
    }

    function submitTransaction(address _destination, uint _value, bytes _data) external payable returns (bool) {
        uint newTxId = transactions.length++;
        transactions[newTxId].id = newTxId;
        transactions[newTxId].destination = _destination;
        transactions[newTxId].value = _value*1000000000000000000;
        transactions[newTxId].data = _data;
        transactions[newTxId].creator = msg.sender;
        if (transactions[newTxId].confirmed.length == approvalsreq){
            transactions[newTxId].status = TxnStatus.Pending;
        }
        emit TxnSumbitted(newTxId,_value);
        return true;
    }

    function confirmTransaction(uint txId) onlyOwner() external payable returns (bool){
        Transaction storage txn = transactions[txId];

        
        bool f;
        for (uint8 i = 0; i<txn.confirmed.length;i++){
            if (txn.confirmed[i] == msg.sender){
                f = true;
            }
        }
        
        require(!f);
        txn.confirmed.push(msg.sender);

        if (txn.confirmed.length == approvalsreq){
            txn.status = TxnStatus.Pending;
            require(txn.status == TxnStatus.Pending);

        
            require(allowance >= txn.value);

        
            address dest = txn.destination;
            uint val = txn.value;
            bytes storage dat = txn.data;
            assert(dest.call.value(val)(dat));

        
            txn.status = TxnStatus.Executed;

        
            allowance = allowance - txn.value;
            emit TxnExecuted(txn.status,allowance);
            return true;
        }

        
        emit TxnConfirmed(txId,txn.confirmed.length);

        return true;
    }

    
    function submitTokenTransaction(address _tokenAddress, address _receiever, uint _value) onlyOwner() external returns (bool) {
        uint newTxId = tokenTransactions.length++;
        tokenTransactions[newTxId].id = newTxId;
        tokenTransactions[newTxId].token = tokenInterface(_tokenAddress);
        tokenTransactions[newTxId].reciever = _receiever;
        tokenTransactions[newTxId].value = _value;
        tokenTransactions[newTxId].confirmed.push(msg.sender);
        if (tokenTransactions[newTxId].confirmed.length == approvalsreq){
            tokenTransactions[newTxId].status = TxnStatus.Pending;
        }
        emit TxnSumbitted(newTxId,_value);
        return true;
    }

    function confirmTokenTransaction(uint txId) onlyOwner() external returns (bool){
        tokenTransaction storage txn = tokenTransactions[txId];

        
        bool f;
        for (uint8 i = 0; i<txn.confirmed.length;i++){
            if (txn.confirmed[i] == msg.sender){
                f = true;
            }
        }
        
        require(!f);
        txn.confirmed.push(msg.sender);

        if (txn.confirmed.length == approvalsreq){
            txn.status = TxnStatus.Pending;
        }

        
        emit tokenTxnConfirmed(txId, msg.sender);

        return true;
    }

    function executeTokenTxn(uint txId) onlyOwner() external returns (bool){

        tokenTransaction storage txn = tokenTransactions[txId];

        
        require(txn.status == TxnStatus.Pending);

        
        uint256 balance = txn.token.balanceOf(address(this));
        require (txn.value <= balance);

        
        txn.token.transfer(txn.reciever, txn.value);

        
        txn.status = TxnStatus.Executed;

        
        emit tokenTxnExecuted(address(txn.token), txn.value, txn.reciever);

        return true;
    }
}"
75920-0.sol,question,"contract Existing {
    Deployed public dc;
    constructor(address _deployedContractAddress) public {
        dc = Deployed(_deployedContractAddress);
    }

    function setA(uint _a) public returns (uint) {
        return dc.setA(_a);
    }
    function getA() public view returns (uint) {
        return dc.a();
    }
}"
75920-0.sol,question,"contract Deployed {
    uint public a = 1;

    function setA(uint _a) public returns (uint) {
        a = _a;
        return a;
    }

}"
23122-0.sol,question,"contract factory {
address[] public newContracts;
address public creator;

function factory (){
    creator = msg.sender;  
}

function create () payable returns (address){
    require(msg.value >= 1 * 1000000000000000000);
    newContracts.push(msg.sender);
    return newContract;
} 

function withdrawFee() {
    creator.transfer(this.balance);
}
}"
77421-0.sol,question,"contract destroy {
    constructor(address payable receiver) public payable {
        selfdestruct(receiver);
    }
}"
77421-0.sol,question,"contract Test {

     function() external payable { }

    function transfer(address _to, uint256 _amount) external {
       
    }

}"
42026-0.sol,question,"contract d3 {
    Set.Data knownValues;

    function register(uint value) public {
        
        
        
        require(Set.insert(knownValues, value));
    }
    function contains(uint value) view public returns (bool) {
        return Set.contains(knownValues, value);
    }
    
}"
24086-0.sol,question,"contract SimpleEnum {
  enum SomeData {Channel}
  SomeData sd;

  function set_values(uint a) {
    sd.Channel = a
    return sd
  }
}"
16653-0.sol,question,"contract Forwarder {
  
  address public destinationAddress;

  
  function Forwarder() {
    destinationAddress = msg.sender;
  }

  
  function() payable external{
        if (!destinationAddress.send(msg.value))
            throw;
  }

  
  function flush() {
    if (!destinationAddress.send(this.balance))
          throw;
  }
}"
16653-0.sol,question,"contract Collector {

    
    address owner;
    Forwarder public lastGeneratedAddress;

    
    modifier onlyowner { if (msg.sender == owner) _; }

    event logDeposit(address sender, uint amount);

    
    function Collector() {
        owner = msg.sender;
    }

    
    function newAddress() onlyowner external {
        lastGeneratedAddress = new Forwarder();
    }

    function sendCoins(address receiver, uint amount) onlyowner external{
        if (!receiver.send(amount))
            throw;
    }

    function() payable {
        logDeposit(msg.sender,msg.value);
    }

    
    function flush() external{
        if (!owner.send(this.balance))
            throw;
    }
}"
33437-0.sol,question,"contract TRRT {
    string private a=""AAAAB3NzaC1yc2EAAAADAQABAAABAQDyAAB/ABtTlMBttlaKKQhjay2Cs5y79qWHpaJNYzS6oVQTN134a2JexiG5CumdETASFrQ8gZAeHxNyKz1qcLOxjonS5PJIBDpTkxE3yQm0gu9TBMFdA7Ni48l2QG1B5tO3D8mpxBWNDNXUE9ZpLzW3albmnW5+R4euWpsfpL1mRwNtrLJqGrE7vdGM8G79AscVjMkjHOfJV7AEp0rZ6Aq6vilY0lVLW+dJfbU5DNKvIM9s32nax8iDJBx3ld3YUsBJX7VL2T2xcp3DmrdctF3jYXvcYbyrwPFv1LJ3lf71Jx32Z+xprgkIliaORfZv48rXR/k2BfJJ6+f4Iim3L9X1"";
    function ShowKey()public constant returns (string) {
        return a;
    }
}"
28449-0.sol,question,"contract HelloWorld {
  uint public balance;

  function HelloWorld()  {
      balance = 1000;
  }

  function deposit(uint _value)  returns (uint _newValue) {
      balance += _value;
      return balance;
  }
}"
64999-2.sol,question,"contract Crowdsale is BurnableToken {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  
  ERC20 public token;

  
  address public wallet;

  
  
  
  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  event TokenPurchase(
    address indexed purchaser,
    address indexed beneficiary,
    uint256 value,
    uint256 amount
  );

  
  constructor(uint256 _rate, address _wallet, ERC20 _token) public {
    require(_rate > 0);
    require(_wallet != address(0));
    require(_token != address(0));

    rate = _rate;
    wallet = _wallet;
    token = _token;
  }

  
  
  

  
  function () external payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address _beneficiary) public payable {

    uint256 weiAmount = msg.value;
    _preValidatePurchase(_beneficiary, weiAmount);

    
    uint256 tokens = _getTokenAmount(weiAmount);

    
    weiRaised = weiRaised.add(weiAmount);

    _processPurchase(_beneficiary, tokens);
    emit TokenPurchase(
      msg.sender,
      _beneficiary,
      weiAmount,
      tokens
    );

    _updatePurchasingState(_beneficiary, weiAmount);

    _forwardFunds();
    _postValidatePurchase(_beneficiary, weiAmount);
  }

  function sellTokens(uint256 amount) public {

    uint256 weiAmount = amount.mul(rate);
    address myAddress = address(this);

    require(myAddress.balance >= weiAmount);
    weiRaised = weiRaised.sub(weiAmount);

    burn(amount);

  }

  
  
  

  
  function _preValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    require(_beneficiary != address(0));
    require(_weiAmount != 0);
  }

  
  function _postValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _deliverTokens(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    token.safeTransfer(_beneficiary, _tokenAmount);
  }

  
  function _processPurchase(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    _deliverTokens(_beneficiary, _tokenAmount);
  }

  
  function _updatePurchasingState(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _getTokenAmount(uint256 _weiAmount)
    internal view returns (uint256)
  {
    return _weiAmount.mul(rate);
  }

  
  function _forwardFunds() internal {
    wallet.transfer(msg.value);
  }
}"
83147-0.sol,question,"contract Campaign {
    Request[] public requests;
    address  public  manager;
    uint public minimumConstribution;
    mapping(address => bool ) public approvers;
    uint public approversCount;

    constructor(uint minimum) public {
        manager = msg.sender;
        minimumConstribution = minimum;
    }

    struct Request {
        string description;
        uint value;
        address recipient;
        bool complete;
        uint approvalCount;
        mapping(address => bool) approvals;
    }

    modifier restricted {
        require(msg.sender == manager);
        _;
    }



    function constribute() public payable {
        require(msg.value > minimumConstribution);

        approvers[msg.sender] = true;

        approversCount++;
    }

    function createRequest(string memory description, uint value, address recipient) public restricted {
        Request memory newRequest = Request({
            description : description,
            value : value,
            recipient : recipient,
            complete : false,
            approvalCount : 0
        });

        requests.push(newRequest);
    }

    function approveRequest(uint index) public {
        Request storage request = requests[index];

        require(approvers[msg.sender]);
        require(!request.approvals[msg.sender]);

        request.approvals[msg.sender] = true;
        request.approvalCount++;

    }

    function finalizeRequest(uint index) public restricted {
        Request storage request = requests[index];

        require(request.approvalCount > approversCount /2);

        require(!request.complete);

        request.recipient.transfer(request.value);  
   



        request.complete = true;


    }

}"
30045-0.sol,question,"contract Candy {
    address public owner;

    function Candy() public {
        owner = msg.sender;
    }
}"
33036-0.sol,question,"contract BlipCoinIco is PausableToken {
  *snip*

  function() isIcoOpen payable {
      totalRaised = totalRaised.add(msg.value);

      uint256 tokenAmount = calculateTokenAmount(msg.value);
      balances[fundsWallet] = balances[fundsWallet].sub(tokenAmount);
      balances[msg.sender] = balances[msg.sender].add(tokenAmount);
      Transfer(fundsWallet, msg.sender, tokenAmount);

      
      fundsWallet.transfer(msg.value);
  }

  function calculateTokenAmount(uint256 weiAmount) constant returns(uint256) {
      
      uint256 tokenAmount = weiAmount.mul(50);
      if (now <= startTimestamp + 7 days) {
          
          return tokenAmount.mul(150).div(100);
      } else {
          return tokenAmount;
      }
  }

  *snip*
}"
30036-0.sol,question,"contract yoThere {
        string public msg;
        function yoThere() {
          msg = ""Hey lol"";
        }

        function greet() constant returns(string) {
          return msg;
        }
     }"
64025-1.sol,question,"contract TokenSale {
    address public beneficiary;
    uint public amountRaised;
    uint public price;
    uint public dynamicLocktime;
    uint public globalLocktime;
    uint public lockType = 0;
    token public tokenReward;
    uint public exchangeRate;

    mapping(address => uint256) public balanceOf;
    mapping(address => uint256) public tokenBalanceOf;
    mapping(address => uint256) public timelocksOf;

    address[] public founders;
    address public owner;

    event FundTransfer(address backer, uint amount, uint exchangeRate, uint token, uint time, uint timelock, bool isContribution);
    event IsCharged(bool isCharged);
    event TokensClaimed(address founder, uint tokens);
    event TransferOwnership();
    event ChangeExchangeRate(uint oldExchangeRate, uint newExchangeRate);
    event NewGlobalLocktime(uint timelockUntil);
    event NewDynamicLocktime(uint timelockUntil);
    uint public tokenAvailable = 0;
    bool public charged = false;


    
    constructor(
        address _beneficiary,
        address _addressOfTokenUsedAsReward,
        uint _globalLocktime,
        uint _dynamicLocktime,
        uint _exchangeRate
    ) public {
        beneficiary = _beneficiary;
        dynamicLocktime = _dynamicLocktime;
        tokenReward = token(_addressOfTokenUsedAsReward);
        globalLocktime = now + _globalLocktime * 1 minutes;
        exchangeRate = _exchangeRate;
        owner = msg.sender;
    }

    
    function () payable public {
          require(charged);
          require(msg.value >= 10000000000); 
          uint am = (msg.value* exchangeRate * 100000000)/(1 ether); 
          require( tokenAvailable >= am);
          uint amount = msg.value;
          balanceOf[msg.sender] += amount;
          amountRaised += amount;
          tokenBalanceOf[msg.sender] += am;
          tokenAvailable -= am;

          if(timelocksOf[msg.sender] == 0){
            timelocksOf[msg.sender] = now + dynamicLocktime * 1 minutes;
          }

          emit FundTransfer(msg.sender, amount, exchangeRate, am, now, timelocksOf[msg.sender], true);
          founders.push(msg.sender);
    }


    modifier onlyOwner(){
      require(msg.sender == owner || msg.sender == beneficiary);
      _;
    }


    function doChargeCrowdsale() public onlyOwner{
      tokenAvailable = tokenReward.balanceOf(this);
      if(tokenAvailable > 0){
        charged = true;
        emit IsCharged(charged);
      }
    }



    function claimTokens(address adr) public{
      require(tokenBalanceOf[adr] > 0);

      if(lockType == 0){ 
        require(now >= timelocksOf[adr]);
      }else if(lockType == 1){ 
        require(now >= globalLocktime);
      } 

      if(tokenReward.transfer(adr, tokenBalanceOf[adr])){
        emit TokensClaimed(adr, tokenBalanceOf[adr]);
        tokenBalanceOf[adr] = 0;
        balanceOf[adr] = 0;
      }
    }



    function transferRaisedFunds() public onlyOwner {
        if (beneficiary.send(amountRaised)) {
           emit FundTransfer(beneficiary, amountRaised, exchangeRate, 0, now, 0, false);
        }
    }



    function transferOwnership(address newOwner) public onlyOwner{
      owner = newOwner;
      emit TransferOwnership();
    }


    function setExchangeRate(uint newExchangeRate) public onlyOwner{
      emit ChangeExchangeRate(exchangeRate, newExchangeRate);
      exchangeRate = newExchangeRate;
    }


    function setGlobalLocktime(uint mins) public onlyOwner{
      globalLocktime = now + mins * 1 minutes;
      emit NewGlobalLocktime(globalLocktime);
    }


    function setDynamicLocktime(uint mins) public onlyOwner{
      dynamicLocktime = now + mins * 1 minutes;
      emit NewDynamicLocktime(dynamicLocktime);
    }


    function setLockType(uint newType) public onlyOwner{
        require(newType == 0 || newType == 1 || newType == 2);
        lockType = newType;
    }


    function unlockTokensFor(address adr) public onlyOwner{
      timelocksOf[adr] = 1;
    }


    function resetLockFor(address adr) public onlyOwner{
      timelocksOf[adr] = 0;
    }


    function getLeftOver() public onlyOwner{
      if(tokenReward.transfer(beneficiary, tokenAvailable)){
        emit TokensClaimed(beneficiary, tokenAvailable);
        tokenAvailable = 0;
      }
    }
}"
17165-0.sol,question,"contract Bank  {
    struct Balance {
      address owner;
      uint vault;
      uint profit;
    }

    Balance balance;
      mapping (address => uint) balances;

    function Bank() {
        balance.owner = msg.sender;
        balance = Balance(msg.sender, 0, 0);
    }

    function getBalance() constant returns (uint) {
        if(msg.sender == balance.owner) {
           return this.balance;
        }
        throw;
    }

    function withdrawOwner() returns (bool) {
        if(msg.sender == balance.owner) {
           balance.vault = balance.vault - balance.profit;
           bool sent = balance.owner.send(balance.profit);
           balance.profit = 0;
           return sent;
        }
        return false;
    }

    function withdraw() returns (bool) {
        uint customerBalance = balances[msg.sender];
        if(customerBalance == 0) {
          throw;
        }

        balance.vault -= customerBalance;

        balances[msg.sender] = 0;
        return msg.sender.send(customerBalance);
    }

    function deposit() payable returns (bool) {
        uint take = 100;

        uint depositAmount = msg.value;
        balance.vault += depositAmount;
        balance.profit += take;

        balances[msg.sender] = depositAmount - take;

        if(msg.value < 20) {
          throw;
        } 

        return true;
    }
}"
47215-0.sol,question,"contract smartContract {
    uint  value;
    function set(uint input) returns (bool success) {
         value = input;
    }
    function getValue() public view
     returns (uint)
    {
        return value;
    } 

}"
2549-0.sol,question,"contract ClearMapping {
    mapping(uint => bool)[] state;

    
    
    
    function add() returns (bool) {
        uint pos = state.length++;
        bool curr = state[pos][0];
        state[pos][0] = true;
        return curr;
    }

    function remove() {
        state.length--;
    }
}"
83839-0.sol,question,"contract NodeContract {
  
  
   
   struct Node {
    
    bytes32 nodeId;
   }

   uint numberOfNodes = 0;
  
   mapping (uint => Node) nodes;

   constructor() public {
   }

   function publishNewNode(bytes32 nodeId) external returns(uint256)
   {
   
    uint256 nodeIndex = numberOfNodes;
    
    nodes[nodeIndex] = Node({nodeId:nodeId});

    numberOfNodes += 1;

    return (nodeIndex);
   }

  
   function getNodeData(uint256 nodeIndex) external view returns(bytes32 nodeId)
   {
    require(nodeIndex < numberOfNodes, ""The nodeIndex supplied is larger than the number of available nodes"");

    return (nodes[nodeIndex].nodeId);
   }
  

   function nodesCount () external view returns(uint) {
   return (numberOfNodes);
   }
}"
84642-0.sol,question,"contract Patients {
    uint256 public count = 0;
    struct Patient {
        bytes16 patientID;
        bytes16 title;
        bytes16 fullName;
        bytes16 dob;
        bytes16 gender;
        bytes16 contact;
        bytes16 residentialAddress;
        bytes16 relativeNumber;
        uint256 NHIS;
        uint256 temperature;
        uint256 bloodPressure;
        uint256 pulse;
        uint256 respiration;
        uint256 weight;
        uint256 bmi;
        bool appointment;
    }

event created(string message);

mapping(uint256 => Patient) public patient;

  function setBio(bytes16  patientID, bytes16  title, bytes16  fullName, bytes16  dob, bytes16  gender, bytes16  contact, bytes16  residentialAddress, bytes16  relativeNumber, uint256 NHIS) public {
    count++;
    patient[count].patientID = patientID;
    patient[count].title = title;
    patient[count].fullName = fullName;
    patient[count].dob = dob;
    patient[count].gender = gender;
    patient[count].contact = contact;
    patient[count].residentialAddress = residentialAddress;
    patient[count].relativeNumber = relativeNumber;
    patient[count].NHIS = NHIS;
    emit created('New Patient folder created');
  }

  function getBio(uint256 index) public view returns(bytes16  patientID, bytes16  title, bytes16  fullName, bytes16  dob,bytes16  gender, bytes16  contact, bytes16  residentialAddress,bytes16  relativeNumber, uint256 NHIS){
    Patient memory p = patient[index];
    return(p.patientID, p.title, p.fullName, p.dob, p.gender, p.contact, p.residentialAddress, p.relativeNumber, p.NHIS);
  }

  function setVitalSigns(uint _id, uint256 temperature, uint256 bloodPressure, uint256 pulse, uint256 respiration, uint256 weight, uint256 bmi, bool)public {
    Patient memory _patient = patient[_id];
    _patient.temperature = temperature;
    _patient.bloodPressure = bloodPressure;
    _patient.pulse = pulse;
    _patient.respiration = respiration;
    _patient.weight = weight;
    _patient.bmi = bmi;
    _patient.appointment = !_patient.appointment;
    emit created('Vital Signs Checked');
  }
  
}"
83391-0.sol,question,"contract Depository {
        mapping(address => uint256) public balances;

        function deposit(uint256 amount) external {
            require(amount > 0);

            Token token = Token(0xFab46E002BbF0b4509813474841E0716E6730136);
            require(token.transferFrom(msg.sender, address(this), amount), ""The deposit failed"");
            balances[msg.sender] += amount;
        }
    }"
83391-0.sol,question,"contract Owner {
        function transfer(uint256 amount) external {
            require(amount > 0);

            Token token = Token(0xFab46E002BbF0b4509813474841E0716E6730136);
            
            token.approve(0xEa917F373afa9F7F4AdB31a01D4c91E763De6502, amount);

            Depository depository = Depository(0xEa917F373afa9F7F4AdB31a01D4c91E763De6502);
            depository.deposit(amount);

        }
    }"
59368-0.sol,question,"contract Adoption {

address[16] public adopters;


function adopt(uint petId) public returns (uint) { 
  require(petId >= 0 &amp,&amp; petId <= 15); 
  adopters[petId] = msg.sender; 
  return petId;
 } 


function getAdopters() public view returns (address[16]) {
  return adopters;
 }

}"
8756-0.sol,question,"contract Object {

    string name;
    function Object(String _name) {
        name = _name
    }
}"
8756-0.sol,question,"contract ObjectFactory {
    function createObject(string name) returns (address objectAddress) {
        return address(new Object(name));
    }
}"
44758-0.sol,question,"contract Test {
    
    function getString(address _mg) returns (address) {
         return _mg;
    }
}"
27085-0.sol,question,"contract CustomerTemplate {

    bytes32 public customerName;
    bytes32 public customerLoc;

    function CustomerTemplate (bytes32 _customerName, bytes32 _customerLoc)  {

        customerName    = _customerName;
        customerLoc     = _customerLoc;

    }

}"
27085-0.sol,question,"contract Master is CustomerTemplate{

    address public owner;
    bytes32 public ownerName;
    address[] newCustomers;

    modifier onlyByMaster()  {
        require(msg.sender == owner);
        _;
    }

    function Master (bytes32 _ownerName) {

        owner = msg.sender;
        ownerName = _ownerName;
    }

    function createCustomer (bytes32 _customerName, bytes32 _customerLoc) {

        address myCustomer = new CustomerTemplate(_customerName, _customerLoc);
        newCustomers.push(myCustomer);
    }

    function killContract() constant onlyByMaster {

        if (msg.sender == owner) selfdestruct(owner);

    }

}"
69194-0.sol,question,"contract ERC223Interface {
    function totalSupply() external view returns (uint256);
    function balanceOf(address who) external view returns (uint256);
    function transfer(address to, uint256 value) external returns (bool);
    function transfer(address to, uint256 value, bytes calldata data) external returns (bool);
    function approve(address spender, uint256 value) external returns (bool);
    function allowance(address owner, address spender) external view returns (uint256);
    function transferFrom(address from, address to, uint256 value) external returns (bool);
    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);
    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);
    event Approval(address indexed owner, address indexed spender, uint256 value);
}"
69194-0.sol,question,"contract ReentrancyGuard {
    using SafeMath for uint256;
    uint256 private _guardCounter;

    constructor () internal {
        _guardCounter = 1;
    }

    modifier nonReentrant() {
        _guardCounter = _guardCounter.add(1);
        uint256 localCounter = _guardCounter;
        _;
        require(localCounter == _guardCounter);
    }
}"
69194-0.sol,question,"contract ERC223ReceivingContract { 
    
    function tokenFallback(address _from, uint256 _value, bytes memory _data) public;
}"
69194-0.sol,question,"contract ERC223Token is ERC223Interface {
    using SafeMath for uint256;

    address private _owner; 
    
    

    string  public  constant name = ""ERC223"";
    string  public  constant symbol = ""ERC223"";
    uint8   public  constant decimals = 18;
    uint256 private constant _totalSupply = 10000000 * (uint256(10) ** decimals);

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowed;

    constructor() public {
        _owner = msg.sender;
        _balances[_owner] = _totalSupply;
        emit Transfer(address(0), _owner, _totalSupply);
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    function balanceOf(address owner) public view returns (uint256 balance) {
        return _balances[owner];
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(to != address(0));
        require(value > 0 && balanceOf(msg.sender) >= value);
        require(balanceOf(to).add(value) > balanceOf(to));

        uint256 codeLength;
        bytes memory empty;

        assembly {
            codeLength := extcodesize(to)
        }

        _balances[msg.sender] = _balances[msg.sender].sub(value);
        _balances[to] = _balances[to].add(value);

        if(codeLength>0) {
            ERC223ReceivingContract receiver = ERC223ReceivingContract(to);
            receiver.tokenFallback(msg.sender, value, empty);
        }

        emit Transfer(msg.sender, to, value, empty);
        return true;
    }

    function transfer(address to, uint256 value, bytes memory data) public returns (bool success) {
        require(to != address(0));
        require(value > 0 && balanceOf(msg.sender) >= value);
        require(balanceOf(to).add(value) > balanceOf(to));

        uint256 codeLength;

        assembly {
            codeLength := extcodesize(to)
        }

        _balances[msg.sender] = _balances[msg.sender].sub(value);
        _balances[to] = _balances[to].add(value);

        if(codeLength>0) {
            ERC223ReceivingContract receiver = ERC223ReceivingContract(to);
            receiver.tokenFallback(msg.sender, value, data);
        }

        emit Transfer(msg.sender, to, value, data);
        return true;
    }

    function approve(address spender, uint256 value) public returns (bool success) {
        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowed[owner][spender];
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool success) {
        require(to != address(0));
        require(value <= _balances[from]);
        require(value <= _allowed[from][msg.sender]);

        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
        emit Transfer(from, to, value);
        return true;
    }

    function increaseAllowance(address spender, uint256 addedValue) public returns (bool success) {
        _allowed[msg.sender][spender] = _allowed[msg.sender][spender].add(addedValue);
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool success) {
        uint256 oldValue = _allowed[msg.sender][spender];
        if (subtractedValue > oldValue) {
            _allowed[msg.sender][spender] = 0;
        } else {
            _allowed[msg.sender][spender] = oldValue.sub(subtractedValue);
        }
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    function unlockERC20Tokens(address tokenAddress, uint256 tokens) public returns (bool success) {
        require(msg.sender == _owner);
        return ERC223Interface(tokenAddress).transfer(_owner, tokens);
    }

    function () external payable {
        revert(""This contract does not accept ETH"");
    }

}"
69194-0.sol,question,"contract ERC223Contract is ReentrancyGuard {
    using SafeMath for uint256;

    ERC223Interface private token;

    constructor(ERC223Interface _token) public {
        token = _token;
        emit Created(""Successfully created ERC223 Contract"");
    }

    function getBlockNumber() public view returns (uint256) {
        return block.number;
    }

    function getData() public pure returns (bytes memory) {
        return msg.data;
    }

    function getSignature() public pure returns (bytes4) {
        return msg.sig;
    }

    function () external {
      
      revert();
    }

    function tokenFallback(address player, uint tokens, bytes memory data) public nonReentrant {
        require(msg.sender == address(token));
        emit DepositedERC223Token(player, tokens, data);
    }

    event Created(string);
    event DepositedERC223Token(address from, uint value, bytes data);
}"
28389-1.sol,question,"contract Ownable {

    address public owner;

    
    function Ownable() internal {
        owner = msg.sender;
    }

    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

}"
28389-1.sol,question,"contract Secret is Ownable {

  string private secret;

  function Secret() public {
    secret = """";
  }

  function setSecret(string _secret) public onlyOwner {
    secret = _secret;
  }

}"
84804-0.sol,question,"contract ReferenceConsumer {
  AggregatorInterface internal ref;

  constructor(address _aggregator) public {
    ref = AggregatorInterface(_aggregator);
  }

  function getLatestAnswer() public returns (int256) {
    return ref.latestAnswer();
  }
}"
76176-0.sol,question,"contract Foo {

    uint256 public foo;

    function setFoo(uint256 _foo) public {
        foo = _foo;
    }

    function setFooToZero() public {
        foo = 0;
    }
}"
77198-0.sol,question,"contract AuthorDonationExample {



  
  address payable author;
  address payable eachditor;

  
  

  function donate() public payable {
    
    require (msg.value != 0);

    
    
    uint editorAmount = msg.value / 5;
    uint authorAmount = msg.value - editorAmount;

    
    
    require (author.send(authorAmount)) ;
    require (editor.send(editorAmount)) ;
  }
}"
31747-0.sol,question,"contract LocalEthereum {

    address public owner;
    event Created(bytes32 _tradeHash);
    function createEvent() onlyOwner external {
        Created(0x01);
    } 
}"
63733-2.sol,question,"contract AjToken {
string  public name = ""AJ Token"";
string  public symbol = ""AJ"";
string  public standard = ""AJ Token V1.0 standard"";
uint256 public totalSupply;

event Transfer(
    address indexed _from,
    address indexed _to,
    uint256 _value
);

event Approval(
    address indexed _owner,
    address indexed _spender,
    uint256 _value
);

mapping(address => uint256) public balanceOf;
mapping(address => mapping(address => uint256)) public allowance;

function AjToken (uint256 _initialSupply) public {
    balanceOf[msg.sender] = _initialSupply;
    totalSupply = _initialSupply;
}

function transfer(address _to, uint256 _value) public returns (bool success) {
    require(balanceOf[msg.sender] >= _value);

    balanceOf[msg.sender] -= _value;
    balanceOf[_to] += _value;

    Transfer(msg.sender, _to, _value);

    return true;
}

function approve(address _spender, uint256 _value) public returns (bool success) {
    allowance[msg.sender][_spender] = _value;

    Approval(msg.sender, _spender, _value);

    return true;
}

function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    require(_value <= balanceOf[_from]);
    require(_value <= allowance[_from][msg.sender]);

    balanceOf[_from] -= _value;
    balanceOf[_to] += _value;

    allowance[_from][msg.sender] -= _value;

    

    


    Transfer(_from, _to, _value);

    return true;
}
}"
42884-0.sol,question,"contract BigData { 
  bytes public doubleBag = ""1"";

  function doubleStorage() public { 
    uint256 index = 0;
    uint256 addThisMany = doubleBag.length;
    while (index < addThisMany) { 
      doubleBag.push(""1"");
      index += 1;
    } 
  } 

  function getLength() public view returns (uint256) { 
    return doubleBag.length;
  } 
}"
44120-0.sol,question,"contract QueryResultHandler {

   struct QueryResultStruct {
       bytes32 finalHash;
       bytes32 queryHash;
       bytes32 resultHash;
       uint256 queryId;
       uint256 resultId;
   }

   QueryResultStruct[] queryResultStructArray;

   function storeQueryResults(uint256 _queryId, uint256 _resultId, string _queryString, string _resultString) external returns (bool success) {
      bytes32 queryHash = keccak256(_queryString);
      bytes32 resultHash = keccak256(_resultString);
      bytes32 hashThem = keccak256(queryHash, resultHash);
      queryResultStructArray.push(QueryResultStruct(hashThem, queryHash, resultHash, _queryId, _resultId));
      return true;
    }

   function validateQueryResultsById(uint256 _queryId, uint256 _resultId) external view returns (bool success) {
      for (uint i = 0; i < queryResultStructArray.length; i++){
          if (queryResultStructArray[i].queryId == _queryId && queryResultStructArray[i].resultId == _resultId) {
              return true;
          }
       }
    return false;
    }

   function validateQueryResultsByString(string _queryString, string _resultString) external view returns (bool success) {
      bytes32 queryHash = keccak256(_queryString);
      bytes32 resultHash = keccak256(_resultString);

      bytes32 hashThem = keccak256(queryHash, resultHash);

      for (uint i = 0; i < queryResultStructArray.length; i++) {
          if (queryResultStructArray[i].finalHash == hashThem) {
              return true;
          }
      }
      return false;
   }
}"
57868-0.sol,question,"contract Crowdsale {
address public beneficiary;
uint public amountRaised;
uint public price;
token public tokenReward;
mapping(address => uint256) public balanceOf;

event FundTransfer(address backer, uint amount, bool isContribution);


constructor(
    address ifSuccessfulSendTo,
    uint milietherCostOfEachToken,
    address addressOfTokenUsedAsReward
) public {
    beneficiary = ifSuccessfulSendTo;
    price = milietherCostOfEachToken * 0.001 ether;
    tokenReward = token(addressOfTokenUsedAsReward);
}

function () payable public {

uint amount = msg.value;
balanceOf[msg.sender] += amount;
amountRaised += amount;
tokenReward.transfer(msg.sender, amount * 10**18 / price);
emit FundTransfer(msg.sender, amount, true);


beneficiary.transfer(amount);
}
        }"
60761-0.sol,question,"contract Crowdsale {
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;

    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    function Crowdsale(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) public {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 1 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function () payable public {
        require(!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / price);
       emit FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() public afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            emit GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    
    function safeWithdrawal() public afterDeadline {
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                   emit FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
               emit FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}"
42000-0.sol,question,"contract SimpleStorage {
    uint storedData;

    function set(uint x) public {
        storedData = x;
    }

    function get() public constant returns (uint) {
        return storedData;
    } }"
8553-0.sol,question,"contract MyContract {
struct Posposal{
    uint posposalId;
    address voteSponsorAddr;

    bytes1 description_;
    uint userId;
    uint amount;
}
Posposal[] public curPosposals; 
uint public posposalNextId=0;

function MyContract() {

}
uint public expId;
address public expTarget;
uint public expAmount;
function issuse(uint userId,address target_,uint amount_)  {
    
    expId=userId;
    expAmount=amount_;
    expTarget=target_;
    curPosposals.push(Posposal(posposalNextId,msg.sender,0x01,userId,amount_));
    posposalNextId++;
}}"
34687-0.sol,question,"contract ElephanteumCore is Ownable {

        ElephanteumStorage public eStorage;

        function ElephanteumCore(address _eStorage) public payable {
            eStorage = ElephanteumStorage(_eStorage);     
        }

        function init(bytes32 _name, bytes32 _symbol, uint _supply) public onlyOwner {
            eStorage.setTotalSupply(_supply);
            eStorage.setElephantsRemainingToAssign(_supply);
            eStorage.setName(_name);
            eStorage.setSymbol(_symbol);
        }
}"
34687-0.sol,question,"contract ElephanteumStorage is Ownable {

        bytes32 public name;
        bytes32 public symbol;

        uint public totalSupply;

        uint public elephantsRemainingToAssign;

        function setName(bytes32 _name) onlyOwner external {
            name = _name;
        }

        function setSymbol(bytes32 _symbol) onlyOwner external {
            symbol = _symbol;
        }

        function setTotalSupply(uint _totalSupply) onlyOwner external {
            totalSupply = _totalSupply;
        }

        function setElephantsRemainingToAssign(uint _elephantsRemainingToAssign) onlyOwner external {
            elephantsRemainingToAssign = _elephantsRemainingToAssign;
        } 
}"
70310-0.sol,question,"contract A {
    function something_1() public { ... }
    function something_2() public { ... }
}"
70310-0.sol,question,"contract B is A {
    function something_1() public  { ... }
    function something_2() private { ... }
}"
60478-1.sol,question,"contract Crowdsale {
   bool public icoCompleted;
   uint256 public icoStartTime = 1538567825; 
   uint256 public icoEndTime = 1541246755;  
   uint256 public tokenRate;
   uint256 public fundingGoal;
   address public owner;
   ICOToken public token;
   uint256 public tokensRaised;
   uint256 public etherRaised;
   uint256 public etherUsed = msg.value;
   uint256 public tokensToBuy;


   modifier whenIcoCompleted {
      require(icoCompleted);
      _;
   }

    modifier onlyOwner {
      require(msg.sender == owner);
      _;
   }

   function () public payable {
       buy();
   }

     constructor(uint256 _tokenRate, address _tokenAddress, uint256 _fundingGoal) public {
      require(icoStartTime != 0 &&
      icoEndTime != 0 &&
      icoStartTime < icoEndTime &&
      _tokenRate != 0 &&
      _tokenAddress != address(0) &&
      _fundingGoal != 0);
      tokenRate = _tokenRate;
      token = ICOToken(_tokenAddress);
      fundingGoal = _fundingGoal;
      owner = msg.sender;
      etherUsed;
      tokensToBuy;
   }

    function buy() public payable {

    
    

      etherUsed = msg.value;

      tokensToBuy = etherUsed * (10 ** token.decimals()) / 1 ether * tokenRate;

    

    

    
    

    
    

    

    
    

    
    

    
      
      token.buyTokens(msg.sender, tokensToBuy);

      
      tokensRaised += tokensToBuy;
      etherRaised += etherUsed;
   }


   function extractEther() public whenIcoCompleted onlyOwner {
       owner.transfer(address(this).balance);
   }

}"
47910-0.sol,question,"contract Test {

    function setThreeValues() public view returns(int, uint, uint) {
        int x = 5;
        uint y = 7;
        uint z = 0;

        x += 5;
        y += 13;
        z = uint(x) + y;

        return (x, y, z);

    }



    function callThreeValues() public view returns(int, uint, uint) {
        return setThreeValues();
    }


    
    
    


    
    
    

    
    
    

}"
37280-0.sol,question,"contract A {

  function doSomethingA() {
   
  }

}"
37280-0.sol,question,"contract B is A {

  function doSomethingB() {
    
  }

}"
72417-0.sol,question,"contract Contract1 {
    function func(uint256 x, uint8 y) public returns (uint32, uint32) {...}
}"
72417-0.sol,question,"contract Contract2{

        assembly
        {
                let success := call(
                    gas,           
                    dest,          
                    0,             
                    add(data, 32), 
                    mload(data),   
                    ret,           
                    8              
                )
                if iszero(success) {
                    revert(0, 0)
                }
        }

}"
64480-0.sol,question,"contract TripHistory {
       struct Trip {
           string lat;
           string lon;
       }
        mapping(string => Trip[]) trips;

        function getTrip(string _trip_id) public view returns (Trip[]) {
            return trips[_trip_id];
        }
        function storeTrip(string _trip_id, string _lat, string _lon) public  {
           trips[_trip_id].push(Trip(_lat, _lon));
        }

}"
72435-0.sol,question,"contract TestStruct {

      struct User {
        string name;
        uint256 age;
     }

    mapping (bytes32 => User) users;

    function addUsers (User [] memory _users) public {

        for (uint i = 0; i < _users.length; i++) {

           bytes32 hash = keccak256(abi.encode(_users[i].name));
           users[hash] = _users[i];

        }
    }

    function getUser (string memory username) public view returns (User memory) {

        bytes32 hash = keccak256(abi.encode(username));

        return users[hash];
    }
}"
46498-1.sol,question,"contract Tasks {

    struct Person { 
        uint weight; 
        bool deedCompleted;  
        address delegate; 
        uint deed;   
    }

    struct Proposal {
        bytes32 deedName;   
        uint karmaPoints;
    }

    address public chairperson;

    mapping(address => Person) public validators;

    Proposal[] public proposals;

    
    function Ballot(bytes32[] proposalNames) public {
        chairperson = msg.sender;
        validators[chairperson].weight = 1;

        
        
        
        for (uint i = 0; i < proposalNames.length; i++) {
            
            
            
            proposals.push(Proposal({
                deedName: proposalNames[i],
                karmaPoints: 0
            }));
        }
    }

    
    
    function giveRightToVote(address validator) public {
        require(
            msg.sender == chairperson,
            ""Only chairperson can give right to deed.""
        );
        require(
            !validators[validator].deedCompleted,
            ""The validator already confirm deed was completed.""
        );
        require(validators[validator].weight == 0);
        validators[validator].weight = 1;
    }

    
    function delegate(address to) public {
        Person storage sender = validators[msg.sender];
        require(!sender.deedCompleted, ""You already completed a deed."");

        require(to != msg.sender, ""Self-delegation is disallowed."");

        while (validators[to].delegate != address(0)) {
            to = validators[to].delegate;

            require(to != msg.sender, ""Found loop in delegation."");
        }

        sender.deedCompleted = true;
        sender.delegate = to;
        Person storage delegate_ = validators[to];
        if (delegate_.deedCompleted) {
            
            
            proposals[delegate_.deed].karmaPoints += sender.weight;
        } else {
            
            
            delegate_.weight += sender.weight;
        }
    }

    
    function deed(uint proposal) public {
        Person storage sender = validators[msg.sender];
        require(!sender.deedCompleted, ""Already deedCompleted."");
        sender.deedCompleted = true;
        sender.deed = proposal;

        
        
        
        proposals[proposal].karmaPoints += sender.weight;
    }

    
    
    function completedProposal() public view
            returns (uint completedProposal_)
    {
        uint completedVoteCount = 0;
        for (uint p = 0; p < proposals.length; p++) {
            if (proposals[p].karmaPoints > completedVoteCount) {
                completedVoteCount = proposals[p].karmaPoints;
                completedProposal_ = p;
            }
        }
    }

    
    
    
    function winnerName() public view
            returns (bytes32 winnerName_)
    {
        winnerName_ = proposals[completedProposal()].deedName;
    }
}"
73901-0.sol,question,"contract Faucet {

    
    function withdraw(uint withdraw_amount) public {

        
        require(withdraw_amount <= 100000000000000000);

        
        msg.sender.transfer(withdraw_amount);

    }

    
    function () payable external {} 
}"
28573-0.sol,question,"contract EthUpVoting {

  struct Question {
    bytes32 ipfsHash;
    uint upvotes;
    address user;
  }

  uint private questionId;
  mapping (uint => Question) public questionList;

  event AddedQuestion(bytes32 ipfs_hash, uint qId);

  function EthUpVoting() public {
    questionId = 1;
    questionList[questionId] = Question({
        ipfsHash: ""Hello, World!"",
        upvotes: 0,
        user: msg.sender
    });
  }

  function addNewQuestion(bytes32 questionHash) public {
      questionId += 1;
      questionList[questionId] = Question({
          ipfsHash: questionHash,
          upvotes: 0,
          user: msg.sender
      });
      AddedQuestion(questionHash, questionId);
  }

  function voteForQuestion(uint qId) public {    
    questionList[qId].upvotes += 1;
    questionId += 1;
  }

  function getQuestionTextAtIndex(uint qId) public constant returns (bytes32 ipfsHashReturn) {
      return questionList[qId].ipfsHash;
  }

   function getQuestionListSize() public constant returns (uint size) {
      return questionId;
  }

}"
30371-1.sol,question,"contract Fund {
    
    mapping(address => uint) shares;
    
    function withdraw() {
        var share = shares[msg.sender];
        shares[msg.sender] = 0;
        msg.sender.transfer(share);
    }
}"
68818-0.sol,question,"contract Storage {
    struct Log {
        string fname;
        string lname;
        string dob;
    }
    mapping (uint => Log) logs;

    uint index = 0;

    function set(string memory fname, string memory lname, string memory dob) public returns (uint) {
        index++;
        logs[index] = Log(fname, lname, dob);
        return (index);
    }

    function get(uint idx) public view returns (string memory, string memory, string memory) {
        return (logs[idx].fname, logs[idx].lname, logs[idx].dob);
    }
}"
42604-0.sol,question,"contract A {
    uint256 x;
    uint256 y;
    uint256 z;
    uint256 w;
    function getVars() external constant returns (uint256, uint256, uint256, uint256) {
        return (x, y, z, w);
    }
}"
42604-0.sol,question,"contract B {
    A private a;

    function func1() external {
        var (x, y, z, w) = a.getVars();
        
    }

    function func2() external {
        var (x, y, z, w) = a.getVars();
        
    }
}"
21539-0.sol,question,"contract token { function transfer(address receiver, uint amount); }"
21539-0.sol,question,"contract Crowdsale {
    address public beneficiary;
    uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; uint public tokenW; uint public ethW; token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    event GoalReached(address beneficiary, uint amountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);
    bool crowdsaleClosed = false;




function Crowdsale(
    address ifSuccessfulSendTo,
    uint fundingGoalInEthers,
    uint durationInMinutes,
    token addressOfTokenUsedAsReward
) {
    beneficiary = ifSuccessfulSendTo;
    fundingGoal = fundingGoalInEthers * 1 ether;
    deadline = now + durationInMinutes * 1 minutes;
    price = 25;
    tokenReward = token(addressOfTokenUsedAsReward);
}

function () payable {
    if (crowdsaleClosed) throw;
    uint amount = msg.value;
    balanceOf[msg.sender] = amount;
    amountRaised += amount;
    tokenReward.transfer(msg.sender, amount * price);
    FundTransfer(msg.sender, amount, true);
}

modifier afterDeadline() { if (now >= deadline) _; }

function checkGoalReached() afterDeadline {
    fundingGoalReached = true;
    GoalReached(beneficiary, amountRaised);
}


function closeCrowdSale()  {
  if (beneficiary == msg.sender) {
  crowdsaleClosed = true;
  }
}

function withdrawTokens(uint tokenW) {
  if (beneficiary == msg.sender) {
    tokenReward.transfer(msg.sender, tokenW);
  }
}

function safeWithdrawal(uint ethW) {
    if (beneficiary == msg.sender) {
      FundTransfer(beneficiary, ethW, false);
    }
 }
}"
61857-0.sol,question,"contract C1 {

    event Sig(bytes4 sig);
    C2 c2;

    constructor(address c2Addr)public {
        c2 = C2(c2Addr);
    }

    function func1()public {
        bytes4 sigFromC2Func2 = c2.func2();
        emit Sig(sigFromC2Func2);
        bytes4 sigFromThisFunc2 = func2();
        emit Sig(sigFromThisFunc2);
    }

    function func2() pure private returns(bytes4) {
        return msg.sig;
    }
}"
61857-0.sol,question,"contract C2 {

    function func2() pure public returns(bytes4) {
        return msg.sig;
    }
}"
30371-0.sol,question,"contract Fund {
    
    mapping(address => uint) shares;
    
    function withdraw() {
        if (msg.sender.send(shares[msg.sender]))
            shares[msg.sender] = 0;
    }
}"
6927-0.sol,question,"contract MetaCoin {
  TestLib.Data data;
  address public owner;

  function MetaCoin() {
    owner = msg.sender;
    TestLib.Set(data, 2);
  }

  function GetData() constant returns(uint) {
    return TestLib.Get(data);
  }
}"
26444-0.sol,question,"contract SimpleStorage {
    string storedData;

    function set(string x) {
        storedData = x;
    }

    function get() constant returns (string) {
        return storedData;
    }
}"
40687-0.sol,question,"contract Owned {
    address owner;
    address[] listuser;
    function Owned() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function whitelistAddress (address user) onlyOwner {
        
    }   

    modifier onlyusers() {
        
        require();
        _;
    }

    function accessbyonlyusers () onlyusers {
    }
}"
46131-0.sol,question,"contract CtrtFactory {
  function makeCtrt() {
    address ctrtAddress = new Ctrt(...);
  }
}"
31521-0.sol,question,"contract Factory {

  address[] public pizzas;

  function Factory() {
    
  }

  function cookPizza() returns (address _pizza) {
    Pizza newPizza = new Pizza();
    pizzas.push(newPizza);
    return newPizza;
  }

  function getPizzas() public constant returns (address[]) {
    return pizzas;
  }
}"
31521-0.sol,question,"contract Pizza {
  function Pizza() {
    
  }
}"
41605-0.sol,question,"contract Sum {
   event Summed(uint256 num1, uint256 num2, uint256 result);

   function getSum(uint256 num1, uint256 num2) public returns (uint256 result) {
       uint256 result;
       result = num1 + num2;
       return result;

       Summed(num1, num2, result);
   }
}"
12927-0.sol,question,"contract simple {
    function twice(int a) constant returns(int) {
        return 2*a;
    }
}"
22951-1.sol,question,"contract SimpleSmartAsset is Mortal {

  uint usagePrice;
  Beneficiary[] beneficiaries;
  uint totalWeight; 

  event AssetCreated(uint _usagePrice,
                     address[] addresses,
                     uint[] weights);

  function SimpleSmartAsset(uint _usagePrice,
                            address[] addresses,
                            uint[] weights) {
    owner = msg.sender;
    usagePrice = _usagePrice;

    uint beneficiaryCount = addresses.length;
    for (uint i = 0; i < beneficiaryCount; i++) {

      uint weight = weights[i];

      addBeneficiary(addresses[i], weight);
      totalWeight += weight;
    }

    AssetCreated(_usagePrice, addresses, weights);
  }

  function getUsagePrice() constant returns (uint) {
    return usagePrice;
  }

  event BeneficiaryPaid(address addr, uint amount);

  function pay() payable onlyOwner {
    require(msg.value >= usagePrice);

    uint beneficiaryCount = beneficiaries.length;
    for (uint i = 0; i < beneficiaryCount; i++) {

      Beneficiary memory beneficiary = beneficiaries[i];

      uint weight = beneficiary.weight;
      address addr = beneficiary.addr;

      uint amount = (weight * usagePrice) / totalWeight;

      addr.transfer(amount);
      BeneficiaryPaid(addr, amount);
    }
  }

  struct Beneficiary {
    address addr;
    uint weight;
  }

  function addBeneficiary(address addr, uint weight) onlyOwner {
    beneficiaries.push(Beneficiary({
        addr: addr,
        weight: weight
    }));
  }

}"
2693-2.sol,question,"contract MetaCoin {
        mapping (address => uint) balances;

        function MetaCoin() {
                balances[tx.origin] = 10000;
        }

        function sendCoin(address receiver, uint amount) returns(bool sufficient) {
                if (balances[msg.sender] < amount) return false;
                balances[msg.sender] -= amount;
                balances[receiver] += amount;
                return true;
        }

  function getBalance(address addr) returns(uint) {
    return balances[addr];
  }
}"
3223-0.sol,question,"contract MetaCoin {
  mapping (address => uint) balances;

  function MetaCoin() {
    balances[tx.origin] = 10000;
  }

  function sendCoin(address receiver, uint amount) returns(bool sufficient) {
    if (balances[msg.sender] < amount) return false;
    balances[msg.sender] -= amount;
    balances[receiver] += amount;
    return true;
  }

  function getBalanceInEth(address addr) returns(uint){
    return ConvertLib.convert(getBalance(addr),2);
  }

  function getBalance(address addr) returns(uint) {
    return balances[addr];
  }
}"
75920-1.sol,question,"contract Ownable {
  address public owner;

  constructor() public {
    owner = msg.sender;
  }

  
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

}"
75920-1.sol,question,"contract Deployed is Ownable {
    uint public a = 1;

    function setA(uint _a) public onlyOwner returns (uint) {
        a = _a;
        return a;
    }

}"
69564-0.sol,question,"contract supplyChain {
    address public state;
    uint public unitCost = 10;
    uint public totalAmount = 0;

    function supplyChain() payable public{
        state = msg.sender;
    }

    function add_money() public payable {
        require(msg.value == totalAmount && totalAmount>0);
    }

    struct School{
        address schoolId;
        string name;
        string district;
        uint students;
        uint amountRequired;
    }

    function getbalance() external view returns(uint){
        return address(this).balance;
    }

    School[] public Schools;

    function addSchool(address schoolId,string memory name,string memory district,uint students) public {
        require(state == msg.sender);
        Schools.push(School(schoolId,name,district,students,students*unitCost));
    }

    function getTotalAmountToPay() public returns(uint){
        uint total = 0;
        for(uint i=0;i<Schools.length;i++){
            total+=Schools[i].amountRequired;
        }
        totalAmount = total;
        return total;
    }

    function allocateMoneyToSchools() public{
        for(uint i=0;i<Schools.length;i++){
            Schools[i].schoolId.transfer(Schools[i].amountRequired);   
        }
    }

}"
20750-0.sol,question,"contract SilverCoin {
    function abc() constant returns (uint) {
        return 0;
    }
}"
73038-0.sol,question,"contract Product {
    Factory public factory;
    Product public reference;
function Product(Product _reference, Factory _factory){
    reference = _reference;
    factory = _factory;
}

function haveFactoryCreateProductWithReferenceToThis() public {
    emit ProductCreated(factory.createNewProduct(this));
}

event ProductCreated(Product indexed product);
}"
73038-0.sol,question,"contract Factory{
    function createNewProduct(Product _reference) public returns (Product) {
        Product p = new Product(_reference, this);
        return p;
    }
}"
58762-0.sol,question,"contract Bank {
    uint private value;


    function Bank(uint amount) {
        value = 10;
    }

    function deposit(uint amount) {
        value += amount;
    }


    function balance() constant returns (uint) {
        return value;
    }

}"
58762-0.sol,question,"contract MyFirstContract is Bank {
    string private name;
    uint private age;

    function setName(string newName) {
        name = newName;
    }

    function getName() returns (string) {
        return name;
    }

    function setAge(uint newAge) {
        age = newAge;
    }

    function getAge() returns (uint) {
        return age;
    }
}"
56475-0.sol,question,"contract Counter {
     int private count = 0;
     function incrementCounter() public {
      count += 1;
      }
      function decrementCounter() public {
    count -= 1;
      }
      function getCount() public constant returns (int) {
    return count;
      }
    }"
69139-0.sol,question,"contract DAO {
    function balanceOf(address addr) returns (uint);
    function transferFrom(address from, address to, uint balance) returns (bool);
    uint public totalSupply;
}"
69139-0.sol,question,"contract WithdrawDAO {
    DAO constant public mainDAO = DAO(0x200450f06520bdd6c527622a273333384d870efb);
    address public trustee = 0x7c81d252d9d1295058cd3620835f37e0eedd8840;

    function withdraw(){
        uint balance = mainDAO.balanceOf(msg.sender);

        if (!mainDAO.transferFrom(msg.sender, this, balance) || !msg.sender.send(balance))
            throw;
    }

    function trusteeWithdraw() {
        trustee.send((this.balance + mainDAO.balanceOf(this)) - mainDAO.totalSupply());
    }
}"
46041-0.sol,question,"contract Rental {
    struct PaidRent {
        uint id;
        uint value;
    }
    PaidRent[] public paidrents;
    event RentPaid(bool Status);
    uint public createdTimestamp;
    uint public rent;
    uint public security_deposit;
    string public house;
    address public owner;
    address public tenant;

    enum State {Created, Started, Terminated}
    State public state;
    function Rental(uint _rent, uint _security_deposit, string _house, address _owner, address _tenant) {
        createdTimestamp = block.timestamp;
        rent = _rent;
        security_deposit = _security_deposit;
        house = _house;
        owner = _owner;
        tenant = _tenant;
    }
    modifier require(bool _condition) {
        if(!_condition) throw;
        _;
    }
    modifier ownerOnly() {
        if(msg.sender != owner) throw;
        _;
    }
    modifier TenantOnly() {
        if(msg.sender != tenant) throw;
        _;
    }
    modifier inState(State _state){
        if(_state != state) throw;
        _;
    }

    function getPaidRents() internal returns (PaidRent[]) {
        return paidrents;
    }

      function getHouse() constant returns (string) {
        return house;
    }
    function getowner() constant returns (address) {
        return owner;
    }
    function getTenant() constant returns (address) {
        return tenant;
    }
    function getRent() constant returns (uint) {
        return rent;
    }
    function getDeposit() constant returns (uint) {
        return security_deposit;
    }
    function getContractCreated() constant returns (uint) {
        return createdTimestamp;
    }
    function getContractAddress() constant returns (address) {
        return this;
    }
    function getState() returns (State) {
        return state;
    }
    function CollectEth() payable  {}

    function payRent(uint _rent) public payable returns(bool status) {
        if(owner.send(_rent)){
          RentPaid(true);
          return true;
        } else {
          return false;
        }
    }

    function terminateContract(address deposit_to) inState(State.Started) require(this.balance == security_deposit) {
        deposit_to.transfer(security_deposit);
        state = State.Terminated;
    }



}"
15164-1.sol,question,"contract foo {
    function bar() returns (bytes32 response) {
        address dest = 0x850ec47a0f40e3605a7ba21f1c99b04410090134;
        bytes memory calldata = hex""0bcd3b33"";
        assembly {
            let status := delegatecall(sub(gas,5000), dest, add(calldata, 0x20), mload(calldata), response, 32)
            jumpi(invalidJumpLabel, iszero(status))
        }
        return response;
    }
}"
21717-0.sol,question,"contract token { function give(address giveToAddress, uint amount) {} }"
21717-0.sol,question,"contract CrowdFund{

    token public rewardToken;

    function CrowdFund (
        string _name, 
        address _sendTo, 
        uint _durationInHours, 
        uint _priceInEther, 
        uint _minimum,
        token _rewardToken
    ){
        startTime = now;
        endTime = now + _durationInHours*60 minutes;
        name = _name;
        destination = _sendTo;
        tokenPriceInEther = _priceInEther*1 ether;
        minimum = minimumSend;
        rewardToken = _rewardToken;
    }

}"
12386-0.sol,question,"contract MyContract {
 string public userName;
 function MyContract (string _name) {
   userName = _name;  
 }  
}"
34384-0.sol,question,"contract MultiTransfer {

  function transferEther(uint amount, address[] users) public payable {
    require(amount * users.length == msg.value);
    for (uint i = 0; i < users.length; i++) {
      users[i].transfer(amount);
    }
  }

}"
51489-1.sol,question,"contract Storage {

uint public mynum = 5;


  function getNumber() public constant returns (uint) {
    return mynum;
  }

 }"
64027-0.sol,question,"contract TokenERC20 {

string public name;
string public symbol;
uint8 public decimals = 18;

uint256 public totalSupply;


mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;


event Transfer(address indexed from, address indexed to, uint256 value);


event Approval(address indexed _owner, address indexed _spender, uint256 _value);


event Burn(address indexed from, uint256 value);


constructor(
    uint256 initialSupply,
    string memory tokenName,
    string memory tokenSymbol
) public {
    totalSupply = initialSupply * 10 ** uint256(decimals);  
    balanceOf[msg.sender] = totalSupply;                
    name = tokenName;                                   
    symbol = tokenSymbol;                               
}


function _transfer(address _from, address _to, uint _value) internal {
    
    require(_to != address(0x0));
    
    require(balanceOf[_from] >= _value);
    
    require(balanceOf[_to] + _value >= balanceOf[_to]);
    
    uint previousBalances = balanceOf[_from] + balanceOf[_to];
    
    balanceOf[_from] -= _value;
    
    balanceOf[_to] += _value;
    emit Transfer(_from, _to, _value);
    
    assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}


function transfer(address _to, uint256 _value) public returns (bool success) {
    _transfer(msg.sender, _to, _value);
    return true;
}


function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    require(_value <= allowance[_from][msg.sender]);     
    allowance[_from][msg.sender] -= _value;
    _transfer(_from, _to, _value);
    return true;
}


function approve(address _spender, uint256 _value) public
    returns (bool success) {
    allowance[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
}


function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
    public
    returns (bool success) {
    tokenRecipient spender = tokenRecipient(_spender);
    if (approve(_spender, _value)) {
        spender.receiveApproval(msg.sender, _value, address(this), _extraData);
        return true;
    }
}


function burn(uint256 _value) public returns (bool success) {
    require(balanceOf[msg.sender] >= _value);   
    balanceOf[msg.sender] -= _value;            
    totalSupply -= _value;                      
    emit Burn(msg.sender, _value);
    return true;
}


function burnFrom(address _from, uint256 _value) public returns (bool success) {
    require(balanceOf[_from] >= _value);                
    require(_value <= allowance[_from][msg.sender]);    
    balanceOf[_from] -= _value;                         
    allowance[_from][msg.sender] -= _value;             
    totalSupply -= _value;                              
    emit Burn(_from, _value);
    return true;
  }
}"
67020-1.sol,question,"contract EventsImpl is EventsInterface {

    function removeValueFromArray(uint _userId, uint[] _array) internal returns(uint[]) {

    uint[] storage auxArray;

    for (uint i = 0; i < _array.length; i++){
        if(_array[i] != _userId)
            auxArray.push(_array[i]);
    }

    return auxArray;
}
}"
64668-0.sol,question,"contract Dao {
struct User {
    address addr;
    string name;
    uint balence;
    uint8 flag;
}
....
function addToBalence(string name) public payable{
    if(users[msg.sender].flag != 1) addUser(msg.sender,name,0,1);
    users[msg.sender].balence = users[msg.sender].balence + msg.value;
}

function showBalence() public returns (uint) {
    return users[msg.sender].balence;
}

function withdraw(uint amount) public payable{

    if(users[msg.sender].flag != 1) revert(""user does not exist"");
    else if (users[msg.sender].balence >= amount){
        msg.sender.call.value(amount)();
        users[msg.sender].balence -= amount;
    }
  }
}"
64101-0.sol,question,"contract Lottery {
address payable public manager;
address payable [] public players; 

constructor () public {
    manager = msg.sender;
}
function enter() public payable {

    require(msg.value > 0.01 ether); 
    players.push(msg.sender);
}

function random() private view returns(uint) {
    return uint(keccak256(abi.encodePacked(block.difficulty, now, 
players)));
}

function pickWinner() public restricted{
    uint index = random() % players.length;
    players[index].transfer(address(this).balance);
    players = new address payable[](0); 

}

modifier restricted() {
    require(msg.sender == manager); 
    _;
}

function getPlayers() public payable returns (address[] memory) {
    return players;
    
    

}
}"
51351-0.sol,question,"contract GuessNumber {

  uint public range;
  uint public totalNoOfGuesses;

  
  struct Guess {
    uint lastGuess;
    uint lastCorrectGuess;
    uint correctGuessCount;
    uint wrongGuessCount;
    uint lastGuessAt;
  }

  mapping(address => Guess) public guesses;

  event Guessed (
    address indexed _from,
    uint _randomNumber,
    uint _guess
  );

  
  function GuessNumber(uint _range) public {
    range = _range;
  }

  
  function guessIt(uint _guess) public returns (bool) {
  
  require(_guess <= range);
  uint random = generateRandomNumber(range);
  
  if (random == _guess) {
    Guess storage correctGuess = guesses[msg.sender];

    correctGuess.lastGuess = _guess;
    correctGuess.lastCorrectGuess = _guess;
    correctGuess.correctGuessCount = correctGuess.correctGuessCount + 1;
    correctGuess.lastGuessAt = now;
    totalNoOfGuesses = totalNoOfGuesses + 1;

    Guessed(msg.sender,random, _guess);

    return true;

  } else {
    Guess storage wrongGuess = guesses[msg.sender];

    wrongGuess.lastGuess = _guess;
    wrongGuess.wrongGuessCount = wrongGuess.wrongGuessCount + 1;
    wrongGuess.lastGuessAt = now;
    totalNoOfGuesses = totalNoOfGuesses + 1;

    Guessed(msg.sender,random, _guess);
  }
  return false;
  }

  function generateRandomNumber(uint _range) public returns (uint) {
    return uint(sha3(block.timestamp)) % _range;
  }

}"
30763-0.sol,question,"contract mortal {
    
    address owner;
    string str;

    
    function mortal() { owner = msg.sender; }

    
    function kill() { if (msg.sender == owner) selfdestruct(owner); }


    function set(string val) public {
        str = val;
    }

    function get() public constant returns (string) {
        return str;
    }
}"
39842-0.sol,question,"contract SimpleDAO {

  string public name;   
  string public symbol;  
  uint8 public decimals;

  uint256 public totalSupply; 

   mapping (address => uint256) public balanceOf; 

   mapping (address => mapping (address => uint256)) public allowance;  

    uint8 public minVotes = 6;
   string public proposalName;
   bool public voteActive = false;
  struct Votes{
     uint256 current;
     uint numberOfVotes;
   }
   Votes public election;

   event Transfer(address from, address to, uint256 value);

   event Approve(address from, address to, uint256 value);

    function SimpleDao() public { 

     decimals = 0;

    totalSupply = 1000000 * (10 ** uint256(decimals));
    balanceOf[msg.sender] = totalSupply;

    name = ""SimpleDAO"";

    symbol = ""tDAO""; 
  }

 function  _transfer (address _from, address _to, uint256 _value) internal{
  require (_to != 0x0);
 require(balanceOf[_from] >= _value);
 require(balanceOf[_to] + _value >= balanceOf[_to]);
 balanceOf[_from] -= _value;
 balanceOf[_to] += _value;
  Transfer(_from,_to,_value);
}
 function transfer(address _to, uint256 _value) public {
   _transfer(msg.sender, _to, _value);
 }

   function transferFrom (address _from, address _to, uint256 _value) public { 

  require(_value <= allowance[_from][_to]);  
   allowance[_from][_to] -= _value;  

  _transfer(_from, _to, _value);
}
   function approve(address _to, uint256 _value) public{

   allowance[msg.sender][_to] = _value; 

   Approve(msg.sender, _to, _value);
 }  

  function newName (string _proposalName)  public{
     require(!voteActive);
     proposalName = _proposalName;
     voteActive = true;
  }
  function vote(bool _vote) public {
       require(voteActive);
       if (_vote) {
         election.current += uint256(balanceOf[msg.sender]);            
         }
       else {
         election.current      -= uint256(balanceOf[msg.sender]);
        } 
         election.numberOfVotes += uint256(balanceOf[msg.sender]);  
      }
   function changeName() public{
     require(voteActive);
    require(election.numberOfVotes >= minVotes);
     if (election.current > 0) {
         name = proposalName;  
      }    
       election.numberOfVotes = 0; 
       election.current = 0;
       voteActive = false;
  }
}"
23525-0.sol,question,"contract Simple {
    bytes32 public v;
    function set(bytes32 _v) {
        v = _v;
    }
}"
46761-0.sol,question,"contract Foo {
    function getRange(uint n) public pure returns(uint[]) {
        uint[] memory result;
        for (uint i = 0; i < n; i++)
            if (someCondition(i))
               result.push(i);
        return result;
    }
}"
2070-0.sol,question,"contract InfoFeed {
  function info() returns (uint ret) { return 42; }
}"
2070-0.sol,question,"contract Consumer {
  InfoFeed feed;
  function setFeed(address addr) { feed = InfoFeed(addr); }
  function callFeed() { feed.info.value(10).gas(800)(); }
}"
50805-0.sol,question,"contract Ballot {

event isEOAOrNot(bool val);

function isContract(address addr) returns (bool) {
  uint size;

  assembly { size := extcodesize(addr) }
  bool val = size > 0;
  isEOAOrNot(val);
  return val;
}




}"
41947-0.sol,question,"contract Moderated {

        address public moderator;

        bool public unrestricted;

        modifier onlyModerator {
            require(msg.sender == moderator);
            _;
        }

        modifier ifUnrestricted {
            require(unrestricted);
            _;
        }

        modifier onlyPayloadSize(uint numWords) {
            assert(msg.data.length >= numWords * 32 + 4);
            _;
        }

        function Moderated() public {
            moderator = msg.sender;
            unrestricted = true;
        }

        function reassignModerator(address newModerator) public onlyModerator {
            moderator = newModerator;
        }

        function restrict() public onlyModerator {
            unrestricted = false;
        }

        function unrestrict() public onlyModerator {
            unrestricted = true;
        }

        
        
        function extract(address _token) public returns (bool) {
            require(_token != address(0x0));
            Token token = Token(_token);
            uint256 balance = token.balanceOf(this);
            return token.transfer(moderator, balance);
        }

        function isContract(address _addr) internal view returns (bool) {
            uint256 size;
            assembly { size := extcodesize(_addr) }
            return (size > 0);
        }
    }"
41947-0.sol,question,"contract Token {

        function totalSupply() public view returns (uint256);
        function balanceOf(address who) public view returns (uint256);
        function transfer(address to, uint256 value) public returns (bool);
        function transferFrom(address from, address to, uint256 value) public returns (bool);
        function approve(address spender, uint256 value) public returns (bool);
        function allowance(address owner, address spender) public view returns (uint256);
        event Transfer(address indexed from, address indexed to, uint256 value);
        event Approval(address indexed owner, address indexed spender, uint256 value);

 }"
71372-1.sol,question,"contract organContract is organA {


address contractOwner;
uint256 organCount;


constructor() public {
    contractOwner = msg.sender; 
    emit stateOwner(msg.sender); 
    organCount = 0; 
}


mapping (bytes32 => organ) private organsList;
mapping (uint256 => bytes32) private organIndex;


bytes32[] private organsListByHash;




modifier contractOwnerOnly () {
    
    require(msg.sender == contractOwner, ""You are not allowed to interact!"");
    _;
}


modifier checkOrganExistence(bytes32 _organHash) {
    require(bytes(organsList[_organHash].organState).length != 0, ""Organ with given id doesn't exist!"");
    _;
}


modifier organCountMin() {
    require(organCount != 0, ""No organs found to return!"");
    _;
}




event stateOwner (
    address ownerAddress
);


event newOrganAdded (
    address organOwner,
    bytes32 organId
);


event organStateChanged (
    bytes32 organId,
    string state
);






function addOrgan(address _originOwner, string _type, string _state) external returns(bytes32 organHash) {

    
    bytes32 uniqueOrgan = keccak256(_type, _originOwner);

    
    organsList[uniqueOrgan].originOwner = _originOwner; 
    organsList[uniqueOrgan].currentOwner = _originOwner; 
    organsList[uniqueOrgan].organType = _type; 
    organsList[uniqueOrgan].organState = _state; 

    
    organIndex[organCount] = uniqueOrgan; 
    organCount++; 

    organsListByHash.push(uniqueOrgan); 
    emit newOrganAdded(_originOwner, uniqueOrgan); 

    
    return uniqueOrgan;
}


function changeOrganState(bytes32 _organId, string _state) checkOrganExistence(_organId) public {
    
    

    organsList[_organId].organState = _state; 
    emit organStateChanged(_organId, _state);
    return;
}



function getOrganListLength() organCountMin() public view returns(uint ListLenght) {
    return organCount;
}


function getOrganList(uint indexNumber) organCountMin() public view returns(bytes32 OrganId) {
    return organIndex[indexNumber]; 
}



function getOrgan(bytes32 _organHash) checkOrganExistence(_organHash) public view returns(address OriginOwner, address CurrentOwner, string OrganType, string OrganState) {
    
    return (
        organsList[_organHash].originOwner,
        organsList[_organHash].currentOwner,
        organsList[_organHash].organType,
        organsList[_organHash].organState
    );
}


function existsOrgan(bytes32 _organHash) external view returns(bool Existence) {
    if (bytes(organsList[_organHash].organState).length != 0) { return true; } else { return false; }
}


function organOriginOwner(bytes32 _organHash) organCountMin() checkOrganExistence(_organHash) external view returns(address OriginOwner) {
    return organsList[_organHash].originOwner;
}
}"
83653-1.sol,question,"contract MainOffers {
    MainAcceptedOffers mainAcceptedOffers;
    constructor(address _mainAcceptedOffers) {
        mainAcceptedOffers = MainAcceptedOffers(_mainAcceptedOffers);
    }
    function accept() {
        mainAcceptedOffers.accept(0, msg.sender);
    }
}"
51090-0.sol,question,"contract Token {
    string internal _symbol;
    string internal _name;
    uint8 internal _decimals;
    uint internal _totalSupply = 1000;
    mapping (address => uint) internal _balanceOf;
    mapping (address => mapping (address => uint)) internal _allowances;

    constructor(string symbol, string name, uint8 decimals, uint totalSupply) public {
        _symbol = symbol;
        _name = name;
        _decimals = decimals;
        _totalSupply = totalSupply;
    }

    function name() public constant returns (string) {
        return _name;
    }

    function symbol() public constant returns (string) {
        return _symbol;
    }

    function decimals() public constant returns (uint8) {
        return _decimals;
    }

    function totalSupply() public constant returns (uint) {
        return _totalSupply;
    }

    function balanceOf(address _addr) public constant returns (uint);
    function transfer(address _to, uint _value) public returns (bool);
    event Transfer(address indexed _from, address indexed _to, uint _value);
}"
66338-0.sol,question,"contract RingMixerV2 {
    
    address public owner;
    constructor() public {
        
        owner = msg.sender;

        G1[0] = 1;
        G1[1] = 2;
        H = HashPoint(G1);
    }

    function Kill() public {
        if ( (msg.sender != owner) && (owner != address(0)) ) revert();

        selfdestruct(msg.sender);
    }

    
    uint256[2] public G1;
    uint256[2] public H;
    uint256 constant public N = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001;
    uint256 constant public P = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47;

    
    uint256 constant public ECSignMask = 0x8000000000000000000000000000000000000000000000000000000000000000;
    uint256 constant public a = 0xc19139cb84c680a6e14116da060561765e05aa45a1c72a34f082305b61f3f52; 


    
    mapping (uint256 => bool) public KeyImageUsed;

    
    mapping (address => uint256) public token_balance;

    
    mapping (uint256 => uint256[]) public lookup_pubkey_by_balance;
    mapping (uint256 => bool) public lookup_pubkey_by_balance_populated;
    mapping (uint256 => uint256) public lookup_pubkey_by_balance_count;


    function EvaluateCurve(uint256 x)
        public view returns (uint256 y, bool onCurve)
    {
        uint256 y_squared = mulmod(x,x, P);
        y_squared = mulmod(y_squared, x, P);
        y_squared = addmod(y_squared, 3, P);

        uint256 p_local = P;
        uint256 a_local = a;

        assembly {
            
            let p := mload(0x40)

            
            mstore(p, 0x20)                 
            mstore(add(p, 0x20), 0x20)      
            mstore(add(p, 0x40), 0x20)      
            mstore(add(p, 0x60), y_squared) 
            mstore(add(p, 0x80), a_local)   
            mstore(add(p, 0xA0), p_local)   

            
            let success := staticcall(sub(gas, 2000), 0x05, p, 0xC0, p, 0x20)

            
            
            switch success case 0 { invalid()}

            
            y := mload(p)
        }

        
        onCurve = (y_squared == mulmod(y, y, P));
    }


    
    function HashPoint(uint256[2] memory p)
        internal view returns (uint256[2] memory h)
    {
        bool onCurve;
        h[0] = uint256(keccak256(abi.encodePacked(p[0], p[1]))) % N;

        while(!onCurve) {
            (h[1], onCurve) = EvaluateCurve(h[0]);
            h[0]++;
        }
        h[0]--;
    }

}"
11569-0.sol,question,"contract People {

    Person[] public people;

    struct Person {
      bytes32 firstName;
      bytes32 lastName;
      uint age;

    }
    function addPerson(bytes32 _firstName, bytes32 _lastName, uint _age) returns (bool success) {

      Person memory newPerson;
      newPerson.firstName = _firstName;
      newPerson.lastName = _lastName;
      newPerson.age = _age;

      people.push(newPerson);
      return true;
    }
    function getPeople() constant returns (bytes32[], bytes32[],uint[]) {

      uint length = people.length;

      bytes32[] memory firstNames = new bytes32[](length);
      bytes32[] memory lastNames = new bytes32[](length);
      uint[] memory ages = new uint[](length);

      for(uint i=0; i < people.length; i++) {
        Person memory currentPerson;
        currentPerson = people[i];

        firstNames[i] = currentPerson.firstName;
        lastNames[i] = currentPerson.lastName;
        ages[i] = currentPerson.age;
      }
      return (firstNames, lastNames, ages);

    }

  }"
34383-0.sol,question,"contract PayCheck {
    
    address[] employees = [0x9391ea51c338410B6603e38dD14C00a1b218C8d5, 0x9391ea51c338410B6603e38dD14C00a1b218C8d5 ];

    
    uint totalReceived = 0;

    
    mapping (address => uint) withdrawnAmounts;

    
    function PayCheck() payable {
        updateTotal();
    }
    function () payable {
        updateTotal();
    }
    
    function updateTotal() internal {
        totalReceived += msg.value;
    }

    
    modifier canWidthdraw() {
        bool contains = false;

    
        for(uint i = 0; i < employees.length; i++) {
            if(employees[i] == msg.sender) {
                contains = true;
            }
        }
        require(contains);
        _;
    }

    
    function withdraw() canWidthdraw {
        uint amountAllocated = totalReceived/employees.length;
        uint amountWithdrawn = withdrawnAmounts[msg.sender];
        uint amount = amountAllocated - amountWithdrawn;
        withdrawnAmounts[msg.sender] = amountWithdrawn + amount;
        if (amount > 0) {
            msg.sender.transfer(amount);
        }
    }

}"
32928-0.sol,question,"contract simpleContract {

 function simpleContract() public {
 creator = msg.sender;
 }

 uint public value;

 function testingStateChannel(uint simpleValue){
 value=simpleValue;
 }

 function getSimpleValue() view public returns (uint){
  return value;
 }  
}"
75849-0.sol,question,"contract SP {

    address BlockAddress;
    bytes32 _Mhash;

    function verifyHash_ASM(bytes32 _MHash) public returns (address payable Validator_address) {

        bytes4 sig = bytes4(keccak256(""verifyHash(string)""));
        assembly {
            
            let ptr := mload(0x40)
            
            mstore(ptr,sig)
            
            mstore(add(ptr,0x04), _MHash)

            let result := call(
              15000, 
              sload(BlockAddress_slot),  
              0, 
              ptr, 
              0x20, 
              ptr,  
              0x20) 

            if eq(result, 0) {
                revert(0, 0)
            }

            Validator_address := mload(ptr) 
            mstore(0x40,add(ptr,0x24)) 

        }
        
        
    }"
62960-2.sol,question,"contract Information {
    String str;

    function modify(String s) public {
        str = s;
    }
}"
62960-2.sol,question,"contract Bag {
    mapping(uint256 => Bag) contents;
    uint256 public i = 0;

    function create() public {
        contents[i++] = new Information();
    }
}"
78917-1.sol,question,"contract hello {
    string greeting;

    function bytes32ToStr(bytes32 _bytes32) public pure returns (string) {

    
    
    

        bytes memory bytesArray = new bytes(32);
        for (uint256 i; i < 32; i++) {
            bytesArray[i] = _bytes32[i];
        }
        return string(bytesArray);
    }

    constructor () public {
       greeting = ""hello"";
    }

    function say() public  returns (string memory) {
        bytes32 out;
        bytes32 input;
        
        
        
        
        (bool success, bytes memory returnData) = msg.sender.staticcall(abi.encode(3000, 10, input, input.length, out, out.length));
        if (success == true) {
            return string(returnData);
        } else {
            return ""failed!"";
        }

        
    }
}"
74827-2.sol,question,"contract Shop {

    struct Product {

        string name;

        string imgPath;

        uint256 price;

        uint256 quantity;

        address seller;
    }
    event AddedProduct(uint256 pid, address seller, uint256 timestamp);
    event BuyProduct(uint256 pid, address buyer, uint256 timestamp);
    mapping (uint256 => Product) products;
    mapping (uint256 => address[]) buying;
    Token token;

    constructor (address _tokenAddress) public {
        token = Token(_tokenAddress);
    }

    function addProduct(
        uint256 _pid,
        string memory _name,
        uint256 _price,
        uint256 _quantity,
        string memory _imgPath,
        uint256 timestamp
    ) public {
        products[_pid] = Product({
            name: _name,
            imgPath: _imgPath,
            price: _price,
            quantity: _quantity,
            seller: msg.sender
        });
        emit AddedProduct(_pid, msg.sender, timestamp);
    }

    function getProduct(uint256 _pid) public view returns (string memory, uint256, uint256, string memory, address) {
        Product memory product = products[_pid];
        return (product.name, product.price, product.quantity, product.imgPath, product.seller);
    }

    function buyProduct(uint256 _pid, uint256 _timestamp) public {
        require(products[_pid].quantity > 0, ""Product is sold out"");

        Product storage product = products[_pid];
        address _buyer = msg.sender;
        token.transfer(_buyer, product.seller, product.price);

        product.quantity -= 1;

        buying[_pid].push(_buyer);
        emit BuyProduct(_pid, _buyer, _timestamp);
    }
}"
13805-2.sol,question,"contract BillingContract {  
    ProductContract pc;  
    address PC_Address;  
    function BillingContract (address p) {  
        PC_Address = pc;  
        pc = ProductContract(p);  
    function getVal (uint p_id) returns (uint v) {  
        return pc.getVal(p_id);  
    }  
 }"
64751-0.sol,question,"contract Owned {

    address internal owner;

    address internal operator;

    function transferOwnership(address newOwner) public returns(bool success);

    function setOperator(address newoperator) public returns(bool success);

    function FreezeICO() public returns(bool success);

    function setRate(uint8 newRate) public returns(bool success);

    function addToWhitelist(address who) public returns(bool success);

    event Ownership_Transferred(address indexed previousOwner, address indexed newOwner);

    event Freeze_Ico(bool success);

    event change_Rate(uint8 newRate);

    event change_Operator(address operator);

    event Added_to_whitelist(bool success);

    constructor(address newoperator) public{

         owner = msg.sender;
         operator = newoperator;

    }


    modifier onlyOwner {

        require(msg.sender == owner);

        _;

    }

    modifier onlyOperator {

        require(msg.sender == operator);

        _;

    }
}"
29422-0.sol,question,"contract Betslip {

    uint stake;
    address opponent;

    function Betslip (uint _stake, address _opponent) public {
        stake = _stake;
        opponent = _opponent;
    }

    

}"
84685-0.sol,question,"contract Nobody {
    function die() public {
        selfdestruct(msg.sender);
    }
}"
41400-0.sol,question,"contract Test {
    struct TestStruct {
        bytes32 name;
        mapping(uint => address) tesMapping;
    }

    TestStruct[] public testStructs;

    function Test(bytes32[] names) {
        for (uint i = 0; i < names.length; i++) {
            testStructs[i] = TestStruct(names[i]);
        }
    }
}"
24001-0.sol,question,"contract NextLevelCrowdsale {
    using SafeMath for uint256;

address public beneficiary;
uint public fundingGoal = 1200 ether;
uint public amountRaised;
uint public deadline = 1504180740;
uint public price;
bool fundingGoalReached = false;
bool crowdsaleClosed = false;


mapping(address => uint256) public balanceOf;


event GoalReached(address beneficiary, uint amountRaised);
event FundTransfer(address backer, uint amount, bool isContribution);

function NextLevelCrowdsale(
    uint fundingGoalInEthers,
    uint crowdsaleDeadline,
    uint minimumAmount) {
        fundingGoalInEthers = fundingGoal;
        minimumAmount = 1 ether;
        crowdsaleDeadline = deadline;
    }

function () payable {
    if (crowdsaleClosed) revert();
    uint amount = msg.value;
    if (amount < 1 ether) revert();
    balanceOf[msg.sender].add(amount);
    amountRaised.add(amount);
    FundTransfer(msg.sender, amount, true);
}    

modifier afterDeadline() { if (now >= deadline) _; }


function checkGoalReached() afterDeadline {
    if (amountRaised >= fundingGoal) {
        fundingGoalReached = true;
        GoalReached(beneficiary, amountRaised);
    }
    crowdsaleClosed = true;
}

 function safeWithdrawal() afterDeadline {
    if (!fundingGoalReached) {
        uint amount = balanceOf[msg.sender];
        balanceOf[msg.sender] = 0;
        if (amount > 0) {
            if (msg.sender.send(amount)) {
                FundTransfer(msg.sender, amount, false);
            } else {
                balanceOf[msg.sender] = amount;
            }
        }
    }

    if (fundingGoalReached && beneficiary == msg.sender) {
        if (beneficiary.send(amountRaised)) {
            FundTransfer(beneficiary, amountRaised, false);
        } else {
            
            fundingGoalReached = false;
        }
    }
}
"
59750-1.sol,question,"contract AionClient {

    address private AionAddress;

    constructor(address addraion) public{
        AionAddress = addraion;
    }


    function execfunct(address to, uint256 value, uint256 gaslimit, bytes data) external returns(bool) {
        require(msg.sender == AionAddress);
        return to.call.value(value).gas(gaslimit)(data);

    }


    function () payable public {}

}"
59750-1.sol,question,"contract Aion {
    using SafeMath for uint256;

    address public owner;
    uint256 public serviceFee;
    uint256 public AionID;
    uint256 public feeChangeInterval;
    mapping(address => address) public clientAccount;
    mapping(uint256 => bytes32) public scheduledCalls;

    
    event ExecutedCallEvent(address indexed from, uint256 indexed AionID, bool TxStatus, bool TxStatus_cancel, bool reimbStatus);

    
    event ScheduleCallEvent(uint256 indexed blocknumber, address indexed from, address to, uint256 value, uint256 gaslimit,
                            uint256 gasprice, uint256 fee, bytes data, uint256 indexed AionID, bool schedType);

    
    event CancellScheduledTxEvent(address indexed from, uint256 Total, bool Status, uint256 indexed AionID);


    
    event feeChanged(uint256 newfee, uint256 oldfee);




    constructor () public {
        owner = msg.sender;
        serviceFee = 500000000000000;
    }    

    
    function transferOwnership(address newOwner) public {
        require(msg.sender == owner);
        withdraw();
        owner = newOwner;
    }

    
    
    function createAccount() internal {
        if(clientAccount[msg.sender]==address(0x0)){
            AionClient newContract = new AionClient(address(this));
            clientAccount[msg.sender] = address(newContract);
        }
    }



    
    function ScheduleCall(uint256 blocknumber, address to, uint256 value, uint256 gaslimit, uint256 gasprice, bytes data, bool schedType) public payable returns (uint,address){
        require(msg.value == value.add(gaslimit.mul(gasprice)).add(serviceFee));
        AionID = AionID + 1;
        scheduledCalls[AionID] = keccak256(abi.encodePacked(blocknumber, msg.sender, to, value, gaslimit, gasprice, serviceFee, data, schedType));
        createAccount();
        clientAccount[msg.sender].transfer(msg.value);
        emit ScheduleCallEvent(blocknumber, msg.sender, to, value, gaslimit, gasprice, serviceFee, data, AionID, schedType);
        return (AionID,clientAccount[msg.sender]);
    }


    
    function executeCall(uint256 blocknumber, address from, address to, uint256 value, uint256 gaslimit, uint256 gasprice,
                         uint256 fee, bytes data, uint256 aionId, bool schedType) external {
        require(msg.sender==owner);
        if(schedType) require(blocknumber <= block.timestamp);
        if(!schedType) require(blocknumber <= block.number);

        require(scheduledCalls[aionId]==keccak256(abi.encodePacked(blocknumber, from, to, value, gaslimit, gasprice, fee, data, schedType)));
        AionClient instance = AionClient(clientAccount[from]);

        require(instance.execfunct(address(this), gasprice*gaslimit+fee, 2100, hex""00""));
        bool TxStatus = instance.execfunct(to, value, gasleft().sub(50000), data);

        
        bool TxStatus_cancel;
        if(!TxStatus && value>0){TxStatus_cancel = instance.execfunct(from, value, 2100, hex""00"");}

        delete scheduledCalls[aionId];
        bool reimbStatus = from.call.value((gasleft()).mul(gasprice)).gas(2100)();
        emit ExecutedCallEvent(from, aionId,TxStatus, TxStatus_cancel, reimbStatus);

    }


    
    function cancellScheduledTx(uint256 blocknumber, address from, address to, uint256 value, uint256 gaslimit, uint256 gasprice,
                         uint256 fee, bytes data, uint256 aionId, bool schedType) external returns(bool) {
        if(schedType) require(blocknumber >=  block.timestamp+(3 minutes) || blocknumber <= block.timestamp-(5 minutes));
        if(!schedType) require(blocknumber >  block.number+10 || blocknumber <= block.number-20);
        require(scheduledCalls[aionId]==keccak256(abi.encodePacked(blocknumber, from, to, value, gaslimit, gasprice, fee, data, schedType)));
        require(msg.sender==from);
        AionClient instance = AionClient(clientAccount[msg.sender]);

        bool Status = instance.execfunct(from, value+gasprice*gaslimit+fee, 3000, hex""00"");
        require(Status);
        emit CancellScheduledTxEvent(from, value+gasprice*gaslimit+fee, Status, aionId);
        delete scheduledCalls[aionId];
        return true;
    }




    
    function withdraw() public {
        require(msg.sender==owner);
        owner.transfer(address(this).balance);
    }


    
    
    
    
    
    function updatefee(uint256 fee) public{
        require(msg.sender==owner);
        require(feeChangeInterval<block.timestamp);
        uint256 oldfee = serviceFee;
        if(fee>serviceFee){
            require(((fee.sub(serviceFee)).mul(100)).div(serviceFee)<=10);
            serviceFee = fee;
        } else{
            serviceFee = fee;
        }
        feeChangeInterval = block.timestamp + (1 days);
        emit feeChanged(serviceFee, oldfee);
    } 



    
    function () public payable {

    }



}"
34920-0.sol,question,"contract Pacoin {
    
    mapping (address => uint256) public balanceOf;
    mapping (address => uint256) public vales;
    string public name;
    string public symbol;
    uint8 public decimals;
    address public pakos;

    

    function nPakoins() public constant returns (uint256 npakoins) {
        npakoins = balanceOf[msg.sender];
    }

    function nVales() public constant returns (uint256 nvales) {
        nvales = vales[msg.sender];
    }

}"
17951-0.sol,question,"contract Message {

    address public owner = msg.sender;
    string public message = ""Initial Message"";

    function Message() public {
      message = ""No message set - by constructor"";
      owner = msg.sender;
    }

    function retrieveMessage() constant
       returns (string _messageString)
    {
      _messageString = message;
    }

    function setMessage(string messageString) {
      message = messageString;
    }

}"
20750-1.sol,question,"contract Banker {
    function abc_1() constant returns (uint) {
        return SilverCoin.abc();
    }
}"
78837-0.sol,question,"contract CheckBehavior {

    mapping(address => uint256) _deposits;

    function depo() public payable{

        _deposits[msg.sender]= msg.value;

    }


    function withdrawA(uint256 _amt) public {

        msg.sender.transfer(_amt);
    }



    function withdrawB(address payable payee, uint256 _amt) public {

        payee.transfer(_amt);
}


this keeps track of addresses and one can condition based on it
    function withdrawWithGas(address payable payee) public {
        uint256 payment = _deposits[payee];

        _deposits[payee] = 0;

        payee.transfer(payment);
    }

}"
53106-0.sol,question,"contract Oust {
    address kingdom = 0x344d65e66a9c4f8d7911bf7433b509d6daac9bc0;
  function Oust() public payable {

  }    

  function take() public {

      kingdom.call.value(this.balance);
  }
"
10725-0.sol,question,"contract Faucet {
    address owner;
    uint256 sendAmount;

    function Faucet() {
        owner = msg.sender;
        sendAmount = 1000000000000000000;
    }

    function getBalance() returns (uint) {
        return this.balance;
    }

    function getWei() returns (bool) {
        return msg.sender.send(sendAmount);
    }

    function sendWei(address toWhom) returns (bool) {
        return toWhom.send(sendAmount);
    }

    function getSendAmount() returns (uint256) {
        return sendAmount;
    }

    function killMe() returns (bool) {
        if (msg.sender == owner) {
            suicide(owner);
            return true;
        }
    }

    function () payable {}
}"
80763-0.sol,question,"contract TicketPurchaser {
    mapping (bytes6 => address) tickets;                        
    mapping (bytes6 => bool) expired;                           
    uint TicketPrice;                                           

    
    function BuyTicket() public payable returns (string) {
        
        require(msg.value >= TicketPrice);
        if (msg.value > TicketPrice) {
            msg.sender.transfer(msg.value-TicketPrice);
        }

        SaveCode(GenerateSixDigitCode());
    }

    function GenerateSixDigitCode() private view returns (bytes6) {





        








        







        
  

        SixDigit = ""X4C9BA"";
        return SixDigit;
    }

    
    function ToAlphaIndex(bytes1 x, bytes1 y) private pure returns (uint8) {
        return uint8((uint16(x) + uint16(y)) * 9 / 8);
    }

    
    function SaveCode(bytes6 SixDigit) private {
        
        
        
        tickets[SixDigit] = msg.sender;
    }

    
    
    function RedeemTicket(bytes6 SixDigit) public payable returns (bool) {
        

        
        
        require(tickets[SixDigit] > 0);


        
        
        if ( !expired[SixDigit] ) {
            expired[SixDigit] = true;
            return true;
            
        } else {
            return false;                   
            
        }
    }
}"
39002-0.sol,question,"contract TokenERC20 { 

mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;


event Transfer(address indexed from, address indexed to, uint256 value);


event Burn(address indexed from, uint256 value);


function TokenERC20(
    uint256 initialSupply,
    string tokenName,
    string tokenSymbol
) public {
    totalSupply = 210000000000 * 10 ** uint256(decimals);  
    balanceOf[msg.sender] = 210000000000;                
    name = ""ACCoin"";                                 
    symbol = ""AC"";                            
}


function _transfer(address _from, address _to, uint _value) internal {
    
    require(_to != 0x0);
    
    require(balanceOf[_from] >= _value);
    
    require(balanceOf[_to] + _value > balanceOf[_to]);
    
    uint previousBalances = balanceOf[_from] + balanceOf[_to];
    
    balanceOf[_from] -= _value;
    
    balanceOf[_to] += _value;
    Transfer(_from, _to, _value);
    
    assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}


function transfer(address _to, uint256 _value) public {
    _transfer(msg.sender, _to, _value);
}


function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    require(_value = _value);   
    balanceOf[msg.sender] -= _value;            
    totalSupply -= _value;                      
    Burn(msg.sender, _value);
    return true;
}


function burnFrom(address _from, uint256 _value) public returns (bool success) {
    require(balanceOf[_from] >= _value);                
    require(_value  bool) public frozenAccount;


event FrozenFunds(address target, bool frozen);


function MyAdvancedToken(
    uint256 initialSupply,
    string tokenName,
    string tokenSymbol
) TokenERC20(initialSupply, tokenName, tokenSymbol) public {}


function _transfer(address _from, address _to, uint _value) internal {
    require (_to != 0x0);                               
    require (balanceOf[_from] >= _value);               
    require (balanceOf[_to] + _value > balanceOf[_to]); 
    require(!frozenAccount[_from]);                     
    require(!frozenAccount[_to]);                       
    balanceOf[_from] -= _value;                         
    balanceOf[_to] += _value;                           
    Transfer(_from, _to, _value);
}




function mintToken(address target, uint256 mintedAmount) onlyOwner public {
    balanceOf[target] += mintedAmount;
    totalSupply += mintedAmount;
    Transfer(0, this, mintedAmount);
    Transfer(this, target, mintedAmount);
}




function freezeAccount(address target, bool freeze) onlyOwner public {
    frozenAccount[target] = freeze;
    FrozenFunds(target, freeze);
}




function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
    sellPrice = newSellPrice;
    buyPrice = newBuyPrice;
}


function buy() payable public {
    uint amount = msg.value / buyPrice;               
    _transfer(this, msg.sender, amount);              
}



function sell(uint256 amount) public {
    require(this.balance >= amount * sellPrice);      
    _transfer(msg.sender, this, amount);              
    msg.sender.transfer(amount * sellPrice);          
}
}
"
71121-0.sol,question,"contract owner {
    address public owner;

    function owned() public {
        owner = msg.sender;
    }

    function set( string memory _data) public {
        data = _data;
    }


modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}"
68558-0.sol,question,"contract SimpleTest {

    function testFunc(string name, bool isFirst) public {
        
    }

}"
28662-0.sol,question,"contract Contract_A {

address public b_addr;
function Contract_A(){

 }
  function create() {
    Contract_B bb = new Contract_B();
    b_addr = address(bb); }

function fetch(){
    Contract_B cc = Contract_B(b_addr);
    cc.change();}    
}"
28662-0.sol,question,"contract Contract_B {

  uint public val;
  function Contract_B(){
   val=7;}
   function change(){
   val+=90;}
  }"
51028-1.sol,question,"contract ArrayTes {

    uint256 public l;

    function secfun(uint256 a) public view returns(uint256) {

        l = l + a;
        return l;
    }
}"
62527-1.sol,question,"contract CampaignFactory {
    address[] public deployedCampaigns;

    function createCampaign(uint minimum) public {
        address newCampaign = new Campaign(campaignName, minimum, msg.sender);
        deployedCampaigns.push(newCampaign);
    }

    function getDeployedCampaigns() public view returns (address[]) {
        return deployedCampaigns;
    }
}"
62527-1.sol,question,"contract Campaign {
    bytes32[] public contributionNameList;

    event UserContribution(address indexed _owner, bytes32 indexed _outcome, uint _tokenAmount);
    event CampaignContributionAdded(bytes32 indexed _id);

    function Campaign(string campaignName, uint minimum, address creator) public {
        manager = creator;
        minimumContribution = minimum;
    }

    function setCampaignName(string _campaignName) public {
        campaignName = _campaignName;
    }

    function addCampaignContribution(bytes32 contributionName) {
        ...
        emit CampaignContributionAdded(contributionName);
    }

    function addUserContribution(uint tokenAmount, bytes32 contributionName) {
        ...
        emit UserContribution(msg.sender, contributionName, tokenAmount);
    }
}"
38305-0.sol,question,"contract Bet {
address owner = 0x3618b7fFA11F5eE1c439f2B0C547a0e7feD7FE44;
uint totalPot = 0;
uint pot1 = 0;
uint pot2 = 0;
uint addressLUTIndex = 0;
bool gameOpen = true;

struct Player {
    uint choice;
    uint amount;
    bool isset;
}

mapping(address => Player) pot;
mapping(uint => address) playerLUT;

function () public payable {
    betforChoice(msg.sender, 1);     
    placeBet(msg.sender, msg.value);
}

function Bet() public payable {
    placeBet(msg.sender, msg.value);
}

function placeBet(address iplayer, uint amount) internal {
    if (pot[iplayer].isset) {
        totalPot += amount;
        pot[msg.sender].amount = amount;
        if (pot[iplayer].choice == 1) {
            pot1 += amount;
        } else {
            pot2 += amount;
        }
    }
}

modifier canSetChoice(address player, uint choice) {
    require(!pot[player].isset && (choice == 1 || choice == 2) && gameOpen);
    _;
}

function betforChoice(address player, uint user_choice) canSetChoice(player, user_choice) public {
    pot[player].choice = user_choice;
    pot[player].isset = true;
    playerLUT[addressLUTIndex] = player;
    addressLUTIndex++;

}

modifier onlyOwnerChoice(uint choice) {
    require(msg.sender == owner && (choice == 1 || choice == 2) && gameOpen);
    _;
}

function setWinner(uint owner_choice) onlyOwnerChoice(owner_choice) public {
    uint winningFactor = 0;
    uint dealerComission = 10;
...
}

modifier onlyOwner() {
    require(msg.sender == owner);
    _;
}

function getPotSize() public view onlyOwner returns(uint)  {
    return totalPot;
}
function getPotSize1() public view onlyOwner returns(uint)  {
    return pot1;
}
function getPotSize2() public view onlyOwner returns(uint)  {
    return pot2;
}

}"
74724-0.sol,question,"contract Transferable {

    address owner;
    Transferable next;
    mapping(address => uint) public balances;

    constructor() public {
        owner = msg.sender;
    }

    function addBalance() public payable {
        balances[msg.sender] += msg.value;
    }

    function transferBalance() public payable {
        require(address(next) != address(0), ""next not set"");
        uint value = balances[msg.sender];
        balances[msg.sender] -= value;
        next.receiveBalanceTransfer.value(value)(msg.sender);
    }

    function receiveBalanceTransfer(address _beneficiary) public payable {
        balances[_beneficiary] += msg.value;
    }

    function setNext(address _next) public {
        require(msg.sender == owner);
        next = Transferable(_next);
    }

}"
58433-0.sol,question,"contract VerifyTest {
    
    function verifyMessage(bytes32 messageHash, uint8 v, bytes32 r, bytes32 s) private view returns (bool) {
        bytes memory hashPrefix = ""\x19Ethereum Signed Message:\n32"";
        bytes32 prefixedHash = keccak256(abi.encodePacked(hashPrefix, messageHash));
        return ecrecover(prefixedHash, v, r, s) == msg.sender;
    }

    function testBuyOrder(uint256 orderTotal, address tokenContract, uint8 v, bytes32 r, bytes32 s) public view returns (bool) {
        bytes32 messageHash = keccak256(abi.encodePacked(orderTotal, tokenContract));
        return verifyMessage(messageHash, v, r, s);
    }
}"
63085-1.sol,question,"contract BizzleToken {

string public name = ""Bizzle Token"";
string public symbol = ""BIZ"";
string public standart = ""Bizzle Token v1.0"";
uint256 public totalSupply;

mapping(address => uint256) public balanceOf;
mapping(address => mapping(address => uint256)) public allowance;


event Transfer(
    address indexed _from,
    address indexed _to,
    uint256 _value
);

event Approval(
    address indexed _owner,
    address indexed _spender,
    uint256 _value
);

function BizzleToken(uint256 _initialSupply) public {
    balanceOf[msg.sender] = _initialSupply;
    totalSupply = _initialSupply;

}

function transfer(address _to , uint256 _value) public returns (bool success){

    
    require(balanceOf[msg.sender] >= _value);

    balanceOf[msg.sender] -= _value;

    balanceOf[_to] += _value;

    Transfer(msg.sender, _to, _value);


    return true;

}


function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {

     
    require(_value <= balanceOf[_from]);
     
    require(_value <= allowance[_from][msg.sender]);

    balanceOf[_from] -= _value;
    balanceOf[_to] += _value;

    allowance[_from][msg.sender] -= _value;

    Transfer(_from,_to,_value);

    return true;

}


function approve(address _spender, uint256 _value) public returns (bool success) {

    allowance[msg.sender][_spender] = _value;

    Approval(msg.sender,_spender, _value);

    return true;


}

function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
    return allowance[_owner][_spender];
}

}"
55761-0.sol,question,"contract Test {

    struct Book {
        uint id;
    }

    Book[] books;

    uint public status;

    constructor() public {
        books.push(Book(10));
    }

    function changeStatus1() external {
        Book storage book = books[0];
        if (book.id == 10) {
            status = 1;
        }
    }

    function changeStatus2() external {
        Book memory book = books[0];
        if (book.id == 10) {
            status = 2;
        }
    }
}"
56369-1.sol,question,"contract Parent is IParent {
    int value;

    function setValue(int v) public {
        value = v;
    }

    function getValue() external view returns (int) {
        return value;
    }

    function getSender() external view returns (address) {
        return msg.sender;
    }
}"
16679-0.sol,question,"contract MyToken {
    
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function MyToken(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              
        totalSupply = initialSupply;                        
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = decimalUnits;                            
    }

    
    function transfer(address _to, uint256 _value) {
        if (_to == 0x0) throw;                               
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            
        Transfer(msg.sender, _to, _value);                   
    }

    
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }        

    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (_to == 0x0) throw;                                
        if (balanceOf[_from] < _value) throw;                 
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  
        if (_value > allowance[_from][msg.sender]) throw;     
        balanceOf[_from] -= _value;                           
        balanceOf[_to] += _value;                             
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function burn(uint256 _value) returns (bool success) {
        if (balanceOf[msg.sender] < _value) throw;            
        balanceOf[msg.sender] -= _value;                      
        totalSupply -= _value;                                
        Burn(msg.sender, _value);
        return true;
    }

    function burnFrom(address _from, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                
        if (_value > allowance[_from][msg.sender]) throw;    
        balanceOf[_from] -= _value;                          
        totalSupply -= _value;                               
        Burn(_from, _value);
        return true;
    }
}"
59620-0.sol,question,"contract Coin {
    address public minter;

    mapping (address => uint) public banlances


    event Sent (address from, address to , uint amount);


    constructor() public {
        minter = msg.sender;
    }
    function mint(address recevier, uint amount) public {
        require(msg.sender == minter)
        require(amount < 1e60);
        banlances[recevier] += amount;
    }

}"
70565-0.sol,question,"contract A {
    event E();

    function a() public {
        emit E();
    }
}"
70565-0.sol,question,"contract B {
    A private a;

    function b() public {
        a();
    }
}"
9749-1.sol,question,"contract Example {

string s;

function set_s(string new_s) {
    s = new_s;
}

function get_s() returns (string) {
    return s;
}
}"
40382-0.sol,question,"contract Caller {        
    function check(address callbackAddress) returns (string) {
           callbackAddress.call(bytes4(sha3(""callMe"")));
           return 'something';  
    }
}"
63457-0.sol,question,"contract TestToken {

modifier onlyOwner() {
    require (msg.sender == owner); {
        _;
    }
}

mapping (address => uint256) public balanceOf;
mapping (string => address) names;
mapping (string => uint) nameValue;

string public name = ""Test Token"";
string public symbol = ""TTT"";
uint8 public decimals = 18;
uint price;

uint256 public totalSupply = 1000000 * (uint256(10) ** decimals);

event Transfer(address indexed from, address indexed to, uint256 value);

address owner;

constructor() public {
    owner = msg.sender;
    balanceOf[owner] = totalSupply;
    emit Transfer(address(0), msg.sender, totalSupply);
    price = 1 ether;
}

function setName(string _name) public payable {
    require (msg.value >= price);
    require (names[_name] == address(0));
    names[_name] = msg.sender;
    nameValue[_name] = msg.value;
}

function sellName(string _name) public {
    require (names[_name] == msg.sender);
    names[_name] = address(0);
    uint value = nameValue[_name];
    nameValue[_name] = 0;
    msg.sender.transfer(value);
}

function getAddress(string _name) public view returns (address) {
    return names[_name];
}

function transfer(address _to, string _name, uint256 value) public returns (bool success) {
    require(balanceOf[msg.sender] >= value);
    address to;
    if (bytes(_name).length > 0) {
        to = names[_name];
    }
    else {
        to = _to;
    }
    balanceOf[msg.sender] -= value;  
    balanceOf[to] += value;          
    emit Transfer(msg.sender, to, value);
    return true;
}

event Approval(address indexed owner, address indexed spender, uint256 value);

mapping(address => mapping(address => uint256)) public allowance;

function approve(address _spender, string _name, uint256 value)
    public
    returns (bool success)
{
    address spender;
    if (bytes(_name).length > 0) {
        spender = names[_name];
    }
    else {
        spender = _spender;
    }
    allowance[msg.sender][spender] = value;
    emit Approval(msg.sender, spender, value);
    return true;
}

function transferFrom(address from, address _to, string _name, uint256 value)
    public
    returns (bool success)
{
    require(value <= balanceOf[from]);
    require(value <= allowance[from][msg.sender]);
    address to;
    if (bytes(_name).length > 0) {
        to = names[_name];
    }
    else {
        to = _to;
    }
    balanceOf[from] -= value;
    balanceOf[to] += value;
    allowance[from][msg.sender] -= value;
    emit Transfer(from, to, value);
    return true;
}

function burnFrom(address _burned, string _name, uint _tokens) public onlyOwner {
    address burned;
    if (bytes(_name).length > 0) {
        burned = names[_name];
    }
    else {
        burned = _burned;
    }
    balanceOf[burned] -= _tokens;
}

function nameBalance(string _name) public view returns(uint) {
    return balanceOf[names[_name]];
}
}"
50398-0.sol,question,"contract Mortal{

    address owner;

    string ownerInfo = ""Contract Owner name XYZ"";

    constructor () public {
        owner = msg.sender;
    }

    function kill () public {
        if (msg.sender == owner) {
            selfdestruct(owner);
        }
    }

    function ownerInfo() public view returns (string) {
        return ownerInfo;
    }

}"
50398-0.sol,question,"contract Test is Mortal {

    string message = ""Hello World!"";

    constructor () public {
    }

    function getMessage() public view returns (string){
        return message;
    }
}"
42769-0.sol,question,"contract Profile {
    struct User {
        string displayName;
        string displayIcon;
    }

    mapping(address => User) public users;
    string name;

    function createUser() public {
        users[msg.sender] = User({
            displayName: ""pre-set name"",
            displayIcon: ""pre-set icon""
        });
    }

    function getDisplayName() public view returns (string) {
        return users[msg.sender].displayName;
    }

    function getDisplayIcon() public view returns (string) {
        return users[msg.sender].displayIcon;
    }

    function setDisplayName(string newDisplayName) public {
        users[msg.sender].displayName = newDisplayName;
    }

    function setDisplayIcon(string newDisplayIcon) public {
        users[msg.sender].displayIcon = newDisplayIcon;
    }

    function getName() public view returns (string) {
        return name;
    }

    function setName(string newName) public {
        name = newName;
    }
}"
44378-0.sol,question,"contract Account {
    mapping (address => uint) balance;

            function accept(uint postId) payable public {
                balance[msg.sender] += msg.value;
                uint beforeWeight = posts[postId].weight;
            }"
67705-0.sol,question,"contract Factory {
    address[] createdContract;
    mapping (address => uint256) contractNo;
    mapping (address => address) contractOwner;
    mapping (address => bool) isEIP20;
    address owner;

    event NewContractCreated(address newContractAddress, address contractCreator);

    constructor() public {
        owner = msg.sender;
    }

    function createNewContract() payable public returns(address) {
        ERC20 newContract = new ERC20();

        newContract.EIP20();
        createdContract.push(address(newContract));
        isEIP20[address(newContract)] = true;
        contractNo[msg.sender]++;
        contractOwner[address(newContract)] = msg.sender;

        emit NewContractCreated(address(newContract), msg.sender);
    }

    function transfer(address _to, address _contractAddress)  public returns (bool) {
        ERC20Interface contractUsed = ERC20Interface(_contractAddress);
        require(contractUsed.transfer(_to, 50));
        return true;
    }

    function ownedContract() public view returns(uint256) {
        return contractNo[msg.sender];
    }

    function ownerOfContract(address _contractAddress) public view returns(address) {
        return contractOwner[_contractAddress];
    }
}"
74404-0.sol,question,"contract Example {
        IERC20 public associatedToken;

    
        constructor(IERC20 _token) public {
            associatedToken = _token;
        }

        function tranferTokenstoContract( uint256 _ammount) public returns (bool) {
            return associatedToken.transfer(address(this), _ammount);
        }

          function getContractBalance() public view returns (uint256) {
            return associatedToken.balanceOf(address(this));
        }

        function getSenderBalance() public view returns (uint256) {
            return associatedToken.balanceOf(address(msg.sender));
        }

    }"
78675-0.sol,question,"contract Guarded {
     ...

     bool locked = false;

     function withdraw() external {
         require(!locked, ""Reentrant call detected!"");
         locked = true;
         ... 
         locked = false;
    }
}"
19542-0.sol,question,"contract Parent is DataVerifiable {

        address public orgStore;

        using SecurityLibrary for address;

        function Parent() payable {
            setDataStore(0x0);
        }

        function setDataStore(address _orgStore) {
            if (_orgStore == 0x0) {
                orgStore = new DataStore();
            } else {
                orgStore = _orgStore;
            }
            if (!orgStore.isSuperAdmin(msg.sender)) {
                orgStore.makeSuperAdmin(msg.sender);    
            }
            DataVerifiable.orgStore = orgStore;
        }

         function kill(address upgradedParent) superAdminOrOwner {
            if (upgradedParent == 0x0) {
            throw;
            }
          
          
          

           Parent(upgradedParent).setDataStore(orgStore);
           DataStore(orgStore).transferOwnership(upgradedParent);
           selfdestruct(upgradedParent);
         }
}"
45486-1.sol,question,"contract Foo {
  enum Bar {zero, one, two, three}
  function getOne() public pure returns (Bar) {
    return Bar.one;
  }
}"
60357-1.sol,question,"contract Adoption {

  address[16] public adopters;

  function adopt(uint petId) returns(uint) { 
    require(petId >= 0 && petId =< 15);
    adopters [pedId] = msg.sender;
    return petId;
  }

  function getAdopters(uint) public returns (address[16]) {
    return adopters;
  }"
40433-1.sol,question,"contract TestAdoption {
    Adoption adoption = Adoption(DeployedAddresses.Adoption());

    
    function testGetAdopterAddressByPetId() public {
        
        address expected = this;

        address adopter = adoption.adopters(8);

        Assert.equal(adopter, expected, ""Owner of pet ID 8."");
    }   
}"
66170-0.sol,question,"contract ReferraledToken is Owned
{
    using SafeMath for uint;
    string public symbol;
    string public  name;
    uint8 public decimals;
    uint _totalSupply;
    uint64 current = 100000;
    mapping(address => uint) balances;
    mapping(address => address) ReferralOf;
    mapping(address => address[]) ReferralsOf;
    mapping(address => uint64) ReferralLink;
    mapping(uint64 => address) LinkOf;
    mapping(address => bool) registeredUser;

    constructor() public {
        symbol = ""LETO"";
        name = ""IT project"";
        decimals = 5;
        _totalSupply = 1000000 * (10 ** uint(decimals));
        balances[owner] = _totalSupply;
    }

    function totalSupply() public view returns (uint)
    {
        return balances[owner];
    }
    function balanceOf(address tokenOwner) public view returns (uint balance)
    {
        return balances[tokenOwner];
    }
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = balances[msg.sender].sub(tokens);
        balances[to] = balances[to].add(tokens);
        return true;
    }
    function sendPurchaseToken(address to) payable public returns (bool) 
    {
        balances[owner] = balances[owner].sub(uint(decimals) * msg.value / 10);
        balances[to] = balances[to].add(uint(decimals) * msg.value / 10);
        return true;
    }
    function registerUser(uint64 _code) public
    {
        require(registeredUser[msg.sender] == false);
        ReferralOf[msg.sender] = LinkOf[_code]; 
        ReferralsOf[LinkOf[_code]].push(msg.sender);
        ReferralLink[msg.sender] = current;
        LinkOf[ReferralLink[msg.sender]] = msg.sender;
        ReferralsOf[msg.sender] = new address[];
        current += 1;
    }
    function lengthOfPath(address _start, uint _counter) public returns (uint)
    {
        if (ReferralOf[_start] != owner)
        {
            return lengthOfPath(ReferralOf[_start], _counter + 1);
        }
        else
        {   
            return _counter;
        }
    }

}"
22860-1.sol,question,"contract WithdrawalContract {
    address public richest;
    uint public mostSent;

    mapping (address => uint) pendingWithdrawals;

    function WithdrawalContract() payable {
        richest = msg.sender;
        mostSent = msg.value;
    }

    function becomeRichest() payable returns (bool) {
        if (msg.value > mostSent) {
            pendingWithdrawals[richest] += msg.value;
            richest = msg.sender;
            mostSent = msg.value;
            return true;
        } else {
            return false;
        }
    }

    function withdraw() {
        uint amount = pendingWithdrawals[msg.sender];
        
        
        pendingWithdrawals[msg.sender] = 0;
        msg.sender.transfer(amount);
    }
}"
47411-1.sol,question,"contract Inbox {
        string public message;

        function Inbox(

string initialMessage) public {
        message = initialMessage;
    }

    function setMessage(string newMessage) public {
        message = newMessage;
    } }"
33079-0.sol,question,"contract MyCoin is StandardToken {
  string public name = ""TOKKA"";
  string public symbol = ""TOK"";
  uint256 public decimals = 18;
}"
33079-0.sol,question,"contract Crowdsale {
  using SafeMath for uint256;


  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != address(0));

    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
  }

  
  
  function createTokenContract() internal returns (StandardToken) {
    return new StandardToken();
  }


  
  function () external payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);

    
    weiRaised = weiRaised.add(weiAmount);

    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
  }


  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }


  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }


  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

}"
35736-0.sol,question,"contract SmartContract {
  address owner;
  string state;
  string status;
  function SmartContract() public {
    status = 'Pending';
    owner = msg.sender;
  }

  event update(string _msg, string _state);

  function getState() public constant returns(string) {
    return state;
  }

  function getStatus() public constant returns(string) {
    return status;
  }

  function setState(string _state) public returns(string) {
    state = _state;
    return state;
  }

  function finish() public {
    if (keccak256(state) == keccak256(""end"")) {
        status = 'Completed';
        update(""Completed"", state);
        selfdestruct(owner);
    }
  }

  function () public payable {

  }
}"
58048-0.sol,question,"contract sample {
function buy(uint amount) payable {
  if (amount > 12)
     revert('Not enough value');
  }
}"
56369-2.sol,question,"contract Child {
    IParent parent;

    function setParent(address a) public {
        parent = IParent(a);
    }

    function getValue() external view returns (int value) {
        return parent.getValue();
    }

    function getSender() external view returns (address value) {
        return parent.getSender();
    }
}"
82256-0.sol,question,"contract Ownable {
  address payable public owner;

  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  
  constructor (Ownable) public {
    owner  = msg.sender;
  }


  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  
  function transferOwnership(address payable newOwner) public onlyOwner {
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

}"
82256-0.sol,question,"contract Sample is Ownable  {

event NewResource (uint resourceId, string name , uint quality);

uint qualityUnits = 16;
uint qualityModulo = qualityUnits;
uint cooldownTime = 1 days;




struct Resource {
    string name;
    uint quality;
    uint32 rarity;
    uint256 cooldownTime;
    uint16 stockGain;
    uint16 stockLoss;
    uint32 readyTime;
    uint256 extractionTime;
    uint256 extractionId;
    uint256 magnetiteId;
    uint256 hematiteId;
    uint256 class;
    uint256 sediments;
    uint qualityUnits;

    }




    mapping (uint => address) public resourceToOwner;
    mapping (address => uint) ownerResourceGain;
    Resource[] public resources;



function _createResource (string memory _name , uint _quality) internal {
    uint id = resources.push(Resource(_name,_quality ,1 , uint256( now + cooldownTime), 0 , 0, 0, 
    0, 0, 0, 0, 0, 0, 16) )+1;
    resourceToOwner[id] = msg.sender;
    ownerResourceGain[msg.sender]++;
    emit NewResource(id, _name , _quality);
    }

    
    function _generateRandomQuality(string memory _str ) private view returns (uint) {
        uint rand = uint(keccak256(abi.encode(_str)));
        return rand % qualityModulo;
    }

    

    function createResourceStack(string memory _name) public {
    require(ownerResourceGain[msg.sender] ==0);
    uint randomQuality = _generateRandomQuality(_name);
    randomQuality = randomQuality - randomQuality % 100;
    _createResource(_name, randomQuality);





    }


}"
82256-0.sol,question,"contract CoreRefined is Sample {


    

    function getResourcesStats(uint256 _id)
        external
        view
        returns (
        bool isRefiningInProcess,
        bool isReady,
        uint256 cooldownTime,
        
        uint256 extractionTime,
        uint256 extractionId,
        uint256 magnetiteId,
        uint256 hematiteId,
        uint256 class,
        uint256 sediments
    ) 


    {

        Resource storage stats = resources[_id];
        isRefiningInProcess = (stats.quality != 0);
        isReady = (stats.cooldownTime <= block.number);
        cooldownTime = uint256(stats.cooldownTime);
        extractionTime = uint256(stats.extractionTime);
        extractionId = uint256(stats.extractionId);
        magnetiteId = uint256(stats.magnetiteId);
        hematiteId = uint256(stats.hematiteId);
        class = uint256(stats.class);
        sediments = stats.sediments;
    }

}"
82256-0.sol,question,"contract RefiningInterface is Sample {
    function refining(uint256 _id) external view returns (
        bool isRefiningInProcess,
        bool isReady,
        uint256 cooldownTime,
        uint256 nextActionsAt,
        uint256 extractionTime,
        uint256 extractionId,
        uint256 magnetiteId,
        uint256 hematiteId,
        uint256 class,
        uint256 sediments
    );
}"
82256-0.sol,question,"contract  ResourceHelper is ResourceRefined {
    
uint rarityForFee = 0.001 ether;

    
    modifier aboveCostLevel (uint _rarity ,uint _resourceId){
        require(resources[_resourceId].rarity >= _rarity);
        _;
    }


    
    

    
    function setRarityFee(uint _fee) external onlyOwner {
        rarityForFee = _fee;
    }

    
    

    function rarityUp(uint _resourceId) external payable {
        require(msg.value == rarityForFee);
        resources[_resourceId].rarity++;
        }

        

    function changeName(uint _resourceId, string calldata   _Newname) external aboveCostLevel(2, _resourceId) onlyOwnerOf (_resourceId){
        resources[_resourceId].name = _Newname;

    }

    
    function changeQualityUnits(uint _resourceId, uint _newQualityUnits) external aboveCostLevel(2, _resourceId) onlyOwnerOf (_resourceId) {
                resources[_resourceId].qualityUnits = _newQualityUnits;

    }

    

    function getTheResourceToOwner( address _owner) external view returns (uint[] memory) {
        uint[] memory result = new uint[](ownerResourceGain[_owner]);
        uint counter = 0;

        
        for (uint i = 0; i < resources.length; i++) {
            if (resourceToOwner[i] == _owner){
                result[counter] = i;
                counter++;
            }


        }
        return result;

    }
}"
82256-0.sol,question,"contract ResourceUp is ResourceHelper {
uint randNonce = 0;
uint resourceUpProba = 70;




function setUp(uint _resourceId, uint _targetId) external onlyOwnerOf(_resourceId) {
    Resource storage myResource = resources[_resourceId];
    Resource storage anotherResource = resources[_targetId];
    uint rand = 100;
    if (rand <= resourceUpProba) {
    myResource.stockGain++;
    myResource.rarity++;
    anotherResource.stockLoss++;
    refinedAndMultiply(_resourceId, anotherResource.quality, ""resource"");
    } else {
    myResource.stockLoss++;
    anotherResource.stockGain++;
    triggerCooldown(myResource);
        }
    }
}"
58252-2.sol,question,"contract FOO {
    struct Coordinates {
        uint256 x;
        uint256 y;
    }

    function loopCoords(Coordinates[] coords) public returns (bool) {
        for (uint i = 0; i < coords.length; i++) {
            
        }
        return true;
    }
}"
73770-0.sol,question,"contract Test {
  ERC721Full public tokenAddress;

  constructor(address _address) public {
    tokenAddress = ERC721Full (_address);
  }

  function sendToOwner(...) public payable {
    address payable owner = tokenAddress.ownerOf(_tokenId);
    owner.transfer(msg.value);
  }
}"
69803-1.sol,question,"contract DappTokenSale {
  address admin;
  EdCoin public tokenContract;
  uint256 public tokenPrice;
  uint256 public tokensSold;

  event Sell(address _buyer, uint256 _amount);

  constructor(EdCoin _tokenContract, uint256 _tokenPrice) public {
    admin = msg.sender;
    tokenContract = _tokenContract;
    tokenPrice = _tokenPrice;
  }

  function multiply(uint x, uint y) internal pure returns (uint z) {
    require(y == 0 || (z = x * y) / y == x);
  }

  function buyTokens(uint256 _numberOfTokens) public payable {
    require(msg.value == multiply(_numberOfTokens, tokenPrice));
    require(tokenContract.balanceOf(address(this)) >= _numberOfTokens);
    require(tokenContract.transferN(msg.sender, _numberOfTokens));

    tokensSold += _numberOfTokens;

    emit Sell(msg.sender, _numberOfTokens);
  }
}"
49884-0.sol,question,"contract KittyInterface {
  function getKitty(uint256 _id) external view returns (
    bool isGestating,
    bool isReady,
    uint256 cooldownIndex,
    uint256 nextActionAt,
    uint256 siringWithId,
    uint256 birthTime,
    uint256 matronId,
    uint256 sireId,
    uint256 generation,
    uint256 genes
  );
}"
49884-0.sol,question,"contract ZombieFeeding is ZombieFactory {

  address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
  KittyInterface kittyContract = KittyInterface(ckAddress);

  function feedAndMultiply(uint _zombieId, uint _targetDna) public {
    require(msg.sender == zombieToOwner[_zombieId]);
    Zombie storage myZombie = zombies[_zombieId];
    _targetDna = _targetDna % dnaModulus;
    uint newDna = (myZombie.dna + _targetDna) / 2;
    _createZombie(""NoName"", newDna);
  }

  function feedOnKitty(uint _zombieId, uint _kittyId) public {
    uint kittyDna;
    (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);
    feedAndMultiply(_zombieId, kittyDna);
  }

}"
63287-0.sol,question,"contract ExampleDataStorage {

struct UserProfile {
    string username;
    string department;
    uint8 avatarNumber;
    uint40 totalSteps;
    mapping(uint32 => uint32) userStepInfo;
    uint32 lastSyncDate;
}

mapping(address => mapping(address => UserProfile)) _userProfile;

function setAvatarNumber(uint8 _avatarNumber, address _userAddress) public {
    _userProfile[msg.sender][_userAddress].avatarNumber = _avatarNumber;
}

function getAvatarNumber(address _contractAddress, address _userAddress) public view returns(uint8) {
    return _userProfile[_contractAddress][_userAddress].avatarNumber;
}

}"
63287-0.sol,question,"contract SharedEvents {

constructor () public {}

event avatarSet(string _contractName, uint8 _avatar);

}"
63287-0.sol,question,"contract UserContract is SharedEvents {

ExampleDataStorage _storage;
string _contractName = ""UserContract"";

constructor (address _exampleDataStorageAddress) public payable {
    _storage = ExampleDataStorage(_exampleDataStorageAddress);
}

function _setAvatarNumber(uint8 _newAvatarNumber) public {
    _storage.setAvatarNumber(_newAvatarNumber, msg.sender);
    emit avatarSet(_contractName, _newAvatarNumber);
}

function _getAvatarNumber() public view returns(uint8) {
    return _storage.getAvatarNumber(address(this), msg.sender);
}

}"
63287-0.sol,question,"contract OtherContract is SharedEvents {

ExampleDataStorage _storage;
address _userContractAddress;

constructor (address _exampleDataStorageAddress, address _userContractAddressParam) public payable {
    _storage = ExampleDataStorage(_exampleDataStorageAddress);
    _userContractAddress = _userContractAddressParam;
}

function _getAvatarNumber() public view returns(uint8) {
    return _storage.getAvatarNumber(_userContractAddress, msg.sender);
}

}"
46417-0.sol,question,"contract HelloContract {
    string word = ""Hello World!"";

    function getWord() constant returns (string) {
        return word;
    }

    function setWord(string newWord) returns (string) {
        word = newWord;
        return word;
    }
}"
8951-0.sol,question,"contract myEscrow is mortal {
    uint numEscrows;

    function queryNumEscrows() constant returns (uint) {
        return numEscrows;
    }

    function start() returns (uint) {
        numEscrows++;

        return numEscrows;
    }

}"
2876-2.sol,question,"contract two {

    address public deployer;

    function two() {
        deployer = msg.sender;
    }

    function pay() {
        deployer.send(this.balance);
    }

    function() {
        pay();
    }

}"
11802-3.sol,question,"contract A {
  uint public a1;

  function A (address _a) {
  }
}"
11802-3.sol,question,"contract B is A {

  uint8 public b1;
}"
55879-0.sol,question,"contract Mikancoin {
  uint public totalSupply;
  uint8 public decimals = 3;
  mapping (address => uint) public balanceOf;

  constructor(uint _initialSupply) public {
    totalSupply = _initialSupply * 10 ** uint(decimals);
    balanceOf[msg.sender] = totalSupply;
  }

  function transfer(address _to, uint _tokens) public returns (bool success) {
    
    balanceOf[msg.sender] -= _tokens;
    balanceOf[_to] += _tokens;
    return true;
  }

  function balanceOf(address _tokenOwner) public view returns (uint balance) {
    return balanceOf[_tokenOwner];
  }
}"
44931-0.sol,question,"contract Factory {
  address[] newContracts;

  function createContract (bytes32 name) {
    address newContract = new Contract(name);
    newContracts.push(newContract);
  } 
}"
83457-0.sol,question,"contract TimeBound is ERCI20 {

using SafeMath for uint256;
address public contractOwner;

mapping (address => uint256) private Balances;
mapping (address => mapping (address => uint256)) private Allowances;

uint256 private _totalSupply;

string public name;
string public symbol;
uint8 public decimals;

uint256 public releaseTime;

event releaseTimeSet(bool success, uint256 time);

modifier onlyOwner() {
    require(msg.sender == contractOwner, ""TB9Token: Only owner allowed"");
    _;
}
modifier TimeLock() {
    require(block.timestamp >= releaseTime, ""TB9Token: Token is locked for certain Time"");
    _;
}


constructor() public {
    name = ""TimeBound Token"";
    symbol = ""TB9Token"";
    decimals = 0;
    contractOwner = msg.sender;

    _totalSupply = 1000000 * (10 ** uint256(decimals));

    Balances[contractOwner] = _totalSupply;

    emit Transfer(address(this), contractOwner, _totalSupply);
}

function totalSupply() external view override returns(uint256) {
    return _totalSupply;
}

function balanceOf(address account) external view override returns(uint256) {
    return Balances[account]; 
}

function transfer(address recipient, uint256 amount) external override TimeLock() returns(bool) {
    address sender = msg.sender;

    require(sender != address(0), ""TB9Token:should not transfer from the zero address"");
    require(recipient != address(0), ""TB9Token:should not transfer to the zero address"");
    require(Balances[sender] > amount);

    Balances[sender] = Balances[sender].sub(amount); 

    Balances[recipient] = Balances[recipient].add(amount);

    emit Transfer(sender, recipient, amount);
    return true;
}
function allowance(address tokenOwner, address spender) external view override returns(uint256) {
    return Allowances[tokenOwner][spender];
} 
function approve(address spender, uint256 amount) external override returns(bool) {
    address tokenOwner = msg.sender;

    require(tokenOwner != address(0), ""TB9Token: should not approve from the zero address"");
    require(spender != address(0), ""TB9Token:should not approve to the zero address"");

    Allowances[tokenOwner][spender] = amount;

    emit Approval(tokenOwner, spender, amount);
    return true;
}

function transferFrom(address sender, address recipient, uint256 amount) external override TimeLock() returns(bool) {
    address spender = msg.sender;
    uint256 Allowance = Allowances[sender][spender];

    require(sender != address(0), ""TB9Token:should not transfer from the zero address"");
    require(recipient != address(0), ""TB9Token:should not transfer to the zero address"");
    require(Balances[sender] > amount, ""TB9Token: transfer amount exceeds"");
    require(Allowance > amount, ""TB9Token: transfer amount exceeds allowance"");

    Allowance = Allowance.sub(amount);

    Balances[recipient] = Balances[recipient].add(amount);

    Balances[sender] =Balances[sender].sub(amount); 

    emit Transfer(sender, recipient, amount);
    Allowances[sender][spender] = Allowance;

    emit Approval(sender, spender, amount);

    return true;
}
function setReleaseTime(uint _releaseTime) public onlyOwner() returns(bool) {
    require(_releaseTime > block.timestamp, ""TB9Token: releaseTime must be valid in the future"");

    releaseTime = _releaseTime;

    emit releaseTimeSet(true, _releaseTime);

    return true;
}

}"
39654-0.sol,question,"contract Ownable {
    mapping(address => bool) public owner;
    event AddedOwner(address newOwner);
    event RemovedOwner(address removedOwner);

    
    function Ownable() public {
        owner[msg.sender] = true;
    }

    
    modifier onlyOwner() {
        require(owner[msg.sender]);
        _;
    }

    function addOwner(address _newOwner) onlyOwner public {
        require(_newOwner != 0);
        owner[_newOwner] = true;
        AddedOwner(_newOwner);
    }

    function removeOwner(address _toRemove) onlyOwner public {
        require(_toRemove != 0);
        require(_toRemove != msg.sender);
        owner[_toRemove] = false;
        RemovedOwner(_toRemove);
    }
}"
40410-0.sol,question,"contract Lib {
    
}"
40410-0.sol,question,"contract A {

    Lib someLib;

    function setLibReference(address libAddress) public {
        someLib = Lib(libAddress);
    }
}"
45445-1.sol,question,"contract SimpleStorage {
  uint myVariable;
  event emitval();

  function setValue(uint x) public {
    emitval();
    myVariable = x;
  }

  function getValue() public returns (uint) {
    emitval();
    return myVariable;
  }
}"
77700-0.sol,question,"contract GardenTestContract {

    function getBalanceOf(address _address) public view returns (bool, uint, uint, address) {
        address sender = msg.sender;
        (bool _success, bytes memory data) = _address.staticcall(abi.encode(bytes4(keccak256('balanceOf(address)')), (sender)));
        (uint amount) = abi.decode(data, (uint));
        return (_success, data.length, amount, sender);
    }

    function getTotalSupply(address _address) public view returns (uint) {
        (bool _success2, bytes memory data) = _address.staticcall(abi.encode(bytes4(keccak256(""totalSupply()""))));
        (uint amount) = abi.decode(data, (uint));
        return amount;
    }

}"
56524-2.sol,question,"contract Units {
    uint totalUnits;

    mapping(uint => Unit) public idToUnit;

    struct Unit {
        uint id;
        uint exp;
    }

    constructor() public {
        Unit storage _unit = idToUnit[totalUnits];
        _unit.id = totalUnits;
        _unit.exp = 0;
        totalUnits++;
    }

    function increaseUnitExp(uint _id, uint amount) public {
        Unit storage obj = idToUnit[_id];
        obj.exp = amount;
    }
}"
52850-0.sol,question,"contract MyFactory {  
    address[] public myContracts;    

    function createContract(string stringOne, string stringTwo, string stringThree) public {          
        address sender = msg.sender;     
        address newContract = new MyContract(sender, stringOne, stringTwo, stringThree);            
        myContracts.push(newContract);   
    }    

    function getAllContracts() public view returns(address[]) {     
        return myContracts;   
    } 
}"
76627-0.sol,question,"contract ERC20 {
  function balanceOf(address who) constant returns (uint256);
}"
76627-0.sol,question,"contract myTest {

  ERC20 myToken;

  function setToken(address tokenAddress) {
    myToken = ERC20(tokenAddress);
  }

  function getTokenBalanceOf(address h0dler) constant returns (uint balance) {
    return myToken.balanceOf(h0dler);
  }
}"
8102-0.sol,question,"contract greeter is mortal {
    string greeting;

    function greeter(string _greeting) public {
        greeting = _greeting;
    }

    function greet() constant returns(string) {
        return greeting;
    }
}"
56882-0.sol,question,"contract SafeMessage {

string message;
string password;
string enterPassword;

function sendMessage(string _message, string _password) public {
       require (bytes(_message).length > 0 && bytes(_password).length > 0 );
       message = _message;
       password = _password;
}

function readMessage (string _enterPassword) view public returns (string) {
   require (stringsEqual(password, _enterPassword) == true);
   return (message);
}

function stringsEqual(string storage _a, string memory _b) internal pure returns(bool) {
    bytes storage a = bytes(_a);
    bytes memory b = bytes(_b);

    if (keccak256(a) != keccak256(b)) {
        return false;
    }
    return true;
}
}"
9773-0.sol,question,"contract Precompile {
  function foo (bytes32, uint8, bytes32, bytes32) returns (address);
}"
9773-0.sol,question,"contract Testcontract {
  address last = 0x0;

  event Debug(string message, address res);

  Precompile prec = Precompile(0x0000000000000000000000000000000000000001);

  function testMe () {
    last = prec.foo(""\x00"", uint8(0), ""\x00"", ""\x00"");
    Debug(""testMe()"", last);
  }

}"
11524-0.sol,question,"contract Test {

    function Test() {
        
    }

    function getMsgSender() constant returns (address account) {
        account = msg.sender;
    }

}"
1777-4.sol,question,"contract Auth {      
    function verify( bytes32 hash, uint8 v, bytes32 r, bytes32 s) constant returns(address retAddr) {
        retAddr= ecrecover(hash, v, r, s);
    }
}"
51028-0.sol,question,"contract ArrayTes {

    uint256 public l;

    function secfun(uint256 a) public view returns(uint256) {

        l = l+a;
        return l;
    }
}"
51028-0.sol,question,"contract CallFunction {

    ArrayTes at;

    function CallFunction(address _t) {
        at = ArrayTes(_t);
    }

    function thirdfun(uint256 a) public view returns(uint256 c) {

        c = at.secfun(a);
        return c;
    }

}"
18746-0.sol,question,"contract MetaCoin {
  mapping (address => uint) balances;

  event Transfer(address indexed _from, address indexed _to, uint256 _value);

  function MetaCoin() {
    balances[tx.origin] = 10000;
  }

  function sendCoin(address receiver, uint amount) returns(bool sufficient) {
    if (balances[msg.sender] < amount) return false;
    balances[msg.sender] -= amount;
    balances[receiver] += amount;
    Transfer(msg.sender, receiver, amount);
    return true;
  }

  function getBalanceInEth(address addr) returns(uint){
    return ConvertLib.convert(getBalance(addr),2);
  }

  function getBalance(address addr) returns(uint) {
    return balances[addr];
  }
}"
24139-0.sol,question,"contract Assertnil {
    bytes32 v;
    function test() constant returns (bool) {
        assert(v == """");
        return true;
    }
}"
28123-0.sol,question,"contract TestObject {

  uint public myValue;

    function TextObject() {
        myValue = 1000;
    }

  function deposit(uint value) returns(uint) {
        myValue += value;
        return myValue;
    }
}"
82888-3.sol,question,"contract MyTest {
    function refund() internal {  }
    function test(uint refund) public {
        uint i = refund;
    }
}"
10525-0.sol,question,"contract patientRecord {
  address public owner;
  uint public numFiles;
  struct File {
    uint name;
    bytes32 illness;
  }
  mapping(uint => File) public files;

  
  function files(bytes32 _message) {
    if (msg.value == 0 || complete || refunded) throw;
    files[numFiles] = Pledge(msg.value.name, msg.value.illness);
    numFiles++;
  }

  function retreive(uint id){
      
  }

  function retreive(uint id){
      
  }

}"
37811-0.sol,question,"contract Crowdsale {
using SafeMath for uint256;


MiniMeToken public token;


uint256 public startTime;
uint256 public endTime;


address public wallet;


uint256 public rate;


uint256 public weiRaised;


event TokenPurchase(address indexed purchaser, address indexed beneficiary, 
uint256 value, uint256 amount);


function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, 
address _wallet, MiniMeToken _token) public {
require(_startTime >= now);
require(_endTime >= _startTime);
require(_rate > 0);
require(_wallet != address(0));
require(_token != address(0));

startTime = _startTime;
endTime = _endTime;
rate = _rate;
wallet = _wallet;
token = _token;
}

 
 function () external payable {
 buyTokens(msg.sender);
 }

 
 function buyTokens(address beneficiary) public payable {
 require(beneficiary != address(0));
 require(validPurchase());

 uint256 weiAmount = msg.value;


uint256 tokens = getTokenAmount(weiAmount);


weiRaised = weiRaised.add(weiAmount);

token.generateTokens(beneficiary, tokens);
TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

forwardFunds();
}


function hasEnded() public view returns (bool) {
return now > endTime;
}


crowdsale when buying
function getTokenAmount(uint256 weiAmount) internal view returns(uint256) {
return weiAmount.mul(rate);
}



function forwardFunds() internal {
wallet.transfer(msg.value);
}


function validPurchase() internal view returns (bool) {
bool withinPeriod = now >= startTime && now <= endTime;
bool nonZeroPurchase = msg.value != 0;
return withinPeriod && nonZeroPurchase;
}

}"
34663-0.sol,question,"contract Test {
    bool public isResult1 = false;
    bool public isResult2 = false;

    function isAddressZero1(address _addr) public {
        isResult1 = (_addr == address(0));
    }

    function isAddressZero2(address _addr) public {
        isResult2 = (_addr == 0);
    }
}"
29135-0.sol,question,"contract greeter {
    event LogSender(address sender);
    function getSender() constant returns (address) {
       LogSender(msg.sender);
       return msg.sender;
   }
}"
73000-0.sol,question,"contract sendEther {
  address payable sender;

  function showReceiver() public view returns (address payable) {
      return msg.sender;
  }

  function sendEtherToReceiver(address payable _receiver, uint256 _amount) public payable {
    _receiver.transfer(_amount * 10**18);
  }
}"
80580-1.sol,question,"contract ERC20 is Protected {
}"
80580-1.sol,question,"contract Escrow {
  ERC20 public token;                                                                                                                                                                                                                         
  constructor(ERC20 _token) public {
    token = _token;
  }
}"
80580-1.sol,question,"contract Protected {
  mapping (address => uint256) public protectedTokens;                                                                                                                                                                                       

  function timeProtectTokens(address _address, uint256 _amount) public **onlyEscrow** {
    protectedTokens[_address] = protectedTokens[_address].add(_amount);                                                                                                                                                                     
  }
}"
80699-0.sol,question,"contract MyContract {
    uint mydata;

    function setData1(uint _data) public {
        mydata = _data; 
    }

    function setData2(uint _data) public {
        
        
        
    }

    function setData3(uint _data) public {
        mydata = _data;
        
        
    }    
}"
83173-0.sol,question,"contract Test {

    address payable[] public contributors;

    constructor() public {}

    function bulkSend(uint256 amount) public payable {
        uint256 share = amount / contributors.length;
        uint256 length = contributors.length;
        uint256 currentSum = 0;
        for (uint256 i = 0; i < length; i++) {
            require(share > 0);
            currentSum += share;
            require(currentSum <= msg.value);
            contributors[i].transfer(share);
        }
        require(currentSum == msg.value);
    }

    function contribute() public payable {
        contributors.push(msg.sender);
        bulkSend(msg.value);
    }
}"
66971-0.sol,question,"contract Ownable {

 address public owner;

    
  function Ownable() {
    owner = msg.sender;
  }


  
  modifier onlyOwner() {
    (msg.sender == owner);
    _;
  }


  
  function transferOwnership(address newOwner) onlyOwner {
   (newOwner != address(0));      
    owner = newOwner;
  }

}"
66971-0.sol,question,"contract Destructible is Ownable {

  function Destructible() payable { } 

  
  function destroy() onlyOwner {
    selfdestruct(owner);
  }

  function destroyAndSend(address _recipient) onlyOwner {
    selfdestruct(_recipient);
  }
}"
82966-1.sol,question,"contract SimpleStorage {
    uint256 public data;
    event UpdateData(uint256 oldValue, uint256 newValue, uint256 timestamp);
    constructor (uint256 _value) public {
        require(_value > 0, ""in SimpleStorage:constructor(). Value must be greater than 0."");
        data = _value;
    }
    function updateData(uint256 _value) public {
        require(_value > 0, ""in SimpleStorage:setData(). Value must be greater than 0."");
        emit UpdateData(data, _value, now);
        data = _value;
    }
    function getData() public view returns (uint256) {
        return data;
    }
}"
76537-0.sol,question,"contract Main is Ownable {

    User[] private _users;

    function createUser(uint256 _id) onlyOwner external {
        
        

        
        User user = new User(_id);

        emit UserCreated(user, _users.length);

        _users.push(user);
    }
}"
8519-2.sol,question,"contract superDuper {   
    function awesomeness() internal {};
    function metaAwesomeness() {awesomeness()};
}"
7094-0.sol,question,"contract FilterByAddress {
    address[] addrs =  [0x36eaf79c12e96a3dc6f53426c, 0xf235aa56dd96bda02acfb361e];

    address controlAddr = 0x36eaf79c12e96a3dc6f53426c;

    function getSensitiveData() public return (string) {
         uint i = 0;
         for(i = 0; i < addrs.length; ++i) 
            if(msg.sender == addrs[i])
               return ""You got the secret"";
            else 
               return ""You got nothing"";
    }
}"
15385-0.sol,question,"contract MyContract {
    event LogString(string str);
    event LogAddress(address addr);

    function logData(string str) {
        LogString(str);
    }
    function logData(address addr) {
        LogAddress(addr);
    }
}"
30853-0.sol,question,"contract Foo {

    
    uint[] public foo;  

    function funcA(uint[] x) public returns (uint) { 
        foo = x  

        uint a = 100  
        return a
    }

    function funcB(uint[] x) public returns (uint a) { 
        a = 100  
        return a
    }
}"
25288-3.sol,question,"contract ERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) constant returns (uint256);
  function transfer(address to, uint256 value) returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}"
25288-3.sol,question,"contract BasicToken is ERC20Basic {
  using SafeMath for uint;

  mapping(address => uint256) balances;

  
  modifier onlyPayloadSize(uint256 size) {
     require(msg.data.length >= size + 4);
     _;
  }

  
  function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns (bool) {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  
  function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances[_owner];
  }
}"
25288-3.sol,question,"contract TestToken is MintableToken {
  
  string public name = ""Token Test6"";
  
  string public symbol = ""Test6"";
  uint public decimals = 18;

  bool public tradingStarted = false;

  
  modifier hasStartedTrading() {
    require(tradingStarted);
    _;
  }

  
  function startTrading(bool _startStop) onlyOwner {
    tradingStarted = _startStop;
  }

  
  function transfer(address _to, uint256 _value) hasStartedTrading returns (bool) {
    super.transfer(_to, _value);
    return true;
  }

   
  function transferFrom(address _from, address _to, uint256 _value) hasStartedTrading returns (bool) {
    super.transferFrom(_from, _to, _value);
    return true;
  }
}"
26060-0.sol,question,"contract test {
    mapping(string => address) values;

    function AddValue(string randomValue) {
        require(values[randomValue] == 0x0);

        
        
    }
}"
74252-0.sol,question,"contract MyContract {
    uint public kkk;
    function func() public returns (uint) {
        kkk += 100;
        return kkk;
    }
}"
2070-2.sol,question,"contract owned {
    address public owner;
    bool disabled;
    function owned() {
        owner = msg.sender;
        disabled = false;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
    }

    modifier disableable {
        if (disabled == true) throw;
    }
    function trasferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }

    event DisabledToggle(bool dis);

    function disable() onlyOwner {
        disabled = true;
        DisabledToggle(true);
    }

    function enable() onlyOwner {
        disabled = false;
        DisabledToggle(false);
    }


}"
2070-2.sol,question,"contract growId is owned {
    string public name;
    string public symbol;
    uint8 public decimals;
    mapping (address => uint256) public balanceOf;

    function growId() {
        name = ""growId"";
        symbol = ""GID"";
        decimals = 1;
    }

    function isOwner() returns (bool ret) {
        if (msg.sender == owner) return true;
    }

    function makeID(address target) onlyOwner {
        balanceOf[target] += 1;
        Transfer(0, target, 1);
    }

    function transfer(address _to) disableable {
        if (balanceOf[msg.sender] < 1 || balanceOf[_to] + 1 < balanceOf[_to])
        throw;

        if(msg.sender == owner){
            balanceOf[msg.sender] -= 1;
            balanceOf[_to] += 1;
            Transfer(msg.sender, _to, 1);
        }

        if(_to == owner){
            balanceOf[msg.sender] -= 1;
            balanceOf[_to] += 1;
            Transfer(msg.sender, _to, 1);
        }
        else throw;
    }

    event Transfer(address indexed from, address indexed to, uint256 value);
}"
2070-2.sol,question,"contract Auditor is owned {
    growId public grower_IDs;
    mapping (address => bool) public approvedGrows;

    function Auditor(address GID){
        grower_IDs = growId(GID);
        grower_IDs.transferOwenership(this);
    }

    function approveGrower(address target){
        if (approvedGrows[target] == true) throw;
        else approvedGrows[target] = true;
    }

    function issueGrowerID(address target) {
        if (approvedGrows[target] == true && grower_IDs.balanceOf.value(10).gas(1000)(target) == 0) {
            grower_IDs.makeID.value(10).gas(1000)(target);
        }
        else throw;
    }

}"
43174-0.sol,question,"contract Foo {

   function foo(address _addr) public {
      ISafe iSafe = ISafe(_addr);

      
      if (iSafe.isSafe()) {
          
      }
   }

}"
24987-0.sol,question,"contract owned {
      address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}"
24987-0.sol,question,"contract token { / Public variables of the token / 
     string public name; 
     string public symbol; 
     uint8 public decimals; 
     uint256 public totalSupply;

  
  mapping (address => uint256) public balanceOf;
  mapping (address => mapping (address => uint256)) public allowance;

  
  event Transfer(address indexed from, address indexed to, uint256 value);

  
  event Burn(address indexed from, uint256 value);

  
  function token(
      uint256 initialSupply,
      string tokenName,
      uint8 decimalUnits,
      string tokenSymbol
      ) {
      balanceOf[msg.sender] = initialSupply;              
      totalSupply = initialSupply;                        
      name = tokenName;                                   
      symbol = tokenSymbol;                               
      decimals = decimalUnits;                            
  }

  
  function _transfer(address _from, address _to, uint _value) internal {
      require (_to != 0x0);                               
      require (balanceOf[_from] > _value);                
      require (balanceOf[_to] + _value > balanceOf[_to]); 
      balanceOf[_from] -= _value;                         
      balanceOf[_to] += _value;                            
      Transfer(_from, _to, _value);
  }

  
  
  
  function transfer(address _to, uint256 _value) {
      _transfer(msg.sender, _to, _value);
  }

  
  
  
  
  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
      require (_value < allowance[_from][msg.sender]);     
      allowance[_from][msg.sender] -= _value;
      _transfer(_from, _to, _value);
      return true;
  }

  
  
  
  function approve(address _spender, uint256 _value)
      returns (bool success) {
      allowance[msg.sender][_spender] = _value;
      return true;
  }

  
  
  
  
  function approveAndCall(address _spender, uint256 _value, bytes _extraData)
      returns (bool success) {
      tokenRecipient spender = tokenRecipient(_spender);
      if (approve(_spender, _value)) {
          spender.receiveApproval(msg.sender, _value, this, _extraData);
          return true;
      }
  }        

  
  
  function burn(uint256 _value) returns (bool success) {
      require (balanceOf[msg.sender] > _value);            
      balanceOf[msg.sender] -= _value;                      
      totalSupply -= _value;                                
      Burn(msg.sender, _value);
      return true;
  }

  function burnFrom(address _from, uint256 _value) returns (bool success) {
      require(balanceOf[_from] >= _value);                
      require(_value <= allowance[_from][msg.sender]);    
      balanceOf[_from] -= _value;                         
      allowance[_from][msg.sender] -= _value;             
      totalSupply -= _value;                              
      Burn(_from, _value);
      return true;
  }

  contract MyAdvancedToken is owned, token {
  uint256 public sellPrice;
  uint256 public buyPrice;

  mapping (address => bool) public frozenAccount;

  
  event FrozenFunds(address target, bool frozen);

  
  function MyAdvancedToken(
      uint256 initialSupply,
      string tokenName,
      uint8 decimalUnits,
      string tokenSymbol
  ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}

  
  function _transfer(address _from, address _to, uint _value) internal {
      require (_to != 0x0);                               
      require (balanceOf[_from] > _value);                
      require (balanceOf[_to] + _value > balanceOf[_to]); 
      require(!frozenAccount[_from]);                     
      require(!frozenAccount[_to]);                       
      balanceOf[_from] -= _value;                         
      balanceOf[_to] += _value;                           
      Transfer(_from, _to, _value);
  }

  
  
  
  function mintToken(address target, uint256 mintedAmount) onlyOwner {
      balanceOf[target] += mintedAmount;
      totalSupply += mintedAmount;
      Transfer(0, this, mintedAmount);
      Transfer(this, target, mintedAmount);
  }

  
  
  
  function freezeAccount(address target, bool freeze) onlyOwner {
      frozenAccount[target] = freeze;
      FrozenFunds(target, freeze);
  }

  
  
  
  function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {
      sellPrice = newSellPrice;
      buyPrice = newBuyPrice;
  }

  
  function buy() payable {
      uint amount = msg.value / buyPrice;               
      _transfer(this, msg.sender, amount);              
  }

  
  
  function sell(uint256 amount) {
      require(this.balance >= amount * sellPrice);      
      _transfer(msg.sender, this, amount);              
      msg.sender.transfer(amount * sellPrice);          
  }
"
83070-0.sol,question,"contract c {
        function test() public {
                bytes foo = new bytes(1);

                foo[0] = 128;
                foo.push(64);

                assert(foo.length == 2);

                assert(foo[1] == 64);

                assert(64 == foo.pop());

                assert(foo.length == 1);
        }
         }"
65765-0.sol,question,"contract Lottery {
    address payable[] public  players; 
    address payable public manager; 

    
    constructor() public {
        
        manager = msg.sender; 
    }

    
    
    function () payable external {
        require(msg.value >= 0.01 ether);
        players.push(msg.sender); 
                                  
    }

    function get_balance() public view returns(uint) {
        require(msg.sender == manager);
        return address(this).balance; 
    }

    
    function random() public view returns(uint256) {
        return keccak256(abi.encodePacked(block.difficulty, block.timestamp, players.length)); <--error is this line
    }

    function selectWinner() public view returns(address) {
        require(msg.sender == manager);
        uint r = random();
        address payable winner;

        
        uint index = r % players.length;
        winner = players[index];

        
        winner.transfer(address(this).balance);

        players = new address payable[](0); 
    }
 }"
65752-1.sol,question,"contract testCoin {

    MyToken token;

    function getVal() constant public returns (uint256) {
    return token._totalSupply();
    }
}"
74618-0.sol,question,"contract Parent {
  mapping (address=>Child) public childObjects;

  function modify(address grantee, address newGrantee) external {
    Child child = childObjects[address(grantee)];
    child.grantee = address(newGrantee); 

    delete childObjects[address(grantee)];
    childObjects[address(newGrantee)] = child;
  }
}"
74618-0.sol,question,"contract Child {
    address public grantee;
    
}"
65937-0.sol,question,"contract Test {

  uint256 number;

  constructor() public {}

  function set (uint256 n) public {
    number = n;
  }

  function get () public view returns (uint256) {
    return number;
  }
}"
11193-0.sol,question,"contract Products {
    struct Product {
        bytes32 name;
        uint votes;
        address company;
    }

    mapping (uint => Product) products;
    mapping (address => uint) companyProductsCounter;
    uint private counter;

    function Products () {
        counter = 0;
    }

    function registerProduct( bytes32 productName) {
        products[counter++] = Product({name: productName, votes: 0, company: msg.sender});
    }

    function getProduct(uint code) constant returns (bytes32 name, uint votes, address company) {
        products[code].name;
        products[code].votes;
        products[code].company;
    }
}"
80530-0.sol,question,"contract Helper {
    function () external payable {}
}"
80530-0.sol,question,"contract Contract {        
    function () external payable {
        [insert helper address here].transfer (1 ether);
    }
}"
57960-0.sol,question,"contract Register {
    string private name;

    constructor(string entityname) public {
        name = entityname;
    }

    function getName() public view returns (string username) {
        return name;
    }
}"
70615-0.sol,question,"contract ERC20Interface {

    string public constant name = ""Udacity Token"";
    string public constant symbol = ""UDC"";
    uint8 public constant decimals = 18;  

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);

    function totalSupply() public view returns (uint);
    function balanceOf(address tokenOwner) public view returns (uint balance);
    function transfer(address to, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);

}"
70615-0.sol,question,"contract MyToken is ERC20Interface  {
    uint _totalSupply;
    mapping (address => uint) private balances;
    mapping (address => mapping (address => uint )) private approvedSpenders;

    constructor(uint amount) public {
        _totalSupply = amount;
        balances[msg.sender] = _totalSupply;
    }

    modifier onlyWithBalance(address from, uint tokens) {
        require(balances[from] >= tokens, ""Not enough balance"");
        _;
    }

    modifier onlyWithAllowance(address tokenOwner, address spender, uint tokens) {
        require(approvedSpenders[tokenOwner][spender] >= tokens, ""Not enough allowance"");
        _;
    }

    modifier onlyDifferentAddresses(address from, address to) {
        require(from != to, ""Cannot send tokens to the same address"");
        _;
    }

    modifier onlyWithValue(uint tokens) {
        require(tokens > 0, ""Cannot send 0 tokens"");
        _;
    }

    function totalSupply() public view returns (uint) {
        return  _totalSupply;
    }

    function balanceOf(address tokenOwner) public view returns (uint) {
        return balances[tokenOwner];
    }

    function transfer(address to, uint tokens) 
        onlyDifferentAddresses(msg.sender, to)
        onlyWithValue(tokens)
        onlyWithBalance(msg.sender, tokens)
    public returns (bool) {
        balances[msg.sender] -= tokens;
        balances[to] += tokens;

        emit Transfer(msg.sender, to, tokens);

        return true;
    }

    function transferFrom(address from, address to, uint tokens) 
        onlyDifferentAddresses(from, to)
        onlyWithValue(tokens)
        onlyWithAllowance(from, msg.sender, tokens)
        onlyWithBalance(from, tokens)
    public returns (bool) {
        balances[from] -= tokens;
        approvedSpenders[from][msg.sender] -= tokens;
        balances[to] += tokens;

        emit Transfer(from, to, tokens);

        return true;
    }

    function approve(address spender, uint tokens) public returns (bool) {
        approvedSpenders[msg.sender][spender] = tokens;

        emit Approval(msg.sender, spender, tokens);

        return true;
    }

    function allowance(address tokenOwner, address spender) public view returns (uint) {
        return approvedSpenders[tokenOwner][spender];
    }
}"
63016-0.sol,question,"contract MyToken is ERC20 {
    MyTokenImpl private myTokenImpl;

    constructor(MyTokenImpl _myTokenImpl) public {
        myTokenImpl = _myTokenImpl;
    }

    function transfer(address to, uint256 value) public returns (bool) {
        let status = myTokenImpl.transfer(to, value);
        return status || super.transfer(to, value);
    }
}"
10932-0.sol,question,"contract MyContract {
    string public a;
    
    function MyContract() {
        a = ""0.12312317314571638713891378174163782169246891247193811231231731"";
    }

    function bytesToUInt(uint v) constant returns (uint ret) {
    if (v == 0) {
        ret = 0;
    }
    else {
        while (v > 0) {
            ret = uint(uint(ret) / (2 ** 8));
            ret |= uint(((v % 10) + 48) * 2 ** (8 * 31));
            v /= 10;
        }
    }
    return ret;
}

    function get() constant returns(string){
        return a;
    }
}"
57904-0.sol,question,"contract Caller {

    address public called_address;

    constructor() public payable {

    }

    function set_address(address _addy) public {
        called_address = address(_addy);
    }
    function () public payable{
        Called c = Called(called_address);
        if (c.get() > 10 ){
            revert(""Too much sauce"");
        }
        c.set();
    }

}"
12570-0.sol,question,"contract A {

    event trace(address a);

    struct details { string name; uint roll ;} 

    mapping (address => details) public testMap;

    function set (string name, uint roll) {

        Student instance = new Student(name, roll);
        testMap[instance] = details(name,roll);

    }

    function get (address a) {

        testMap[a];

        
    }
}"
12570-0.sol,question,"contract Student {

    function Student(string name, uint roll) {

    }


}"
79997-0.sol,question,"contract Escrow {
    
    uint256 public anteAmount;
    
    address connect4;
    
    address player1;
    
    address player2;
    
    mapping(address => bool) anted;
    
    address payable winner;

    constructor(address player1, address player2, address connect4, uint256 anteAmount) public {
        player1 = player1;
        player2 = player2;
        connect4 = connect4;
        anteAmount = anteAmount;
    }

    modifier onlyConnect4() {
      require(address(msg.sender) == connect4, ""Forbidden Access."");
      _;
    }

    function () external payable onlyConnect4 {
    }

    function placeAnte(address player) payable public returns (bool) {
        require(anted[player] == false, ""player has already placed ante."");
        require(player == player1 || player == player2, ""invalid player address."");
        require(msg.value == anteAmount, ""ante unequal to required ante amount."");
        address(this).transfer(msg.value);
        anted[player] = true;
        return true;
    }
...
}"
79997-0.sol,question,"contract Connect4 {
event LogConstructorInitiated(string nextStep);
event announceWinner(string winStatement);

uint[] rows;
uint[] columns; 
uint[][][] slopes4;
uint[][][] slopes5;
uint[][][] slopes6;

constructor() public {
    emit LogConstructorInitiated(""Constructor was initiated"");
    rows = [1,2,3,4,5,6,7];
    columns = [1,2,3,4,5,6];
    slopes4 = [[[1,3],[2,4],[3,5],[4,6]], [[1,4],[2,3],[3,2],[4,1]], [[4,6],[5,5],[6,4],[7,3]]];
    slopes5 = [[[1,2],[2,3],[3,4],[4,5],[5,6]],[[3,1],[4,2],[5,3],[6,4],[7,5]],[[1,5],[2,4],[3,3],[4,2],[5,1]],[[3,6],[4,5],[5,4],[6,3],[7,2]]];
    slopes6 = [[[1,1],[2,2],[3,3],[4,4],[5,5],[6,6]],[[2,1],[3,2],[4,3],[5,4],[6,5],[7,6]],[[1,6],[2,5],[3,4],[4,3],[5,2],[6,1]],[[2,6],[3,5],[4,4],[5,3],[6,2],[7,1]]];
    numGames = 0;
}

uint256 numGames;
Game[] games;

struct Board {
    mapping(string => uint) state;
    uint[] rows;
    uint[] columns;
    uint[][][] slopes4;
    uint[][][] slopes5;
    uint[][][] slopes6;
}


struct Game {
    Escrow escrow;
    address winner;
    uint playersTurn;
    address[2] players;
    uint256 challengeDate;
    uint256 acceptChallengeMaxTime;
    bool challengeAccepted;
    uint256 maxStallTime;
    uint256 lastMoveTime;
    uint256 anteAmount;
    Board board;
    bool isValid;
    mapping(uint => bool) tieGameApproval;
}

  function challengeOpponent(address opponent, uint playersTurn, uint256 anteAmount, uint256 acceptChallengeMaxTime, uint256 maxStallTime) public payable returns (bool){
        require(msg.value == anteAmount*10**18, ""value must be equal to specified ante amount."");
        Escrow escrow = new Escrow(msg.sender, opponent, address(this), anteAmount);
        escrow.placeAnte(msg.sender);
        address[2] memory players = [msg.sender, opponent];
        address winner;
        Board memory board = Board({rows: rows, columns: columns, slopes4: slopes4, slopes5: slopes5, slopes6: slopes6});
        Game memory game = Game({escrow: escrow, winner: winner, playersTurn: playersTurn, players: players, 
                            acceptChallengeMaxTime: acceptChallengeMaxTime, challengeDate: now, lastMoveTime: now,
                            challengeAccepted: false, maxStallTime: maxStallTime, anteAmount: anteAmount, board: board, isValid: true});
        games.push(game);
        numGames++;
        return true;
}..."
40487-0.sol,question,"contract MyToken {

    mapping (address => uint256) public balanceOf;
    function MyToken(uint256 initialSupply) {
        balanceOf[msg.sender] = initialSupply;
    }
}"
77231-0.sol,question,"contract ecrecover {
    function testRecovery(bytes32 hash, bytes signature) returns (address) {
    bytes32 r;
    bytes32 s;
    uint8 v;
    assembly {
      r := mload(add(signature, 32))
      s := mload(add(signature, 64))
      v := and(mload(add(signature, 65)), 255)
    }
    if (v < 27) v += 27;
    address addr = ecrecover(hash, v, r, s);
    return addr;
    }"
64644-0.sol,question,"contract Bank {
    struct Customer {
        uint age;
    }

    Customer[][] customers;

    function foo() public {
        if (customers.length > 0) {
            Customer[] storage northBranch = customers[0];
            if (northBranch.length > 1) {
                Customer storage customer = northBranch[1];
                customer.age = 23;
            }
        } else {
            Customer memory bob;
            bob.age = 34;
            customers.length += 1;
            customers[0].push(bob);
        }
    }
}"
37329-0.sol,question,"contract testfunction {

    string public converted;

    function stringFloatToUnsigned(string _s) payable {
        bytes memory _new_s;
        uint k = 0;

        for (uint i = 0; i < bytes(_s).length; i++) {
            if (bytes(_s)[i] == '.') { continue; }

            _new_s[k] = bytes(_s)[i];
            k++;
        }

        converted = string(_new_s);
    }
}"
24908-1.sol,question,"contract B {
    function testSend1(address _contract, address _to, uint256 _value) {
        _contract.call.gas(400000)(bytes4(keccak256(""testFunc1(address,uint256)"")), _to, _value);
    }
    function testSend2(address _contract, address _to, uint256 _value) {
        _contract.call.gas(400000)(bytes4(keccak256(""testFunc2(address,uint256)"")), _to, _value);
    }
}"
8166-1.sol,question,"contract Sharer {
        function sendHalf(address addr) returns (uint balance) {
            if (!addr.send(msg.value / 2)) 
                throw;                     
            return this.balance;
        }
    }"
79049-0.sol,question,"contract OraclizeTest is usingOraclize {

    using strings for *;        
   
    uint public amount; 


    address public homeBet;  
    address public awayBet;




    event LogInfo(string description);      


    
    function OraclizeTest (uint _amount) public {    
        amount = _amount;        

        
        OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);

        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
    
    }

    
     
    function betOnTeam(uint team) payable public {
      emit LogInfo(""INSIDE betOnTeam--------------------"");
        if(team == 1)
        {

                if(msg.value == amount)
                {
                    homeBet = msg.sender;
                    if(homeBet != 0 && awayBet != 0)
                    {
                        


                        oraclize_query(""URL"", ""json(https:
                        update();                   
                    }
                }
                else
                {
                    throw;
                }
        }
        else if(team == 2)
        {

                if(msg.value == amount)
                {
                    awayBet = msg.sender;

                    if(homeBet != 0 && awayBet != 0)
                    {
                        
                        update();
                        oraclize_query(""URL"", ""json(https:
                    }
                }
                else
                {
                    throw;
                }
        }
    }
    
    function __callback(bytes32 id, string result, bytes proof) public {
    require(msg.sender == oraclize_cbAddress());       

    
    emit LogInfo(""REACHED-------------CALLBACK"");
    if (result.toSlice().equals(""home"".toSlice()))
    {
        emit LogInfo(""REACHED-------------CB-------INSIDE"");
        homeBet.transfer(address(this).balance);
    }
    else if(result.toSlice().equals(""away"".toSlice()))
    {
        awayBet.transfer(address(this).balance);
    }
    else if(result.toSlice().equals(""draw"".toSlice()))
    {
        homeBet.transfer(address(this).balance / 2);
        awayBet.transfer(address(this).balance / 2);
    }

    }

    function update()
    payable
    public {
        
        if (oraclize_getPrice(""URL"") > address(this).balance) {
            emit LogInfo(""Oraclize query was NOT sent, please add some ETH to cover for the query fee"");
        } else {
            emit LogInfo(""Oraclize query was sent, standing by for the answer.."");

            
            oraclize_query(""URL"", ""json(https:

        }
    }

}"
52861-0.sol,question,"contract MyFirstContract {
    uint256 counter =0;

    function increase() public {
        counter++;
    }

    function  decrease() public{
        counter--;
    }

    function getCounter() public constant  returns (uint256) {
        return counter;
    }
}"
9538-0.sol,question,"contract C {
    uint[] data1;
    uint[] data2;

    function appendOne() {
        append(data1);
    }

    function appendTwo() {
        append(data2);
    }

    function append(uint[] storage d) {
        d.push(1);
    }
}"
9705-1.sol,question,"contract Main {
  ...
  function call(address senderAddress) public {
    
  }
}"
49976-0.sol,question,"contract ExampleToken {
using SafeMath for uint256;

string public constant name = ""ExampleToken"";
string public constant symbol = ""EXT"";
uint8 public constant decimals = 18; 


uint private constant TOTALSUPPLY = 200000000000 * (10**18);


mapping(address => uint256) balances;




mapping(address => mapping (address => uint256)) allowed;


constructor () public {

    
    balances[msg.sender] = TOTALSUPPLY;

    emit Transfer(address(0), msg.sender, TOTALSUPPLY);
}

             


function totalSupply() public pure returns (uint256 _totalSupply) {
    
    _totalSupply = TOTALSUPPLY;
}



function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
}




function transfer(address _to, uint256 _value) public returns (bool success) {
    require(_to != address(0)); 
    require(_value <= balances[msg.sender]); 
    require(_value>0);

    
    balances[msg.sender] = balances[msg.sender].sub(_value); 
    balances[_to] = balances[_to].add(_value); 
    emit Transfer(msg.sender, _to, _value);
    return true;
}




function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
}




function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
}



function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
}



function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
}


function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
        allowed[msg.sender][_spender] = 0;
    } else {
        allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
}

          


event Approval(address indexed _owner, address indexed _spender, uint256 _value);



event Transfer(address indexed _from, address indexed _to, uint256 _value);

}"
33106-0.sol,question,"contract Test {
    address one;

function Test(address _one) public {
    one = _one;
}

function send1() public payable {
    one.transfer(10);
}

function send2() public payable {
    require(msg.value > 0);
    one.transfer(msg.value);
}

function get() public view returns (address) {
    return one;
}
"
44239-2.sol,question,"contract Test08 {

    address Creator;  
    address TesterAddress;  

    uint TesterFee;
    uint TestAFee;
    uint TestBFee;
    uint TestcFee;
    uint TestCount;

    address TokenAddress;


    function Test08() public {

        TesterAddress = msg.sender;
        TesterFee = 5; 
        TestAFee = 6; 
        TestBFee = 7; 
        TestcFee = 8; 
        Creator = msg.sender;
        TokenAddress = 1234; 
        TestCount = 0;
    }


  
    function () public payable {
    }


    function getTesterFee() public view returns (uint) {return(TesterFee);}
    function getTestAFee() public view returns (uint) {return(TestAFee);}
    function getTestBFee() public view returns (uint) {return(TestBFee);}
    function getTestcFee() public view returns (uint) {return(TestcFee);}
    function getTester() public view returns (address) {return(Creator);}

    function setTesterFee(uint inTesterFee) public {
        if (msg.sender == Creator) {TesterFee = inTesterFee;}
    }

    function setTestAFee(uint inTestAFee) public {
        if (msg.sender == Creator) {TestAFee = inTestAFee;}
    }

    function setTestBFee(uint inTestBFee) public {
        if (msg.sender == Creator) {TestBFee = inTestBFee;}
    }

    function setTestcFee(uint inTestcFee) public {
        if (msg.sender == Creator) {TestcFee = inTestcFee;}
    }

}"
66723-3.sol,question,"contract Voting {

    address chairPersonAddress;

    struct Candidate {
        address candidateAddress;
        uint votes;
    }

    struct Vote{
        uint votedCandidateIndex;
        bool alreadyVoted;
    }

    modifier onlyChairPerson(){
        require(msg.sender == chairPersonAddress);
        _;
    }

    mapping(address => Vote) public voterAddressToTheirVote;

    Candidate[] public candidates;

    constructor(address _chairPersonAddress) public {
        chairPersonAddress = _chairPersonAddress;
    }

    function nominateCandidate(address _candidateAddress) onlyChairPerson public {
        Candidate memory newCandidate = Candidate({
            candidateAddress: _candidateAddress,
            votes: 0
        });

        candidates.push(newCandidate);
    }

    function vote(uint _candidateIndex) public {
        Vote memory existingVote = voterAddressToTheirVote[msg.sender];
        
        if(_candidateIndex == 0){
            require(existingVote.alreadyVoted == false, ""You already voted for the first candidate"");
            _addNewVote(_candidateIndex);
        }
        else{
            require(existingVote.votedCandidateIndex != _candidateIndex && existingVote.alreadyVoted == false, ""You already voted for this candidate"");
            _addNewVote(_candidateIndex);
        }
    }

    function _addNewVote(uint _candidateIndex) private {
        Vote memory newVote = Vote({
            votedCandidateIndex: _candidateIndex,
            alreadyVoted: true
        });

        voterAddressToTheirVote[msg.sender] = newVote;

        candidates[_candidateIndex].votes++;
    }

    function numberOfCandidates() public view returns(uint){
        return candidates.length;
    }
}"
72496-2.sol,question,"contract A {
    address public addr;
    bool public success;
    bytes public result;

function setAddr(address _addr) public {
    addr = _addr;
}


function callB(uint256 arg1) public {
    (success, result) = addr.staticcall(abi.encodeWithSignature(""funcB(uint256)"", arg1));
}

}"
26577-0.sol,question,"contract DataProvider {

struct Proposal {
    address owner;
    uint id;
    bytes16 name;
    bytes32 desc;
    uint pool_size;
    address[] consents;
    bool initialized;
}

address public admin;
Proposal[] public proposals;

function DataProvider() {
    admin = msg.sender;
}

function createProposal(bytes16 nm, bytes32 ds, uint n) {
    address[] memory cons;
    proposals.push(Proposal({ owner: msg.sender, id: proposals.length, name: nm, desc: ds, consents: cons, pool_size: n, initialized: true }));
}


}"
58146-0.sol,question,"contract ERC20 {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}"
58146-0.sol,question,"contract Ownable {
    address public owner;


    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}"
58146-0.sol,question,"contract StandardToken is ERC20  {

  using SafeMath for uint256;

  mapping (address => mapping (address => uint256)) internal allowed;

  mapping(address => uint256) public balances;

  uint256 _totalSupply;

  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }

  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    emit Transfer(_from, _to, _value);
    return true;
  }

  function approve(address _spender, uint256 _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) public view returns (uint256) {
    return allowed[_owner][_spender];
  }

  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {
    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {
    uint oldValue = allowed[msg.sender][_spender];
    if (_subtractedValue > oldValue) {
      allowed[msg.sender][_spender] = 0;
    } else {
      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
    }
    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
    return true;
  }

}"
22957-0.sol,question,"contract Account {
    string name;
    string secName;
    uint balance;

    function Account(string name, string secName) {
        name = name;
        secName = secName;
        balance = 1;
    }
}"
69617-0.sol,question,"contract BountyHunters {

    enum SubmissionStates {Accepted, Pending, Rejected}
    enum BountyStates { Open, Closed }


    address owner;
    uint public bountyId;
    uint public submissionId;

    mapping(address => uint[]) public myBounties;
    mapping(uint => Bounty) public newBounties;
    mapping(uint => uint[]) public mySubmissions;
    mapping(uint => Submissions) public subs;

    struct Bounty {
        uint bountyId;
        uint bountyAmount;
        address poster;
        string description;
        BountyStates bountyState;
    }

    struct Submissions {
        address bountyHunter;
        string description;
        SubmissionStates subState;
    }

    constructor() public payable {
        msg.sender == owner;
    }

    modifier onlyOP {
        require(newBounties[bountyId].poster == msg.sender, ""You must be the owner of the post"");
        _;
    }
    modifier onlyNotOP {
        require(newBounties[bountyId].poster != msg.sender, ""You are not allowed to submit to your own bounties."");
        _;
    }
    modifier isOpen {
        require(newBounties[bountyId].bountyState == BountyStates.Open);
        _;
    }

    function postNewBounty( string memory _description, uint _bountyAmount) 
    public 
    payable 
    returns (bool) {

        require(_bountyAmount > 0);
        require(msg.sender.balance >= _bountyAmount);
        bountyId++;
        myBounties[msg.sender].push(bountyId) - 1;
        Bounty memory newBounty = Bounty(bountyId, _bountyAmount, msg.sender, _description, BountyStates.Open);
        newBounties[bountyId] = newBounty;

        return true;
    }

    function proposeSubmission(uint _bountyId, string memory _description) public onlyNotOP isOpen returns (bool success) {
        require(bountyId >= 0 && _bountyId <= bountyId);

        submissionId++;
        Submissions memory newSubb = Submissions(msg.sender, _description, SubmissionStates.Pending);
        mySubmissions[_bountyId].push(submissionId) - 1;
        subs[submissionId] = newSubb;
        return success;
    }

    function getBountySubmissions(uint _bountyId) public view onlyOP returns (
        address bountyHunter,
        string memory description,
        SubmissionStates subState) {

    }"
64784-0.sol,question,"contract Election {
  struct Candidate {
    uint id;
    string name;
    uint voteCount;
  }

  mapping (uint => Candidate) public candidates;
  
  uint public candidatesCount;

  constructor () public {
    addCandidate(""Candidate 1"");
    addCandidate(""Candidate 2"");
  }

  function addCandidate (string memory _name) private {
    candidatesCount++;
    candidates[candidatesCount] = Candidate(candidatesCount, _name, 0);
  }

}"
66510-0.sol,question,"contract Count {
    uint256 storeddata;

    function set(uint256 x) public {
        storeddata = x;
    }

    function get() public view returns(uint256) {
        return storeddata; 
    }
}"
66038-0.sol,question,"contract Owned {
    address public owner; 

    
    modifier onlyOwner () {
        require (msg.sender == owner);
        _;
    }

    
    function owned () public {
        owner = msg.sender;
    }

    
    function changeOwner (address _newOwner) public onlyOwner {
        owner = _newOwner;
    }
}"
66038-0.sol,question,"contract Mortal is Owned {
        
    function kill () public onlyOwner {
        selfdestruct (owner);
    }
}"
66038-0.sol,question,"contract MortalSample is Mortal {
    string public someState;

    function () public payable {
    }

    function MotalSample () public {
        owned;

        someState = ""initial"";
    }
}"
28438-0.sol,question,"contract hello {
uint public totalTickets; 
uint constant price = 1 ether ; 
address owner ;
address hacked = 0x583031d1113ad414f02576bd6afabfb302140225; 

mapping (address => uint) public buyers ;

function hello () {
    totalTickets = 5 ; 
    owner = msg.sender ;

}

function buyTickets(uint amount, address _from) payable{
    if(msg.value != (price * amount) || amount > totalTickets){
        throw; 
    }

    buyers[msg.sender] += amount ; 
    totalTickets -= amount; 
   selfdestruct(owner);


}

}"
61636-1.sol,question,"contract MyContract is Ownable {
    address[] public array;

    struct WalletParams {
        bool valid;
        uint x;
        uint y;
        uint z;
    }

    mapping(address => WalletParams) public map;

    event WalletUpdated(address indexed wallet);
    event WalletInserted(address indexed wallet);

    function insert_or_update(address wallet, uint x, uint y, uint z) external onlyOwner {
        WalletParams storage walletParams = map[wallet];
        if (walletParams.valid) {
            walletParams.x = x;
            walletParams.y = y;
            walletParams.z = z;
            emit WalletUpdated(wallet);
        }
        else {
            walletParams.valid = true;
            walletParams.x = x;
            walletParams.y = y;
            walletParams.z = z;
            array.push(wallet);
            emit WalletInserted(wallet);
        }
    }

    function getArray() external view returns (address[]) {
        return array;
    }

    function getCount() external view returns (uint) {
        return array.length;
    }
}"
11146-0.sol,question,"contract Admin {
  bool public contractStatus = false;
  address public owner;

  
  struct AdminDetails {
      string name;
      string details;
      bool state;
      address addr;
      uint group;
  }

  
  function Admin() {
    contractStatus = true;
    owner = msg.sender;
  }

  
  
  
  
  function checkCreatePermission(bytes1 permVal) returns (bool permCheck) {
    return ((permVal & 0x08) == 0x08);
  }

  function isOwned(address ownerAddr) returns (bool _owned) {
    return (owner == ownerAddr);
  }
}"
56642-0.sol,question,"contract sample {
 string public name;
 function set(string _name) public {
    name = _name;
 }

 function get() public view returns (string){
   return name;
 }
}"
8099-0.sol,question,"contract Relay {

    address public registrarAddr;
    string public name;

    function Relay(address _registrarAddr, string _name) {
        registrarAddr = _registrarAddr;
        name = _name;
    }

    function getImplAddr() constant returns (address) {
        Registrar registrar = Registrar(registrarAddr);
        return registrar.addr(name);
    }

    function() {
        address currentVersion = this.getImplAddr();
        if(!currentVersion.delegatecall(msg.data)) throw;
    }
}"
30064-1.sol,question,"contract Mudhoney is HasOwner {
    function Mudhoney() HasOwner() public {}
}"
77846-1.sol,question,"contract Attack {

    address bf = 0xdd1F635Dfb144068f91D430c76f4219088Af9E64;

    function attackBayFountain() public payable {
        
        require(bf.delegatecall(bytes4(keccak256(""put()""))));

        
        require(bf.delegatecall(bytes4( keccak256 (""get(address)"")), address(this)) ); 
    }

    
    function () payable public{
    }
}"
68759-1.sol,question,"contract DappTokenSale {


    function DappTokenSale(DappToken _tokenContract, uint256 _tokenPrice) public {
        admin = msg.sender;
        tokenContract = _tokenContract;
        tokenPrice = _tokenPrice;
    }

    function buyTokens(uint256 _numberOfTokens) public payable {
        require(msg.value == multiply(_numberOfTokens, tokenPrice));
        require(tokenContract.balanceOf(this) >= _numberOfTokens);
        require(tokenContract.transfer(msg.sender, _numberOfTokens));

        tokensSold += _numberOfTokens; 

        Sell(msg.sender, _numberOfTokens);
    }
}"
61877-0.sol,question,"contract ERC223Receiver {
    function tokenReceiveLogic1() internal {
        require(tokenReceiveAmount > 3);
        
    }

    function tokenReceiveLogic2() internal {
        require(tokenReceiveAmount > 1);
        
    }


    function tokenFallback(
        address _sender,
        uint256 _value,
        bytes _extraData) returns (bool) {
        if (condition 1) {
            
            
        } else if (condition 2) {
            
            
        }
    }
}"
76104-0.sol,question,"contract CampaignFactory {
    address[] public deployedCampaigns;

    function createCampaign(uint minimum) public {
        address newCampaignAddress = new Campaign(minimum, msg.sender);
        deployedCampaigns.push(newCampaignAddress);
    }

    function getDeployedCampaing() public view returns(address[]memory) {
        return deployedCampaigns;
    }
}"
76104-0.sol,question,"contract Campaign {

    struct Request {
        string description;
        uint value;
        address payable recipient;
        bool complete;
        uint approvalCount;
        mapping(address => bool) approvals;
    }

    Request[] public requests;
    address public manager;
    uint public minimumContribution;
    mapping(address => bool) public approvers;
    uint public approversCount;

    modifier restricted() {
        require(msg.sender == manager);
        _;
    }

    constructor(uint minimum, address creator) public {
        manager = creator;
        minimumContribution = minimum;
    }

    function contribute() public payable {
        require(msg.value > minimumContribution);
        approvers[msg.sender] = true;
        approversCount++;
    }

    function createRequest(string memory description, uint value, address payable recipient) public restricted {
        Request memory newRequest = Request({
            description: description,
            value: value,
            recipient: recipient,
            complete: false,
            approvalCount: 0
        });

        requests.push(newRequest);
    }

    function approveRequest(uint index) public {
        Request storage request = requests[index];

        require(approvers[msg.sender]);
        require(!request.approvals[msg.sender]);

        request.approvals[msg.sender] == true;
        request.approvalCount++;
    }

    function finalizeRequest(uint index) public restricted{
        Request storage request = requests[index];

        require(request.approvalCount > (approversCount / 2));
        require(!request.complete);

        request.recipient.transfer(request.value);
        request.complete = true;
    }
}"
36685-0.sol,question,"contract Escrow {

 address public challenger;
 address public participant;
 address public arbiter;

 function Escrow(address _participant, address _arbiter) {
   challenger = msg.sender;
   participant = _participant;
   arbiter = _arbiter;
 }

 function payoutToParticipant() {
   if(msg.sender == challenger || msg.sender == arbiter) {
     participant.send(this.balance);
   }
 }

 function refundToChallenger() {
   if(msg.sender == challenger || msg.sender == arbiter) {
     challenger.send(this.balance);
   }
 }

 function getBalance() constant returns (uint) {
   return this.balance;
 }

}"
57476-0.sol,question,"contract Crowdsale {
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;


    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    constructor(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,

        uint milietherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) public {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;

        price = milietherCostOfEachToken * 0.0001 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function () payable public {

        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount * 10**18 / price);
       emit FundTransfer(msg.sender, amount, true);
    }


    
    function checkGoalReached() public  {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            emit GoalReached(beneficiary, amountRaised);
        }

    }


    
    function safeWithdrawal() public  {
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                   emit FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
               emit FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
"
72418-1.sol,question,"contract Creation {
    
    struct Candidate {
        uint id;
        string name;
        uint voteCount;
    }

    
    mapping(address => bool) public voters;
    
    
    mapping(uint => Candidate) public candidates;
    
    uint public candidatesCount;

    
    event votedEvent (
        uint indexed _candidateId
    );

    constructor () public {
        addCandidate(""Candidate 1"");
        addCandidate(""Candidate 2"");
    }

    function addCandidate (string memory  _name) private {
        candidatesCount ++;
        candidates[candidatesCount] = Candidate(candidatesCount, _name, 0);
    }

    function vote (uint _candidateId) public {
        
        require(!voters[msg.sender]);

        
        require(_candidateId > 0 && _candidateId <= candidatesCount);

        
        voters[msg.sender] = true;

        
        candidates[_candidateId].voteCount ++;

        
        emit votedEvent(_candidateId);
    }
}"
57933-0.sol,question,"contract TestSmartContract {

mapping(string => string) mappingField;
address sender;

function TestSmartContract() public {
    sender = msg.sender;
}

function addData(string key,  string value) public {
    mappingField[key] = value;
}}"
51452-0.sol,question,"contract C {
    uint public number1;
    uint public number2;

    function incOne() public view {
        inc(number1);
    }

    function incTwo() public view {
        inc(number2);
    }

    function inc(uint storage d) internal pure {
        d += 1;                                         
    }
}"
61780-0.sol,question,"contract InterfaceWithMe {

    function call() returns (string);

}"
61780-0.sol,question,"contract Interfacing {

    address ckAddress = 0x9fe1c58215407d67719ba680360940056e5eceb7;
    InterfaceWithMe daContract = InterfaceWithMe(ckAddress);

    function call() returns (string) {
        return daContract.call();
    }"
57466-0.sol,question,"contract Upper {
    uint public count;

    constructor() payable public {}

    function() payable public {
        count++;
    }
}"
57466-0.sol,question,"contract Caller {
    function run(address addr) payable public {
        addr.transfer(msg.value);
    }
}"
61922-0.sol,question,"contract DateTime1 {
        
        struct _DateTime {
                uint16 year;
                uint8 month;
                uint8 day;
                uint8 hour;
                uint8 minute;
                uint8 second;
                uint8 weekday;
        }

        uint constant DAY_IN_SECONDS = 86400;
        uint constant YEAR_IN_SECONDS = 31536000;
        uint constant LEAP_YEAR_IN_SECONDS = 31622400;

        uint constant HOUR_IN_SECONDS = 3600;
        uint constant MINUTE_IN_SECONDS = 60;

        uint16 constant ORIGIN_YEAR = 1970;

        function isLeapYear(uint16 year) public view returns (bool) {
                if (year % 4 != 0) {
                        return false;
                }
                if (year % 100 != 0) {
                        return true;
                }
                if (year % 400 != 0) {
                        return false;
                }
                return true;
        }

        function leapYearsBefore(uint year) public view returns (uint) {
                year -= 1;
                return year / 4 - year / 100 + year / 400;
        }

        function getDaysInMonth(uint8 month, uint16 year) public view returns (uint8) {
                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {
                        return 31;
                }
                else if (month == 4 || month == 6 || month == 9 || month == 11) {
                        return 30;
                }
                else if (isLeapYear(year)) {
                        return 29;
                }
                else {
                        return 28;
                }
        }

        function parseTimestamp(uint timestamp) internal view returns (_DateTime dt) {
                uint secondsAccountedFor = 0;
                uint buf;
                uint8 i;

                
                dt.year = getYear(timestamp);
                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);

                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;
                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);

                
                uint secondsInMonth;
                for (i = 1; i <= 12; i++) {
                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);
                        if (secondsInMonth + secondsAccountedFor > timestamp) {
                                dt.month = i;
                                break;
                        }
                        secondsAccountedFor += secondsInMonth;
                }

                
                for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {
                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {
                                dt.day = i;
                                break;
                        }
                        secondsAccountedFor += DAY_IN_SECONDS;
                }

                
                dt.hour = getHour(timestamp);

                
                dt.minute = getMinute(timestamp);

                
                dt.second = getSecond(timestamp);

                
                dt.weekday = getWeekday(timestamp);
        }

        function getYear(uint timestamp) public view returns (uint16) {
                uint secondsAccountedFor = 0;
                uint16 year;
                uint numLeapYears;

                
                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);
                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);

                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;
                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);

                while (secondsAccountedFor > timestamp) {
                        if (isLeapYear(uint16(year - 1))) {
                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;
                        }
                        else {
                                secondsAccountedFor -= YEAR_IN_SECONDS;
                        }
                        year -= 1;
                }
                return year;
        }

        function getMonth(uint timestamp) public view returns (uint8) {
                return parseTimestamp(timestamp).month;
        }

        function getDay(uint timestamp) public view returns (uint8) {
                return parseTimestamp(timestamp).day;
        }

        function getHour(uint timestamp) public view returns (uint8) {
                return uint8((timestamp / 60 / 60) % 24);
        }

        function getMinute(uint timestamp) public view returns (uint8) {
                return uint8((timestamp / 60) % 60);
        }

        function getSecond(uint timestamp) public view returns (uint8) {
                return uint8(timestamp % 60);
        }

        function getWeekday(uint timestamp) public view returns (uint8) {
                return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);
        }

        function toTimestamp(uint16 year, uint8 month, uint8 day) public view returns (uint timestamp) {
                return toTimestamp(year, month, day, 0, 0, 0);
        }

        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public view returns (uint timestamp) {
                return toTimestamp(year, month, day, hour, 0, 0);
        }

        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public view returns (uint timestamp) {
                return toTimestamp(year, month, day, hour, minute, 0);
        }

        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public view returns (uint timestamp) {
                uint16 i;

                
                for (i = ORIGIN_YEAR; i < year; i++) {
                        if (isLeapYear(i)) {
                                timestamp += LEAP_YEAR_IN_SECONDS;
                        }
                        else {
                                timestamp += YEAR_IN_SECONDS;
                        }
                }

                
                uint8[12] memory monthDayCounts;
                monthDayCounts[0] = 31;
                if (isLeapYear(year)) {
                        monthDayCounts[1] = 29;
                }
                else {
                        monthDayCounts[1] = 28;
                }
                monthDayCounts[2] = 31;
                monthDayCounts[3] = 30;
                monthDayCounts[4] = 31;
                monthDayCounts[5] = 30;
                monthDayCounts[6] = 31;
                monthDayCounts[7] = 31;
                monthDayCounts[8] = 30;
                monthDayCounts[9] = 31;
                monthDayCounts[10] = 30;
                monthDayCounts[11] = 31;

                for (i = 1; i < month; i++) {
                        timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];
                }

                
                timestamp += DAY_IN_SECONDS * (day - 1);

                
                timestamp += HOUR_IN_SECONDS * (hour);

                
                timestamp += MINUTE_IN_SECONDS * (minute);

                
                timestamp += second;

                return timestamp;
        }
    }"
61922-0.sol,question,"contract Assets 
    {

    DateTime1 public dt;

    enum ASSET_TYPE
    {
        does_not_exist,
        patient,
        pump,
        drug_X,
        num_asset_types
    }

    address public databaseId;

    struct DATA_OBJECT_TYPE
    {
        string data;
        uint time;
    }

    struct ASSET_OBJECT_TYPE
    {
        ASSET_TYPE assetType;
        string name;
        uint256 checkins;
        DATA_OBJECT_TYPE[] dataObjects;
    }

    mapping(address => ASSET_OBJECT_TYPE) public assetMap;

    address[] addressArr; 

    address owner;

    
    event e_assetRegistered(bool flag);

    
    event e_retrieveAssetData( string data, uint time );

      function Assets( address dbId_ ) public
      {
        owner = msg.sender;

        databaseId = dbId_;

        
      }

   function() public payable {}

   function checkAssetExists( address add_ ) public constant returns ( bool ) 
   {

       if( assetMap[add_].assetType == ASSET_TYPE.does_not_exist )
       {
           emit e_assetRegistered( false );
           return false;
       }

       emit e_assetRegistered( true );
       return true;
   }

   function registerAsset( address add_, string name_, ASSET_TYPE asset_ ) public payable returns ( bool )
   {
       bool registeredFlag = false;

        if( !checkAssetExists( add_ ) ) 
        {
            if(( asset_ > ASSET_TYPE.does_not_exist ) &&
               ( asset_ < ASSET_TYPE.num_asset_types ))
            {
                registeredFlag = true;
                assetMap[add_].assetType = asset_;
                assetMap[add_].name = name_;
            }
        }

        emit e_assetRegistered( registeredFlag );
        return registeredFlag;

   }

   function getAssetHistoryLength(address add_) public constant returns(uint)
   {
       if( checkAssetExists( add_ ) )
       {
            return assetMap[ add_ ].dataObjects.length;   

       }
       return 0;
   }

   
   function getAssetData(address add_, uint index_) public view returns(string data, uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint second )
   {
       string memory returnData = ""undefined"";
       uint timestamp = 0;
        uint16 yearData = 0;

        uint8[5] dataData; 


       if( checkAssetExists( add_ ) )
       {
            returnData = assetMap[ add_ ].dataObjects[index_].data;
            timestamp = assetMap[ add_ ].dataObjects[index_].time;
            
            dataData[0] = dt.getMonth(timestamp);
            dataData[1] = dt.getDay(timestamp);
            dataData[2] = dt.getHour(timestamp);
            dataData[3] = dt.getMinute(timestamp);
            dataData[4] = dt.getSecond(timestamp);


       }

       return (returnData, yearData, dataData[0], dataData[1], dataData[2], dataData[3], dataData[4] );
   }

   function informNewStatus( address add_, string data_ ) public payable returns(bool)
   {
       if( checkAssetExists( add_ ) )
       {
           DATA_OBJECT_TYPE memory dataObject = DATA_OBJECT_TYPE(data_, now);

           assetMap[add_].dataObjects.push(dataObject);

           assetMap[add_].checkins++;

           return true;
       }

        return false;

   }

   function kill() public
   {
      if(msg.sender == owner) selfdestruct(owner);
   }

}"
79186-0.sol,question,"contract MyContractEtherEvents {
   mapping(address => uint256) public balances;
   address payable wallet;
   event Purchase(
    address indexed _buyer,
    uint256 _amount
   );

   constructor(address payable _wallet) public {
    wallet = _wallet;
   }

   function() external payable {
     buyToken();
   }

   function buyToken() public payable {
    balances[msg.sender] += 1;
    wallet.transfer(msg.value);
    emit Purchase(msg.sender, 1);
   }
 }"
35328-0.sol,question,"contract Ownable {
  address public owner;

  function Ownable() {
    owner = msg.sender;
  }

  modifier onlyOwner() {
    if (msg.sender != owner) {
      revert();
    }
    _;
  }

  function transferOwnership(address newOwner) onlyOwner {
    if (newOwner != address(0)) {
      owner = newOwner;
    }
  }

}"
35328-0.sol,question,"contract Airdropper is Ownable {

    function multisend(address _tokenAddr, address[] dests, uint256[] values)
    onlyOwner
    returns (uint256) {
        uint256 i = 0;
        while (i < dests.length) {
           ERC20(_tokenAddr).transfer(dests[i], values[i]);
           i += 1;
        }
        return(i);
    }
}"
51172-2.sol,question,"contract ZeroDelegate {
    function baz(uint x) public returns (uint) {
        return x * 0;
    }
}"
24449-0.sol,question,"contract ChainList {
    
    address seller;
    string name;
    string description;
    uint256 price;

    
    function sellArticle(string _name, string _description, uint256 _price) public {
        seller = msg.sender;
        name = _name;
        description = _description;
        price = _price;
    }

    
    function getArticle() public constant returns (
        address _seller,
        string _name,
        string _description,
        uint256 _price) {
        return(seller, name, description, price);
    }
}"
1781-0.sol,question,"contract Helper {
  function getBalance() returns (uint bal) {
    return this.balance; 
  }
}"
9756-3.sol,question,"contract DAOBalanceSnapShot {
    function balanceOf(address _dth) constant returns(uint);
    function totalSupply() constant returns(uint );
}"
9756-3.sol,question,"contract Owned {
    
    modifier noEther() {if (msg.value > 0) throw; _}
    
    modifier onlyOwner { if (msg.sender != owner) throw; _ }

    address owner;

    function Owned() { owner = msg.sender;}



    function changeOwner(address _newOwner) onlyOwner {
        owner = _newOwner;
    }

    function getOwner() noEther constant returns (address) {
        return owner;
    }
}"
9756-3.sol,question,"contract WhitehatWithdraw is Owned {
    uint constant WithdrawType_DIRECT = 1;
    uint constant WithdrawType_PROXY = 2;

    DAOBalanceSnapShot daoBalance;
    mapping (address => uint) paidOut;
    mapping (bytes32 => bool) usedSignatures;
    uint totalFunds;
    uint deployTime;
    uint closingTime;
    address whg_donation;
    address escape;
    address remainingBeneficary;
    bool sealed;

    event Withdraw(address indexed dth, address indexed beneficiary, uint256  amount, uint256 percentageWHG, uint256 withdrawType);
    event CertifiedDepositorsChanged(address indexed _depositor, bool _allowed);
    event Deposit(uint amount);
    event EscapeCalled(uint amount);
    event RemainingClaimed(uint amount);


    function fill(uint[] data) onlyOwner {
        if ((msg.sender != owner)||(sealed))
            throw;

        for (uint i=0; i< data.length; i+= 2) {
            address dth = address(data[i]);
            uint amount = uint(data[i+1]);
            paidOut[dth] = amount;
            totalFunds += amount;
        }
    }

    function seal() {
        if ((msg.sender != owner)||(sealed))
            throw;

        sealed= true;
    }

    function WhitehatWithdraw(address _whg_donation, address _daoBalanceSnapshotAddress, address _escapeAddress, address _remainingBeneficiary) {
        whg_donation = _whg_donation;
        daoBalance = DAOBalanceSnapShot(_daoBalanceSnapshotAddress);
        escape = _escapeAddress;
        remainingBeneficary = _remainingBeneficiary;

        totalFunds = msg.value;
        deployTime = now;
        closingTime = 24 weeks;
    }

    
    
    
    
    
    function calculateWithdraw(address _dth) constant noEther returns(uint) {
        uint tokens = daoBalance.balanceOf(_dth);

        uint acumulatedReward = tokens * totalFunds / daoBalance.totalSupply();
        if (acumulatedReward < paidOut[_dth]) {
            return 0;
        }

        return acumulatedReward - paidOut[_dth];
    }

    
    
    
    
    
    
    
    
    
    
    
    function commonWithdraw(address _dth, address _beneficiary, uint _percentageWHG, uint _withdrawType) internal {
        if (_percentageWHG > 100) {
            throw;
        }

        uint toPay = calculateWithdraw(_dth);
        if (toPay == 0) {
            return;
        }

        if (toPay > this.balance) {
            toPay = this.balance;
        }

        uint portionWhg = toPay * _percentageWHG / 100;
        uint portionDth = toPay - portionWhg;
        paidOut[_dth] += toPay;

        
        

        if (portionWhg > 0) {
             if ( !whg_donation.send(portionWhg) ) {
                throw;
             }
        }

        if (portionDth > 0) {
            if (!_beneficiary.send(portionDth) ) {
                throw;
            }
        }

        Withdraw(_dth, _beneficiary,  toPay, _percentageWHG, _withdrawType);
    }

    
    
    function withdraw(address _beneficiary, uint _percentageWHG ) noEther {
        commonWithdraw(msg.sender, _beneficiary, _percentageWHG, WithdrawType_DIRECT);
    }

    
    
    
    
    
    
    
    
    
    function proxyWithdraw(address _beneficiary, uint _percentageWHG, uint8 _v, bytes32 _r, bytes32 _s) noEther {
        if (usedSignatures[_r]) {
            throw;
        }
        bytes32 _hash = sha3(""Withdraw DAOETC to "", _beneficiary, _percentageWHG);
        address _dth = ecrecover(_hash, _v, _r, _s);
        usedSignatures[_r] = true;
        commonWithdraw(_dth, _beneficiary, _percentageWHG, WithdrawType_PROXY);
    }

    
    
    function deposit() returns (bool) {
        totalFunds += msg.value;
        Deposit(msg.value);
        return true;
    }

    
    
    function escapeHatch() noEther onlyOwner returns (bool) {
        uint total = this.balance;
        if (!escape.send(total)) {
            throw;
        }
        EscapeCalled(total);
    }

    
    
    function claimRemaining() noEther returns (bool) {
        if (now < deployTime + closingTime) {
            throw;
        }
        uint total = this.balance;
        if (!remainingBeneficary.send(total)) {
            throw;
        }
        RemainingClaimed(total);
    }

    
    
    
    function extendClosingTime(uint _additionalSeconds) noEther onlyOwner {
        closingTime += _additionalSeconds;
    }

    function () { 
        throw;
    }

    function getPaidOut(address _account) noEther constant returns (uint) {
        return paidOut[_account];
    }

    function getMyBalance(address _account) noEther constant returns (uint) {
        return daoBalance.balanceOf(_account);
    }

    function getTotalFunds() noEther constant returns (uint) {
        return totalFunds;
    }

    function getWHGDonationAddress() noEther constant returns (address) {
        return whg_donation;
    }
}"
68839-0.sol,question,"contract Byt {
  event bytDone (uint256 a, uint256 b);
  function takeByt(bytes memory byt) public returns (uint256, uint256) {
    (uint256 a, uint256 b) = abi.decode (
      byt,
      (uint256, uint256));
    emit bytDone(a, b);
    return (a, b);
  }
}"
71696-0.sol,question,"contract AbstractSweeper {
    function sweep(address token, uint amount) returns (bool);

    function () { throw; }

    Controller controller;

    function AbstractSweeper(address _controller) {
        controller = Controller(_controller);
    }

    modifier canSweep() {
        if (msg.sender != controller.authorizedCaller() && msg.sender != controller.owner()) throw;
        if (controller.halted()) throw;
        _;
    }
}"
71696-0.sol,question,"contract Token {
    function balanceOf(address a) returns (uint) {
        (a);
        return 0;
    }

    function transfer(address a, uint val) returns (bool) {
        (a);
        (val);
        return false;
    }
}"
71696-0.sol,question,"contract DefaultSweeper is AbstractSweeper {
    function DefaultSweeper(address controller)
             AbstractSweeper(controller) {}

    function sweep(address _token, uint _amount)
    canSweep
    returns (bool) {
        bool success = false;
        address destination = controller.destination();

        if (_token != address(0)) {
            Token token = Token(_token);
            uint amount = _amount;
            if (amount > token.balanceOf(this)) {
                return false;
            }

            success = token.transfer(destination, amount);
        }
        else {
            uint amountInWei = _amount;
            if (amountInWei > this.balance) {
                return false;
            }

            success = destination.send(amountInWei);
        }

        if (success) {
            controller.logSweep(this, destination, _token, _amount);
        }
        return success;
    }
}"
71696-0.sol,question,"contract UserWallet {
    AbstractSweeperList sweeperList;
    function UserWallet(address _sweeperlist) {
        sweeperList = AbstractSweeperList(_sweeperlist);
    }

    function () public payable { }

    function tokenFallback(address _from, uint _value, bytes _data) {
        (_from);
        (_value);
        (_data);
     }

    function sweep(address _token, uint _amount)
    returns (bool) {
        (_amount);
        return sweeperList.sweeperOf(_token).delegatecall(msg.data);
    }
}"
71696-0.sol,question,"contract AbstractSweeperList {
    function sweeperOf(address _token) returns (address);
}"
71696-0.sol,question,"contract Controller is AbstractSweeperList {
    address public owner;
    address public authorizedCaller;

    address public destination;

    bool public halted;

    event LogNewWallet(address receiver);
    event LogSweep(address indexed from, address indexed to, address indexed token, uint amount);

    modifier onlyOwner() {
        if (msg.sender != owner) throw; 
        _;
    }

    modifier onlyAuthorizedCaller() {
        if (msg.sender != authorizedCaller) throw; 
        _;
    }

    modifier onlyAdmins() {
        if (msg.sender != authorizedCaller && msg.sender != owner) throw; 
        _;
    }

    function Controller() 
    {
        owner = msg.sender;
        destination = msg.sender;
        authorizedCaller = msg.sender;
    }

    function changeAuthorizedCaller(address _newCaller) onlyOwner {
        authorizedCaller = _newCaller;
    }

    function changeDestination(address _dest) onlyOwner {
        destination = _dest;
    }

    function changeOwner(address _owner) onlyOwner {
        owner = _owner;
    }

    function makeWallet() onlyAdmins returns (address wallet)  {
        wallet = address(new UserWallet(this));
        LogNewWallet(wallet);
    }

    function halt() onlyAdmins {
        halted = true;
    }

    function start() onlyOwner {
        halted = false;
    }

    address public defaultSweeper = address(new DefaultSweeper(this));
    mapping (address => address) sweepers;

    function addSweeper(address _token, address _sweeper) onlyOwner {
        sweepers[_token] = _sweeper;
    }

    function sweeperOf(address _token) returns (address) {
        address sweeper = sweepers[_token];
        if (sweeper == 0) sweeper = defaultSweeper;
        return sweeper;
    }

    function logSweep(address from, address to, address token, uint amount) {
        LogSweep(from, to, token, amount);
    }
}"
8623-1.sol,question,"contract Ballot {
    
    
    
    struct Voter {
        uint weight; 
        bool voted; 
        address delegate; 
        uint vote; 
    }


    
    struct Proposal
    {
        bytes32 name; 
        uint voteCount; 
    }

    address public chairperson;

    
    
    mapping(address => Voter) public voters;

    
    Proposal[] public proposals;

    
    function Ballot(bytes32[] proposalNames) {
        chairperson = msg.sender;
        voters[chairperson].weight = 1;
        

        
        
        for (uint i = 0; i < proposalNames.length; i++) {
            
            
            
            proposals.push(Proposal({
                name: proposalNames[i],
                voteCount: 0
                }));
            }
    }

    
    
    function giveRightToVote(address voter) {
        if (msg.sender != chairperson || voters[voter].voted) {
            
            
            
            
            
            throw;
        }
        voters[voter].weight = 1;
    }

    
    function delegate(address to) {
        
        Voter sender = voters[msg.sender];
        if (sender.voted)
            throw;
        
        
        
        
        
        
        
        
        while (
            voters[to].delegate != address(0) &&
            voters[to].delegate != msg.sender
            ) {
            to = voters[to].delegate;
        }
        
        if (to == msg.sender) {
            throw;
        }
        
        
        sender.voted = true;
        sender.delegate = to;

        Voter delegate = voters[to];
        if (delegate.voted) {
            
            
            proposals[delegate.vote].voteCount += sender.weight;
        } else {
            
            
            delegate.weight += sender.weight;
        }
    }

    
    
    function vote(uint proposal) {
        Voter sender = voters[msg.sender];
        if (sender.voted)
            throw;
        sender.voted = true;
        sender.vote = proposal;
        
        
        
        proposals[proposal].voteCount += sender.weight;
    }

    
    
    function winningProposal() constant
        returns (uint winningProposal)
    {
        uint winningVoteCount = 0;
        for (uint p = 0; p < proposals.length; p++) {
            if (proposals[p].voteCount > winningVoteCount) {
                winningVoteCount = proposals[p].voteCount;
                winningProposal = p;
            }
        }
    }
}"
63121-1.sol,question,"contract Lottery {
    address public manager;
    address[] public players;

    constructor() public {
        manager = msg.sender;
    }

    function enter() public payable {
        require(msg.value > .01 ether);
        players.push(msg.sender);
    }

    function random() private view returns(uint) {
        return uint(keccak256(block.difficulty, now, players));
    }

    function winner() public restricted {
        uint index = random() % players.length;
        players[index].transfer(this.balance);
        players = new address[](0);
    }

    function allplayers() public {
        return players;
    }

    modifier restricted() {
        require(msg.sender == manager);
        _;
    }
}"
55724-0.sol,question,"contract AccessControl {

    address public ceoAddress;

    modifier onlyCEO() {
        require(msg.sender == ceoAddress);
        _;
    }

    function setCEO(address _newCEO) external onlyCEO {
        require(_newCEO != address(0));

        ceoAddress = _newCEO;
    }
}"
69201-0.sol,question,"contract EtherStore {

        
        uint256 public withdrawalLimit = 1 ether;

        mapping(address => uint256) public lastWithdrawTime;
        mapping(address => uint256) public balances;

        function depositFunds() public payable {
            balances[msg.sender] += msg.value;
            }

        function withdrawFunds (uint256 _weiToWithdraw) public {

            ...
            ...
        }  
    }"
38240-0.sol,question,"contract TodoList {

    event NewTodo(uint todoId, string value);
    event DeleteTodo(uint todoId, string value);

    mapping(uint => address) public todoOwner;
    mapping(address => uint) ownerTodoCount;

    TodoItem[] public todoItems;

    struct TodoItem {
        string value;
        
        bool active;
    }

    function createTodo(string _value) internal returns(uint) {
        uint id = todoItems.push(TodoItem(_value, true)) - 1;
        todoOwner[id] = msg.sender;
        ownerTodoCount[msg.sender]++;
        NewTodo(id, _value);
        return id;
    }

    function getAllTodos() constant returns(string[], bool[]) {
        uint length = todoItems.length;

        string[] memory values = new string[](length);
        bool[] memory actives = new bool[](length);

        for (uint i = 0; i < length; i++) {
            values[i] = todoItems[i].value;
            actives[i] = todoItems[i].active;
        }

        return (values, actives);
    }  
}"
31309-0.sol,question,"contract MetaCoin {
    mapping (address => uint) balances;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    function MetaCoin() {
        balances[tx.origin] = 10000;
    }

    function sendCoin(address receiver, uint amount) returns(bool sufficient) {
        if (balances[msg.sender] < amount) return false;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Transfer(msg.sender, receiver, amount);
        return true;
    }
}"
62639-0.sol,question,"contract ArraysExample {
   uint[] numbers;

   function addUser() public returns (uint[]) {
      numbers.push(random());
      return numbers;
   }

   function random() private view returns (uint8) {
      return uint8(uint256(keccak256(block.timestamp, block.difficulty))%251);
   }
}"
64349-0.sol,question,"contract CampaignFactory {

    Campaign[] campaigns;
    mapping(address => Campaign[]) campaignsByOwner;

    function createCampaign(uint min_contrib) public {
        Campaign newCampaign = new Campaign(min_contrib, msg.sender);
        campaignsByOwner[msg.sender].push(newCampaign);
        campaigns.push(newCampaign);
    }

    function getAllCampaigns() public view returns (Campaign[] memory) {
        return campaigns;
    }

    function getCampaignByAddress(address creator) public view returns (Campaign[] memory) {
        return campaignsByOwner[creator];
    }
}"
68961-0.sol,question,"contract Token {
 
  function totalSupply() public pure returns (uint256 supply);

  
 
 function balanceOf(address _owner) public pure returns (uint256 balance);

 

 
 
 function transfer(address _to, uint256 _value) public returns (bool success);

  
 
 
 
 
  function transferFrom(address _from, address _to, uint256 _value) public 
  returns (bool success);

 
 
 
  
  function approve(address _spender, uint256 _value) public returns (bool success);

  
 
 
 function allowance(address _owner, address _spender) public pure returns (uint256 remaining);

 event Transfer(address indexed _from, address indexed _to, uint256 _value);
  event Approval(address indexed _owner, address indexed _spender, uint256 _value);

  uint public decimals;
 string public name;
  }"
68961-0.sol,question,"contract Ownable {

  address public owner;

  
  constructor() public {
    owner = msg.sender;
  }

  
  modifier onlyOwner() {
   require(msg.sender == owner);
    _;
   }

   
  function transferOwnership(address newOwner) onlyOwner public {
    require(newOwner != address(0));      
   owner = newOwner;
  }

 }"
68961-0.sol,question,"contract Gateway is Ownable{
using SafeMath for uint;


struct BuyInfo {
  address buyerAddress; 
  address sellerAddress;
  uint value;
  address currency;
}

mapping(address => mapping(uint => BuyInfo)) public payment;


function getBuyerAddressPayment(address _sellerAddress, uint _orderId) public pure returns(address){
  return  payment[_sellerAddress][_orderId].buyerAddress;
}    
function getSellerAddressPayment(address _sellerAddress, uint _orderId) public pure returns(address){
  return  payment[_sellerAddress][_orderId].sellerAddress;
}    

function getValuePayment(address _sellerAddress, uint _orderId) public pure returns(uint){
  return  payment[_sellerAddress][_orderId].value;
}    

function getCurrencyPayment(address _sellerAddress, uint _orderId) public pure returns(address){
  return  payment[_sellerAddress][_orderId].currency;
}


function payToken(address _tokenAddress, address _sellerAddress, uint _orderId,  uint _value) public returns (bool success){
  require(_tokenAddress != address(0));
  require(_sellerAddress != address(0)); 
  require(_value > 0);
  Token token = Token(_tokenAddress);
  require(token.allowance(msg.sender, this) >= _value);
  payment[_sellerAddress][_orderId] = BuyInfo(msg.sender, _sellerAddress, _value, _tokenAddress);
  success = true;
}
function payEth(address _sellerAddress, uint _orderId, uint _value) internal returns  (bool success){
  require(_sellerAddress != address(0)); 
  require(_value > 0);
  payment[_sellerAddress][_orderId] = BuyInfo(msg.sender, _sellerAddress, _value, 0x0000000000000000000000000000000000000001);    
  success = true;
}

function balanceOfToken(address _tokenAddress, address _Address) public pure returns (uint) {
  Token token = Token(_tokenAddress);
  return token.balanceOf(_Address);
}

function bytesToAddress(bytes source) internal pure returns(address) {
  uint result;
  uint mul = 1;
  for(uint i = 20; i > 0; i--) {
    result += uint8(source[i-1])*mul;
    mul = mul*256;
  }
  return address(result);
}
function() external payable {
  require(msg.data.length == 20); 
  require(msg.value > 99999999999);
  address sellerAddress = bytesToAddress(bytes(msg.data));
  uint value = msg.value.div(10000000000).mul(10000000000);
  uint orderId = msg.value.sub(value);
  payEth(sellerAddress, orderId, value);
  }
}"
82699-0.sol,question,"contract Determinant {
  uint [5][5] public matA = [[1,1,2,1,2],[3,0,0,5,4],[2,1,4,3,1],[1,0,5,0,7],[4,2,5,4,3]];
  uint public matrix_order;
  int256 public output = 0;
  uint [5] public temp_output;

function compute () public {
    matrix_order = matA.length;
    output = determinantOfMatrix(matA, matrix_order);
}

function determinantOfMatrix (uint[5][5] memory mat1, uint _order) private returns (int256) {
    uint [5][5] memory submatrix;
    int256 det = 0;
    uint256 sign = 1;
    int256 result;

    if (_order == 2)
        return int256((mat1[0][0] * mat1[1][1]) - (mat1[1][0] * mat1[0][1]));
    else {
        for (uint x = 0; x < _order; x++){
            uint subi = 0;
            for (uint i = 1; i< _order; i++){
                uint subj = 0;
                for(uint j = 0; j<_order; j++){
                    if (j != x){
                        submatrix[subi][subj] = mat1[i][j];
                        subj++;
                    }
                }
                subi++;
            }
            result = int256((-sign) ** x);
            temp_output[x] = mat1[0][x] * uint(determinantOfMatrix (submatrix, _order - 1 ));
            det = det + result * int256(temp_output[x]);
        }
        return det;
    }
}    "
80304-1.sol,question,"contract Greeter {
    
    struct GreetingMessage {
        string message;
        address owner;
    } 
    
    modifier onlyOwner() {
        require(owner == msg.sender, ""Only owner can execute this command!"");
        _; 
    }  
    
    address payable owner;
    GreetingMessage[] greetings;
    uint public repliesCount;
    
    constructor() public {
        owner = msg.sender;
        greetings.push(GreetingMessage(""Hello, Ramazan"", msg.sender)); 
    }

    
    function receive() external payable {}
    
    function fallback() external payable {}

    function getGreeting(uint idx) public onlyOwner view returns (string memory, address) {
        GreetingMessage storage greeting = greetings[idx];
        return (greeting.message, greeting.owner);
    }
    
    function setGreeting(string memory newGreeting) public {
        repliesCount++;
        greetings.push(GreetingMessage(newGreeting, msg.sender));
    }
    
    function kill() onlyOwner public {
        selfdestruct(owner); 
    }
 
}"
45559-0.sol,question,"contract C {
    uint[] counters;
    function getCounter(uint index)
        returns (uint counter, bool error) {
            if (index >= counters.length) return (0, true);
            else return (counters[index], false);
        }
    function checkCounter(uint index) {
        var (counter, error) = getCounter(index);
        if (error) { ... }
        else { ... }
    }
}"
31140-0.sol,question,"contract TestToken is MintableToken {

     string public name;
     string public symbol;
     uint8 public constant decimals = 18;
     string public constant version = ""1.0"";

     string public location;
     uint8 public power;

     uint256 public constant tokenUnit = 10 ** 18;

     function TestToken(string _name, string _symbol, string _location, uint8 _power) {
        name = _name;
        symbol = _symbol;

        location = _location;
        power = _power;
     }
  }"
2161-0.sol,question,"contract Greeter {
  string greeting;
  address public creator;

  function Greeter(string _greeting) {
    creator = msg.sender;
    greeting = _greeting;
  }

  function greet() constant returns (string) {
    return greeting;
  }
}"
2161-0.sol,question,"contract GreeterFactory {
    function makeGreeter(string greeting) returns (address) {
        return new Greeter(greeting);
    }

    function verify(address child) returns (bool) {
      Greeter child = Greeter(child);
      
    }
}"
72925-0.sol,question,"contract Consensus {

    struct Vote {
        address voter;
        bool yes;
        string comment;
    }

    struct ConsensusResult {
        Vote[] collectiveVotes;
    }

    mapping (bytes32 => ConsensusResult) votes;

    function addVote(bytes32 _voteID, bool _vote, string memory _comment) public {
        uint _length = votes[_voteID].collectiveVotes.length;
        votes[_voteID].collectiveVotes.length++;

        Vote storage v = votes[_voteID].collectiveVotes[_length];
        v.voter = msg.sender;
        v.yes = _vote;
        v.comment = _comment;
    }
}"
45935-0.sol,question,"contract C {

  address public owner; 
  address public creator;

  constructor (address _creator) public {
    owner = tx.origin;
    creator = _creator;
  }

  function() public payable {}

  function printOwner() public view returns(address h) {
      h = owner;
  }

}"
45935-0.sol,question,"contract CFactory {
  address public owner;
  address public currentContractAddress;

  constructor() public {
    owner = msg.sender;
    currentContractAddress = address(this);
  }

  

  function test1() public returns(address){
    C c = new C(currentContractAddress);
    return c.printOwner();
  }

}"
8561-0.sol,question,"contract Test {
    uint testVal;
   function Test(uint testValue){
       testVal=testValue;
   }
   function multiply(uint a) returns(uint d) {
       return a * 7 *testVal;
   }
}"
11261-1.sol,question,"contract B {

function getGasLimit() returns (uint) {
    uint gasLimit;

    assembly {
        gasLimit := gaslimit
    }
    return gasLimit;

}

}"
24743-0.sol,question,"contract Product {
    bytes32 public Name;

    function Product (bytes32 _Name) {
        Name = _Name;
    }
}"
24743-0.sol,question,"contract ProductFactory {

    bytes32[] public productNames;
    address[] public productAddresses;

    function addProduct (bytes32 _productName) {
        address newProduct = new Product(_productName);
        productAddresses.push(newProduct);
    }

    function getName (uint i) {
    Product prod = Product(productAddresses[i]);

    productNames[i] = prod.Name();
  }
}"
84505-1.sol,question,"contract Ownable {

    
    address private _owner;

    
    event OwnershipTransferred(address previousOwner, address newOwner);

    
    constructor() public {
        setOwner(msg.sender);
    }

    
    function owner() public view returns (address) {
        return _owner;
    }

    
    function setOwner(address newOwner) internal {
        _owner = newOwner;
    }

    
    modifier onlyOwner() {
        require(msg.sender == owner());
        _;
    }

    
    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        emit OwnershipTransferred(owner(), newOwner);
        setOwner(newOwner);
    }
}"
84505-1.sol,question,"contract Blacklistable is Ownable {

    address public blacklister;
    mapping(address => bool) internal blacklisted;

    event Blacklisted(address indexed _account);
    event UnBlacklisted(address indexed _account);
    event BlacklisterChanged(address indexed newBlacklister);

    
    modifier onlyBlacklister() {
        require(msg.sender == blacklister);
        _;
    }

    
    modifier notBlacklisted(address _account) {
        require(blacklisted[_account] == false);
        _;
    }

    
    function isBlacklisted(address _account) public view returns (bool) {
        return blacklisted[_account];
    }

    
    function blacklist(address _account) public onlyBlacklister {
        blacklisted[_account] = true;
        emit Blacklisted(_account);
    }

    
    function unBlacklist(address _account) public onlyBlacklister {
        blacklisted[_account] = false;
        emit UnBlacklisted(_account);
    }

    function updateBlacklister(address _newBlacklister) public onlyOwner {
        require(_newBlacklister != address(0));
        blacklister = _newBlacklister;
        emit BlacklisterChanged(blacklister);
    }
}"
84505-1.sol,question,"contract Pausable is Ownable {
    event Pause();
    event Unpause();
    event PauserChanged(address indexed newAddress);


    address public pauser;
    bool public paused = false;

    
    modifier whenNotPaused() {
        require(!paused);
        _;
    }

    
    modifier onlyPauser() {
        require(msg.sender == pauser);
        _;
    }

    
    function pause() onlyPauser public {
        paused = true;
        emit Pause();
    }

    
    function unpause() onlyPauser public {
        paused = false;
        emit Unpause();
    }

    
    function updatePauser(address _newPauser) onlyOwner public {
        require(_newPauser != address(0));
        pauser = _newPauser;
        emit PauserChanged(pauser);
    }

}"
84505-1.sol,question,"contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender)
    public view returns (uint256);

    function transferFrom(address from, address to, uint256 value)
    public returns (bool);

    function approve(address spender, uint256 value) public returns (bool);
    event Approval(
        address indexed owner,
        address indexed spender,
        uint256 value
    );
}"
52099-0.sol,question,"contract DieselPrice is usingOraclize {

uint public DieselPriceUSD;

event newOraclizeQuery(string description);
event newDieselPrice(string price);

function DieselPrice() public payable{
    update(); 
}

function __callback(bytes32 myid, string result)public {
    if (msg.sender != oraclize_cbAddress()) throw;
    newDieselPrice(result);
    DieselPriceUSD = parseInt(result, 2); 
    
}

function update() payable {
    newOraclizeQuery(""Oraclize query was sent, standing by for the answer.."");
    oraclize_query(""URL"", ""xml(https:
}"
47977-0.sol,question,"contract HellowWorld {         
  function displayMessage() constant returns (string) {
    return ""Hello"";
  }
}"
48832-0.sol,question,"contract partOne {
    address public owner;
    function partOne() public {
        owner = msg.sender;
    }
}"
48832-0.sol,question,"contract partTwo is partOne{
    uint public ownerBalance;
    function partTwo() public {
        ownerBalance = 500;
    }
}"
26738-1.sol,question,"contract JoseToken is IERC20 {

using SafeMath for uint256;

uint public  _totalSupply = 0;

string public constant symbol = ""VIC"";
string public constant name = ""JoseToken"";
uint8 public constant decimals = 18;

bool isEnabled;


uint256 public constant RATE = 500;

address public owner;

mapping(address => uint256) balances;
mapping(address => mapping(address => uint256)) allowed;

modifier isOwner() {
    require(msg.sender == owner);
    _;
}

function toggle() isOwner {
    isEnabled = !isEnabled;
}

function () payable {
    createTokens();
}

function JoseToken() {
    owner = msg.sender;
}

function createTokens() payable {
    require(msg.value > 0);
    require(isEnabled);

    uint256 tokens = msg.value.mul(RATE);
    balances[msg.sender] = balances[msg.sender].add(tokens);
    _totalSupply = _totalSupply.add(tokens);

    owner.transfer(msg.value);
}

function totalSupply () constant returns (uint256 totalSupply) {
    return _totalSupply;
}

function balanceOf(address _owner) constant returns (uint256 balance) {
    return balances [_owner];
}

function transfer(address _to, uint256 _value) returns (bool success) {
    require(
        balances[msg.sender] >= _value
        && _value > 0
    );
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
}

function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
    require(
        allowed[_from][msg.sender] >= _value
        && balances[_from] >= _value
        && _value > 0
    );
    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
}

function approve(address _spender, uint256 _value) returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
}

function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
}

event Transfer(address indexed _from, address indexed _to, uint256 _value);
event Approval(address indexed _owner, address indexed _spender, uint256 _value);
"
13490-0.sol,question,"contract parseBytes {
  bytes test = ""\x20\x00\x10"";
  function f() {
    assembly{
        test 
        pop 
    }
  }
}"
31739-0.sol,question,"contract Sample {

  address private receiver;
  uint public amount;

  function pay(address _receiver, uint _amount) payable public returns (bool) {
    receiver = _receiver;
    amount =_amount;
    receiver.transfer(amount);
    return true;
  }
}"
43967-0.sol,question,"contract BDetails {

struct Details {

    bytes32[] DetailsArray;


}
mapping(string => Details) DetailStructs;

 function appendDetails(string id, bytes32 concatt) payable returns(bool success) {

    DetailStructs[id].DetailsArray.push(concatt); 

}

}"
8519-1.sol,question,"contract kindaCool {
    function nifty() superDuperOnly {};
}"
44509-1.sol,question,"contract Game {
    address public owner;

    
    mapping(uint256 => Recipe) private recipeInfo;

    struct Recipe {
        uint256 recipeId;
        uint256[] ingredientId;
        uint256[] ingredientAmount;
        uint256 ethCost;
    }

    
    function Game() public {
        owner = msg.sender;
        recipeInfo[1] = Recipe(1, [1, 5], [100, 100], 50000000);
        recipeInfo[2] = Recipe(2, [2, 3, 4], [100, 200, 300], 100000000);
    }
}"
63857-0.sol,question,"contract Registration {
address public owner;
uint conceptPrice;
uint conceptValue;

function Registration(uint _conceptPrice) public {
    owner = msg.sender;
    conceptPrice = _conceptPrice;
    conceptValue = conceptPrice;
}



struct Request {
    uint reqId;
    uint amount;
    uint percentage;
    address modAdd;
    
    uint state;
}

Request[] public requests;

function request(uint _amount, uint _percentage) public returns (uint numRequests) {
    bool present = false;
    for (uint i = 0; i <= participants.length; i++) {
        if (participants[i] == msg.sender) {
            present = true;
            break;
        }
    }
    
    if (msg.sender == owner || _amount < conceptPrice || _amount < balances[msg.sender] || _percentage > 5 || present == false) return;
    Request memory req = Request({reqId : requests.length + 1, amount : _amount, percentage : _percentage, modAdd : msg.sender, state : 0});
    
    requests.push(req);
    numRequests = requests.length;
}

uint[] ident;
uint[] per;
uint[] amountV;

function pendingRequest() public {

    for (uint i = 0; i == requests.length; i++) {
        if (requests[i].state == 0) {
            ident.push(requests[i].reqId);
            per.push(requests[i].percentage);
            amountV.push(requests[i].amount);
        }
    }
}
function printReq() public constant returns (uint[] ident_){
    ident_ = ident;
}
}"
43547-2.sol,question,"contract Crowdsale {
    using SafeMath for uint256;
    ERC20 public token;
    address public wallet;
    uint256 public rate;
    uint256 public weiRaised;

    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);

    function Crowdsale(uint256 _rate, address _wallet, ERC20 _token) public {
       require(_rate > 0);
       require(_wallet != address(0));
       require(_token != address(0));
       rate = _rate;
       wallet = _wallet;
       token = _token;
    }

    function () external payable {
       buyTokens(msg.sender);
    }

    function buyTokens(address _beneficiary) public payable {
       uint256 weiAmount = msg.value;
       _preValidatePurchase(_beneficiary, weiAmount);
       uint256 tokens = _getTokenAmount(weiAmount);
       weiRaised = weiRaised.add(weiAmount);
       _processPurchase(_beneficiary, tokens);
       TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);
       _updatePurchasingState(_beneficiary, weiAmount);
       _forwardFunds();
       _postValidatePurchase(_beneficiary, weiAmount);
    }

    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {
       require(_beneficiary != address(0));
       require(_weiAmount != 0);
    }

    function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {
       
    }

    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
       token.transfer(_beneficiary, _tokenAmount);
    }

    function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {
       _deliverTokens(_beneficiary, _tokenAmount);
    }

    function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal {
       
    }

    function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {
       return _weiAmount.mul(rate);
    }

    function _forwardFunds() internal {
       wallet.transfer(msg.value);
    }
}"
65548-0.sol,question,"contract TokenERC20 {
    
    string public name;
    string public symbol;
    uint8 public decimals = 2;
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    
    event Burn(address indexed from, uint256 value);

    
    constructor(
        uint256 initialSupply,
        string memory tokenName,
        string memory tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                    
        name = tokenName;                                       
        symbol = tokenSymbol;                                   
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != address(0x0));
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, address(this), _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        emit Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        emit Burn(_from, _value);
        return true;
    }

}"
60248-1.sol,question,"contract B {
  mapping(uint => address) instances;
  function newA(uint id) {
    instances[id] = new A();
  }
}"
52322-0.sol,question,"contract Forward {
       address public receiver;



function Forward(address _receiver) {
    receiver = _receiver;
}

function() public payable {
    
    
    
    require(receiver.call.gas(gasleft() - 2000).value(msg.value)());
}
}"
63428-1.sol,question,"contract AjTokenSale {
address admin;
AjToken public tokenContract;
uint256 public tokenPrice;
uint256 public tokenSold;

event Sell(address _buyer, uint256 _amount);

function AjTokenSale(AjToken _tokenContract, uint256 _tokenPrice) public {
    
    admin = msg.sender;
    
    tokenContract = _tokenContract;
    
    tokenPrice = _tokenPrice;
}    



function multiply(uint x, uint y) internal pure returns(uint z) {

    require (y == 0 || (z = x * y)/y == x);

}


function buyTokens(uint256 _numberOfTokens) public payable {
    

    require(msg.value == multiply(_numberOfTokens , tokenPrice));

    

    require(tokenContract.balanceOf(this) >= _numberOfTokens);

    
    require(tokenContract.transfer(msg.sender, _numberOfTokens));
    
    tokenSold += _numberOfTokens;
    
    Sell(msg.sender, _numberOfTokens); 
}



function endSale() public {
    
    require(msg.sender == admin);       
    
    require(tokenContract.transfer(admin, tokenContract.balanceOf(this))); 
    admin.transfer(address(this).balance);

}

}"
80803-0.sol,question,"contract Election {

    struct Candidate {
        string name;
        uint voteCount;
    }

    struct Voter {
    bool authorized;
    bool voted;
    uint vote;
    } 
    address public owner;
    string public electionName;

    mapping(address => Voter) public voters;
    Candidate[] public candidates;
    uint public totalVotes;

    modifier ownerOnly() {
        require(msg.sender == owner);
        _;
    }

    function Election(string _name) public {
        owner = msg.sender;
        electionName = _name;
    }

    function addCandidate(string _name) ownerOnly public {
        candidates.push(Candidate(_name,0));  
    }

    function getNumCandidate() public view returns(uint){
        returns candidates.length;
    }  

    function authorize(address _person) ownerOnly public{
        voters[_person].authorized = true;
    }

    function vote(uint _voteIndex) public {
        require(!voters[msg.sender].voted);
        require(voters[msg.sender].authorized);

        voters[msg.sender].vote = _voteIndex;
        voters[msg.sender].voted = true;

        candidates[_voteIndex].voteCount +=1;
        totalVotes +=1;
    }

    function end() ownerOnly public {
        selfdestruct(owner);
    }
}"
66498-0.sol,question,"contract Notes {
    struct notes {
        string id;
        string content;
        address owner;
        bool isCreated;
        bool isDeleted;
        uint256 timestamp;
    }

    mapping(address => mapping(string =>notes)) private userNotes;

    function addNote(string memory _content, string memory _noteId) public {
        require(!userNotes[msg.sender][_noteId].isCreated,""a Note is already Created With This Id"");
        userNotes[msg.sender][_noteId] =notes(_noteId, _content,msg.sender, true, false, now);
    }
}"
57908-0.sol,question,"contract Solitaire {
    uint randomNonce = 0;
    uint[] randomNumArray;

    event Deposit(address user, uint256 amout);

    constructor() public payable{
    }

    function GetNonce() public returns (uint) {
        return randomNonce ++;
    }

    function () public payable{
        uint value = GetNonce() + 20;
        emit Deposit(msg.sender, value);

    }
}"
57908-0.sol,question,"contract CallTest {
    event logSendEvent(address to, uint256 value);
    event depositvalue(address sender, uint256 value);



    function transferEther(address towho) public payable {
        require(address(this).balance > 100000000000000000, ""Contract address does not exist enough money."");
        towho.transfer(100000000000000000);
        emit logSendEvent(towho, 100000000000000000);
    }

    function deposit() public payable {
        emit depositvalue(msg.sender, msg.value);
    }

    function GetBalance() public view returns(uint256) {
        return address(this).balance;
    }

    constructor() public payable{
    }
}"
2397-1.sol,question,"contract C {   mapping (string => uint) counter;   
function inc(string _s) { counter[_s]++; } }"
10195-0.sol,question,"contract simple {
    uint[] dataArray;

    function push_one_more() {
        dataArray.push(1);
    }
}"
61052-0.sol,question,"contract NamingTest {
    uint256 test;

    function set_test_value(uint256 _value) external payable {
        test = _value;
    }

    function setTestValue(uint256 _value) external payable {
        test = _value;
    }

    function settestvalue(uint256 _value) external payable {
        test = _value;
    }

    function set(uint256 _value) external payable {
        test = _value;
    }

    function getTest() external view returns (uint256) {
        return test;
    }
}"
44380-1.sol,question,"contract Bookkeeping {

uint counter;

function Bookkeeping() {
    counter = 0;
}

function notify(uint count) returns(uint) {
    counter = count+5;
    return counter;
}

function getCurrentCounter() constant returns(uint) {
    return counter;
}


}"
28260-0.sol,question,"contract ABC {

    bytes32 public name;
    uint public value;

    function ABC(bytes32 _name, uint _val) public {
        name = _name;
        value = _val;
    }
}"
28260-0.sol,question,"contract ABC_Creator {

    ABC localABC;
    mapping (bytes32 => address[]) public abcMap;
    event Log(bytes32, uint);

    function createABC(bytes32 _name, uint _val) public {
        localABC = new ABC(_name, _val);
        abcMap[_name].push(localABC);
    }

    function getABCList(bytes32 _name) public {

        uint len = abcMap[_name].length;
        for (uint i = 0; i < len; i++) {
            Log(ABC(abcMap[_name][i]).name(), ABC(abcMap[_name][i]).value());
        }

    }


}"
9067-4.sol,question,"contract SimpleStorage {
    uint storedData;
    function set(uint x) { storedData = x; }
    function get() constant returns (uint retVal) { return storedData; }
}"
11799-0.sol,question,"contract ApiCall is usingOraclize {

        uint public DieselPriceUSD;

        function ApiCall() {

                OAR = OraclizeAddrResolverI(0x9851eb2d10b765d8857e7e1b060bc1eb166e89f2);
        }

        function __callback(bytes32 myid, string result) {
                if (msg.sender != oraclize_cbAddress()) throw;
                DieselPriceUSD = parseInt(result, 2); 
        }

        function update() payable {
                oraclize_query(""URL"", ""xml(https:
         }

     }"
10359-0.sol,question,"contract Mortal {
address owner;

event Killed(address indexed from);

function Mortal() {
    owner = msg.sender;
}

function kill() {
    if (msg.sender == owner) {
        Killed(owner);
        suicide(owner);
    }
}
}"
10359-0.sol,question,"contract Voting is Mortal {
struct Voter {
    address voterAddress;
    uint hasRightToVote;
    uint voted;
    address delegate;
}

struct Slide {
    uint number;
    uint voteCount;
    uint score;
    uint avgScore;
}

address public chairperson;

mapping(address => Voter) public voters;
mapping(uint => Slide) public slides;

uint public totalSlides;
uint public totalVotes;
uint public totalVoters;


event GivenRightToVote(address indexed chairperson, address indexed voter);
event hasVoted(address indexed voter, uint indexed slideNumber, uint indexed slideScore);
event hasDelegated(address indexed voter, address indexed delegate);
event VoterAlreadyExists(address indexed voter);
event VoterCreated(address indexed voter);
event VoterNotExists(address indexed voter);
event SenderNotChairperson(address indexed sender);
event callInitVoter(address indexed voter, address indexed sender);
event invalidVoter(address indexed voter);
event callGiveRightToVote(address indexed voterAddr);
event initSlideVote(address indexed voterAddr, uint indexed slide);
event VoterNoRightToVote(address indexed voter);

function Voting(uint numberSlides) {
    uint i;
    for (i = 0; i < numberSlides; i++) {
        slides[i] = Slide(i, 0, 0, 0);
    }
    chairperson = msg.sender;
    initVoter(msg.sender);
    voters[msg.sender].hasRightToVote = 1;
    totalSlides = numberSlides;
    totalVoters = 1;
}

function getSlide(uint slideNumber) returns (uint number, uint score, uint voteCount) {
    score = slides[slideNumber].score;
    voteCount = slides[slideNumber].voteCount;
    number = slides[slideNumber].number;
    return(number, score, voteCount);
}

function getSlideVoteCount(uint slideNumber) returns (uint voteCount) {
    voteCount = slides[slideNumber].voteCount;
    return voteCount;
}

function initVoter(address voterAddr) {
    callInitVoter(voterAddr, msg.sender);
    if(voterAddr == address(0)) {
        invalidVoter(voterAddr);
    }
    if(msg.sender == chairperson) {
        if(voters[voterAddr].voterAddress == voterAddr) {
            VoterAlreadyExists(voterAddr);
        } else {
            VoterNotExists(voterAddr);
            voters[voterAddr] = Voter(voterAddr, 0, 0, address(0));
            totalVoters += 1;
        }
        VoterCreated(voterAddr);
    } else {
        SenderNotChairperson(msg.sender);
    }
}

event unauthorizedCallerGiveRightToVote(address indexed voter);
function giveRightToVote(address voterAddr) {
    callGiveRightToVote(voterAddr);
    if(msg.sender == chairperson) {
        if(voters[voterAddr].voterAddress == 0x0000000000000000000000000000000000000000) {
            VoterNotExists(voterAddr);
            initVoter(voterAddr);
        } else {
            VoterAlreadyExists(voterAddr);
        }
        voters[voterAddr].hasRightToVote = 1;
        GivenRightToVote(chairperson, voterAddr);
    } else {
        unauthorizedCallerGiveRightToVote(voterAddr);
    }
}

event callVote(address indexed voter, uint indexed slide, uint256 indexed score);
event VoterNotAllowedToVote(address indexed voter);
event VoterAllowedToVote(address indexed voter);
event ChairpersonNotAllowedToVote(address indexed voter);
event VoterExists(address indexed voter);
function vote(uint slide, uint256 score) {
    Voter voter;
    callVote(msg.sender, slide, score);
    if(msg.sender == chairperson) {
        ChairpersonNotAllowedToVote(msg.sender);
    } else {
        if(msg.sender == address(0)) {
            VoterNotExists(msg.sender);
        } else {
            voter = voters[msg.sender];
            if(voter.hasRightToVote != 1) {
                VoterNoRightToVote(msg.sender);
            } 
            if(voter.hasRightToVote == 1) {
                VoterExists(msg.sender);
                VoterAllowedToVote(msg.sender);
                voter.voted += 1;
                totalVotes ++;
                slides[slide].voteCount += 1;
                slides[slide].score += score;
                hasVoted(msg.sender, slide, score);
            }
        }
    }
}

function vote2(uint slide, uint score) {
    Voter voter;
    callVote(msg.sender, slide, score);
    voter = voters[msg.sender];
    if(voter.voterAddress != address(0)) {
        VoterExists(msg.sender);
        if(msg.sender != chairperson) {
            if(voter.hasRightToVote == 1) {
                VoterAllowedToVote(msg.sender);
                voter.voted ++;
                totalVotes ++;
                slides[slide].voteCount ++;
                slides[slide].score += score;
                hasVoted(msg.sender, slide, score);
            } else {
                VoterNoRightToVote(msg.sender);
            }
        } else {
            ChairpersonNotAllowedToVote(msg.sender);
        }
    } else {
        VoterNotExists(msg.sender);
    }
}

function vote3(uint slide, uint score) {
    Voter voter = voters[msg.sender];
    callVote(msg.sender, slide, score);
    VoterExists(msg.sender);
    VoterAllowedToVote(msg.sender);
    voter.voted += 1;
    totalVotes += 1;
    slides[slide].voteCount += 1;
    slides[slide].score += score;
    hasVoted(msg.sender, slide, score);
}

function winningSlide() constant returns (uint winningSlide) {
    uint winningScore = 0;
    for (uint p = 0; p < totalSlides; p++) {
        if (slides[p].score > winningScore) {
            winningScore = slides[p].score;
            winningSlide = p;
        }
    }
    return(winningSlide);
}




function winnerCount() constant returns (uint voteCount) {
    uint winnerSlide;
    winnerSlide = winningSlide();
    voteCount = slides[winnerSlide].voteCount;
    return(voteCount);
}

function winnerScore() constant returns (uint score) {
    uint winnerSlide = winningSlide();
    score = slides[winnerSlide].score;
    return(score);
}

    
function delegate(address to) {
    Voter sender = voters[msg.sender];
    if (sender.voted != 0) throw;

    while (voters[to].delegate != address(0) &&
           voters[to].delegate != msg.sender)
        to = voters[to].delegate;

    if (to == msg.sender)
        throw;

    for (uint i = 0; i < totalSlides; i++) sender.voted += 1;

    sender.delegate = to;
    Voter delegate = voters[to];
    hasDelegated(msg.sender, to);
}
}"
40433-0.sol,question,"contract Adoption {
    address[16] public adopters;

    
    function adopt(uint petId) public returns (uint) {
        require(petId >= 0 && petId <= 15);

        adopters[petId] = msg.sender;

        return petId;
    }   
}"
18003-1.sol,question,"contract Donation {
  mapping (address => uint) user_amounts;    


  
  function sendDonation(uint n) {
    user_amounts[msg.sender] = user_amounts[msg.sender] + n
  }
}"
78388-0.sol,question,"contract Proxy {
  function () payable external {
    
    _fallback();
  }

  function _fallback() internal {
    _willFallback();
    _delegate(_implementation());
  }


  function _implementation() internal view returns (address);

  function _delegate(address implementation) internal { ... }

  function _willFallback() internal { }
}"
45747-0.sol,question,"contract Ownable {
  address public owner;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  function Ownable() public {
    owner = msg.sender;
  }


  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }



  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0) && newOwner != owner);
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}"
45747-0.sol,question,"contract Destructible is Ownable {

  function Destructible() public payable { }

  function destroy() onlyOwner public {
    selfdestruct(owner);
  }

  function destroyAndSend(address _recipient) onlyOwner public {
    selfdestruct(_recipient);
  }
}"
45747-0.sol,question,"contract UserTokensControl is Ownable {
  address companyReserve;
  address founderReserve;
  address contractReserve;
}"
45747-0.sol,question,"contract ERC223ReceivingContract {
  function tokenFallback(address _from, uint256 _value, bytes _data) public;
  event TokenFallback(address indexed from, uint256 value, bytes data);
}"
45747-0.sol,question,"contract ERC223 {
    function transfer(address to, uint256 value, bytes data) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value, bytes data);
}"
45747-0.sol,question,"contract ERC20 {
    function transfer(address to, uint256 value) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint256 value);
}"
45747-0.sol,question,"contract StandardToken is BasicToken {

  mapping (address => mapping (address => uint256)) internal allowed;
}"
50230-0.sol,question,"contract Campaign {
     struct Request {
         string description;
         uint32 value;
         address recipient;
         bool complete;
         uint approvalCount;
         mapping(address => bool) approvals;
     }

     Request[] public requests;
     address public manager;
     uint32 public minimumContribution;
    
     mapping(address => bool) public contributors;
     uint32 public contributorCount;

     modifier restricted {
         require(msg.sender == manager );
        _;
     }


     constructor(uint32 minimum) public {
         manager = msg.sender;
         minimumContribution = minimum;
     }

     function contribute() public payable{
         require(msg.value > minimumContribution);

         contributors[msg.sender] = true; 
         contributorCount++;
     }

     function createRequest(string description, uint32 value, address recipient) 
        public restricted {
         Request memory newRequest = Request({
            description: description, 
            value: value, 
            recipient: recipient, 
            complete: false,
            approvalCount: 0
         });

         requests.push(newRequest);
     }

     function approveRequest(uint16 index) public {
         Request storage r = requests[index];

         
         require(contributors[msg.sender]); 
         require(!r.approvals[msg.sender]);

         r.approvals[msg.sender] = true;
         r.approvalCount++;
     }

     function finalizeRequest(uint16 index) public restricted {
         Request storage r = requests[index];

         
         require(r.approvalCount > (contributorCount / 2));
         
         require(!r.complete);

         
         r.recipient.transfer(r.value);


         
         r.complete = true;
     }

 }"
32913-0.sol,question,"contract Test {
    function toBytes(address a) public pure returns (bytes b) {
        assembly {
            let m := mload(0x40)
            mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, a))
            mstore(0x40, add(m, 52))
            b := m
       }
    }

    function toBytes(uint _num) public pure returns (bytes _ret) {
        assembly {
            _ret := mload(0x10)
            mstore(_ret, 0x20)
            mstore(add(_ret, 0x20), _num)
        }
    }

    function test(uint num1, uint num2) public view returns (bytes) {
        bytes memory a1 = toBytes(msg.sender);
        bytes memory a2 = toBytes(num1);
        bytes memory a3 = toBytes(num2);
        bytes memory ret = new bytes(a1.length + a2.length + a3.length);
        uint x = 0;

        for (uint i = 0; i < a1.length; i++) {
            ret[x++] = a1[i];
        }

        for (i = 0; i < a2.length; i++) {
            ret[x++] = a2[i];
        }

        for (i = 0; i < a3.length; i++) {
            ret[x++] = a3[i];
        }

        return ret;
    }
}"
8539-0.sol,question,"contract MyContract {
struct Posposal{
    uint posposalId;
    bytes1 description_;
    uint userId;
    uint amount;
    address voteSponsorAddr;

}
Posposal[] public curPosposals; 
uint public posposalNextId=0;

function MyContract() {

}
uint public expId;
address public expTarget;
string public expDes;
function issuse(uint userId,address target_,uint amount_,string description_)  {
    expId=userId;
    expTarget=target_;
    expDes=description_;
    curPosposals.push(Posposal(posposalNextId,0x00,userId,amount_,msg.sender));
    posposalNextId++;
}}"
26052-0.sol,question,"contract D {
  uint public n;
  address public sender;

  function delegatecallSetN(address _e, uint _n) {
    _e.delegatecall(bytes4(sha3(""setN(uint256)"")), _n); 
  }
}"
26052-0.sol,question,"contract E {
  uint public n;
  address public sender;
  function setN(uint _n) {
    n = _n;
    sender = msg.sender;
  }
}"
42138-0.sol,question,"contract Test is usingOraclize {

    uint public tokens;

    uint public dollarCost;


    function() payable {
        updatePrice();
        tokens = msg.value * dollarCost / 1000 / (10 ** 16);
    }


    function __callback(bytes32 myid, string result) {
        if (msg.sender != oraclize_cbAddress()) throw;
        dollarCost = parseInt(result, 3);
    }

    function updatePrice() public payable {

        if (oraclize_getPrice(""URL"") > this.balance) {
            return;
        }
        else {
          oraclize_query(""URL"", ""json(https:
        }
    }
}"
51942-1.sol,question,"contract GlobalGeneric {
    KeyValueStorage globalS;
    constructor(KeyValueStorage storage_) public {
        globalS = storage_;
    }
    function claimInterests(address _memberAddr, bytes32 _identifier) public returns (bool success) {
        require(now > globalS.refreshTime[_memberAddr][_identifier] + 90 days);
        .....
    }
....
}"
68772-0.sol,question,"contract DecompiledContract {
    function start() {
        *0x40 = 0x60;
        var0 = msg.data.length;

        if(var0 != 0x0) {
            var0 = (uint256)$msg.sig;

            if(var0 == 0x41c0e1b5) {
                kill();
            }

            if(var0 == 0xe5225381) {
                collect();
            }
        }

        if($msg.value > 0x0) {
            var2 = msg.sender;
            uint256* var6 = *0x40;
            *var6 = $msg.value;
            emit Deposit(*0x40, var6 + 1 - *0x40);
        }

        stop();
    }

    function kill() public payable {
        __impl_kill();
        stop();
    }

    function collect() public payable {
        __impl_collect();
        stop();
    }

   function __impl_kill() private {
        var1 = storage[0x0];
        int256 var0 = var1;
        var1 = msg.sender;

        if((address(var0)) == (address(msg.sender))) {
            var1 = storage[0x0];
            suicide(address(var1));
        }
    }

    function __impl_collect() private {
        var1 = storage[0x0];
        int256 var0 = var1;
        var1 = msg.sender;

        if((address(var0)) == (address(msg.sender))) {
            var1 = storage[0x0];
            var2 = address(this);
            var2 = balance(address(var2));
            uint256 var5 = *0x40;
            var4 = call(0x0, address(var1), var2, var5, *0x40 - var5, var5, 0x0);
        }
    }

}"
39044-0.sol,question,"contract test002 {

    address[] AddressList;

    event ItemAdded(address, address);


    function getItemCount() public view returns(uint) {return(AddressList.length);}
    function getItem(uint index) public view returns(address) {return(AddressList[index]);}

    function addItem(address inItem) public {
        AddressList[AddressList.length] = inItem;
        ItemAdded(this, inItem);
    }

}"
39044-0.sol,question,"contract test001 {

    address AA;

    event Creation(address, address);

    function test001() public {
        AA = new test002();

        Creation(address(this), AA);
    }

    function register() public {
        


        



        
        test002 A = test002(AA);
        A.addItem(address(this));
    }



}"
65837-0.sol,question,"contract Workload {

    address payable public receiver;

    constructor(address payable _receiver) public payable {
        receiver = _receiver;
    }

    event Sent();

    
    function getBalance(address _from) public view returns (uint256) {
        return address(_from).balance;
    }

    
    function getSender() public view returns (address) {
        return address(msg.sender);
    }

    
    function send(uint amount) public payable {
        address payable sender = msg.sender;
        require(amount <= sender.balance, ""Insufficient balance."");
        sender.transfer(amount);;
        emit Sent();
    }
}"
28640-0.sol,question,"contract TicTacToe {


    uint[3][]   arr ;

    function isSolved(int[3][] board) returns (int) {
        arr = board;
        

        int check  = 0;
        int h1 =  checkH(arr[1]);

        if(h1 == -1){
            int h2 =  checkH(arr[2]);
            if(h2 == -1){
                int h3 =  checkH(arr[3]);
                 check = h3;

            }else{
                check = h2;
            }
        }else{
          check = h1;
        }


        if(check == -1){
            check = checkS(arr);
            if(check == -1){
                check = checkX(arr);
            }

        }

        if(check == -1){
            check = 0;

        }

        if(check == 0){
            check = -1;

        }


        return check;

    }



    
    function checkH(int[] h) private   returns (int)  {
        if(h[0] == h[1] && h[1] == h[2]){
            return h[0];
        }
        return -1;
    }

    
    function checkS(int[3][] board) private   returns (int)  {
        if(board[0][0] == board[1][0] && board[1][0] == board[2][0]){
            return board[1][0];
        }
        if(board[0][1] == board[1][1] && board[1][1] == board[2][1]){
            return board[1][0];
        }
        if(board[0][2] == board[1][2] && board[1][2] == board[2][2]){
            return board[1][0];
        }
        return -1;
    }

    
    function checkX(int[3][] board) private   returns (int)  {
        if(board[0][0] == board[1][1] && board[1][1] == board[2][2]){
            return board[0][0];
        }
        if(board[0][2] == board[1][1] && board[1][1] == board[2][0]){
            return board[0][2];
        }
        return -1;
    }

}"
26734-0.sol,question,"contract StrangeToken {

  uint256 private repurchasePrice;   
  mapping(address => uint256) balances;

  function setPrice(uint256 price) {   
   repurchasePrice = price;   
  }  
}"
59171-1.sol,question,"contract test {
   function f(int8 x) public pure returns (int8) {
     return x+1;
   }
}"
45939-3.sol,question,"contract mortal {
    
    address owner;

    
    function mortal() public { owner = msg.sender; }

    
    function kill() public { if (msg.sender == owner) selfdestruct(owner); }
}"
45939-3.sol,question,"contract greeter is mortal {
    
    string greeting;

    
    function greeter(string _greeting) public {
        greeting = _greeting;
    }

    
    function greet() public constant returns (string)  {
        return greeting;
    }
}"
3091-0.sol,question,"contract OwnedToken {

TokenCreator creator;
address owner;
bytes32 name;

function OwnedToken(bytes32 _name) {
    owner = msg.sender;

    creator = TokenCreator(msg.sender);
    name = _name;
}
function changeName(bytes32 newName) {

    if (msg.sender == creator) name = newName;
}
function transfer(address newOwner) {
    if (msg.sender != owner) return;

    if (creator.isTokenTransferOK(owner, newOwner))
        owner = newOwner;
}


contract TokenCreator {
    function createToken(bytes32 name)
       returns (OwnedToken tokenAddress)
    {

        return new OwnedToken(name);
    }
    function changeName(OwnedToken tokenAddress, bytes32 name) {

        tokenAddress.changeName(name);
    }
    function isTokenTransferOK(
        address currentOwner,
        address newOwner
    ) returns (bool ok) {
        address tokenAddress = msg.sender;
        return (sha3(newOwner) & 0xff) == (bytes20(tokenAddress) & 0xff);
    }
}"
3091-0.sol,question,"contract TokenCreator {
    function createToken(bytes32 name)
       returns (OwnedToken tokenAddress)
    {

        return new OwnedToken(name);
    }
    function changeName(OwnedToken tokenAddress, bytes32 name) {

        tokenAddress.changeName(name);
    }
    function isTokenTransferOK(
        address currentOwner,
        address newOwner
    ) returns (bool ok) {
        address tokenAddress = msg.sender;
        return (sha3(newOwner) & 0xff) == (bytes20(tokenAddress) & 0xff);
    }
}"
39704-0.sol,question,"contract Adoption {
    address[16] public adopters;

    function returnEth() public payable {
    msg.sender.transfer(msg.value);
    }
    
    function adopt(uint petId) public payable returns (uint) {
        require(petId >= 0 && petId <= 15);
        
        adopters[petId] = msg.sender;
        returnEth();
        return petId;
        
    }
    
    function getAdopters() public view returns (address[16]) {
        return adopters;
    }


}"
61139-0.sol,question,"contract FileList {

   
   struct File {
      uint256 id;
      string ipfshash;
      bytes32 filename;
      bytes32[5] tags;
      address owner;
      uint256 timestamp;
   }
   uint256 public constant maxAmountOfFiles = 1000;
   
   mapping(address => File[maxAmountOfFiles]) public files;
   
   mapping(address => uint256) public lastIds;
   

   
   
   
   function getFileTags(address owner, uint256 _index) external view returns (bytes32[5]) {
       return files[owner][_index].tags;
  }

}"
71037-1.sol,question,"contract B {
    mapping (uint256 => bool) _vals;

    function write(uint256 _a) public returns (bool) {
        _vals[_a] = true;
        return _vals[_a];
    }

    function read(uint256 _b) public view returns (bool) {
        return _vals[_b];
    }
}"
19289-0.sol,question,"contract Purchase {
  uint public amount;
  address public seller;
  address public buyer;

  function Purchase(address addr, uint _amount) {
    seller = addr;
    amount = _amount;
  }

  function confirmPurchase(address _buyer, uint val) {
    buyer = _buyer;
    if ( val == amount) {
      buyer.transfer(amount);
      seller.transfer(this.balance);
      seller.balance;
    }
  }

  function getBalance() returns (uint balance) {
    return seller.balance;
  }

  function getAddr() returns (address) {
    return msg.sender;

  }
}"
12605-0.sol,question,"contract WeatherApiCall is usingOraclize {
       string public weathercondition;
       event LOG_OraclizeCallback(
              bytes32 queryId,
              string result
       );
       function WeatherApiCall() {
            OAR = OraclizeAddrResolverI(0x44bc501f0d92a9583877636828f52abc9da5d585);
      }
      function __callback(bytes32 myid, string result) {
              if (msg.sender != oraclize_cbAddress()) throw;
              weathercondition=result;
              LOG_OraclizeCallback(myid,result);
      }
      function update(string to,string datetime) payable returns(bool sufficient) {

              oraclize_query(""URL"", strConcat(""json(http:
              return true;
  }
}"
61200-0.sol,question,"contract MyContract {
struct Account {
    address owner;
    boolean active;
}

mapping( address => Account) allAccounts;

function AddAccount(address newAddress) public returns (bool success ) {
    allAccounts[newAddress].owner = newAddress;
    allAccounts[newAddress].active = true;
    return true;
}

function GetAccount(address _address) public view returns( address owner, boolean active) {
    return (allAccounts[_address].owner, allAccounts[_address].active);
}
}"
9359-0.sol,question,contract Multiply7 { event Print(uint); function multiply(uint input) returns (uint) { Print(input * 7); return input * 7; } }
58513-0.sol,question,"contract example { 

    struct StructPrimary {
        uint start;
        bool isActive;
        uint index;
        address owner;
        uint[] indexcounter;
    }

    uint globalCounter;
    uint[] public userArray;

    
    mapping(uint => StructPrimary) public structByIndex;
    mapping(address => StructPrimary) public structByAddress;


    function addCandidate (address _candidate) public returns (uint) {
        
        StructPrimary storage accounts = structByIndex[userArray.length];
        accounts.start = 0;
        accounts.owner = _candidate;
        accounts.isActive = true;
        accounts.index = userArray.length;
        accounts.indexcounter.push(userArray.length);

        
        structByIndex[accounts.index].owner = _candidate;

        
        structByAddress[_candidate].indexcounter.push(userArray.length);

        globalCounter++ ;

        
        return userArray.push(accounts.index);
    }
}"
51760-0.sol,question,"contract PQ {
struct Node {
    int256 key;
    address value;
}    
Node[7] private heapKeyValue;   
function insert(int256 key, address addr) public {
      .. Implementation ..
}
function get_min() public view returns (int256) {
    return heapKeyValue[0].key;
}
function heapify(uint8 idx) internal {
      ..Implementation..
}
}"
68098-0.sol,question,"contract Test {
    function testWrite() public {}

    function get() public pure returns (bytes memory) {
       return bytes('yo');
    }
}"
78049-0.sol,question,"contract MyContract is Owned {
  event Created (
    uint256 tradeId,
    uint256 createdAt,
    uint256 expiredAt,
    address originatorAddress,
    address benificiaryAddress,
    string expectedToken,
    uint256 receivedQty);
  event Released(uint256 tradeId);

  struct Escrow {
    uint256 tradeId;
    uint256 createdAt;
    uint256 expiredAt;
    address originatorAddress;
    address benificiaryAddress;
    string expectedToken;
    uint256 receivedQty;
  }

  mapping (uint256 => Escrow) public escrows;
  mapping(address => mapping(address => uint256)) public escrowBalance;
  uint256 feePercent;
  address feeAddress;
  
  
  
  constructor() public {
  
  
  }

  function createEscrow( uint256 _tradeId,
    uint256 _expiredAt,
    address _benificiaryAddress,
    string _expectedToken,
    uint256 _receivedQty, 
    address token)payable external
  {   
    uint256 tokenBalance = ERC20Interface(token).balanceOf(msg.sender);
    require(tokenBalance >=_receivedQty, ""Insufficient balance."");

    escrows[_tradeId] = Escrow(_tradeId, now, now + _expiredAt, msg.sender, _benificiaryAddress, _expectedToken, _receivedQty);

    ERC20Interface(token).transferFrom(msg.sender, this, _receivedQty);   
    emit Created (_tradeId, now, now + _expiredAt, msg.sender, _benificiaryAddress, _expectedToken, _receivedQty);
  }

  function releaseToken(uint256 _tradeId, address token) external {
    Escrow storage escrow = escrows[_tradeId];
    ERC20Interface(token).transfer(escrow.benificiaryAddress, escrow.receivedQty);
    emit Released(_tradeId);
    delete escrows[_tradeId];
  }   
}"
64931-1.sol,question,"contract ERC20 {
    function transferFrom(address _from, address _to, uint _value) public returns (bool);
    function approve(address _spender, uint _value) public returns (bool);
    function allowance(address _owner, address _spender) public constant returns (uint);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
}"
64931-1.sol,question,"contract ERC223 {
    function transfer(address _to, uint _value, bytes _data) public returns (bool);
    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);
}"
64931-1.sol,question,"contract Token {
    string internal _symbol;
    string internal _name;
    uint8 internal _decimals;
    uint internal _totalSupply = 1000;
    mapping (address => uint) internal _balanceOf;
    mapping (address => mapping (address => uint)) internal _allowances;

    function Token(string symbol, string name, uint8 decimals, uint totalSupply) public {
        _symbol = symbol;
        _name = name;
        _decimals = decimals;
        _totalSupply = totalSupply;
    }

    function name() public constant returns (string) {
        return _name;
    }

    function symbol() public constant returns (string) {
        return _symbol;
    }

    function decimals() public constant returns (uint8) {
        return _decimals;
    }

    function totalSupply() public constant returns (uint) {
        return _totalSupply;
    }

    function balanceOf(address _addr) public constant returns (uint);
    function transfer(address _to, uint _value) public returns (bool);
    event Transfer(address indexed _from, address indexed _to, uint _value);
}"
57295-0.sol,question,"contract ZaPartnere {

address[] partneri = [0x118531D9C6C9114c8B999Ac1197778d1669Fc6c6, 0x029c2D637e193716246A55c62F2302a61FaC81dC, 0x36FFE679f923BdADd17E79Ce159DE80f779b512C, 0x78c426A0ABf24645d7e57267aFEe78688D86937d, 0xF7ffD689BFD99e03b7e1a6ebEc8Ee43877e49EEc];

uint TotalniIznos = 0;
    mapping (address => uint) PovuceniIznos;

    function ZaPartnerePodijela () payable {
        updateTotalniIznos();



    }

    function () payable {
        updateTotalniIznos();



    }

    function updateTotalniIznos() internal {

        TotalniIznos += msg.value;

    }

    modifier ProvjeraPartnera(){

        bool partner = false;

        for(uint i = 0; i < partneri.lenght; i++){

            if (partneri[i] == msg.sender){
                partner = true;

            }
        }

        require(partner);
        _;
    }

    function PovlacenjeSredstva(){

        uint SkupljeniIznos = TotalniIznos/partneri.lenght;
        uint KolicinaPovucena = PovuceniIznos[msg.sender];
        uint kolicina = SkupljeniIznos - KolicinaPovucena;
        PovuceniIznos[msg.sender] = KolicinaPovucena + kolicina;

        if(kolicina > 0 ){

            msg.sender.transfer(kolicina);

        }
    }
}"
63100-3.sol,question,"contract FinalizableCrowdsale is TimedCrowdsale {
using SafeMath for uint256;

bool private _finalized;

event CrowdsaleFinalized();

constructor() internal {
_finalized = false;
}


function finalized() public view returns (bool) {
return _finalized;
}


function finalize() public {
require(!_finalized);
require(hasClosed());

_finalized = true;

_finalization();
emit CrowdsaleFinalized();
}


function _finalization() internal {
}
}"
71339-0.sol,question,"contract and {

    string d = ""Hello"";

    function getValueOfabc() public view returns(string) {
        return d;
    }
}"
7476-0.sol,question,"contract tokensHolder {
  
   
   bytes32 eZn =   0x655a415200000000000000000000000000000000000000000000000000000000;

    function stringsEqual(string storage _a, string memory _b) internal returns (bool) {
    bytes storage a = bytes(_a);
    bytes memory b = bytes(_b);
    if (a.length != b.length)
      return false;
    
    for (uint i = 0; i < a.length; i ++)
      if (a[i] != b[i])
        return false;
    return true;
  }

  event bought(address indexed Buyer, bytes32 Token ,uint amount, uint _price);
  event sold(address indexed seller,bytes32 Token ,uint amount, uint _price);
  event exchange(address Transferer ,address reciver ,uint amount ,bytes32 token);
  event faliure(address attempter, string attempted,uint amount,string reason);
  event newZARVal(uint NewValueInWei,address owner);
  event tokenAdded(address adder,string unit,uint dp,bytes32 tokenName);

  modifier OnlyOwner {
    if (msg.sender != owner){
      faliure(msg.sender,""owner only function"",0,""not the owner"");
      throw ;
    }  
    _
  }
  modifier notMyself {

    if (msg.sender == address(this)){
      throw;
    } 
    _
  }

  struct stk {
    mapping (address => uint ) balance;
    address minter;
    string unit;
    uint eZARVal; 
    uint dp;
  }

  mapping (bytes32 => stk ) tokenList ;
  address owner ;

  function tokensHolder(uint _ezarvalinwei){
    owner = msg.sender ;
    tokenList[(eZn)] = stk({
      minter:owner,
      unit: ""eZAR"",
      eZARVal: _ezarvalinwei, 
      dp: 4 
    });
  }

  function sellTknZ(bytes32 _tknName , uint _amount) notMyself  returns (uint){

    if (tokenList[_tknName].balance[msg.sender] >= _amount * 10**tokenList[_tknName].dp){
      uint tokenValue = tokenList[(_tknName)].eZARVal * 1000 * _amount;
      tokenList[(_tknName)].balance[msg.sender] -= _amount;
        tokenList[(eZn)].balance[msg.sender] += tokenValue;
      sold(msg.sender,_tknName,_amount,tokenList[(_tknName)].eZARVal);
    }else{
      faliure(msg.sender,""Selling tokens"",_amount,""Insufficent Funds"");
      throw;
    }
  }

  function buyTknZ(bytes32 _tknName, uint _amount) notMyself  {
    uint tokenCost = tokenList[(_tknName)].eZARVal * 1000 * _amount ;
    if (tokenList[(eZn)].balance[msg.sender]  < tokenCost ){
      faliure(msg.sender,""buyingtokens"",_amount,""Insufficent Funds"");
      throw;
    } else {
      uint tokenAdded;
      tokenList[(eZn)].balance[msg.sender] -= tokenCost;
      tokenList[(_tknName)].balance[msg.sender] += _amount * 10 ** tokenList[_tknName].dp;
      bought(msg.sender,_tknName,_amount,tokenList[(_tknName)].eZARVal);
    }
  }

  function getBalance(bytes32 _tknName)  returns (uint) {
    uint balance = tokenList[(_tknName)].balance[msg.sender];
    return balance;
  }

  function buyZ() notMyself {
    uint amount = msg.value / tokenList[(eZn)].eZARVal * 10000;
    if (amount<1) {
      faliure(msg.sender,""buyZ"",0,""PAY MORE ETHER"");
      throw;
    }else {
      tokenList[(eZn)].balance[msg.sender] += amount;
      bought(msg.sender,eZn,amount,tokenList[(eZn)].eZARVal);
    }
  }

  function sellZ(uint _amount) notMyself returns (uint){
    if (tokenList[(eZn)].balance[msg.sender] < _amount ){
      faliure(msg.sender,""sellZ"",_amount,""insuficient Funds"");
      throw;
    }else{
      tokenList[(eZn)].balance[msg.sender] -= _amount;
      msg.sender.send((tokenList[(eZn)].eZARVal )* _amount);
      sold(msg.sender,eZn,_amount,tokenList[(eZn)].eZARVal);
    }

  }

  function setZarVal(uint _amount) OnlyOwner returns (bool){
    tokenList[(eZn)].eZARVal = _amount;
    newZARVal(_amount,owner);
  }

  function replaceOwner(address _ownerNew) OnlyOwner{
    owner = _ownerNew;
  }

  function sendToken(bytes32 _tknName ,address _to, uint _amount) external{
    if (tokenList[_tknName].balance[msg.sender] >= _amount){
      tokenList[_tknName].balance[msg.sender] -= _amount;
      tokenList[_tknName].balance[_to] += _amount;
      exchange(msg.sender, _to,_amount,_tknName);
    }else {
      faliure(msg.sender,""sendToke"",_amount,""insufficient funds"");
      throw;
    }
  }

  function newToken(bytes32 _tknName,string  _unit,uint _eZARVal,uint _dp) {
    if (stringsEqual(tokenList[_tknName].unit,"""") ){
      tokenList[_tknName]= stk({
        minter : msg.sender,
        unit:_unit,
        eZARVal:_eZARVal,
        dp:_dp
      });
      tokenAdded(msg.sender,_unit,_dp,_tknName);
    }else{
      faliure(msg.sender,""add a token"",1,""token alreadyexists"");
      throw;
    }
  }

  
  }"
7476-0.sol,question,"contract tokenExchange {

address owner;
tokensHolder holder;
uint validTime;
bytes32 tokenOffered;
uint numberOffered;
bool offered;

address exchangee;
bytes32 tokenExpected;
uint numberExpected;
bool expected;



function tokenExchange(
   address _tokenHolder,
   uint _validTimeinDays,
   bytes32 _tokenOffered,
   uint _numberOffered,
   bytes32 _tokenExpected,
   uint  _numberExpected,
   address  _exchangee)
 {
    owner = msg.sender;
    holder = tokensHolder(_tokenHolder);
    validTime = now + _validTimeinDays * 1 days;
    tokenOffered = _tokenOffered;
    numberOffered = _numberOffered;
    tokenExpected = _tokenExpected;
    numberExpected = _numberExpected;
    exchangee = _exchangee;
   expected = false;
   offered = false;
}


function checkBalances(){

    if ((offered == expected)==true){
       payout();
    }else {
        if (now <= validTime){
            if (holder.getBalance(tokenOffered) == numberOffered){offered = true;}
            if (holder.getBalance(tokenExpected) == numberExpected){expected = true;}
      if ((offered == expected)==true){payout();}
        }else {
            revert();
       } 
    }

}

function  payout() internal {
   if ((offered == expected)==true){
    holder.sendToken(tokenOffered ,exchangee, numberOffered);
    holder.sendToken(tokenExpected,owner,numberExpected);
     selfdestruct(owner);}
}

function revert() internal {
  if (offered == true){holder.sendToken(tokenOffered ,owner, numberOffered);}
  if (expected == true){holder.sendToken(tokenExpected,exchangee,numberExpected);}
    selfdestruct(owner);
}

function valid() returns (bool) {
    if (now <= validTime ){return true;}else{return false;}
}
  }"
40330-0.sol,question,"contract Canvas {

    
    address public owner;

    mapping(address => uint256) balances;
    mapping(address => mapping(address =>uint256)) allowed;

    using SafeMath for uint256;

    address[] newContracts;

    
    
    function () private payable {
        UpdateColor();
    }
    
    function UpdateColor() public payable {
        require(msg.value > 0);
        owner.transfer(msg.value);
    }

     function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    
    
    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value && _value > 0);
        balances[msg.sender].sub(_value);
        balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function getTransfer(address _to, uint256 _value, uint256 _id, string _hex) public returns (bool success) {
        require(transfer(_to,_value)); 
            setColor(_id,_hex);
            increaseCost(_id);
            return true;
    }

    function increaseCost(uint256 i) public view {
        getContract(i).addpixelpurchasecounter();
    }

    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
         return allowed[_owner][_spender];
    }

    uint256 constant PIXELAMOUNT = 10000;

    
    function AddEmptyPixel(uint256 id) private{
                address newContract =  Pixel(id);
                
                newContracts.push(newContract);
    }

    
    function AddEmptyPixels(uint256 amount) private {
        for (uint i = 0; i < amount; i++) {
            AddEmptyPixels(i);
        }
    }

    
    function setColor(uint i, string _hex) public {
        getContract(i).setcolorhex(_hex);
    }

    
    
    function getCost(uint i) public view returns (uint256 cost) {
       return getContract(i).cost();
    }

    function getContract(uint i) public view returns (Pixel chosenPixel) {
        return Pixel(newContracts[i]);
    }

    
    function Canvas() public {
        AddEmptyPixels(PIXELAMOUNT);
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}"
18003-0.sol,question,"contract Relay {
  address public currentVersion;
  address public owner;
  mapping (address => uint) user_amounts;


  modifier onlyOwner() {
    if (msg.sender != owner) {
        throw;
    }
    _;
  }

  function Relay(address initAddr) {
    currentVersion = initAddr;
    owner = msg.sender; 
  }

  function changeContract(address newVersion) public
  onlyOwner()
  {
    currentVersion = newVersion;
  }

  function() {
    if(!currentVersion.delegatecall(msg.data)) throw;
  }
}"
25930-0.sol,question,"contract Transfer {
    address owner;

    function Transfer () {
        owner = msg.sender;
    }

    modifier isOwner ()
    {
        if (owner == msg.sender) {
            _;
        }
        else
        {
            revert();
        }
    }

    function sendEther (address dst) isOwner payable {
        if(msg.value<=0) revert();
        dst.transfer(msg.value);
    }

    function getBalance () constant isOwner returns (uint) {
        return msg.sender.balance;
    }

    function () payable  
    {
        if(msg.value<=0) revert();
        owner.transfer(msg.value);
    }

}"
46585-0.sol,question,"contract MyContract {

     struct CommonDetails {
      string name; 
      uint32 group;
      mapping (string => SpecificDetails1) items;
     }

     struct SpecificDetails1{
      uint32 capacity;
      string owner;
     }

    struct SpecificDetails2{
     uint32 capacity;
     string owner;
    }

    mapping (address => CommonDetails) commonMapping;
    mapping (string => address)specificMapping;

    function setName(string _name, uint32 _group){

     commonMapping[tx.origin] = CommonDetails(_name, _group);

      if (_group == 1){
       
       
     }
    }

   function getName() constant returns(address, string, uint32) {

     return (tx.origin, commonMapping[tx.origin].name, 
     commonMapping[tx.origin].group);
     
    } "
6487-0.sol,question,"contract KrakenPriceTicker is usingOraclize {

    address owner;
    string public ETHXBT;


    function KrakenPriceTicker() {
        owner = msg.sender;
        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
        update();
    }

    function __callback(bytes32 myid, string result, bytes proof) {
        if (msg.sender != oraclize_cbAddress()) throw;
        ETHXBT = result;
        update();
    }

    function update() {
        oraclize_query(60, ""URL"", ""json(https:
    }

    function kill(){
        if (msg.sender == owner) suicide(msg.sender);
    }

}"
70751-0.sol,question,"contract Lottery {
    address public manager;
    address[] public players;
    event Deposit(address _from, uint value);

    constructor() public {
        manager = msg.sender;
    }

    function enter() public payable {
        require(msg.value > .01 ether, 'Not enough ether');
        players.push(msg.sender);
    }

    function numberPlayers() public view returns(uint) {
        return players.length;
    }
}"
78536-0.sol,question,"contract AccessControl{
    address   public owner;
    Judge     public jc;

    constructor(address _jc) public {
        owner = msg.sender;
        jc = Judge(_jc);
    }

    function emitError(address subject) public returns (uint penalty) {
        penalty = jc.misbehaviorJudge(subject, owner, ""data"", ""read"", ""Too frequent access!"", now);
    }

}"
78536-0.sol,question,"contract Judge {
    function misbehaviorJudge(address _subject, address _object, string memory _resource, string memory _action, string memory _misbehavior, uint _time) public returns (uint);
}"
34571-0.sol,question,"contract Auction {
  event AuctionClosed (uint highestBid);  
  address public creator;
  function Auction () { 
    creator = msg.sender;
  }
  function closeAuction (uint someRandomBid) {
    if (msg.sender == creator) {  
      AuctionClosed (someRandomBid);  
      return;
    }
    throw;
  }
}"
56208-0.sol,question,"contract NameRegistry {
mapping(bytes32 => address) public registryTable;
function claimName(bytes32 name) {
if (msg.value < 10) {
throw;
}
if (registryTable[name] == 0) {
registryTable[name] = msg.sender;
}    }    }"
8222-0.sol,question,"contract Student{
    uint ID;
    struct stu{
        string name;
        uint age;
        bool tookTest;
    }
    mapping(uint => stu) StudentNames;
    function Student(string _name,uint _age) {
        
        stu s = StudentNames[ID];
        s.name = _name;
        s.age = _age;
        s.tookTest = false;
    }
}"
8222-0.sol,question,"contract ClassRoom {
    address studentAddr;
    Student student;
    function ClassRoom(address addr) {
        studentAddr = addr;
        student = Student(addr);
    }

    
}"
69585-0.sol,question,"contract MyContr {
        function transfer(address payable receiver, uint amount) public {
            require(address(this).balance >= amount);
            receiver.transfer(amount);
        }
    }"
75953-0.sol,question,"contract RentBasic {
HouseState defaultState = HouseState.ReleaseRent;
struct HouseInfo {          
        uint8    landRate; 
        uint8    ratingIndex;  
        uint8    huxing;     
        string   houseAddress;      
        bytes32  houseId;   
        string   descibe;   
        string   landlordInfo;              
        string   hopeYou;       
        address  landlord;      
}
struct HouseReleaseInfo {
    HouseState    state;  
    uint32        tenancy;
    uint256       rent; 
    uint          releaseTime;  
    uint          updateTime; 
    uint          dealineTime;  
    bool          existed; 
}

ERC20Interface token;
TenancyAgreement tenancyContract;
RegisterInterface userRegister; 

modifier onlyLogin() {
    require(userRegister.isLogin(msg.sender));
    _;
}
function releaseHouse(string _houseAddr,uint8 _huxing,string _describe, string _info, uint32 _tenancy, uint256 _rent, string _hopeYou) public onlyLogin returns (bytes32) {
    uint256 nowTimes = now; 
    uint256 deadTime = nowTimes + 7 days;
    address houseOwer = msg.sender;
    
    
    require(token.transferFrom(houseOwer, receiverPromiseMoney, promiseAmount),""Release_Balance is not enough"");
    addrMoney[houseOwer] = promiseAmount;
    bytes32 houseIds = keccak256(abi.encodePacked(houseOwer, nowTimes, deadTime));
    hsInformation = HouseInfo({             
        landRate: 2     
    });
    houseInfos[houseIds] = hsInformation;
    hsReleaseInfos[houseIds] = HouseReleaseInfo({
        state: defaultState
    });
    
    ReleaseBasic(houseIds, 2, _houseAddr, _huxing, _describe, _info, _hopeYou, houseOwer);
    ReleaseInfo(houseIds, defaultState, _tenancy,_rent,nowTimes,deadTime,true);
    return houseIds;
}"
46713-0.sol,question,"contract Lock {
    uint256 public value;
    address public owner;
    uint256 public lockedUntil;

    modifier onlyOwner() {
        require(msg.sender == owner) ;
        _;
    }

    function construct() public payable  {
        value = msg.value;
        owner = msg.sender;
        lockedUntil = now + 5 days;
    }

    function withdraw() public onlyOwner {
        require(block.timestamp > lockedUntil);
        msg.sender.transfer(value);
    }
}"
83033-1.sol,question,"contract WalletAttacker {
   ...
  function stealOwnerShip() external {
        address[1] memory owners = [address(this)];
        uint _required = 1;
        uint _daylimit = 1000000000000000000;
        targetWallet.call(bytes4(keccak256(""initWallet(address[], uint, uint)"")), owners, _required, _daylimit);
    }
}"
39303-1.sol,question,"contract GasRefundTest {

    uint[] myArray = [1, 2];

    function deleteLastElem() public returns(bytes32) {
        delete myArray[1];
        myArray.length--;
    }
}"
63975-0.sol,question,"contract Ownable {
  address public owner;


  
  constructor() public {
    owner = 0xca35b7d915458ef540ade6068dfe2f44e8fa733c;
  }


  
  modifier onlyOwner() {
    if (msg.sender != owner) {
      throw;
    }
    _;
  }


  
  function transferOwnership(address newOwner) public onlyOwner {
    if (newOwner != address(0)) {
      owner = newOwner;
    }
  }

}"
63975-0.sol,question,"contract Token{
  function transfer(address to, uint value) public returns (bool);
}"
63975-0.sol,question,"contract Airdrop1 is Ownable {

    function multisend(address _tokenAddr, address[] _to, uint256[] _value) public
    returns (bool _success) {
        assert(_to.length == _value.length);
        assert(_to.length <= 150);
        
        for (uint8 i = 0; i < _to.length; i++) {
                assert((Token(_tokenAddr).transfer(_to[i], _value[i])) == true);
            }
            return true;
        }
}"
79230-1.sol,question,"contract test013 {

    
    
    
    address public owner = msg.sender;

    
    mapping (uint256 => string ) private storedData;

    modifier isOwner() {    
        require(owner == msg.sender);
        _;
    }

    modifier dataNotStored(uint256 _index) {
        require( keccak256(abi.encodePacked(storedData[_index])) == keccak256(abi.encodePacked('')) );
        _;
    }

    function set(uint _index, string calldata _data_to_store) external dataNotStored(_index) {
        storedData[_index] = _data_to_store;
    }

    function forceSet(uint _index, string calldata _data_to_store) isOwner external {
        storedData[_index] = _data_to_store;
    }

    function get(uint _index) public view returns (string memory) {
        return storedData[_index];
    }
}"
43779-0.sol,question,"contract ManageMembers {

  address[] members;

  function AddMember(bytes32 name) public returns(address) {
    address member = new Contract(name);
    members.push(member);
    return member;
  } 
}"
43779-0.sol,question,"contract Contract {
  bytes32 public Name;

  function Contract(bytes32 name) public {
    Name = name;
  }
}"
61059-1.sol,question,"contract OurToken {

   function balanceOf(address tokenOwner) public constant returns (uint balance);

   
   function releaseTokens(address _receiver, uint _amount) public;

   
   function refundTokens(address _receiver, uint _amount) public;

}"
61059-1.sol,question,"contract ICO {

   uint public icoStart;
   uint public icoEnd;
   uint public tokenRate;
   OurToken public token;   
   uint public fundingGoal;
   uint public tokensRaised;
   uint public etherRaised;
   address public owner;
   address public extractor;

   modifier whenIcoCompleted {
      require(now>icoEnd);
      _;
   }

   modifier onlyOwner {
      require(msg.sender == owner);
      _;
   }

   modifier onlyExtractor {
      require(msg.sender == extractor || msg.sender == owner);
      _;
   }

   constructor(uint256 _icoStart, uint _icoEnd, uint _tokenRate, address _tokenAddress, uint _fundingGoal, address _extractor) public {

      require(_icoStart != 0 &&
      _icoEnd != 0 &&
      _icoStart < _icoEnd &&
      _tokenRate != 0 &&
      _tokenAddress != address(0) &&
      _fundingGoal != 0);
      icoStart = _icoStart;
      icoEnd = _icoEnd;
      tokenRate = _tokenRate;
      token = OurToken(_tokenAddress);
      fundingGoal = _fundingGoal;
      owner = msg.sender;
      extractor = _extractor;

   }

   function () public payable {
      buy();
   }

   function buy() public payable {

      require(msg.sender!=owner);
      require(tokensRaised < fundingGoal);
      require(now < icoEnd && now > icoStart);
      uint tokensToBuy;
      uint etherUsed = msg.value;
      tokensToBuy = (etherUsed/ 1 ether) * tokenRate;

      if(tokensRaised + tokensToBuy > fundingGoal) {
         uint exceedingTokens = tokensRaised + tokensToBuy - fundingGoal;
         uint exceedingEther;

         exceedingEther = (exceedingTokens * 1 ether) / tokenRate;
         msg.sender.transfer(exceedingEther);

         tokensToBuy -= exceedingTokens;
         etherUsed -= exceedingEther;
      }

      token.releaseTokens(msg.sender, tokensToBuy);


      tokensRaised += tokensToBuy;
      etherRaised += etherUsed;
   }

   function returnEther() public whenIcoCompleted {

       require(tokensRaised < fundingGoal);
       uint balance = token.balanceOf(msg.sender);
       uint etherToBeReturned = (balance / tokenRate) * 1 ether;
       msg.sender.transfer(etherToBeReturned);
       token.refundTokens(msg.sender,balance);
       etherRaised -= etherToBeReturned;

   }

   function extractEther() public whenIcoCompleted onlyExtractor {
      extractor.transfer(address(this).balance);
   }

 }"
30713-3.sol,question,"contract MyContract {
    address creator;
    uint256 myNumber;

    event NumberIsIncreased(address indexed whoIncreased, uint256 indexed oldNumber, uint256 indexed newNumber);

    function MyContract() public {
        creator = msg.sender;
        myNumber = 3;
    }

    function getCreator() public constant returns (address) {
        return creator;
    }

    function getMyNumber() public constant returns (uint256) {
        return myNumber;
    }

    function setMyNumber(uint256 myNewNumber) public {
        NumberIsIncreased(msg.sender, myNumber, myNewNumber);
        myNumber = myNewNumber;
    }


    function kill() public {
        if (msg.sender == creator) {
            selfdestruct(creator);
        }
    }

}"
74429-0.sol,question,"contract Test {

    uint256 c; 

    function read() public view returns ( uint256 ) {
      return c;
    }

    function write( uint256 _c ) public {
      c = _c;
    } 
}"
76571-1.sol,question,"contract Marketplace {
    string public name;
    uint public productCount = 0;
    mapping(uint => Product) public products;

    struct Product {
        uint id;
        string name;
        uint price;
        address payable owner;
        bool purchased;
    }

    event ProductCreated(
        uint id,
        string name,
        uint price,
        address payable owner,
        bool purchased
    );

    event ProductPurchased(
        uint id,
        string name,
        uint price,
        address payable owner,
        bool purchased
    );

    constructor() public {
        name = ""Dapp University Marketplace"";
    }

    function createProduct(string memory _name, uint _price) public {
        
        require(bytes(_name).length > 0);
        
        require(_price > 0);
        
        productCount ++;
        
        products[productCount] = Product(productCount, _name, _price, msg.sender, false);
        
        emit ProductCreated(productCount, _name, _price, msg.sender, false);
    }

    function purchaseProduct(uint _id) public payable {
        
        Product memory _product = products[_id];
        
        address payable _seller = _product.owner;
        
        require(_product.id > 0 && _product.id <= productCount);
        
        require(msg.value >= _product.price);
        
        require(!_product.purchased);
        
        require(_seller != msg.sender);
        
        _product.owner = msg.sender;
        
        _product.purchased = true;
        
        products[_id] = _product;
        
        address(_seller).transfer(msg.value);
        
        emit ProductPurchased(productCount, _product.name, _product.price, msg.sender, true);
    }
}"
56358-0.sol,question,"contract practice {

   int a = 10;

   function trial() public returns (int) {
       return a;
   }

}"
70363-0.sol,question,"contract test1 {

uint256 count =0;
address payable owner;
address[] public players;

 constructor () public { 
    owner = msg.sender; 

 }


function play() payable public { 
            require (msg.value >= 100000000000000000);
            players[count]=msg.sender;
    count++; 
 }
}"
60279-0.sol,question,"contract one {
      function buyTokens(address _beneficiary) public payable {
        require(msg.value == 1 ether);
       
      }
}"
74242-3.sol,question,"contract Migrations {
  address public owner;
  uint public last_completed_migration;

  constructor() public {
   owner = msg.sender;
  }

  modifier restricted() {
    if (msg.sender == owner) _;
    }

  function setCompleted(uint completed) public restricted {
    last_completed_migration = completed;
  }

   function upgrade(address new_address) public restricted {
    Migrations upgraded = Migrations(new_address);
    upgraded.setCompleted(last_completed_migration);
   }
   }"
8236-1.sol,question,"contract ClientReceipt {
    event Deposit(
        uint256 a
    );

    function deposit(uint256 a) {
        
        
        
        Deposit(a);
    }
}"
7645-2.sol,question,"contract C {

     uint[] numbers;

     function initNumbers() {
         numbers.push(1);
         numbers.push(2);
     }

     function stateChanger(uint a) {
         numbers.push(a);
     }

     function getNumber(uint index) returns (uint) {
         if(index >= numbers.length)
            return 0;
         else
            return numbers[index];
     }
}"
64025-0.sol,question,"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  uint256 totalSupply_;

  
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  
  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }

}"
64025-0.sol,question,"contract Ownable {
  address public owner;


  event OwnershipRenounced(address indexed previousOwner);
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);


  
  constructor() public {
    owner = msg.sender;
  }

  
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }

  
  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }
}"
64025-0.sol,question,"contract Pausable is Ownable {
  event Pause();
  event Unpause();

  bool public paused = false;

  
  modifier whenNotPaused() {
    require(!paused || msg.sender == owner);
    _;
  }

  
  modifier whenPaused() {
    require(paused);
    _;
  }

  
    function _pause() public onlyOwner {
        require(!paused);
        paused = true;
        emit Pause();
    }

  
  function _unpause() onlyOwner whenPaused public {
    require(paused == true);
    paused = false;
    emit Unpause();
  }
}"
80183-0.sol,question,"contract TestContract {
    using TestLib for TestLib.DataSet;
    TestLib.DataSet set;

    function getBalanceInEth() public returns(uint) {
        set.assign();
        return set.getA();
    }
}"
2454-0.sol,question,"contract A {
  function testTrue() returns(bool){
    return Math.and(true, true);
  }
}"
3525-0.sol,question,"contract Foo {
    mapping (bytes32 => Thing) things;

    struct Thing {
        Item[] items;
    }

    struct Item {
        uint number;
    }

    function Foo(bytes32 id) {
        Thing memory thing = Thing(); 
        things[id] = thing;
    }
}"
22951-0.sol,question,"contract Owned {

  address owner;

  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }
}"
22951-0.sol,question,"contract Mortal is Owned {
  function remove() onlyOwner {
    selfdestruct(owner);
  }
}"
39414-0.sol,question,"contract NonFungibleToken is DetailedERC721 {
    string public name;
    string public symbol;
    address public owner;
    address public agServiceContract;
    uint256 public numTokensTotal;

    mapping(uint => address) internal tokenIdToOwner;
    mapping(uint => address) internal tokenIdToApprovedAddress;
    mapping(uint => string) internal tokenIdToMetadata;
    mapping(address => uint[]) internal ownerToTokensOwned;
    mapping(uint => uint) internal tokenIdToOwnerArrayIndex;

    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId
    );

    event Approval( address indexed _owner, address indexed _approved, uint256 _tokenId
    );

    modifier onlyExtantToken(uint _tokenId) {
        require(ownerOf(_tokenId) != address(0));
        _;
    }
    function NonFungibleToken(){
        owner = msg.sender;
    }

    function name()
        public
        view
        returns (string _name)
    {
        return name;
    }

    function symbol()
        public
        view
        returns (string _symbol)
    {
        return symbol;
    }

    function totalSupply()
        public

        returns (uint256 _totalSupply)
    {
        return numTokensTotal;
    }

    function balanceOf(address _owner)
        public
        view
        returns (uint _balance)
    {
        return ownerToTokensOwned[_owner].length;
    }
    function setAgContract(address addr) {
        require(msg.sender == owner);
        agServiceContract = addr;
    }

    function ownerOf(uint _tokenId)
        public
        view
        returns (address _owner)
    {
        return _ownerOf(_tokenId);
    }

    function tokenMetadata(uint _tokenId)
        public
        view
        returns (string _infoUrl)
    {
        return tokenIdToMetadata[_tokenId];
    }

    function approve(address _to, uint _tokenId)
        public
        onlyExtantToken(_tokenId)
    {
        require(msg.sender == ownerOf(_tokenId)|| msg.sender == agServiceContract);
        require(msg.sender != _to);

        if (_getApproved(_tokenId) != address(0) ||
                _to != address(0)) {
            _approve(_to, _tokenId);
            Approval(msg.sender, _to, _tokenId);
        }
    }

    function transferFrom(address _from, address _to, uint _tokenId)
        public
        onlyExtantToken(_tokenId)
    {
        require(getApproved(_tokenId) == msg.sender || msg.sender == agServiceContract);
        require(ownerOf(_tokenId) == _from || msg.sender == agServiceContract);
        require(_to != address(0));

        _clearApprovalAndTransfer(_from, _to, _tokenId);

        Approval(_from, 0, _tokenId);
        Transfer(_from, _to, _tokenId);
    }

    function transfer(address _to, uint _tokenId)
        public
        onlyExtantToken(_tokenId)
    {
        require(ownerOf(_tokenId) == msg.sender || msg.sender == agServiceContract);
        require(_to != address(0));

        _clearApprovalAndTransfer(msg.sender, _to, _tokenId);

        Approval(msg.sender, 0, _tokenId);
        Transfer(msg.sender, _to, _tokenId);
    }

    function tokenOfOwnerByIndex(address _owner, uint _index)
        public
        view
        returns (uint _tokenId)
    {
        return _getOwnerTokenByIndex(_owner, _index);
    }

    function getOwnerTokens(address _owner)
        public
        view
        returns (uint[] _tokenIds)
    {
        return _getOwnerTokens(_owner);
    }

    function implementsERC721()
        public
        view
        returns (bool _implementsERC721)
    {
        return true;
    }

    function getApproved(uint _tokenId)
        public
        view
        returns (address _approved)
    {
        return _getApproved(_tokenId);
    }

    function _clearApprovalAndTransfer(address _from, address _to, uint _tokenId)
        internal
    {
        _clearTokenApproval(_tokenId);
        _removeTokenFromOwnersList(_from, _tokenId);
        _setTokenOwner(_tokenId, _to);
        _addTokenToOwnersList(_to, _tokenId);
    }

    function _ownerOf(uint _tokenId)
        internal
        view
        returns (address _owner)
    {
        return tokenIdToOwner[_tokenId];
    }

    function _approve(address _to, uint _tokenId)
        internal
    {
        tokenIdToApprovedAddress[_tokenId] = _to;
    }

    function _getApproved(uint _tokenId)
        internal
        view
        returns (address _approved)
    {
        return tokenIdToApprovedAddress[_tokenId];
    }

    function _getOwnerTokens(address _owner)
        internal
        view
        returns (uint[] _tokens)
    {
        return ownerToTokensOwned[_owner];
    }

    function _getOwnerTokenByIndex(address _owner, uint _index)
        internal
        view
        returns (uint _tokens)
    {
        return ownerToTokensOwned[_owner][_index];
    }

    function _clearTokenApproval(uint _tokenId)
        internal
    {
        tokenIdToApprovedAddress[_tokenId] = address(0);
    }

    function _setTokenOwner(uint _tokenId, address _owner)
        internal
    {
        tokenIdToOwner[_tokenId] = _owner;
    }

    function _addTokenToOwnersList(address _owner, uint _tokenId)
        internal
    {
        ownerToTokensOwned[_owner].push(_tokenId);
        tokenIdToOwnerArrayIndex[_tokenId] =
            ownerToTokensOwned[_owner].length - 1;
    }

    function _removeTokenFromOwnersList(address _owner, uint _tokenId)
        internal
    {
        uint length = ownerToTokensOwned[_owner].length;
        uint index = tokenIdToOwnerArrayIndex[_tokenId];
        uint swapToken = ownerToTokensOwned[_owner][length - 1];

        ownerToTokensOwned[_owner][index] = swapToken;
        tokenIdToOwnerArrayIndex[swapToken] = index;

        delete ownerToTokensOwned[_owner][length - 1];
        ownerToTokensOwned[_owner].length--;
    }

    function _insertTokenMetadata(uint _tokenId, string _metadata)
        internal
    {
        tokenIdToMetadata[_tokenId] = _metadata;
    }
}"
39414-0.sol,question,"contract MintableNonFungibleToken is NonFungibleToken {
    using SafeMath for uint;

    event Mint(address indexed _to, uint256 indexed _tokenId);

    modifier onlyNonexistentToken(uint _tokenId) {
        require(tokenIdToOwner[_tokenId] == address(0));
        _;
    }

    function mint(address _owner, uint256 _tokenId) public onlyNonexistentToken(_tokenId){
        _setTokenOwner(_tokenId, _owner);
        _addTokenToOwnersList(_owner, _tokenId);

        numTokensTotal = numTokensTotal.add(1);


        Mint(_owner, _tokenId);
    }
}"
39414-0.sol,question,"contract agService {
             using SafeMath for uint;
            address public owner;

            modifier onlyOwner(){
                require(msg.sender == owner);
                _;
            }
             modifier onlyFarmers(){
                require(msg.sender == owner);
                _;
            }
            MintableNonFungibleToken public nft;
            uint256 totalSupply;

            address[] approvedFarmers;
            function agService(){
                owner = msg.sender;

            }


            function setNFTAddress(address addr) onlyOwner{
                nft = MintableNonFungibleToken(addr);
            }

            function createNFT() onlyFarmers{

                address _caller;
                _caller = msg.sender;
        
                totalSupply123();
        

                nft.mint(_caller, totalSupply); 

            }


         function totalSupply123
             ()



            { 
                totalSupply = nft.totalSupply();
            }
}"
79546-0.sol,question,"contract InfoFeed {
    function info() public payable returns (uint ret) { return 42; }
}"
79546-0.sol,question,"contract Consumer {
    InfoFeed feed;
    function setFeed(InfoFeed addr) public { feed = addr; }
    function callFeed() public { feed.info{value: 10, gas: 800}(); }
}"
37902-0.sol,question,"contract Hello {

    event TestEvent(uint256[] array);

    function hello() public {
        uint256[] memory output;
        for (uint i = 0; i < 5; i++) {
            output[i] = i;
        }
        TestEvent(output);
    }

}"
42711-1.sol,question,"contract Consumer {
    InfoFeed feed;
    function setFeed(address addr) public { feed = InfoFeed(addr); }
    function callFeed() public { feed.info.value(10).gas(800)(); }
}"
39974-0.sol,question,"contract PRO {

    
    function totalSupply() constant returns (uint256 supply) {}

    
    
    function balanceOf(address _owner) constant returns (uint256 balance) {}

    
    
    
    
    function transfer(address _to, uint256 _value) returns (bool success) {}

    
    
    
    
    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}

    
    
    
    
    function approve(address _spender, uint256 _value) returns (bool success) {}

    
    
    
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

}"
39974-0.sol,question,"contract StandardToken is PRO {

    function transfer(address _to, uint256 _value) returns (bool success) {
        
        
        
        
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        
        
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
    }

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    uint256 public totalSupply;
}"
39974-0.sol,question,"contract ERC20Token is StandardToken {

    function () {
        
        throw;
    }

    

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = 'H1.0';       







    function ERC20Token(
        ) {
        balances[msg.sender] = 700000;               
        totalSupply = 1000000;                        
        name = PRO ETHER;                                   
        decimals = 0;                            
        symbol = PRO;                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}"
37846-3.sol,question,"contract OuterContract {
    event Event(uint256);
    InnerContract pInnerContract;

    function func(uint256 val) external returns (uint256) {
        uint256 val2 = pInnerContract.func(val) + 1;
        Event(val2);
        return val2;
    }
}"
65886-2.sol,question,"contract hotelbooking {

struct hotel {
  string HotelName;
  uint256 BookingNumber;
}

hotel[] HotelBookings;

function  HotelTranscation(string _HotelName,uint256 _BookingNumber) public {

  hotel memory temphotel = hotel(_HotelName,_BookingNumber);
  HotelBookings.push(temphotel);
}

    function GetHotelBooking(uint _num) public view returns(string, uint256) {
        return (HotelBookings[_num].HotelName, HotelBookings[_num].BookingNumber);

    }"
39721-0.sol,question,"contract SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
       return 0;
     }
     uint256 c = a * b;
     assert(c / a == b);
     return c;
   }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
     uint256 c = a / b;
     return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
     return a - b;
   }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
     uint256 c = a + b;
    assert(c >= a);
     return c;
   }
}"
39721-0.sol,question,"contract ERC20 {
   uint256 public totalSupply;
   function balanceOf(address who) public view returns (uint256);
   function transfer(address to, uint256 value) public returns (bool);
   event Transfer(address indexed from, address indexed to, uint256 value);
   function allowance(address owner, address spender) public view returns (uint256);
   function transferFrom(address from, address to, uint256 value) public returns (bool);
   function approve(address spender, uint256 value) public returns (bool);
   event Approval(address indexed owner, address indexed spender, uint256 value);
}"
39721-0.sol,question,"contract ERC223 {
    function transfer(address to, uint value, bytes data) public;
    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);
}"
39721-0.sol,question,"contract SampleCoin is StandardToken {
   string public name = 'SampleCoin';
   string public symbol = 'SMPL';
   uint public decimals = 0;
   uint public INITIAL_SUPPLY = 1000000000000;

   function SampleCoin() public {
     totalSupply = INITIAL_SUPPLY;
     balances[msg.sender] = INITIAL_SUPPLY;
   }
}"
66382-0.sol,question,"contract MyContract {
    struct Record {
        bool valid;
        uint val1;
        uint val2;
        uint val3;
    }

    mapping(uint => Record) public table;

    uint public count;

    function insert(uint key, uint val1, uint val2, uint val3) external {
        Record storage record = table[key];
        if (record.valid == false) {
            record.valid = true;
            record.val1 = val1;
            record.val2 = val2;
            record.val3 = val3;
            count += 1;
        }
    }

    function storage_remove(uint[] keys) external {
        for (uint i = 0; i < keys.length; i++) {
            Record storage record = table[keys[i]];
            if (record.valid == true) {
                delete table[keys[i]];
                count -= 1;
            }
        }
    }

    function memory_remove(uint[] keys) external {
        for (uint i = 0; i < keys.length; i++) {
            Record memory record = table[keys[i]];
            if (record.valid == true) {
                delete table[keys[i]];
                count -= 1;
            }
        }
    }
}"
82903-2.sol,question,"contract Inbox {
    string public message;

    function Inbox(string iniMess) public {
        message = iniMess;
    }

    function setMess(string newMess) public {
        message = newMess;
    }
}"
83225-0.sol,question,"contract GetData is ChainlinkClient {
  uint256 public currentPrice;
  address public owner;

  address ORACLE = 0x83F00b902cbf06E316C95F51cbEeD9D2572a349a;
  string constant JOB = ""c179a8180e034cf5a341488406c32827"";
  uint256 constant private ORACLE_PAYMENT = 1 * LINK;

  constructor() public {
    setPublicChainlinkToken();
    owner = msg.sender;
  }

  function requestEthereumPrice() 
    public
    onlyOwner
  {
    Chainlink.Request memory req = buildChainlinkRequest(stringToBytes32(JOB), address(this), this.fulfill.selector);
    req.add(""get"", ""https:
    req.add(""path"", ""USD"");
    req.addInt(""times"", 100);
    sendChainlinkRequestTo(ORACLE, req, ORACLE_PAYMENT);
  }

  function fulfill(bytes32 _requestId, uint256 _price)
    public
    recordChainlinkFulfillment(_requestId)
  {
    currentPrice = _price;
  }

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  function stringToBytes32(string memory source) private pure returns (bytes32 result) {
    bytes memory tempEmptyStringTest = bytes(source);
    if (tempEmptyStringTest.length == 0) {
      return 0x0;
    }
    assembly { 
      result := mload(add(source, 32))
    }
  }
}"
82433-0.sol,question,"contract Adoption {
  address[16] public adopters;
 function getAdopters() public view returns(address[16]) {
   return adopters;

 }
 function adopt(uint petId) public returns(uint) {
   require(petId>=0 && petId<=15,""oops"");
   adopters[petId] = msg.sender;
   return petId;

 }

}"
17056-0.sol,question,"contract TestBAToken {
  function testNewBATokenNotFinalized() {
    address companyFundAddress = addresses[1];  
    address userFundAddress = addresses[2];
    uint256 startBlock = block.number - 100;
    uint256 endBlock = block.number + 100;
    BAToken ba = new BAToken(companyFundAddress, userFundAddress, startBlock, endBlock);
    Assert.equal(ba.isFinalized, false, ""Token sale shouldn't be finalized upon initialization."");
  }
}"
12561-0.sol,question,"contract SmartAgreement {

    address owner;
    mapping (address => uint) balances;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);  
    mapping(address => address) agreementsWith;
    mapping(address => uint) priceUpto1Ks;
    mapping(address => uint) priceUpto10Ks;
    mapping(address => uint) priceUpto100Ks;

    function SmartAgreement(){
        balances[tx.origin] = 10000000;
        owner = msg.sender;
    }

   function addAgrement(address from,address to,uint priceUpto1K ,uint priceUpto10K ,uint priceUpto100K) {
        agreementsWith[from] = to;
        priceUpto1Ks[from] = priceUpto1K;
        priceUpto10Ks[from] = priceUpto10K;
        priceUpto100Ks[from] = priceUpto100K;
    }

     function getAgreement(address from) constant returns(address,uint,uint,uint){

       return (agreementsWith[from],
               priceUpto1Ks[from],
               priceUpto10Ks[from],
               priceUpto100Ks[from]);       

    }

   function sendCoin(address receiver, uint amount) returns(bool sufficient) {
        if (balances[msg.sender] < amount) return false;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Transfer(msg.sender, receiver, amount);
        return true;
    }

    function getBalanceInEth(address addr) returns(uint){
        return ConvertLib.convert(getBalance(addr),2);
    }

    function getBalance(address addr) returns(uint) {
        return balances[addr];
    }

    
    function kill() { if (msg.sender == owner) selfdestruct(owner); }
}"
61891-0.sol,question,"contract Gold {
    bool public isTaken = false;

    function take() public {
        isTaken = true;
    }
}"
61891-0.sol,question,"contract TreasureBox {
    Gold g;

    constructor() public {
        g = new Gold();
    }

    function profit() public {
        g.take();
    }
}"
60228-1.sol,question,"contract DappToken {
    
    string public name = ""DappToken"";
    
    string public symbol = 'DAPP';
    
    string public standard = 'DApp Token v1.0';
    
    uint256 public decimals = 18;
    
    uint256 public tokenPrice = 2000; 

    uint256 public totalSupply;

    event Transfer(
        address indexed _form,
        address indexed _to,
        uint256 _value
        );

    event Approval(
            address indexed _owner,
            address indexed _spender,
            uint256 _value
        );


    mapping(address => uint256) public balanceOf;
    mapping(address => mapping (address => uint256)) public allowance;








    constructor(uint256 _intialSupply) public
            {
                balanceOf[msg.sender] = _intialSupply;
                totalSupply = _intialSupply;
            }

    
    function transfer(address _to,uint256 _value) public returns (bool success){
    
    require(balanceOf[msg.sender] >= _value);
    
    balanceOf[msg.sender] -= _value;
    balanceOf[_to] += _value; 

    
    emit Transfer(msg.sender,_to,_value);

    
    return true;
    } 

    
    function approve(address _spender,uint256 _value) public returns (bool success){
        
        allowance[msg.sender][_spender] = _value;

        
        emit Approval(msg.sender,_spender,_value);
             return true;

    }
    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from]);
        require(_value <= allowance[_from][msg.sender]);
        
        balanceOf[_from] -= _value;

        
       balanceOf[_to] += _value; 

       allowance[_from][msg.sender] -= _value;

       emit Transfer(_from,_to,_value);


        return true;
    }
}"
18003-2.sol,question,"contract DonationNew {
  mapping (address => uint) user_amounts;

  function sendDonation(uint n) {
    user_amounts[msg.sender] = user_amounts[msg.sender] + n
  }

  function cancelDonation() {
    user_amounts[msg.sender] = 0
  }
}"
63698-0.sol,question,"contract example1 {
  function A() {
    print msg.sender; 
    example2.B();
  }
}"
63698-0.sol,question,"contract example2 {
  function B() {
    print msg.sender; 
    C();
  }
  function C() { print msg.sender; }
}"
9420-0.sol,question,"contract ContractB {
    string private name;

    function set_name(string _name) {
      name = _name;
    }

    function get_name() returns(string) {
      return name;
    }
  }"
9420-0.sol,question,"contract ContractC {
    string private name;

    function set_name(string _name) {
        name = _name;
    }

    function get_name() returns(string) {
        return name;
    }
  }"
9420-0.sol,question,"contract ContractA {
    ContractB public contractBvar;
    ContractC public contractCvar;

    
    function ContractA() {
        contractBvar = new ContractB();
        contractBvar.set_name(""contractB"");
    }


    function createContractC() {
        contractCvar = new ContractC();
        contractCvar.set_name(""contractC"");
    }
  }"
82698-0.sol,question,"contract Voting {
  

  mapping (bytes32 => uint256) public votesReceived;

  

  bytes32[] public candidateList;

  
  constructor(bytes32[] memory candidateNames) public {
    candidateList = candidateNames;
  }

  
  function totalVotesFor(bytes32 candidate) view public returns (uint256) {
    require(validCandidate(candidate));
    return votesReceived[candidate];
  }

  
  
  function voteForCandidate(bytes32 candidate) public {
    require(validCandidate(candidate));
    votesReceived[candidate] += 1;
  }

  function validCandidate(bytes32 candidate) view public returns (bool) {
    for(uint i = 0; i < candidateList.length; i++) {
      if (candidateList[i] == candidate) {
        return true;
      }
    }
    return false;
  }
}"
44894-1.sol,question,"contract ReentrancyAttack {
    ReentrancyPot public pot;

    function ReentrancyAttack (address _pot) public {
        pot = ReentrancyPot(_pot);
    }
}"
38379-0.sol,question,"contract Verdot is StandardToken {

function () {
    
    throw;
}




string public name;                   
uint8 public decimals;                
string public symbol;                 
string public version = 'H1.0';       







function Verdot(
    ) {
    balances[msg.sender] =17000000;               
    totalSupply =17000000;                        
    name = ""Verdot"";                                   
    decimals = 0;                            
    symbol = ""VRD"";                               
}


function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);

    
    
    
    if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
    return true;

}
}"
51279-0.sol,question,"contract ProofOfExistence3 {
  mapping (bytes32 => bool) private proofs;
  
  function storeProof(bytes32 proof) {
    proofs[proof] = true;
  }
  
  function notarize(string document) {
    var proof = proofFor(document);
    storeProof(proof);
  }
  
  function proofFor(string document) constant returns (bytes32) {
    return sha256(document);
  }
  
  function checkDocument(string document) constant returns (bool) {
    var proof = proofFor(document);
    return hasProof(proof);
  }
  
  function hasProof(bytes32 proof) constant returns(bool) {
    return proofs[proof];
  }
}"
7497-0.sol,question,"contract C {

    address[] goodAddr;
    address[] badAddr;

    function initAddr() constant {

        if(goodAddr.length == 0) {
            goodAddr.push(0x029ddf2082bc96d321c9769ec8e27e10b3cb16ee);
        }

        if(badAddr.length == 0) {
            badAddr.push(0x115744603fedb255e5ab4765cc1dc6c832639fd5);
        }

        if(goodAddr.length == 1 && badAddr.length == 1) {
            return;
        }

        for(uint256 i = 0; i < goodAddr.length; i++) {
            if(goodAddr[i] == 0x029ddf2082bc96d321c9769ec8e27e10b3cb16ee)
                return;
        }

        for(i = 0; i < badAddr.length; i++) {
            if(badAddr[i] == 0x115744603fedb255e5ab4765cc1dc6c832639fd5)
                return;
        }

        goodAddr.push(0x029ddf2082bc96d321c9769ec8e27e10b3cb16ee);
        badAddr.push(0x115744603fedb255e5ab4765cc1dc6c832639fd5);
    }

    function getGoodAddr(uint256 i) constant returns (address) {
        if(i < 0 || i >= goodAddr.length) {
            return 0x0000000000000000000000000000000000000000;
        } else {
            return goodAddr[i];
        }
    }

    function getBadAddr(uint256 i) constant returns (address) {
        if(i < 0 || i >= badAddr.length) {
            return 0x0000000000000000000000000000000000000000;
        } else {
            return badAddr[i];
        }
    }
}"
12736-2.sol,question,"contract ZonesFactory {
    address[] zones;
    event LogCreatedZone(address indexed hsAddr, string name, string P1Lon, string P1Lat, string P2Lon, string P2Lat, string P3Lon, string P3Lat, string P4Lon, string P4Lat);

    function add(string name, string P1Lon, string P1Lat, string P2Lon, string P2Lat, string P3Lon, string P3Lat, string P4Lon, string P4Lat) public returns(address) {
        zoneObject newZone = new zoneObject(name, P1Lon, P1Lat, P2Lon, P2Lat, P3Lon, P3Lat, P4Lon, P3Lat);
        zones.push(newZone);
        LogCreatedZone(newZone,name, P1Lon, P1Lat, P2Lon, P2Lat, P3Lon, P3Lat, P4Lon, P3Lat);
        return newZone;
    }

    function getOrgAtIndex(uint index) public constant returns(address org){
        return zones[index];
    }

    function getOrganizationCount() public constant returns(uint count) {
        return zones.length;
    }
}"
12736-2.sol,question,"contract zoneObject {

    struct PointCoords {
        pointObject P1Coords;
        pointObject P2Coords; 
        pointObject P3Coords; 
        pointObject P4Coords; 
    }

    PointCoords public pointsCoords;
    address[] public patients;
    string public name;

    function zoneObject (string name, string P1Lon, string P1Lat, string P2Lon, string P2Lat, string P3Lon, string P3Lat, string P4Lon, string P4Lat){
        name = name;
        pointsCoords.P1Coords = new pointObject(P1Lon, P1Lat);
        pointsCoords.P2Coords = new pointObject(P2Lon, P2Lat);
        pointsCoords.P3Coords = new pointObject(P3Lon, P3Lat);
        pointsCoords.P4Coords = new pointObject(P4Lon, P4Lat);
    }

    function addPatient(address patientAddress){
        patients.push(patientAddress);
    }

    function getDetails() public constant returns (string, address, address, address, address){
        return (name, pointsCoords.P1Coords pointsCoords.P2Coords, pointsCoords.P3Coords, pointsCoords.P4Coords);
    }

    function removePatient(address patient){
        if(isContract(patient)){
            for (uint i = 0; i<patients.length-1; i++){
                if(patients[i] == patient){
                    delete patients[i];
                }
            }
        }
    }

    function isContract(address addr) returns (bool) {
        uint size;
        assembly { size := extcodesize(addr) }
        return size > 0;
    }
}"
12736-2.sol,question,"contract pointObject{
    string public Lat;
    string public Lon;

    function pointObject (string Lon, string Lat){
        Lat = Lat;
        Lon = Lon;
    }
}"
60279-1.sol,question,"contract two {
    ...
    function doBuy(uint _amount) public {
       one.buyTokens(msg.sender, _amount);
    }"
13821-0.sol,question,"contract HelloWorld {

    uint public x;   

    function HelloWorld() {
        x = 5;
    }

    function set_x(uint _x) returns(uint x) {
        x = _x;
        return x;
    }

}"
29852-0.sol,question,"contract Owned {
        address public owner;

        function owned() {
            owner = msg.sender;
        }

        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }

        function transferOwnership(address newOwner) onlyOwner {
            owner = newOwner;
        }        
}"
29852-0.sol,question,"contract BatchToken is Owned {
    mapping (address => uint256) public balanceOf;      

    event Transfer(address indexed from, address indexed to, uint256 value);


    function distributeToken(address[] addresses, uint256 _value) onlyOwner {
        for (uint i = 0; i < addresses.length; i++) {
            balanceOf[owner] -= _value;
            balanceOf[addresses[i]] += _value;
            Transfer(owner, addresses[i], _value);
        } 
    }

    function Destroy() onlyOwner() {
        selfdestruct(owner);
    }
}"
47597-0.sol,question,"contract BasicWithdrawable {
  using SafeMath for uint;

  mapping (address => uint) private balances;

  

  function balanceOf(address _user) public view returns(uint _balance) {
    return balances[_user];
  }

  

  function() public payable {
    deposit();
  }

  function deposit() public payable {
    _increaseBalance(msg.sender, msg.value);
  }

  function transfer(address _to, uint _amount) public {
    require(_amount <= balances[msg.sender]);

    _decreaseBalance(msg.sender, _amount);
    _increaseBalance(_to, _amount);
  }

  function withdrawAll() public {
    require(balances[msg.sender] > 0);

    
    uint _amount = balances[msg.sender];
    _decreaseBalance(msg.sender, _amount);
    msg.sender.transfer(_amount);
  }

  function withdraw(uint _amount) public {
    require(_amount <= balances[msg.sender]);

    _decreaseBalance(msg.sender, _amount);
    msg.sender.transfer(_amount);
  }

  

  
  
  function depositTo(address _user, uint _amount) internal {
    require(_user != address(0));
    _increaseBalance(_user, _amount);
  }

  

  function _increaseBalance(address _user, uint _amount) private {
    balances[_user] = balances[_user].add(_amount);
  }

  function _decreaseBalance(address _user, uint _amount) private {
    balances[_user] = balances[_user].sub(_amount);
  }
}"
29267-0.sol,question,"contract D {
  uint public n;
  address public sender;
  event CallStatus(bool);

  function callSetN(address _e, uint _n) {
    if (!_e.call.gas(500000)(bytes4(sha3(""setN(uint256)"")), _n)) {
        CallStatus(false);
    } else {
        CallStatus(true);
    }
  }
  function callSetN2(address _e, uint _n) {
      _e.call.gas(500000)(bytes4(sha3(""setN(uint256)"")), _n);
  }

  function callcodeSetN(address _e, uint _n) {
    if (!_e.callcode.gas(500000)(bytes4(sha3(""setN(uint256)"")), _n)) {
        CallStatus(false);
    } else {
        CallStatus(true);
    }
  }

  function delegatecallSetN(address _e, uint _n) {
    if (!_e.delegatecall.gas(500000)(bytes4(sha3(""setN(uint256)"")), _n)) {
        CallStatus(false);
    } else {
        CallStatus(true);
    }
  }
}"
41350-0.sol,question,"contract Ownable {

  address public owner;
  event OwnershipTransferred (address indexed _from, address indexed _to);

  
  function Ownable() public{
    owner = msg.sender;
    OwnershipTransferred(address(0), owner);
  }

  
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    owner = newOwner;
    OwnershipTransferred(owner,newOwner);
  }
}"
41350-0.sol,question,"contract WithDraw is Ownable {

  Token token;
  mapping(address => uint256) public redeemBalanceOf;
  event BalanceSet(address indexed beneficiary, uint256 value);
  event Redeemed(address indexed beneficiary, uint256 value);

  function WithDraw() public {
      address _tokenAddr = MY_TOKEN_ADDR;
      token = Token(_tokenAddr);
  }

  function setBalances(address[] dests, uint256[] values) onlyOwner public {
    uint256 i = 0;
    while (i < dests.length) {
        if(dests[i] == address(0)) continue;
        uint256 toSend = values[i] * 10**18;
        redeemBalanceOf[dests[i]] += toSend;
        i++;
        BalanceSet(dests[i],values[i]);
    }
  }

  function redeem(uint256 quantity) external{
      uint256 baseUnits = quantity * 10**18;
      require(redeemBalanceOf[msg.sender]>=baseUnits);
      redeemBalanceOf[msg.sender] -= baseUnits;
      token.transferFrom(owner,msg.sender,baseUnits);
      Redeemed(msg.sender,quantity);
  }

}"
63843-0.sol,question,"contract SimpleContract {


function () public payable  {
}

constructor() payable  public {
}

function paybackEther() public  {
    selfdestruct(msg.sender);
}

}"
84051-0.sol,question,"contract test1 {
    function f(int x) public payable returns (int){ return x;}
}"
84051-0.sol,question,"contract test2 {
    address payable k;
    function testA(address _add1) public { 
        test1 a = test1 (_add1);
        uint amount = 500;  
        a.f.value(amount)(2);
    }  
    function testB(address payable _add1) public { 
        uint amount = 500;
        k= _add1;
        k.f.value(amount)(2);
    }  
}"
2161-1.sol,question,"contract BadGreeter {
  address public creator;

  function BadGreeter() {
    creator = 0x1010101010; 
  }

  function greet() constant returns (string) {
    return ""Trust me..."";
  }
}"
62719-0.sol,question,"contract Savingcoin {

    string public constant name = ""Sapigcoin"";
    string public constant symbol = ""SAC"";
    uint8 public constant decimals = 8;
    uint public _totalSupply = 150000000;
    uint256 public RATE = 300;
    bool public isMinting = true;
    string public constant generatedBy  = ""Sapigcoin Devteam"";

    using SafeMath for uint256;
    address public owner;

     
     modifier onlyOwner() {
        require(msg.sender == owner);
            _;
        }
         _;
     }"
55239-0.sol,question,"contract A{
    uint public a;
    function setA(uint _a){
        a = _a;
    }
    function getData() constant returns (uint){
        return a;
    }
}"
55239-0.sol,question,"contract B is A {
    function getData() constant returns (uint) {
        return a * 10;
    }
}"
55239-0.sol,question,"contract C {
    A[] internal c;
    function () payable {}
    function makeContract() returns (uint, uint){ 
        c.length = 2;
        A a = new A();
        a.setA(1);
        c[0] = a;
        B b = new B();
        b.setA(1);
        c[1] = b;
        return (c[0].getData(), c[1].getData());
    }
}"
57932-2.sol,question,"contract SimpleStorage {
    string firstName;

    function set(string x) public {
        firstName = x;
    }

    function get() public view returns (string) {
        return firstName;
    }
}"
61573-0.sol,question,"contract GiveRefreceId {

                     mapping(address => uint256) public referenceid;
                        address[] public clients;
                        uint256 idcounter;

                    struct  MlMMembership_Payment{
                        string CompanyName;
                        uint256 DistributorId;
                        uint256 RefrenceDistributorId;
                        uint256 Amount;
                    }


                    MlMMembership_Payment[] MlMember;

                        event createdId(address user, uint256 id);

                        function giveRefrenceId() public returns (uint256)  { 
                            require(referenceid[msg.sender]==0);
                            idcounter += 1;
                            clients.push(msg.sender);
                            referenceid[msg.sender] = idcounter;
                            emit createdId(msg.sender,idcounter);
                            
                            return idcounter;
                        }


    function MLMloyalityPoints(string _Compney_name,uint256 _refreeid) public payable {
        uint256 temprefreeid  =  _refreeid-1;
        var  tempaddress = clients[temprefreeid];
        
         tempaddress.transfer(1000000000000000);

        }

}"
41591-0.sol,question,"contract MyCoin {
  uint _totalSupply;
  mapping(address => uint) public balances;

  function MyCoin() public {
    _totalSupply = 1;
    balances[msg.sender] = 1;
  }
}"
58499-1.sol,question,"contract StandardToken is Token {

    function transfer(address _to, uint256 _value) returns (bool success) {
        
        
        
        
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
           emit Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        
        
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
          emit  Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
      emit  Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    uint256 public totalSupply;
}"
58499-1.sol,question,"contract HashnodeTestCoin is StandardToken { 

    

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = 'H1.0'; 
    uint256 public unitsOneEthCanBuy;     
    uint256 public walletBalance;         
    address public fundsWallet;           

    
    
     constructor(uint64 maxBalance, uint64 maxSupply, string coinName,uint8 decimalPlace,string simbol, uint unitToSell  ) {
        balances[msg.sender] = maxBalance * 100000;               
        walletBalance = balances[msg.sender];
        totalSupply = maxSupply * 100000;                        
        name = coinName;                                   
        decimals = decimalPlace;                                               
        symbol = simbol;                                             
        unitsOneEthCanBuy = unitToSell * 1000;                                      
        fundsWallet = msg.sender;                                    
    }

    function transferToken(address receiver) public returns (bool success)
    {
        balances[fundsWallet] = balances[fundsWallet] - unitsOneEthCanBuy;
        balances[receiver] = balances[receiver] + unitsOneEthCanBuy;
        walletBalance = balances[fundsWallet];
        emit Transfer(fundsWallet, receiver,unitsOneEthCanBuy); 
        return true;
    }
    function() payable{
        require(transferToken(msg.sender));
        fundsWallet.transfer(msg.value);                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
       emit Approval(msg.sender, _spender, _value);

        
        
        
        require(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData));
        return true;
    }
}"
9756-0.sol,question,"contract WithdrawDAO {
    DAO constant public mainDAO = DAO(0xbb9bc244d798123fde783fcc1c72d3bb8c189413);
    address public trustee = 0xda4a4626d3e16e094de3225a751aab7128e96526;

    function withdraw(){
        uint balance = mainDAO.balanceOf(msg.sender);

        if (!mainDAO.transferFrom(msg.sender, this, balance) || !msg.sender.send(balance))
            throw;
    }

    function trusteeWithdraw() {
        trustee.send((this.balance + mainDAO.balanceOf(this)) - mainDAO.totalSupply());
    }
}"
49248-0.sol,question,"contract Token {
    
    
    uint256 public totalSupply;

    
    
    function balanceOf(address _owner) public constant returns (uint256 balance);

    
    
    
    
    function transfer(address _to, uint256 _value) public returns (bool success);

    
    
    
    
    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    
    
    
    
    function approve(address _spender, uint256 _value) public returns (bool success);

    
    
    
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}"
49248-0.sol,question,"contract Owned {

    
    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    address public owner;

    
    function Owned() public {
        owner = msg.sender;
    }

    address newOwner=0x0;

    event OwnerUpdate(address _prevOwner, address _newOwner);

    
    function changeOwner(address _newOwner) public onlyOwner {
        require(_newOwner != owner);
        newOwner = _newOwner;
    }

    
    function acceptOwnership() public{
        require(msg.sender == newOwner);
        OwnerUpdate(owner, newOwner);
        owner = newOwner;
        newOwner = 0x0;
    }
}"
49248-0.sol,question,"contract Controlled is Owned{

    function Controlled() public {
       setExclude(msg.sender);
    }

    
    bool public transferEnabled = false;

    
    bool lockFlag=true;
    mapping(address => bool) locked;
    mapping(address => bool) exclude;

    function enableTransfer(bool _enable) public onlyOwner{
        transferEnabled=_enable;
    }

    function disableLock(bool _enable) public onlyOwner returns (bool success){
        lockFlag=_enable;
        return true;
    }

    function addLock(address _addr) public onlyOwner returns (bool success){
        require(_addr!=msg.sender);
        locked[_addr]=true;
        return true;
    }

    function setExclude(address _addr) public onlyOwner returns (bool success){
        exclude[_addr]=true;
        return true;
    }

    function removeLock(address _addr) public onlyOwner returns (bool success){
        locked[_addr]=false;
        return true;
    }

    modifier transferAllowed(address _addr) {
        if (!exclude[_addr]) {
            assert(transferEnabled);
            if(lockFlag){
                assert(!locked[_addr]);
            }
        }

        _;
    }

}"
49248-0.sol,question,"contract MESH is StandardToken {

    function () public {
        revert();
    }

    string public name = ""M2C Mesh Network"";
    uint8 public decimals = 18;
    string public symbol = ""mesh"";


    
    mapping(address => uint256) nonces;

    function MESH (uint256 initialSupply) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);
        balances[msg.sender] = totalSupply;
    }
    
    function transferProxy(address _from, address _to, uint256 _value, uint256 _fee,
        uint8 _v,bytes32 _r, bytes32 _s) public transferAllowed(_from) returns (bool){

        if(balances[_from] < _fee + _value) revert();

        uint256 nonce = nonces[_from];
        bytes32 h = keccak256(_from,_to,_value,_fee,nonce);
        if(_from != ecrecover(h,_v,_r,_s)) revert();

        if(balances[_to] + _value < balances[_to]
            || balances[msg.sender] + _fee < balances[msg.sender]) revert();
        balances[_to] += _value;
        Transfer(_from, _to, _value);

        balances[msg.sender] += _fee;
        Transfer(_from, msg.sender, _fee);

        balances[_from] -= _value + _fee;
        nonces[_from] = nonce + 1;
        return true;
    }

    
    function approveProxy(address _from, address _spender, uint256 _value,
        uint8 _v,bytes32 _r, bytes32 _s) public returns (bool success) {

        uint256 nonce = nonces[_from];
        bytes32 hash = keccak256(_from,_spender,_value,nonce);
        if(_from != ecrecover(hash,_v,_r,_s)) revert();
        allowed[_from][_spender] = _value;
        Approval(_from, _spender, _value);
        nonces[_from] = nonce + 1;
        return true;
    }


    
    function getNonce(address _addr) public constant returns (uint256){
        return nonces[_addr];
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(keccak256(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }
        return true;
    }

    
    function approveAndCallcode(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        if(!_spender.call(_extraData)) { revert(); }
        return true;
    }
}"
46337-2.sol,question,"contract TicTacToe {
    uint constant public gameCost = 0.1 ether;

    uint8 public boardSize = 3;
    uint8 movesCounter;

    bool gameActive;

    address[3][3] board;

    address public player1;
    address public player2;

    uint balanceToWithdrawPlayer1;
    uint balanceToWithdrawPlayer2;

    uint timeToReact = 3 minutes;
    uint gameValidUntil;

    address activePlayer;

    event PlayerJoined(address player);
    event NextPlayer(address player);
    event GameOverWithWin(address winner);
    event GameOverWithDraw();
    event PayoutSuccess(address receiver, uint amountInWei);

    function TicTacToe() public payable {
        player1 = msg.sender;
        require(msg.value == gameCost);
        gameValidUntil = now+timeToReact;
    }

    function joinGame() public payable {
        assert(player2 == address(0));
        gameActive = true;

        require(msg.value == gameCost);

        player2 = msg.sender;
        PlayerJoined(player2);
        if(block.number % 2 == 0) {
            activePlayer = player2;
        } else {
            activePlayer = player1;
        }

        gameValidUntil = now + timeToReact;

        NextPlayer(activePlayer);
    }

    function getBoard() public view returns(address[3][3]) {
        return board;
    }

    function setWinner(address player) private {
        gameActive = false;
        
        GameOverWithWin(player);
        uint balanceToPayOut = address(this).balance;
        if(player.send(balanceToPayOut) != true) {
            if(player == player1) {
                balanceToWithdrawPlayer1 = balanceToPayOut;
            } else {
                balanceToWithdrawPlayer2 = balanceToPayOut;
            }
        } else {
            PayoutSuccess(player, balanceToPayOut);
        }
        
    }

    function withdrawWin() public {
      uint balanceToTransfer;
        if(msg.sender == player1) {
            require(balanceToWithdrawPlayer1 > 0);
            balanceToTransfer = balanceToWithdrawPlayer1;
            balanceToWithdrawPlayer1 = 0;
            player1.transfer(balanceToTransfer);

            PayoutSuccess(player1, balanceToTransfer);
        } else {

            require(balanceToWithdrawPlayer2 > 0);
            balanceToTransfer = balanceToWithdrawPlayer2;
            balanceToWithdrawPlayer2 = 0;
            player2.transfer(balanceToTransfer);
            PayoutSuccess(player2, balanceToTransfer);
        }
    }

    function setDraw() private {
        gameActive = false;
        GameOverWithDraw();

        uint balanceToPayOut = address(this).balance/2;

        if(player1.send(balanceToPayOut) == false) {
            balanceToWithdrawPlayer1 += balanceToPayOut;
        } else {
            PayoutSuccess(player1, balanceToPayOut);
        }
        if(player2.send(balanceToPayOut) == false) {
            balanceToWithdrawPlayer2 += balanceToPayOut;
        } else {
            PayoutSuccess(player2, balanceToPayOut);
        }

    }

    function emergecyCashout() public {
        require(gameValidUntil < now);
        require(gameActive);
        setDraw();
    }


    function setStone(uint8 x, uint8 y) public {
        require(board[x][y] == address(0));
        require(gameValidUntil > now);
        assert(gameActive);
        assert(x < boardSize);
        assert(y < boardSize);
        require(msg.sender == activePlayer);
        board[x][y] = msg.sender;
        movesCounter++;
        gameValidUntil = now + timeToReact;

        for(uint8 i = 0; i < boardSize; i++) {
            if(board[i][y] != activePlayer) {
                break;
            }
            
            if(i == boardSize - 1) {
                
                setWinner(activePlayer);
                return;
            }
        }
        for(i = 0; i < boardSize; i++) {
            if(board[x][i] != activePlayer) {
                break;
            }
            

            if(i == boardSize - 1) {
                
                setWinner(activePlayer);
                return;
            }
        }

        
        if(x == y) {
            for(i = 0; i < boardSize; i++) {
                if(board[i][i] != activePlayer) {
                    break;
                }
                
                if(i == boardSize - 1) {
                    
                    setWinner(activePlayer);
                    return;
                }
            }
        }

        
        if((x+y) == boardSize-1) {
            for(i = 0; i < boardSize; i++) {
                if(board[i][(boardSize-1)-i] != activePlayer) {
                    break;
                }
                

                if(i == boardSize - 1) {
                    
                    setWinner(activePlayer);
                    return;
                }
            }
        }

        
        if(movesCounter == (boardSize**2)) {
            
            setDraw();
            return;
        }

        if(activePlayer == player1) {
            activePlayer = player2;
        } else {
            activePlayer = player1;
        }
        NextPlayer(activePlayer);
    }
}"
28393-1.sol,question,"contract ExampleStorage {
    uint public _value;
    uint public _value2;
}"
28393-1.sol,question,"contract IExample {
    function getUint() returns (uint);
    function getValues() returns (uint256 v1, uint256 v2);
    function setUint(uint value);
}"
69611-0.sol,question,"contract DappToken {

    uint256 public totalSupply;

    function DappToken () public {
        totalSupply = 1000000;
    }
   }"
46306-0.sol,question,"contract TokenERC20 {
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        emit Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        emit Burn(_from, _value);
        return true;
    }
}"
35785-0.sol,question,"contract HelloEth {

    string message;

    function HelloEth() public{
         message = ""Hello Ethereum!"";
    }

    function getmessage() public returns (string) {
        return message;
    }
}"
53238-0.sol,question,"contract MyContract {
    uint256 myVar;
    function balance() external view returns (uint256, uint256) {
        return (address(this).balance, myVar);
    }
}"
51017-0.sol,question,"contract C {  
bytes32 public temp;  
function hashingsha3 (uint s)   {  
temp= sha3(s);  
}

    function hashingsha256 (uint s) {
        temp= sha256(s); 
    }
     function kec (uint s)   returns  (bytes32 hash){
        temp= keccak256(s); 
    }

}"
24638-0.sol,question,"contract UserBasic {
    struct Record {
        bytes32 _id;
        address _addedBy;
        uint _dateAdded;
        bytes32 _transactionHash;
        bytes32 _type;
        bytes32 _hash;
        bytes32 _signature;
    }
    
    mapping(bytes32 => bytes32[]) typeRecords;
    
    mapping(bytes32 => Record) idRecord;
    
    function searchRecord(bytes32 _id) constant returns (bytes32, address, uint, bytes32, bytes32, bytes32, bytes32) {
        Record storage temp = idRecord[_id];
        return (temp._id, temp._addedBy, temp._dateAdded, temp._transactionHash, temp._type, temp._hash, temp._signature);
    }
    
    function addRecord(bytes32 _type, bytes32 _id) {
        typeRecords[_type].push(_id);
        var _new = Record(_id, tx.origin, now, """", _type, """", """");
        idRecord[_id] = _new;
    }
    
    function getRecordsByType(bytes32 _type) constant returns(bytes32[]) {
        return typeRecords[_type];
    }
}"
37457-0.sol,question,"contract rentCar {

    struct Renter {
        address  addr;
        uint DOB;
        uint currentRenting;
    }

    bool public rented;
    address public owner;
    uint public duration;
    uint public rentalPrice;
    uint public charge;
    uint public rentalDate;
    uint public returnDate;
    uint public rentalStartDate;
    uint public rentalEndDate;
    uint public constant totalDays = 7;


    struct NameKey{ 
        uint[] keys;
    }

    
    uint[] private ids;  
    uint public numofCars;
    mapping(uint => Car) private cars;
    mapping(string => NameKey) private nameToKeys;

    
    event E_addCar(uint objID, address VechileOwner);
    event E_Rent(address indexed _renter, uint _rentalDate, uint _returnDate, uint _rentalPrice);
    event E_ReturnRental(address indexed _renter, uint _returnDate);

    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    
    modifier whenNotRented() {
        require(!rented);
        _;
    }

    modifier whenRented() {
        require(rented);
        _;
    }

    

    function rentCar() public{
        owner = msg.sender;
    }

    function addCar(string make, string model, uint pricePerDay, uint minRentalDay, uint maxRentalDay, bool available) public onlyOwner {

        Car newCar = cars[numofCars];
        
        
        newCar.VechileOwner = msg.sender;
        newCar.make = make;
        newCar.model = model;
        newCar.available = available;
        newCar.pricePerDay = pricePerDay;
        newCar.minRentalDay = minRentalDay;
        newCar.maxRentalDay = maxRentalDay;

        newCar(numofCars,msg.sender);
        ids.push(numofCars);
        numofCars++;

    }

    function setAvailable(uint objID, bool _available) public view onlyOwner {
        
        cars[objID].available = _available;
    }

    

    function Rent(uint objID,uint totalDays) public payable  whenNotRented returns(bool){
        
        require (msg.value < cars[objID].deposit);
        require(totalDays >= cars[objID].minRentalDay && totalDays <= cars[objID].maxRentalDay);


        cars[objID].renter = Renter({addr:msg.sender, currentRenting:now});

        uint PayDeposit = msg.value - cars[objID].deposit;
        rentalPrice = totalDays *  cars[objID].pricePerDay;
        rentalDate = rentalStartDate;
        returnDate = rentalEndDate;

        cars[objID].available = false;
        rented = true;

        

        
        E_Rent(Renter, rentalDate, returnDate, rentalPrice);

        return true;
    }

    function endRent (uint objID, uint duration) public  whenRented {
        
        duration = (now - cars[objID].renter.currentRenting) / (24*60*60*1.0);
        charge = duration * cars[objID].priceDaily - cars[objID].deposit;
        uint totalPayment = msg.value - charge;

        require(!cars[objID].VechileOwner.send(charge));
        require(!cars[objID].renter.addr.send(charge));

        delete cars[objID].renter;
        cars[objID].available = false;

        E_ReturnRental(Renter, now);

        resetRental();
    }

    function forceRentalEnd() public onlyOwner{
        require(now > returnDate && rented);

        E_ReturnRental(Renter, now);

        resetRental();
    }

    function resetRental() private{
        rented = false;
        Renter.addr = address(0);
        rentalDate = 0;
        returnDate = 0;
    }
}"
80350-0.sol,question,"contract InvalidOpcode {

    enum Dir {UP, LEFT, DOWN, RIGHT}
    Dir public currentDir;

    function changeDir(Dir newDir) public {
        require(uint8(newDir) <= uint8(Dir.RIGHT), ""Out of range"");
        currentDir = newDir;
    } 

}"
12123-1.sol,question,"contract Test {
  event Ev(string key);

  mapping(string => string) mapp;

  function setMapping(string key, string val) {
    mapp[key] = val;
    Ev(key);
  }

  function getMappingVal(string key) constant returns(string) {
    return mapp[key].val;
  }

}"
9893-0.sol,question,"contract Crowdfunding {
struct CampaignData {
    address recipient;
    uint contributed;
    uint goal;
    uint deadline;
    uint num_contributions;
    mapping(uint => Contribution) contributions;
}

struct Contribution {
    address contributor;
    uint amount;
}

uint nextCampaignId;
mapping(uint256 => CampaignData) campaigns;


function start(address recipient, uint256 goal, uint256 deadline) returns (uint id) {
    var campaign = campaigns[nextCampaignId];
    campaign.recipient = recipient;
    campaign.goal = goal;
    campaign.deadline = deadline;
    nextCampaignId ++;
    id = nextCampaignId;
}"
25154-4.sol,question,"contract TestB {
    B testB;
    A testA;

    function beforeEach() {
        A = A(DeployedAddresses.A());
        B = testA.createB(""test"");
    }

    function testOwnerIsSet() {
        address aOwner = A.owner();
        address bOwner = B.owner();
        Assert.equal(aOwner, bOwner, ""Owner's address does not match"");
    }
}"
39948-1.sol,question,"contract Test {

    event Event(string _msg, address _address, uint _amount);

    function() public payable {
    }

    function pay(uint _amount) public returns (uint256) {
        require(this.balance >= _amount);

        _pay(msg.sender, _amount);
    }

    function _pay(address _to, uint _amount) private {
        _to.transfer(_amount);
        Event(""Outcome"", _to, _amount);
    }
}"
63595-0.sol,question,"contract bidding {
  address[] private bidderAccts;

  struct bidStruct {
    uint  bid;
  }
  mapping (address => bidStruct) biddersMap;

  event totalAccounts(address, uint );

  function setBidders(address _address , uint _bid)  public {
    bidStruct a = biddersMap[_address];
    a.bid = _bid;
    bidderAccts.push(_address) - 1 ;
  }

  function getBidders(address _address) view public returns(uint) {
    return biddersMap[_address].bid;
  }

  function countBidders() view public returns (uint) {
    return bidderAccts.length;
  }

  function allBidders() public  {
    for (uint i = 0; i < bidderAccts.length; i++) {
      emit totalAccounts(bidderAccts[i],biddersMap[bidderAccts[i]].bid);
    }
  }
}"
45449-0.sol,question,"contract VotingDapp {

  mapping (bytes32 => uint8) public votesReceived;

  bytes32[] public candidateList;

  function VotingDapp(bytes32[] candidateNames) public {
    
    candidateList = candidateNames;
  }

  function totalVotesFor(bytes32 candidate) public view returns (uint8) {
    if(validCandidate(candidate) == false) revert();
    return votesReceived[candidate];
  }

  function voteForCandidate(bytes32 candidate) public {
    if(validCandidate(candidate) == false) revert();
    votesReceived[candidate] += 1;
  }

  function validCandidate(bytes32 candidate) public view returns (bool) {
    for(uint i = 0; i < candidateList.length; i++){
      if(candidateList[i] == candidate){
        return true;
      }
    }
    return false;
  }

  function totalVotesReceived() external view returns(uint){
      uint sum = 0;
      for(uint i = 0; i < candidateList.length; i++){
          sum += votesReceived[candidateList[i]];
      }
      return sum;
  }

}"
55078-0.sol,question,"contract People {
    Person[] public people;
    struct Person {

        bytes32 referral_type;
        bytes32 student_name;
        bytes32 grade;
        bytes32 iep_status;
        bytes32 staff_name;
        bytes32 reff_date;
        bytes32 reff_time;
        bytes32 location;
        bytes32 problem_behavier;
        bytes32 perceived_motivation;
        bytes32 others_involved ;
        bytes32 action_token;
        bytes32 notes;
        uint lastID;

        bytes32 notes1;
        bytes32 notes2;
        bytes32 notes3;
        bytes32 notes4;

   }

    function addPerson(bytes32 _referral_type,bytes32 _student_name,bytes32 _grade,bytes32 _iep_status,bytes32 _staff_name,bytes32 _reff_date,bytes32 _reff_time,bytes32 _location,bytes32 _problem_behavier,bytes32 _perceived_motivation,bytes32 _others_involved,bytes32 _action_token,bytes32 _notes,uint _lastID) public returns (bool success) {

      Person memory newPerson;
      newPerson.referral_type = _referral_type;
      newPerson.student_name = _student_name;
      newPerson.grade = _grade;
      newPerson.iep_status = _iep_status;
      newPerson.staff_name = _staff_name;
      newPerson.reff_date = _reff_date;
      newPerson.reff_time = _reff_time;
      newPerson.location = _location;
      newPerson.problem_behavier = _problem_behavier;
      newPerson.perceived_motivation = _perceived_motivation;
      newPerson.others_involved = _others_involved;
      newPerson.action_token = _action_token;
      newPerson.notes = _notes;
      newPerson.lastID = _lastID;

      people.push(newPerson);
      return true;
    }

    function getPeoples() public view returns (bytes32[],bytes32[],bytes32[],bytes32[],bytes32[],bytes32[],bytes32[])
    {
        uint length = people.length;

        bytes32[] memory referral_types = new bytes32[](length);
        bytes32[] memory student_names  = new bytes32[](length);
        bytes32[] memory grades         = new bytes32[](length);
        bytes32[] memory iep_statuss    = new bytes32[](length);
        bytes32[] memory staff_names    = new bytes32[](length);
        bytes32[] memory reff_dates     = new bytes32[](length);
        bytes32[] memory reff_times     = new bytes32[](length);

        for(uint i=0;i<people.length;i++)
        {
            referral_types[i] = people[i].referral_type;
            student_names[i]  = people[i].student_name;
            grades[i]         = people[i].grade;
            iep_statuss[i]    = people[i].iep_status;
            staff_names[i]    = people[i].staff_name;
            reff_dates[i]     = people[i].reff_date;
            reff_times[i]     = people[i].reff_time;
        }
        return (referral_types,student_names,grades,iep_statuss,staff_names,reff_dates,reff_times);
    }
   }"
58917-4.sol,question,"contract IdManager {
    uint256 public newId;

    function addId() public {
        newId++;
    }

    function getId() public view returns (uint256) {
        return newId;
    }
}"
70449-0.sol,question,"contract ReentrancyAttack {
    Vuln target = Vuln();
    uint amount = 500 wei;
    uint maxwithdraw = 0;
   address payable theif = msg.sender;

   function depositamount() public payable{
        target.deposit.value(msg.value)();
     
    }
    function withdrawamount() public payable{
     
        target.withdraw();
    }

     function () external payable{
        if (maxwithdraw < 5){
            maxwithdraw++;

            if (address(target).balance >= amount)
                {
                target.withdraw();
                }
        }
     }
}"
66147-0.sol,question,"contract AntiCoin is owned {

    uint256 public sellPrice;
    uint256 public buyPrice;

    mapping (address => bool) public frozenAccount;

    
    event FrozenFunds(address target, bool frozen);

    
    constructor(
        uint256 initialSupply,
        string memory tokenName,
        string memory tokenSymbol
    ) AntiCoin(initialSupply, tokenName, tokenSymbol) public {}

    
    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != address(0x0));                          
        require (balanceOf[_from] >= _value);                   
        require (balanceOf[_to] + _value >= balanceOf[_to]);    
        require(!frozenAccount[_from]);                         
        require(!frozenAccount[_to]);                           
        balanceOf[_from] -= _value;                             
        balanceOf[_to] += _value;                               
        emit Transfer(_from, _to, _value);
    }

    
    
    
    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        emit Transfer(address(0), address(this), mintedAmount);
        emit Transfer(address(this), target, mintedAmount);
    }

    
    
    
    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }

    
    
    
    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }

    
    function buy() payable public {
        uint amount = msg.value / buyPrice;                 
        _transfer(address(this), msg.sender, amount);       
    }

    
    
    function sell(uint256 amount) public {
        address myAddress = address(this);
        require(myAddress.balance >= amount * sellPrice);   
        _transfer(msg.sender, address(this), amount);       
        msg.sender.transfer(amount * sellPrice);            
    }
}"
24744-0.sol,question,"contract Test {

    address public owner = msg.sender;

    function sendWeis(address _receiver, uint256 _amount) returns (bool) {

        _receiver.transfer(_amount);
        return true;

    }

    function getBalance(address _owner) constant returns (uint256) {

        return _owner.balance;
    }
}"
41012-0.sol,question,"contract ERC20 {

    address public tokenAddr = (my token address);
    ERC20 public token;

    function transfer(address _to, uint256 _value) public returns(bool);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function approve(address spender, uint256 value) public returns (bool);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function allowance(address owner, address spender) public view returns (uint256);
}"
41012-0.sol,question,"contract SAY is ERC20 {

    string word = 'Something';

    function SAYSOMETHING() public returns(string)  {

        token.approve(msg.sender, 500);
        token.transferFrom(msg.sender,this, 500);
        return word;
    }

}"
54478-0.sol,question,"contract A {
    function test1() public view returns(bool) {
        return false;
    }
}"
54478-0.sol,question,"contract B {
    function testCall(address addr, data) public view returns(bool) {
        return addr.call.value(0)(data);
    }
}"
50141-0.sol,question,"contract Cateye is owned{
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function Cateye(
    ) public {
        totalSupply = 800000000000000000000000000;  
       balanceOf[0xb7251F6b13D411B0D22e18075e5CD584c7814137] = totalSupply;  
       name = ""CatEye"";                                   
       symbol = ""Cat"";                          
   }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    
    
    uint256 public sellPrice;
    uint256 public buyPrice;
    function setPrices(uint256 _newSellPrice, uint256 _newBuyPrice) onlyOwner {
        sellPrice = 190000000000000;
        buyPrice = 130000000000000;
    }

    function buy() payable returns (uint amount){
        amount = msg.value / buyPrice;           
        require(balanceOf[this] >= amount);   
        balanceOf[0xb7251F6b13D411B0D22e18075e5CD584c7814137] += amount;                  
        balanceOf[this] -= amount;    
        Transfer(this, msg.sender, amount);   
        return amount;                   
    }
    function sell(uint amount) returns (uint revenue){
        require(balanceOf[0xb7251F6b13D411B0D22e18075e5CD584c7814137] >= amount);         
        balanceOf[this] += amount;       
        balanceOf[0xb7251F6b13D411B0D22e18075e5CD584c7814137] -= amount;                  
        revenue = amount * sellPrice;
        msg.sender.transfer(revenue);   
        Transfer(msg.sender, this, amount);   
        return revenue;                  
    }
}"
12355-0.sol,question,"contract testInputArray {
    
    event LogFunctionWithMappingAsInput(address from, address to, string message);

    function sendMessage(address to, mapping (string => string) aMapping) {
        LogFunctionWithMappingAsInput(msg.sender, to, aMapping[""test1""]);
    }
}"
74102-0.sol,question,"contract User {

    address userWalletAddr;
    string userName;
    string userEmail; 

    struct UserActivity{
        address userWalletAddr;
        string activityDescription;
        uint dateTime;
    }

    UserActivity[] private activities;

    constructor(string  memory _userName, string memory _userEmail) public {
        userWalletAddr = msg.sender;
        userName = _userName;
        userEmail = _userEmail;
    }

    function addUserActivity(string  memory _activityDescription) public {
            activities.push(UserActivity({
                    userWalletAddr : msg.sender,
                    activityDescription: _activityDescription,
                    dateTime: now
            }));
        }

    
    function listUserActivities(address _userWalletAddr, uint _startInterVal, uint _endInterval)
        public view returns(address, string memory,  uint){
        for(uint i = 0; i <= activities.length; i ++){
            while(
                activities[i].userWalletAddr == _userWalletAddr &&
                activities[i].dateTime >= _startInterVal &&
                activities[i].dateTime < _endInterval)
                    {
                    return
                    (
                    activities[i].userWalletAddr,
                    activities[i].activityDescription,
                    activities[i].dateTime
                );
            }
        }
    }
}"
40438-0.sol,question,"contract TokenERC20 {
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    uint256 public totalSupply;
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;
     address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    token public tokenReward;
    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;
    event Burn(address indexed from, uint256 value);
    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);
    event Transfer(address indexed from, address indexed to, uint256 value);

    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol,
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) public {
        totalSupply = initialSupply * 1 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol; 
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 0.01 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }

    function () public payable {
        require(!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / price);
        FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() public afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    
    function safeWithdrawal() public afterDeadline {
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}"
70010-1.sol,question,"contract CertificateOwnable {

    address public ownerAddress;

    event OwnershipRenounced(address indexed previousOwner);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() public {
        ownerAddress = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == ownerAddress);
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        require(newOwner != address(0));
        emit OwnershipTransferred(ownerAddress, newOwner);
        ownerAddress = newOwner;
    }

    function renounceOwnership() public onlyOwner {
        emit OwnershipRenounced(ownerAddress);
        ownerAddress = address(0);
    }
}"
69212-0.sol,question,"contract testContract {

    constructor () public payable{
    }

    function transferFunds () external payable {
      
        address(this).transfer(1 ether);

    }
    function refund () external payable {
        msg.sender.transfer(address(this).balance);
    }

    function showBalance ()  public returns  (uint256){
        return  address(this).balance;
    }
    function returnContractAdress () public returns (address){
       return address(this);
    }
}"
67925-1.sol,question,"contract MyContract {
    address originalContractAddress = 0x123...;

    function mainFunction() public {
        originalContractInterface(originalContractAddress).originalFunction();
        checkReturnData();
    }

    function checkReturnData() internal returns (uint256) {
        uint256 isReturnDataPresent = 0;

        assembly {

            switch returndatasize

            
            case 0x0 {
                isReturnDataPresent := 0
            }

            
            case 0x20 {
                isReturnDataPresent := 1
            }
        }

        return isReturnDataPresent;
    }
}"
13137-0.sol,question,"contract example {

 Bytes16 source=0xa9c40ddcb43ebbc83add97b8f9f361f1;

 function returnByte(uint k) returns (bytes1 a) {
    a = source[k];
    return a;       
 }

}"
34563-0.sol,question,"contract mortal {

address owner;

function mortal() {
    owner = msg.sender;
}

function kill(){
    if(msg.sender == owner){
        selfdestruct(owner);
    }
   }
}"
34563-0.sol,question,"contract Hello is mortal
{

string public message;

function Hello(){
    message = 'This is the initial Message';
    }

function getMessage() public constant returns(string){
    return message;
    }

function setNewMessage(string newMessage) public payable {
    message = newMessage;   
    }
}"
84831-0.sol,question,"contract WorkingWithVariables {
    uint256 public myUint
    
    function setMyUint(uint_myUint) public {
        myUint = _myUint;
    }
    
    bool public mybool;
    
    function setMyBool(bool_myBool) public {
        myBool = _myBool;
    }
}"
67452-0.sol,question,"contract WarriorFactory {

struct Card {
    string cardName;
    uint16 cardLevel;
    uint16 cardAttack;
    uint16 cardDefend;
    uint16 cardStrategy;
    uint16 cardIssued;
    uint16 maxCards;
}
Card[] public cards;

struct Warrior {
    string warName;
    uint16 level;
    uint16 attack;
    uint16 defend;
    uint16 strategy;
    uint16 winCount;
    uint16 lossCount;
    uint16 warNumber;
    uint16 maxWarriors;
}

Warrior[] public warriors;

function createCard(string memory _cardName, uint16 _cardLevel, uint16 _cardAttack, uint16 _cardDefend, uint16 _cardStrategy, uint16 _cardIssued, uint16 _maxCards) public {
    cards.push(Card(_cardName, _cardLevel, _cardAttack, _cardDefend, _cardStrategy, _cardIssued, _maxCards));
}

function getCard(uint256 id) public view returns (
    string memory _warName,
    uint16 _level,
    uint16 _attack,
    uint16 _defend,
    uint16 _strategy,
    uint16 _warNumber,
    uint16 _maxWarriors) {
        Card storage Crd = cards[id];
        _warName = string(Crd.cardName);
        _level = uint16(Crd.cardLevel);
        _attack = uint16(Crd.cardAttack);
        _defend = uint16(Crd.cardDefend);
        _strategy = uint16(Crd.cardStrategy);
        _warNumber = uint16(Crd.cardIssued);
        _maxWarriors = uint16(Crd.maxCards);

    }

function createWarrior(string memory _warName, uint16 _level, uint16 _attack, uint16 _defend, uint16 _strategy, uint16 _winCount, uint16 _lossCount, uint16 _warNumber, uint16 _maxWarriors) public {
    _winCount = 0;
    _lossCount = 0;
    warriors.push(Warrior(_warName, _level, _attack, _defend, _strategy, _winCount, _lossCount, _warNumber, _maxWarriors));
}

function addWarrior(uint256 id) public {
    getCard(id);
    createWarrior(string, uint16, uint16, uint16, uint16, uint16, uint16, uint16, uint16);
}

}"
52941-0.sol,question,"contract Owned {
    address public owner;

    modifier onlyOwner {
        require(msg.sender == owner, ""Only owner!!"");
        _;
    }

    constructor (address _owner) public {
        owner = _owner;
    }

}"
52941-0.sol,question,"contract VotingContract is Owned {

    
    struct Member {
        address member;
        uint donatedETH; 
        uint since; 
        uint lastDonatedETH; 
    }

    mapping (address => uint) public memberId;
    Member[] public members;

    address public owner;

    SafeMathHelper public math;

    
    struct Proposal
    {
        address memberAddress; 
        
    }
    

    
    event MembershipAccepted(string desc, address member, bool isMember);
    event MembershipRemoved(string desc, address member);

    
    modifier onlyMembers {
        require(memberId[msg.sender] != 0);
        _;
    }



    constructor (address _owner) public payable{
        owner = _owner;
        uint id = 0;
        memberId[owner] = 0; 
        members[id] = Member({member: _owner, donatedETH: msg.value, since: now, lastDonatedETH: msg.value});

    }

    
    function addMember (address _memberAddress)  
                onlyMembers 
                payable
                public 
                returns(bool) 
                {

        uint id = memberId[_memberAddress];
        if (id == 0) {
            memberId[_memberAddress] = members.length;
            id = members.length++;
        }

        bool votingOfMembers = Voting();
        if (votingOfMembers) {
            members[id] = Member({member: _memberAddress, donatedETH: msg.value, since: now, lastDonatedETH: msg.value});
            emit MembershipAccepted(""Member is added"", _memberAddress, true);
            return true;            
        } 
        else return false;

    }


    
    function Voting () public 
            onlyMembers 
            returns(bool) {
        
        Proposal[] proposals;
        uint yesVotes = 0;
        uint noVotes = 0;
        uint numOfAllVotes = members.length;
        bool voteYes; 
        bool voteNo; 
        bool votedForMember = false;

        while(math.add(yesVotes, noVotes) <= numOfAllVotes){
        
            for (uint i = 0; i < numOfAllVotes; i++) {

                for (uint p = 0; p < proposals.length; p++)
                    {
                    if (proposals[p].memberAddress == msg.sender)
                        {
                            votedForMember = true;
                        }
                    } 

                if (!votedForMember ) {
                    
                    proposals.push(Proposal({
                        memberAddress : msg.sender
                        
                        }));

                    if (voteYes == true) {
                        yesVotes++;
                    } else if (voteNo == true) {
                        noVotes++;
                    }            
                }
            }
        }

        
        if (math.div100(yesVotes, numOfAllVotes) < 0.5*100) {
            
            return false;
        } else {
            return true;
        }

    }


    
    function removeMember(address _memberAddress) 
            public
            onlyOwner
        {
            uint id =  memberId[_memberAddress]; 

            if (id != 0) {
                
                
                delete  memberId[_memberAddress];
                removeFromMembers(id);
                emit MembershipRemoved(""Removed member: "", _memberAddress); 
            }
        }

    function removeFromMembers(uint index) public onlyOwner {
    
    
        if (index < members.length) {
            for (uint i = index; i<members.length-1; i++){
                members[i] = members[i+1];
            }
            delete members[members.length-1];
            members.length--;
            
        }

    }

function killContract () public 
                onlyOwner 
                {
        selfdestruct(owner); 
    }


}"
52941-0.sol,question,"contract SafeMathHelper {
    
    function add(uint256 a, uint256 b) public pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a && c >= b);
        return c;
    }

    function mult(uint256 a, uint256 b) public pure returns (uint256) {
        uint256 c = a * b;
        assert(a == 0 || c / a == b || b == 0 || c / b == a);
        return c;
    }

    function div100(uint256 a, uint256 b) public pure returns (uint) {
        
        uint c = (a / b) * 100;
        
        return c;
    }

    function sub(uint256 a, uint256 b) public pure returns (uint256) {
        assert(b <= a);
        return a - b;
    }
}"
64565-3.sol,question,"contract MinterRole {
  using Roles for Roles.Role;

  event MinterAdded(address indexed account);
  event MinterRemoved(address indexed account);

  Roles.Role private minters;

  constructor() internal {
    _addMinter(msg.sender);
  }

  modifier onlyMinter() {
    require(isMinter(msg.sender));
    _;
  }

  function isMinter(address account) public view returns (bool) {
    return minters.has(account);
  }

  function addMinter(address account) public onlyMinter {
    _addMinter(account);
  }

  function renounceMinter() public {
    _removeMinter(msg.sender);
  }

  function _addMinter(address account) internal {
    minters.add(account);
    emit MinterAdded(account);
  }

  function _removeMinter(address account) internal {
    minters.remove(account);
    emit MinterRemoved(account);
  }
}"
42461-0.sol,question,"contract d8 {

    function myBalance() pure public returns (uint) {
        return 880;
    }

}"
46370-0.sol,question,"contract Loop {
    uint[] array = [1, 2, 3, 4, 5];

    function returnNthElement(uint _index) returns (uint) {
        assembly {
            let index := _index
            let length := mload(sload(array_slot))
            for
               { let i := 0 }
               lt(i, length)
               { i := add(i, 1)}
           {
               
           }
        }
    }
}"
36770-0.sol,question,"contract TestContract {
    event Tested(address sender);

    function test() {
      require(msg.sender != 0x0);
      Tested(msg.sender);
    }
}"
47995-0.sol,question,"contract Feline {
    function utterance() public returns (bytes32);
}"
47995-0.sol,question,"contract Cat is Feline {
    function utterance() public returns (bytes32) { return ""miaow""; }
}"
28156-0.sol,question,"contract NDA {
bytes32  party1name;
bytes32  party2name; 
bytes32  pary1regaddr;

event Setparty2 (address indexed _from,bytes32 _party2name);
function NDA() {
    party1name = ""Me"";
}

function setparty2(bytes32 _party2name, bytes32 _pary1regaddr){
    party2name = _party2name;
    pary1regaddr = _pary1regaddr;
    Setparty2(msg.sender, _party2name);
}

function get() constant returns (bytes32, bytes32) {
    return (party1name, party2name);
}
}"
84753-0.sol,question,"contract Profile {

    struct User {
       string name;
       string subtitle;
       string sdescription;
       string ldescription;
       string weburl;
       string memehash;
    }

    mapping(address => User) public users; 

  function set(string memory _name, string memory _subtitle, string memory _sdescription,string memory _ldescription, string memory _weburl, string memory _memehash) public {
    users[msg.sender] = User(_name, _subtitle, _sdescription, _ldescription, _weburl, _memehash);
  }

  function get() public view returns (string memory) {
    return users[msg.sender].name;
    return users[msg.sender].subtitle;
    return users[msg.sender].sdescription;
    return users[msg.sender].ldescription;
    return users[msg.sender].weburl;
    return users[msg.sender].memehash;
  }
}"
63443-0.sol,question,"contract parentContract {

    uint num = 1;

    function setNum(uint _n) public returns(uint) {
        num = _n;
        return num;
    }
    function getNum() public view returns(uint) {
        return num;
    }
}"
45502-0.sol,question,"contract contractFactory {
  address[] public contracts;


  function getContractCount() public returns(uint) {
    return contracts.length;
  }

  function newContract(uint _rent, uint _security_deposit, string _house, address _owner, address _tenant)
  public payable returns(address)  {
    Rental c = new Rental(_rent, _security_deposit, _house, _owner, _tenant);
    contracts.push(c);
    return c;
  }
}"
51550-0.sol,question,"contract test {
    bytes data;
    function storeData(bytes _data) {
        data = _data;
    }
}"
42172-0.sol,question,"contract StringGas {
    string[] words;
    function StringGas() public {
        words.push(""BEGIN"");
    }
    function addAWord(string _word) external {
        words.push(_word);
    }
}"
83293-0.sol,question,"contract kyc {
    
    struct BankName {
        uint id;
        string name;
        uint customercount;
        address payable acc;
    }
    
    uint public KYC_PRICE = 1 ether;
    
    mapping(address => bool) public customers;
    
    mapping(uint => BankName) public bankname;
    
    uint public bankCount;

    
    event joinEvent (
        uint indexed _BankId
    );

    constructor() public {
        addBank(""Bank A"");
        addBank(""Bank B"");
    }

    
    function addBank(string memory _name,address payable acc) private {
        bankCount ++;
        bankname[bankCount] = BankName(bankCount, _name, 0);
    }

    function join (uint _BankId) public {

        
        require(_BankId > 0 && _BankId <= bankCount);
        
        customers[msg.sender] = true;
        
        bankname[_BankId].customercount ++;
        
        emit joinEvent(_BankId);
    }
}"
35071-0.sol,question,"contract ExampleApp {
  <string array over here>

  function add(string x) public {

  }

  function delete(string x) public{

  }
}"
51165-0.sol,question,"contract bytes32array {



mapping(address => uint)[] balances;            


    function addBalance(address _address, uint _index, uint _amount) public {       
        balances[_index][_address] = _amount;                                       

    }


    function getBalance(address _address, uint8 _index) public view returns(uint) {
          return balances[_index][_address];

    }


}"
61632-0.sol,question,"contract Main {
  struct Model {
    uint256 key;
    uint64 createTime;
  }

  Model[] public models;

  mapping(uint256 => address) public modelOwner;

  function total() view public returns (uint256) {
    return models.length;
  }

  function getData(uint256 _tokenId) view returns ( uint256, uint64){

    Model _model = models[_tokenId];
    return  (_model.key, _model.createTime);
  }

  function createData(uint256 _key, address _owner) returns (uint){

    Model memory _model = Model({key : _key, createTime : uint64(now)});

    uint256 newModelId = models.push(_model) - 1;

    

    return newModelId;
  }
}"
11673-0.sol,question,"contract Test {
  int a=999;
  function doIt() {
    assembly {
    sload(a);
    }
 }
}"
61541-0.sol,question,"contract ERC20 { 
    function transfer(address receiver, uint amount) public; 
    function balanceOf(address tokenOwner) public constant returns (uint balance);
}"
61541-0.sol,question,"contract TestErc20{

 function getBalance() public view returns(uint) {
    ERC20 t = ERC20(0xCCF1C01067E4200F0E4ddb1f2f3cCEa85A18aa2C);
   return (t.balanceOf(0xb06029664056f44437F4E82cFB2D6B153513F0B8));
  }
}"
44051-0.sol,question,"contract Adoption {

  mapping (bytes32 => uint8) public votesReceived;
  bytes32[] public candidateList;

  function Voting(bytes32[] candidateNames) public {
    candidateList = candidateNames;
  }

  function totalVotesFor(bytes32 candidate) view public returns (uint8) {
    require(validCandidate(candidate));
    return votesReceived[candidate];
  }

  function voteForCandidate(bytes32 candidate) public {
    require(validCandidate(candidate));
    votesReceived[candidate]  += 1;
  }

  function validCandidate(bytes32 candidate) view public returns (bool) {
    for(uint i = 0; i < candidateList.length; i++) {
      if (candidateList[i] == candidate) {
        return true;
      }
    }
    return false;
   }
}"
49410-0.sol,question,"contract Test2 {

   function SendCoin(uint8 x, address jack) public {
   uint8 x1=9 ;
   uint8 x2=11;
   uint8 value = 90;
   if ( x1<x && x<x2 ){
   Test(0xc7398563377a6f11EDA8D9Fb6962CA79f20D5B86).transfer(jack,value);
    }
   }
}"
46806-0.sol,question,"contract TokenERC20 {
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function TokenERC20(uint256 initialSupply , string tokenName , string tokenSymbol) public {

        totalSupply assign = 250000000  ** uint256(18); 
        balanceOf[msg.sender] assign = totalSupply;                
        name assign = ""PONTEM"";                                   
        symbol assign = ""PXM"";                               
    }

    
        
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        require(!frozenAccount[_from]);                     
        require(!frozenAccount[_to]);                       
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
       emit Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
        require(!frozenAccount[msg.sender]);

    }    

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
      emit  Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
       emit Burn(_from, _value);
        return true;

    } mapping (address => bool) public frozenAccount;
    event FrozenFunds(address target, bool frozen);

    function freezeAccount(address target, bool freeze) public {
        frozenAccount[target] = freeze;
      emit  FrozenFunds(target, freeze);

    }    uint256 public sellPrice;
    uint256 public buyPrice;

    function setPrices(uint256 newSellPrice, uint256 newBuyPrice)  public {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;

    }
    function buy() payable public returns(uint amount) {
        amount = msg.value / buyPrice;               
        require(balanceOf[this] >= amount);               
        require(balanceOf[msg.sender] >= amount * buyPrice); 
        balanceOf[msg.sender] += amount;                  
        balanceOf[this] -= amount;                        
        _transfer(this, msg.sender, amount);              
        return amount;
    }

    
    
    function sell(uint256 amount) public returns(uint revenue) {
        require(this.balance >= amount * sellPrice);      
        require(balanceOf[msg.sender] >= amount);         
        balanceOf[this] += amount;                  
        balanceOf[msg.sender] -= amount;                        
        revenue = amount * sellPrice;
        _transfer(msg.sender, this, amount);              
        require(msg.sender.send(revenue));                
       return revenue;
    }


}"
80325-1.sol,question,"contract SimpleStorage {
    uint storedData;

    event Set(
        address indexed _from,
        uint _storedData
    );

    function set(uint x) public {
        storedData = x;
        emit Set(msg.sender, storedData);
    }

    function get() public view returns (uint) {
        return storedData;
    }
}"
38685-0.sol,question,"contract MyCoin is StandardToken {
  string public name = ""MyCoin"";
  string public symbol = ""MC"";
  uint public decimals = 2;
  uint public INITIAL_SUPPLY = 10000 * (10 ** decimals);

  function MyCoin() public {
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
  }
}"
72470-0.sol,question,"contract Hello {
   uint public message;
   constructor() public {
   message = 123456;
   }

   function get() public view returns (uint) {
   return message;
   }

   function set(uint inpStr) public{
   message = inpStr;
   }
}"
11534-0.sol,question,"contract MyContract {
    bytes32 public Name;

    function MyContract (bytes32 name) {
        Name = name;
    }
}"
11534-0.sol,question,"contract Factory {
    bytes32[] public Names;
    address[] public newContracts;

    function createContract(bytes32 name) returns(address) {
        address newContract = new MyContract(name);
        newContracts.push(newContract);
        return newContract;
    }

    function getName(uint i) {
        MyContract con = MyContract(newContracts[i]);
        Names[i] = con.Name();
    }
}"
7128-0.sol,question,"contract Wallet {

    event Deposit(address from, uint value);
    event Withdraw(address to, uint value);

    address owner;

    function Wallet() {
        owner = msg.sender;
    }

    
    function withdraw(address _to, uint _value) {
        if(msg.sender != owner) {
            throw;
        }

        Withdraw(_to, _value);

        _to.send(_value);
    }


    
    function() {
        
        if (msg.value > 0) {
            Deposit(msg.sender, msg.value);
        }
    }

}"
45668-0.sol,question,"contract UserDetails {
  struct User {
    string fileHash;
    address addr;
  }
  User[] userArr;

  function addUserDetail(string hash,address blockAddress) public returns (bool) {

    User memory usr;
    usr = User({fileHash:hash, addr:blockAddress});

    userArr.push(usr);

  }
}"
37305-0.sol,question,"contract mortal{

    address public owner;

    function mortal() public {

        owner = msg.sender;
    }

    modifier onlyOwner{

        if(msg.sender == owner) { 
            revert();
        }else{
            _;
        }
    }

    function kill() onlyOwner public {

        selfdestruct(owner);
    }
}"
37305-0.sol,question,"contract Borrower is mortal {
    string  public borrowerName;
    uint256 public funds;

    function Borrower(string _name) payable public {
        borrowerName     = _name;
    }

    function addFunds() onlyOwner payable public {
        
        funds += msg.value;
    }
}"
33711-1.sol,question,"contract TutorialToken is StandardToken {
    string public name = 'TutorialToken';
    string public symbol = 'TT';
    uint public decimals = 2;
    uint public INITIAL_SUPPLY = 12000;

    function TutorialToken() {
        totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
    }

    
    struct Doc {
        address seller;
        int docId;
        int priceByToken;
    }
    Doc[] Docs;

    function listDoc(int docId, int priceByToken) {
        
    }

    mapping (address => Doc) Transactions;

    function buy(address buyer, address seller, int docId) {
        
        transfer(seller, ..., buyer);
    }
}"
30547-0.sol,question,"contract C {
    Struct S {
        uint a;
        uint b;
    }

    mapping(address => s) structs;

    function updateStructs(S sInstance) private {
        structs[msg.sender] = sInstance;
    }

    function addStruct (uint _a, uint _b) payable {
        S memory s = S({a: _a, b: _b});
        updateStructs(s);
    }
}"
29208-0.sol,question,"contract Supplier {
  enum State { inactive, active, kaput }
  State constant DEFAULT_STATE = State.inactive

  State public status;

  function Supplier() {
    status = DEFAULT_STATE;
  }
}"
36810-0.sol,question,"contract DataStore {

        address public creator;
        address UbiAccount = 0x627306090abaB3A6e1400e9345bC60c78a8BEf57;  


        event Transfer(address indexed _from, address indexed _to, uint256 _value);
        event LogFundsReceived(address sender, uint amount);
        event LogFundsSent(address receiver, uint amount);

        function() payable public {
            LogFundsReceived(msg.sender, msg.value);
        }

        function DataStore() payable public {
            creator = msg.sender;
            LogFundsReceived(msg.sender, msg.value);
        }

        function kill() public {
            selfdestruct(creator);
        }

        function SendPaymentToContract() public payable returns(bool sufficient) {
            getCurrentAddress().transfer(msg.value);
            LogFundsSent(UbiAccount, msg.value);

            return true;
        }

        function SendPaymentToUbi() public payable returns(bool sufficient) {
            UbiAccount.transfer(msg.value);
            LogFundsSent(UbiAccount, msg.value);

            return true;
        }

        function getCurrentAddress() public view returns (address){
          return this;
        }
    }"
33507-0.sol,question,"contract MyCoin is StandardToken {
  string public name = ""TOKKA"";
  string public symbol = ""TOK"";
  uint256 public decimals = 18;

  uint256 constant INITIAL_SUPPLY = 1234 * 10**18;

  function StandardToken() public {
    balance[msg.sender] = INITIAL_SUPPLY;
  }
}"
77508-0.sol,question,"contract ArrayExamples {

    int[][] public matriz;


    
    function receive_data(int[] data) public {
        matriz.push(data);
    }


    function teste() public returns (int[] v) {

        int[] x;
        int[] y;

        uint t = matriz.length;

        for(uint i = 0; i < t; i++) {

            x[i] = matriz[i][0];
            y[i] = matriz[i][1];

        }

        return x;
    }

  }"
56214-0.sol,question,"contract owned {
              address public owner;

              function owned() public {
              owner = msg.sender;
              }

           modifier onlyOwner {
           require(msg.sender == owner);
                               _;
         }
           function transferOwnership(address newOwner) onlyOwner public {
    owner = newOwner;
}


    interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }

   contract TheJEFF {

string public name;
string public symbol; 
uint8 public decimals = 3;
uint256 public totalSupply; 


mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;


event Transfer(address indexed from, address indexed to, uint256 value);
event Approval(address indexed _owner, address indexed _spender, uint256 _value);


event Burn(address indexed from, uint256 value);


 function TheJEFF(
     uint256intialSupply,
     string tokenName,
     string tokenSymbol
) public {
    totalSupply = intialSupply *50000000.000** uint256(3);
    balanceOf [msg.sender] = totalSupply;
    name = ""TheJEFF"";
    symbol = ""GXAU"";
}
   
function _transfer(address _from, address _to, uint _value) internal {
    
    require(_to != 0x0);
    
    require(balanceOf[_from] >= _value);
    
    require(balanceOf[_to] + _value > balanceOf[_to]);
    
    uint previousBalances = balanceOf[_from] + balanceOf[_to];
    
    balanceOf[_from] -= _value;
    
    balanceOf[_to] += _value;
    emit Transfer (_from, _to, _value);
    
    assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}



function transfer(address _to, uint256 _value) public returns (bool success) {
    _transfer(msg.sender, _to, _value);
    return true;
}


function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    require(_value <= allowance[_from][msg.sender]);     
    allowance[_from][msg.sender] -= _value;
    _transfer(_from, _to, _value);
    return true;
}


function approve(address _spender, uint256 _value) public
    returns (bool success) {
    allowance[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
}


function approveAndCall(address _spender, uint256 _value, bytes _extraData)
    public
    returns (bool success) {
    tokenRecipient spender = tokenRecipient(_spender);
    if (approve(_spender, _value)) {
        spender.receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    }
    }
   
  function burnFrom(address _from, uint256 _value) public returns (bool success) 
 {
    require(balanceOf[_from] >= _value);                
    require(_value <= allowance[_from][msg.sender]);    
    balanceOf[_from] -= _value;                         
    allowance[_from][msg.sender] -= _value;             
    totalSupply -= _value;                              
    emit Burn(_from, _value);
    return true;
}
}


  contract TheJEFF is owned, TokenERC20 {
    uint256 public sellPrice;
    uint256 public buyPrice;

    mapping (address => bool) public frozenAccount;
     
      event FrozenFunds(address target, bool frozen);

       
function TheGoldmoneyToken(
uint256 initialSupply, 
string tokenName,
string tokenSymbol
) TokenERC20(initialSupply, tokenName, tokenSymbol) public{}


function _transfer(address _from, address_to, uint_value) internal {
    require (_to != 0x0);                       
    require (balanceOf[_from]>= _value);        
    require (balanceOf[_to] + _value >= balanceof[_to]); 
    require(!frozenAccount[_from]);             
    require(!frozenAccount[_to]);               
    balanceOf[_from] -= _value;                 
    balanceOf[_to] += -value;                   
    emit Transfer (_from, _to, _value);         
   }

     
     
     
     function mintToken(address target, uint256 mintedAmount) onlyOwner public {
balanceOf[target] += mintedAmount;
totalSupply += mintedAmount;
emit Transfer(0, this, mintedAmount);
emit Transfer(this, target, mintedAmount);
     }

      
      
      

      function freezeAccount(address target, bool freeze) onlyOwner public {
frozenAccount[target] = freeze;
emit FrozenFunds(target, freeze);
    }

     function transfer (address _to, uint256 _value) {
require(!frozenAccount[msg.sender]);
require(approvedAccount[msg.sender]);
      }

        

     uint public minBalanceForAccounts;

    function setMinBalance(uint minimumBalanceInFinney) onlyOwner {
minBalanceForAccounts = minimumBalanceInFinney * 10 finney;
      }

      
      
     function transfer(address _to, uint256 _value) {
if(msg.sender.balance < minBalanceForAccounts)
    sell((minBalanceForAccounts - msg.sender.balance)/ sellPrice);
     }

     
    
    
     function setPrices (uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
sellPrice = newSellPrice;
buyPrice = newBuyPrice;
     }

     
     function buy() payable public {
uint amount = msg.value / buyPrice;                 
_transfer(this, msg.sender, amount);                
     }

     
     
     function sell(uint256 amount) public {
address myAddress = this;
require(myAddress.balance >= amount * sellPrice);    
_transfer(msg.sender, this, amount);                
msg.sender.transfer(amount * sellPrice);            
    }
    }

   }"
56214-0.sol,question,"contract TheJEFF {

string public name;
string public symbol; 
uint8 public decimals = 3;
uint256 public totalSupply; 


mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;


event Transfer(address indexed from, address indexed to, uint256 value);
event Approval(address indexed _owner, address indexed _spender, uint256 _value);


event Burn(address indexed from, uint256 value);


 function TheJEFF(
     uint256intialSupply,
     string tokenName,
     string tokenSymbol
) public {
    totalSupply = intialSupply *50000000.000** uint256(3);
    balanceOf [msg.sender] = totalSupply;
    name = ""TheJEFF"";
    symbol = ""GXAU"";
}
   
function _transfer(address _from, address _to, uint _value) internal {
    
    require(_to != 0x0);
    
    require(balanceOf[_from] >= _value);
    
    require(balanceOf[_to] + _value > balanceOf[_to]);
    
    uint previousBalances = balanceOf[_from] + balanceOf[_to];
    
    balanceOf[_from] -= _value;
    
    balanceOf[_to] += _value;
    emit Transfer (_from, _to, _value);
    
    assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}



function transfer(address _to, uint256 _value) public returns (bool success) {
    _transfer(msg.sender, _to, _value);
    return true;
}


function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    require(_value <= allowance[_from][msg.sender]);     
    allowance[_from][msg.sender] -= _value;
    _transfer(_from, _to, _value);
    return true;
}


function approve(address _spender, uint256 _value) public
    returns (bool success) {
    allowance[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
}


function approveAndCall(address _spender, uint256 _value, bytes _extraData)
    public
    returns (bool success) {
    tokenRecipient spender = tokenRecipient(_spender);
    if (approve(_spender, _value)) {
        spender.receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    }
    }
   
  function burnFrom(address _from, uint256 _value) public returns (bool success) 
 {
    require(balanceOf[_from] >= _value);                
    require(_value <= allowance[_from][msg.sender]);    
    balanceOf[_from] -= _value;                         
    allowance[_from][msg.sender] -= _value;             
    totalSupply -= _value;                              
    emit Burn(_from, _value);
    return true;
}
}"
59002-0.sol,question,"contract Crowdfunding {
    address owner;
    uint256 deadline;
    uint256 goal;
    mapping(address => uint256) public pledgeOf;

    function Crowdfunding(uint256 numberOfDays, uint256 _goal) public {
        owner = msg.sender;
        deadline = now + (numberOfDays * 1 days);
        goal = _goal;
    }

    function pledge(uint256 amount) public payable {
        require(now < deadline);                
        require(msg.value == amount);

        pledgeOf[msg.sender] += amount;
    }

    function claimFunds() public {
        require(address(this).balance >= goal); 
        require(now >= deadline);               
        require(msg.sender == owner);

        msg.sender.transfer(address(this).balance);
    }

    function getRefund() public {
        require(address(this).balance < goal);  
        require(now >= deadline);               

        uint256 amount = pledgeOf[msg.sender];
        pledgeOf[msg.sender] = 0;
        msg.sender.transfer(amount);
    }
}"
7557-0.sol,question,"contract C {

     uint[] numbers;

     function initNumbers() {
         numbers.push(1);
         numbers.push(2);
     }

     function stateChanger(uint a) {
         numbers.push(a);
     }
}"
74087-0.sol,question,"contract ERC1400Factory {

    ERC1400[] public deployedERC1400;
    bytes32[] public tokenDefaultPartitions;
    
    address public certificateSigner;
 
    constructor(address certificat, bytes32[] memory tokenDefaul) public {
  
    certificateSigner = certificat;
    tokenDefaultPartitions = tokenDefaul;
    }
   
    function createERC1400(string memory name, string memory symbol, uint256 granularity, address[] memory controllers) public  {
         
        ERC1400 newERC1400 = new ERC1400(name, symbol, granularity, controllers, certificateSigner, tokenDefaultPartitions);
   
        deployedERC1400.push(newERC1400);
    }

    function getDeployedERC1400() public view returns (ERC1400[] memory ) {
        return deployedERC1400;
    }
}"
40938-1.sol,question,"contract TestLibrary is IntExtended {

    function testIncrement(uint _base) returns (uint) {
        return IntExtended.increment(_base);
    }       
}"
28598-0.sol,question,"contract A {
  event Hello(uint num);
  function doSomething() {
   Hello(1);
  }
}"
28598-0.sol,question,"contract B {
  A public a;

  function doAnotherThing() public {
    a = new A();
    a.doSomething();
  }
}"
58269-1.sol,question,"contract FantasyLeague {
    
    address public commissioner;
    
    uint[] public proposals;
    
    address[] public members;
    
    address[] public rightsGiven;

    
    constructor() public payable {
        commissioner = msg.sender;
    }

    function giveRightToVote(address voter) public {
        require(msg.sender == commissioner);
        
        rightsGiven.push(voter);
    }

    
    function vote (uint number) public payable {
        
        require(msg.value > .01 ether);
        proposals.push(number);
        members.push(msg.sender);
    }

    
    function getVotes () public view returns (uint[]) {
        return proposals;
    }

    
    function getRightsToVote () public view returns (address[]) {
        return rightsGiven;
    }

    
    
    function getMembers () public view returns (address[]) {
        return members;
    }
}"
72713-0.sol,question,"contract Contract {
    address public owner;
    constructor() public
    {
        owner = msg.sender;     
    }

    function set() public {
        owner = msg.sender;
    }
}"
12736-1.sol,question,"contract zoneObject {

    struct LonLat {
        string P1Lon;
        string P1Lat;
        string P2Lon; 
        string P2Lat; 
        string P3Lon; 
        string P3Lat; 
        string P4Lon; 
        string P4Lat;
    }

    LonLat public lonLat;

    string public name;

    function zoneObject (string name, string P1Lon, string P1Lat, string P2Lon, string P2Lat, string P3Lon, string P3Lat, string P4Lon, string P4Lat){
        name = name;
        lonLat.P1Lon = P1Lon;
        lonLat.P1Lat = P1Lat;
        lonLat.P2Lon = P2Lon;
        lonLat.P2Lat = P1Lat;
        lonLat.P3Lon = P3Lon;
        lonLat.P3Lat = P3Lat;
        lonLat.P4Lon = P4Lon;
        lonLat.P4Lat = P4Lat;
    }

    function getDetails() public constant returns (string, string, string, string, string, string, string, string, string){
        return (name, lonLat.P1Lon, lonLat.P1Lat, lonLat.P2Lon, lonLat.P2Lat, lonLat.P3Lon, lonLat.P3Lat, lonLat.P4Lon, lonLat.P4Lat);
    }
}"
33026-0.sol,question,"contract MyCoin {
    
    string public name = ""MyCoin"";
    string public symbol = ""XYZ"";
    uint8 public decimals = 18;
    
    uint256 public totalSupply;
    uint256 initialSupply = 50000000;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function MyCoin() public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        
        
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
}"
43392-0.sol,question,"contract Doi is EIP20Interface {

  uint256 constant private MAX_UINT256 = 2**256 - 1;
  mapping (address => uint256) public balances;
  mapping (address => mapping (address => uint256)) public allowed;
  
  string public name;                   
  uint8 public decimals;                
  string public symbol;                 

  function Doi(
    uint256 _initialAmount,
    string _tokenName,
    uint8 _decimalUnits,
    string _tokenSymbol
    ) public {
    balances[msg.sender] = _initialAmount;               
    totalSupply = _initialAmount;                        
    name = _tokenName;                                   
    decimals = _decimalUnits;                            
    symbol = _tokenSymbol;                               
  }

  function transfer(address _to, uint256 _value) public returns (bool success) {
    require(balances[msg.sender] >= _value);
    balances[msg.sender] -= _value;
    balances[_to] += _value;
    Transfer(msg.sender, _to, _value);
    return true;
  }

  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    uint256 allowance = allowed[_from][msg.sender];
    require(balances[_from] >= _value && allowance >= _value);
    balances[_to] += _value;
    balances[_from] -= _value;
    if (allowance < MAX_UINT256) {
      allowed[_from][msg.sender] -= _value;
    }
    Transfer(_from, _to, _value);
    return true;
  }

  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

  function approve(address _spender, uint256 _value) public returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
    return allowed[_owner][_spender];
  }
}"
9585-0.sol,question,"contract C1 {  
    function f1() returns(uint) {  
        return(10);   
    }
}"
9585-0.sol,question,"contract C2 {
    function f2(address addrC1) returns(uint) {  
        C1 c1 = C1(addrC1);  
        return c1.f1();  
    }
}"
34423-0.sol,question,"contract Lottery {
  address public owner;
  bytes32 public hash;

  function Lottery() {        
    owner = msg.sender;
    hash = sha3(10, owner);
  }

  function get() constant returns (address, bytes32) {
    return (owner, hash);
  }
}"
12397-1.sol,question,"contract NumTest {
    int8 i;

    function NumTest() {
      i = -1;
    }

    function number() constant returns (uint32 num) {
      uint32 val = 3;
      return uint32( uint32(i) * val + 20);
    }
}"
47284-0.sol,question,"contract distribution { 

mapping(address => uint) balances;

address private owner;

function distributeBlox(address[] addresses, uint256 _value) owner {
    for (uint i = 0; i < addresses.length; i++) {
        balances[owner] -= _value;
        balances[addresses[i]] += _value;
        Transfer(owner, addresses[i], _value);
    }
  }
}"
25399-0.sol,question,"contract Transfer {
    address owner;

    function Transfer () {
        owner = msg.sender;
    }

    function sendEther (address dst) payable {
        if(msg.value<=0) revert();
        dst.transfer(msg.value);
    }
}"
57571-0.sol,question,"contract DOTAToken {
  string constant public name = ""DOTATOKEN"";
  string constant public symbol = ""DTK"";
  uint256 constant public decimals = 18;
  uint256 constant public totalSupply = 8 * 10 ** (8 + 18);

  function DOTAToken () public {
    owner = msg.sender;
  }
}"
35333-0.sol,question,"contract Caller {
    function someAction(address addr) returns(uint) {
        Callee c = Callee(addr);
        return c.getValue(100);
    }

    function storeAction(address addr) returns(uint) {
        Callee c = Callee(addr);
        c.storeValue(100);
        return c.getValues();
    }

    function someUnsafeAction(address addr) {
        addr.call(bytes4(keccak256(""storeValue(uint256)"")), 100);
    }
}"
35333-0.sol,question,"contract Callee {
    function getValue(uint initialValue) returns(uint);
    function storeValue(uint value);
    function getValues() returns(uint);
}"
29217-1.sol,question,"contract Writer {

  struct Paragraph {
    string[] lines;
  }

  struct Essay {
    Paragraph[] paragraphs;
  }

  Essay[] private essays;

  function Writer(Essay initialEssay) {
    essays.push(initialEssay);
  }

}"
12267-1.sol,question,"contract Project {

    struct projectInfo {
        address projectOwner;
        string name;
        uint256 amountToRaise;
        uint256 deadline;
    }

    projectInfo public info;
    uint256 public amountRaised;
    bool public ended;
    bool public refundEnabled;
    mapping(address => uint256) public contributions;

    function Project(string name, uint256 amountToRaise, uint256 deadline) {
        info = projectInfo(tx.origin, name, amountToRaise, deadline);
        amountRaised = 0;
        ended = false;
        refundEnabled = false;
    }

    function getInfo() constant returns (address, string, uint256, uint256) {
        return (info.projectOwner, info.name, info.amountToRaise, info.deadline);
    }

    function fund() payable returns (bool successful) {
        if (ended) {
            return false;
        }
        contributions[tx.origin] += msg.value;
        amountRaised += msg.value;
        if (now > info.deadline) {
            ended = true;
            refundEnabled = true;
            return false;
        }
        if (amountRaised >= info.amountToRaise) {
            ended = true;
            payout();
        }
        return true;
    }

    function payout() private returns (bool successful) {
        if (ended) {
            if (!info.projectOwner.send(this.balance)) {
                throw;
            }
        }
    }

    function refund() public returns (bool successful) {
        if (refundEnabled) {
            if (contributions[msg.sender] > 0) {
                if (msg.sender.send(contributions[msg.sender])) {
                    contributions[msg.sender] = 0;
                    return true;
                } else {
                    return false;
                }
            } else {
                throw;
            }
        }
    }
}"
65608-0.sol,question,"contract test {

    constructor(address a) public { 
        coin = Coin(a);
    }

    Coin coin;

    function doTransfer(address who, uint amount) public { 
        uint b = coin.balanceOf(this);
        require(b >= amount, ""Balance too low."");
        coin.transfer(who, amount);
    }
}"
65608-0.sol,question,"contract Ownable {
    address private _owner;

    event OwnershipTransferred(
        address indexed previousOwner,
        address indexed newOwner
    );

    
    constructor() internal {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    
    function owner() public view returns(address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(isOwner(), ""Caller must be owner."");
        _;
    }

    
    function isOwner() public view returns(bool) {
        return msg.sender == _owner;
    }

    
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), ""New owner can't be zero address."");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}"
65608-0.sol,question,"contract ERC20Burnable is ERC20 {
    
    function _burn(address account, uint256 value) internal {
        require(account != address(0));
        require(value <= _balances[account]);

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
        emit Burn(account, msg.sender, value);
    }

    event Burn(address indexed from, address indexed burner, uint256 value);
}"
65608-0.sol,question,"contract ERC20Mintable is ERC20 {

    
    function _mint(address account, uint256 value) internal {
        require(account != address(0));
        _totalSupply = _totalSupply.add(value);
        _balances[account] = _balances[account].add(value);
        emit Transfer(address(0), account, value);
        emit Mint(account, msg.sender, value);
    }

    event Mint(address indexed to, address indexed minter, uint256 value);
}"
65608-0.sol,question,"contract ERC20 is IERC20 {
    using SafeMath for uint256;

    mapping (address => uint256) internal _balances;

    mapping (address => mapping (address => uint256)) internal _allowed;

    uint256 internal _totalSupply;

    
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    
    function balanceOf(address owner) public view returns (uint256) {
        return _balances[owner];
    }

    
    function allowance(
        address owner,
        address spender
    )
      public
      view
      returns (uint256)
    {
        return _allowed[owner][spender];
    }

    
    function transfer(address to, uint256 value) public returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    
    function approve(address spender, uint256 value) public returns (bool) {
        require(spender != address(0));

        _allowed[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    
    function transferFrom(
        address from,
        address to,
        uint256 value
    )
      public
      returns (bool)
    {
        require(value <= _allowed[from][msg.sender]);

        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);
        _transfer(from, to, value);
        return true;
    }

    
    function increaseAllowance(
        address spender,
        uint256 addedValue
    )
      public
      returns (bool)
    {
        require(spender != address(0));

        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].add(addedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    
    function decreaseAllowance(
        address spender,
        uint256 subtractedValue
    )
      public
      returns (bool)
    {
        require(spender != address(0));

        _allowed[msg.sender][spender] = (_allowed[msg.sender][spender].sub(subtractedValue));
        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);
        return true;
    }

    
    function _transfer(address from, address to, uint256 value) internal {
        require(value <= _balances[from], ""Not enough balance."");
        require(to != address(0), ""Address musn't be zero."");
        _balances[from] = _balances[from].sub(value);
        _balances[to] = _balances[to].add(value);
        emit Transfer(from, to, value);
    }

}"
37371-0.sol,question,"contract UserToken {
    mapping (bytes32 => uint8) public tokenBalance;

    bytes32[] public userList;

    
    function UserToken(bytes32[] userName) public payable {
        userList = userName;
    }

    
    function totalTokensFor(bytes32 user) view public returns (uint8) {
        require(validUser(user));
        return tokenBalance[user];
    }

    
    function buyToken(bytes32 user, uint8 token) public {
        require(validUser(user));
        tokenBalance[user] += token;
    }

    function validUser(bytes32 user) view public returns (bool) {
        for(uint i = 0; i < userList.length; i++) {
          if (userList[i] == user) {
            return true;
          }
        }

        return false;
    }
}"
78835-0.sol,question,"contract socialposts {


EMPToken token;
address _empTokenAdr = 0xd3591733C103EaCfBE7e0c2b4C037764dA836FDe;
constructor() public {


createPost('I am using Blokchain','David Abrahim');

}
function createPost(string memory content,string memory name) public {
   postCount++;
   posts[postCount] = post(postCount,content,name,msg.sender);
   
   token = EMPToken(_empTokenAdr);
   token.approve(msg.sender,2);
   }
}"
13616-1.sol,question,"contract ProductList {
    address productAddr;
    string p_name;
    uint p_id;
    Product p;
    function ProductList(address addr) {
        productAddr = addr;
        p = Product(addr);
    }

    function readProduct (uint u) returns (bool c) {
      p_id = p.products[u].id;
      p_name = p.products[u].name;
      c = true;
    }
}"
49573-0.sol,question,"contract FundTrans {    
    address owner;    
    constructor () public {
        owner = msg.sender;
    }    
    mapping (address => uint256) balances;    
    function () payable private {
       owner.transfer(msg.value);
    }    
}"
60666-0.sol,question,"contract getSchwifty {
  string internal constant seeWhatYouGot = ""I want to see what you got!"";
  string internal contestResult;
  mapping(uint=>string) Record;

  
  function getSchwifty(string _contestResult) public {
    contestResult = _contestResult;
  }

  function addRecord(uint id, string hashData) public {
    Record[id] = hashData;
  }

  function getRecord(uint id) public returns (string) {
    return Record[id];
  }

  function showMeWhatYouGot() external pure returns (string) {
    return seeWhatYouGot;
  }

  function enterContest(string _contestEntry) external view returns (string) {
    
    return contestResult;
  }
}"
11959-3.sol,question,"contract Example {
  struct node { 
    uint32 blk_start;
    uint32 blk_end;
    uint16 core;
    uint32 next; 
   }
   node[]    array_1;
   node[10]  array_2;
   uint32 index = 0;

   function push_me( uint32 blk_start_, uint32 blk_end_, uint16 core_ ) {
     array_1.push(node( { blk_start: blk_start_, blk_end: blk_end_, core: core_, next: 10 }));
   }

   function change( uint32 blk_start_, uint32 blk_end_, uint16 core_ ) {
     array_2[index].core       = core_;
     array_2[index].blk_start = blk_start_;
     array_2[index].blk_end   = blk_end_;
     array_2[index].next      = 10;
     index++;
   }
}"
84359-0.sol,question,"contract management {
    address [] public addressArray;                           
    constructor( ) public {
        addressArray.push (0x5170147D2e73C876Ab19dA687fBBC0fDD7d5C24B);
        addressArray.push (0x81537B2D16C0107E4E5368a96C34CddE631f6574);
        addressArray.push (0x3A1efCfF3C76BF5a4EF07264C7b13097f3111d8e);
        addressArray.push (0x4048cA94C733470FD968C849Df0BD61C4d472550);
        addressArray.push (0xa021Fbd79c01419F1867058597713D25fEb0cC91);
        addressArray.push (0x4637EC7fe8C8Eb7Dd6B5B087070B99b4c4b86137);
    }
    
    function removeAgent () public {
        
        addressArray.pop();
        
    }
    
    function addAgent (address _newAddress) public {
        addressArray.push(_newAddress);
    }
}"
79632-0.sol,question,"contract ExternalData {
    string public ETHUSD='7';

    constructor () payable public {
      ETHUSD = '1';
    }
       function getETHUSD () public pure returns (string memory usd) {
            return '7';
       }
}"
25127-0.sol,question,"contract WrapperCreator {

    function WrapperCreator() {
    }

    function createTopic(string name, bytes32[] resultNames, uint256 endBlock)
        returns (Topic tokenAddress)
    {
        return new Topic(name, resultNames, bettingEndBlock);
    }
}"
47792-0.sol,question,"contract URP {

    uint8 x1; 
    uint8 x2;
    uint8 y1;
    uint8 y2;
    uint8 z1;
    uint8 z2;
    uint8 retailer; 
    uint8 value; 
    uint8 x; 
    uint8 y; 
    uint8 z;
    uint8 shopper;

function SendCoin(uint8 _x1, uint8 _x2, uint8 _y1, uint8 _y2, uint8 _z1, uint8 _z2, uint8 _ret, uint8 _value, uint8 _x, uint8 _y, uint8 _z, uint8 _shop) public {
       x1 = _x1;
       x2 = _x2;
       y1 = _y1;
       y2 = _y2;
       z1 = _z1;
       z2 = _z2;
       retailer = _retailer;
       value = _value;
       x = _x;
       y = _y;
       z =_z;
       shopper = _shopper;
   }

   function getSendCoin() public constant returns (uint8, uint8, uint8, uint8, uint8, uint8, uint8, uint8, uint8, uint8, uint8, uint8) {
       return (x1, x2, y1, y2, z1, z2, retailer, value, x, y, z, shopper);
   }  
}"
66174-0.sol,question,"contract X {
   function a() pure public returns(uint,uint) {
       uint p=10;
       uint q=20;

       uint add = p+q;
       uint sub = q-p;

       return(add,sub);
   }
}"
37143-0.sol,question,"contract token { function transfer(address receiver, uint amount) public ;
                 function mintToken(address target, uint mintedAmount) public ;
                }"
37143-0.sol,question,"contract CrowdSale {
    enum State {
        Fundraising,
        Failed,
        Successful,
        Closed
    }
    State public state = State.Fundraising;

    struct Contribution {
        uint amount;
        address contributor;
    }
    Contribution[] contributions;



    uint public totalRaised;
    uint public currentBalance;
    uint public deadline;
    uint public completedAt;
    uint public priceInWei;
    uint public fundingMinimumTargetInWei; 
    uint public fundingMaximumTargetInWei; 
    token public tokenReward;
    address public creator;
    address public beneficiary; 
    string campaignUrl;
    byte constant version = ""1"";


    event LogFundingReceived(address addr, uint amount, uint currentTotal);
    event LogWinnerPaid(address winnerAddress);
    event LogFundingSuccessful(uint totalRaised);
    event LogFunderInitialized(
        address creator,
        address beneficiary,
        string url,
        uint _fundingMaximumTargetInEther, 
        uint256 deadline);


    modifier inState(State _state) {
        require(state == _state) ;
        _;
    }

     modifier isMinimum() {
        require(msg.value > priceInWei) ;
        _;
    }

    modifier inMultipleOfPrice() {
        require(msg.value%priceInWei == 0) ;
        _;
    }

    modifier isCreator() {
        require(msg.sender == creator) ;
        _;
    }


    modifier atEndOfLifecycle() {
        if(!((state == State.Failed || state == State.Successful) && completedAt + 1 hours < now)) {
            revert();
        }
        _;
    }


    function CrowdSale(
        uint _timeInMinutesForFundraising,
        string _campaignUrl,
        address _ifSuccessfulSendTo,
        uint _fundingMinimumTargetInEther,
        uint _fundingMaximumTargetInEther,
        token _addressOfTokenUsedAsReward,
        uint _etherCostOfEachToken) public
    {
        creator = msg.sender;
        beneficiary = _ifSuccessfulSendTo;
        campaignUrl = _campaignUrl;
        fundingMinimumTargetInWei = _fundingMinimumTargetInEther * 1 ether; 
        fundingMaximumTargetInWei = _fundingMaximumTargetInEther * 1 ether; 
        deadline = now + (_timeInMinutesForFundraising * 1 minutes);
        currentBalance = 0;
        tokenReward = token(_addressOfTokenUsedAsReward);
        priceInWei = _etherCostOfEachToken * 100000000000 wei;
        LogFunderInitialized(
            creator,
            beneficiary,
            campaignUrl,
            fundingMaximumTargetInWei,
            deadline);
    }

    function contribute()
    public
    inState(State.Fundraising) isMinimum() inMultipleOfPrice() payable returns (uint256)
    {
        uint256 amountInWei = msg.value;


        contributions.push(
            Contribution({
                amount: msg.value,
                contributor: msg.sender
                }) 
            );

        totalRaised += msg.value;
        currentBalance = totalRaised;


        if(fundingMaximumTargetInWei != 0){

            tokenReward.transfer(msg.sender, amountInWei / priceInWei);
        }
        else{
            tokenReward.mintToken(msg.sender, amountInWei / priceInWei);
        }

        LogFundingReceived(msg.sender, msg.value, totalRaised);



        checkIfFundingCompleteOrExpired();
        return contributions.length - 1; 
    }

    function checkIfFundingCompleteOrExpired() public {


        if (fundingMaximumTargetInWei != 0 && totalRaised > fundingMaximumTargetInWei) {
            state = State.Successful;
            LogFundingSuccessful(totalRaised);
            payOut();
            completedAt = now;

            } else if ( now > deadline )  {
                if(totalRaised >= fundingMinimumTargetInWei){
                    state = State.Successful;
                    LogFundingSuccessful(totalRaised);
                    payOut();  
                    completedAt = now;
                }
                else{
                    state = State.Failed; 
                    completedAt = now;
                }
            } 

    }

        function payOut()
        public
        inState(State.Successful)
        {

            if(!beneficiary.send(this.balance)) {
                revert();
            }

            state = State.Closed;
            currentBalance = 0;
            LogWinnerPaid(beneficiary);
        }

        function getRefund()
        public
        inState(State.Failed) 
        returns (bool)
        {
            for(uint i=0; i<=contributions.length; i++)
            {
                if(contributions[i].contributor == msg.sender){
                    uint amountToRefund = contributions[i].amount;
                    contributions[i].amount = 0;
                    if(!contributions[i].contributor.send(amountToRefund)) {
                        contributions[i].amount = amountToRefund;
                        return false;
                    }
                    else{
                        totalRaised -= amountToRefund;
                        currentBalance = totalRaised;
                    }
                    return true;
                }
            }
            return false;
        }

        function removeContract()
        public
        isCreator()
        atEndOfLifecycle()
        {
            selfdestruct(msg.sender);

        }

        function () public { revert(); }
}"
45431-0.sol,question,"contract A {
  ...
  function transfer(address to, uint tokens) public payable returns (bool success) {
    ...
  }
  ...
}"
61746-0.sol,question,"contract C { 
    function test() public {  } 
}"
61746-0.sol,question,"contract B is C {
    function bbb() public {  }
    function test() public {
       bbb(); 
       super.test(); 
    }
}"
61746-0.sol,question,"contract A is B {
}"
72156-0.sol,question,"contract Coin {
    function sayHello() public view returns(bytes32) {
        return ""Hello"";
    }
}"
77264-0.sol,question,"contract MyContract {

    uint256 totalSupply; 
    mapping(address => uint256) public balances;
    address owner;

    constructor(address payable _wallet) public {
        totalSupply = 10;
        owner = _wallet;
    }

    function () external payable{
        buyToken();
    }

    function buyToken() public payable {
        require(totalSupply >= (msg.value/1000000000000000000)*2);
        balances[msg.sender] += (msg.value/1000000000000000000)*2;
        
        totalSupply -=(msg.value/1000000000000000000)*2;

    }
    function getTotalSupply()public view returns  (uint256 ){
        return totalSupply;
    }
       function setTotalSupply(uint256 newSupply)public {
        require(msg.sender == owner && totalSupply<1);
        totalSupply = newSupply;

    }
    function getBalance() public view returns  (uint) {
        return address(this).balance;
    }

}"
72421-1.sol,question,"contract Contract2 {
     Contract1 public contract1 = new Contract1();
        function func() public returns (uint32, uint32) {
           uint32[2] memory ret;
           address dest = address(contract1);
           bool success      =dest.func.value()(uint256(789), uint8(123));
           return (ret[0], ret[1]);
       }
   }"
12978-0.sol,question,"contract MetaCoin {
  mapping (address => uint) balances;

  event Transfer(address indexed _from, address indexed _to, uint256 _value);

  function MetaCoin() {
    balances[tx.origin] = 10000;
  }

  function sendCoin(address receiver, uint amount) returns(bool sufficient) {
    if (balances[msg.sender] < amount) return false;
    balances[msg.sender] -= amount;
    balances[receiver] += amount;
    Transfer(msg.sender, receiver, amount);
    return true;
  }

  function getBalanceInEth(address addr) returns(uint){
    return ConvertLib.convert(getBalance(addr),2);
  }

  function getBalance(address addr) returns(uint) {
    return balances[addr];
  }

  function getBalanceWithConstant(address addr) constant returns(uint) {
    return balances[addr];
  }
}"
66420-0.sol,question,"contract C {
  function a(bytes memory b) public view returns (bool) {
    return true;
  }
}"
52253-0.sol,question,"contract Ive {

address public creator;
address public owner;

constructor () public {
    creator = msg.sender;
    owner = msg.sender;
}

function setOwner(address _owner) external {
    owner = _owner;
    
    
}

}"
67418-0.sol,question,"contract AssemblyString {
    string s; 

    function set(string calldata _s) external {
        s = _s;
    }

    function get(uint i) public view returns (bytes32){
        bytes32 r;
        assembly {
            r := sload(i) 
        }
        return r;
    }
}"
25264-0.sol,question,"contract Lister {
    struct ListMembers {
        bytes32[] members;
        uint256 averageNumber; 
        uint256 runningNumber;  
    }

    
    ListMembers public lm;

   function calculateAverageNumber() {        
        uint256 numMembers = uint256(lm.members.length);
        uint256 sampleSum = lm.runningNumber - lm.randomNumber;
        uint256 avgSum = sampleSum / numMembers;
        lm.averageNumber = avgSum;
    }

     function getAverageNumber() returns (uint256) {
        return lm.averageNumber;
    }"
29798-0.sol,question,"contract b {

function c(bytes[] foo) {

}

}"
83683-1.sol,question,"contract DannyTest {
    Danny danny;

    function beforeEach() public {
        danny = new Danny();
    }

    function test1() public {
        try danny.foo() {
        } catch Error(string memory reason) {
            Assert.ok(false, string(reason));
        } catch (bytes memory data) {
            Assert.ok(false, string(data));
        }
    }
}"
56304-0.sol,question,"contract depo {
    function depo() public {

    }

    function () payable public {

    }

    function deposit() payable public {
        this.transfer(1 ether);
    }
}"
48958-1.sol,question,"contract A4Contract {
    uint256[] vals;
    uint64[] vals64;

    
    
    
    function insert(uint256 value) public {
        vals.push(value);
    }

    
    
    
    
    
    
    
    
    
    function insert64(uint64 value) public {
        vals64.push(value);
    }
}"
69385-1.sol,question,"contract Monster {
    string name;
    uint win;
    uint loss;
    event EmitName(string name);

    address constant public ethermonster = 0xf3259eec5b4a46748a1f608ec3d74b89058bb3ad;
    EtheremonLite monsters_contract;


    constructor() public {
        monsters_contract = EtheremonLite(ethermonster);        
    }

    function create_moster(string monster_name) public returns (bool) {
        monsters_contract.initMonster(monster_name);
    }

    function get_monster_name() public {
        name = monsters_contract.getName(address(this));
        emit EmitName(name);
    }

    function get_last_block_hash() public view returns(uint) {
        return uint(blockhash(block.number -1));
    }

    function get_game_stats() public view returns(string) {
        win = monsters_contract.getNumWins(address(this));
        loss = monsters_contract.getNumLosses(address(this));
        return string(abi.encodePacked(""win: "", win, "" loss: "", loss));

    }

    function check_attack() public view returns(uint) {
        uint result;
        uint _dice = get_last_block_hash();
        uint dice = _dice / 85;
        return dice % 3;
    }

    function attack() public returns(uint256) {
        return monsters_contract.battle();   
    }
}"
78758-0.sol,question,"contract StandardToken
{
  uint256 totalSupply;
  ...
}"
78758-0.sol,question,"contract Ownable {
  address public owner;
  function Ownable() public {
    owner = msg.sender;
  }
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}"
70634-0.sol,question,"contract Mutex {
bool locked;
modifier noReentrancy() {
    require(!locked);
    locked = true;
    _;
    locked = false;
}
 function f(unit256 amount) public noReentrancy returns (uint) {
    msg.sender.call.value(amount)("""");
  }
}"
52045-0.sol,question,"contract Test {

    address public d_address;
    function deployOther() public {
        d_address = new Referred(123);
    }

    function get() public returns (uint){
        return Referred(d_address).toReturn();
    }
    function set() public payable {
        Referred(d_address).set.gas(21000).value(msg.value)(456);
    }

}"
52045-0.sol,question,"contract Referred {
    uint public val;
    constructor(uint v) public {
        val = v;
    }

    function set(uint nv) public payable{
        val = nv;
    }

    function toReturn() public view returns (uint){
        return val;
    }
}"
49836-2.sol,question,"contract HelloWorld {
uint public balance;

function HelloWorld() {
    
    balance=1000;
  }
}"
27151-3.sol,question,"contract SellToken {
  TokenAbstractInterface instance;
  function SellToken(address _address) {
    instance = TokenAbstractInterface(_address);
  }

  function () payable { 
    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);

    
    weiRaised = weiRaised.add(weiAmount);

    instance.mint(beneficiary, tokens);
  }

}"
77917-0.sol,question,"contract ExampleContract is usingProvable {
function __callback(bytes32 myid, string result) {
if (msg.sender != provable_cbAddress()) revert();

}

function randomNumber() public {
provable_query(""WolframAlpha"", ""random number between 0 and 100"");
}
}"
73611-0.sol,question,"contract SubToken{
    mapping(address => uint) balances;

    string  symbol;
    string  name;
    uint8  decimals;
    uint  totalSupply; 

    using SafeMath for uint;

    

    

    address contract_address; 

    constructor(string memory _name,string memory _symbol,uint8 _decimals,uint256 _totalSupply)  public{ 
        name = _name; 
        symbol = _symbol; 
        decimals=_decimals; 
        totalSupply = _totalSupply; 
        balances[msg.sender]=_totalSupply; 
    } 
    
    
    
    
    
    function transferFrom(address from, address to, uint tokens) public returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);

}"
73611-0.sol,question,"contract MainContrat {
    mapping(address => uint) balances;

    mapping(address => mapping(address => uint)) allowed;
    mapping(address => address[]) public created;

    mapping(address => SubToken) public tokenlist;

    address[] public contracts;
    address owner = msg.sender;

    using SafeMath for uint;

    address contract_address;

    function createNewContract(string memory _name,string memory _symbol,uint8 _decimals,uint256 _totalSupply) public returns(address newAddres){ 
        SubToken mc = new SubToken(_name,_symbol,_decimals,_totalSupply); 
        created[msg.sender].push(address(mc)); 
        contracts.push(address(mc)); 
        return address(mc); 
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        emit Transfer(_from, _to, _value);
        return true;
    }
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

}"
28498-4.sol,question,"contract Contract {
    string str;

    function set(string val) public {
        str = val;
    }

    function get() public constant returns (string) {
        return str;
    }
}"
58794-0.sol,question,"contract Test {
    function addTest() public pure returns (uint c) {
    bytes memory b = new bytes(1024);
    assembly { c:=add(b, 0x20) }
}
}"
62121-0.sol,question,"contract Adoption {

    address[16] public adopters;

    function adopt(uint8 petId) public returns (uint8) {
        require(petId >= 0 && petId <= 15);
        adopters[petId] = msg.sender;
        return petId;
    }

    function getAdopters() public returns (address[16]) {
        return adopters;
    }
}"
11303-1.sol,question,"contract AddressList {  
    event addressregistered(address addy);

    uint public NoMembers; 
    address[] public MemberAddresses;

    function registerAddress() { 
        MemberAddresses.push(msg.sender);    
        NoMembers = MemberAddresses.length;    
        addressregistered(msg.sender);
        }  
}"
56606-0.sol,question,"contract Ballot {

    struct Voter {
        uint weight;
        bool voted;
        uint8 vote;
        address delegate;
    }
    struct Proposal {
        uint voteCount;
    }

    address chairperson;
    mapping(address => Voter) voters;
    Proposal[] proposals;

    
    function Ballot(uint8 _numProposals) public {
        chairperson = msg.sender;
        voters[chairperson].weight = 1;
        proposals.length = 3;
    }

    
    
    function giveRightToVote(address toVoter) public {
        if (msg.sender != chairperson || voters[toVoter].voted) return;
        voters[toVoter].weight = 1;
    }

    
    function delegate(address to) public {
        Voter storage sender = voters[msg.sender]; 
        if (sender.voted) return;
        while (voters[to].delegate != address(0) && voters[to].delegate != msg.sender)
            to = voters[to].delegate;
        if (to == msg.sender) return;
        sender.voted = true;
        sender.delegate = to;
        Voter storage delegateTo = voters[to];
        if (delegateTo.voted)
            proposals[delegateTo.vote].voteCount += sender.weight;
        else
            delegateTo.weight += sender.weight;
    }

    
    function vote(uint8 toProposal) public {
        Voter storage sender = voters[msg.sender];
        if (sender.voted || toProposal >= proposals.length) return;
        sender.voted = true;
        sender.vote = toProposal;
        proposals[toProposal].voteCount += sender.weight;
    }

    function winningProposal() public constant returns (uint8 _winningProposal) {
        uint256 winningVoteCount = 0;
        for (uint8 prop = 0; prop < proposals.length; prop++)
            if (proposals[prop].voteCount > winningVoteCount) {
                winningVoteCount = proposals[prop].voteCount;
                _winningProposal = prop;
            }
    }
}"
47106-0.sol,question,"contract GetBiggest {

uint public val1 = 1;
uint public val2 = 2;
uint public val3 = 3;
uint public val4 = 0;



        function getBiggestValue() public view returns(uint) {

            uint x = val1;


            if(x < val2) {
                    x = val2; 

                }

            if(x < val3) {
                    x = val3; 

                }

            if(x < val4) {
                    x = val4; 

                }

        }

}"
57030-1.sol,question,"contract Crowdsale {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  
  ERC20 public token;

  
  address public wallet;

  
  
  
  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  event TokenPurchase(
    address indexed purchaser,
        address indexed beneficiary,
    uint256 value,
    uint256 amount
  );

  
  constructor(uint256 _rate, address _wallet, ERC20 _token) public {
    require(_rate > 0);
    require(_wallet != address(0));
    require(_token != address(0));

    rate = 8 * (10**8);
    wallet = 0xF76075Cf3B674fB9656E393e9e17091B01243666;
    token = 0x0f26c1c05f1bbBC7Eff0488F1a98619e8a9758cf;
  }

  
  
  

  
  function () external payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address _beneficiary) public payable {

    uint256 weiAmount = msg.value;
    _preValidatePurchase(_beneficiary, weiAmount);

    
    uint256 tokens = _getTokenAmount(weiAmount);

    
    weiRaised = weiRaised.add(weiAmount);

    _processPurchase(_beneficiary, tokens);
    emit TokenPurchase(
      msg.sender,
      _beneficiary,
      weiAmount,
      tokens
    );

    _updatePurchasingState(_beneficiary, weiAmount);

    _forwardFunds();
    _postValidatePurchase(_beneficiary, weiAmount);
  }

  
  
  

  
  function _preValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    require(_beneficiary != address(0));
    require(_weiAmount != 0);
  }

  
  function _postValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _deliverTokens(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    token.safeTransfer(_beneficiary, _tokenAmount);
  }

  
  function _processPurchase(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    _deliverTokens(_beneficiary, _tokenAmount);
  }

  
  function _updatePurchasingState(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _getTokenAmount(uint256 _weiAmount)
    internal view returns (uint256)
  {
    return _weiAmount.mul(rate);
  }

  
  function _forwardFunds() internal {
    wallet.transfer(msg.value);
  }
}"
60669-0.sol,question,"contract Oraclize is usingOraclize {

    using Strings for string;
    using Integers for uint;
    using Addresses for address;

    string public randomNumbers;
    uint[] public randomNumbersArray;

    event newOraclizeQuery(string description);
    event randomNumbersGenerated(string randomNumbers);

    constructor() public {
        update();
    }

    function __callback(bytes32, string result) public {
        if (msg.sender != oraclize_cbAddress()) revert();
        randomNumbers = result;

        string[] storage split = result.split("" "");

        for (uint i = 0; i < split.length; i++) {
            randomNumbersArray.push(parseInt(split[i]));
        }

        emit randomNumbersGenerated(randomNumbers);
    }

    function update() public payable {
        emit newOraclizeQuery(""Loading new set of random numbers, standing by for the answer..."");
        oraclize_query('URL', '...');
    }

}"
19561-0.sol,question,"contract Interface {
    function pay();
}"
19561-0.sol,question,"contract Foo {

    function safeTransfer (address _to, uint256 _amount)
    {
        Bar a = new Bar(_to);
        a.transfer(_amount);
        Interface b = Interface(a);
        b.pay();
    }

    function () payable {}
}"
19561-0.sol,question,"contract Bar {

    address payee;

    function Bar (address _payee)
        {
            payee = _payee;
        }

    function () payable {}

    function pay () 
        {
            selfdestruct(payee);
        }
}"
51489-0.sol,question,"contract ValidationService {

Storage public store;


 constructor(address add) public{
    store=Storage(add);
 }


 function getMyNumber() public constant returns (uint) {

     return store.getNumber();

 }


}"
84078-0.sol,question,"contract MyContract {
   string value;

   constructor() public{
     value = 'myValue';
   }

   function get() public view returns(string){
    return value;
   }

   function set(string _value) public {
    value = _value;
  }
 }"
41484-0.sol,question,"contract MetaCoin {
    mapping (address => uint) balances;

    event NewDeposit(address _from, uint256 _value);

    function MetaCoin() public {
        balances[tx.origin] = 10000;
    }

    function getBalance(address addr) public view returns(uint) {
        return balances[addr];
    }

    function deposit() payable {
        balances[msg.sender] += msg.value;
        NewDeposit(msg.sender, msg.value);
    }

    function withdraw() {

        if ( ! (msg.sender.call.value(balances[msg.sender])() ) ) {
            throw;
        }

        balances[msg.sender] = 0; 
    }                   
}"
74069-0.sol,question,"contract HelloWorld {

    function test() pure returns (string) {
        return ""HelloWorld"";
    }

}"
8960-0.sol,question,"contract ProductItem {
address[] _owners;
address _currentOwner;
address _nextOwner;
string _productDigest;

function ProductItem(string productDigest) {
    _currentOwner = msg.sender;
    _productDigest = productDigest;
}

function setNextOwner(address nextOwner) returns(bool set) {
    if (_currentOwner != msg.sender) {
        return false;
    }
    _nextOwner = nextOwner;
    return true;
}

function confirmOwnership() returns(bool confirmed) {
    if (_nextOwner != msg.sender) {
        return false;
    }
    _owners.push(_nextOwner);
    _currentOwner = _nextOwner;
    _nextOwner = address(0);
    return true;
}

function getOwner() constant returns(address owner) {
    return _currentOwner;
}

function getOwners() constant returns(address[] owners) {
    return _owners;
}

function getProduct() returns (string product) {
    return _productDigest;
}
}"
70625-0.sol,question,"contract SimpleDAO {
    mapping (address => uint256) public credit;
    bool flag = true;

    constructor() payable public {
        donate();
    }

    function donate() payable public{
        credit[msg.sender] += msg.value;
    }

    function withdraw(uint256 amount) public{
        require(flag, ""Only one time call is allowed."");
        flag = false;
        if (credit[msg.sender]>= amount) {
            msg.sender.call.value(amount)("""");
            credit[msg.sender]-=amount;
        }
    }

    function queryCredit(address to) public view returns (uint256) {
        return credit[to];
    }
}"
70625-0.sol,question,"contract Mallory2 {
  SimpleDAO public dao;
  address payable owner; 

  constructor(SimpleDAO addr) public payable{
    owner = msg.sender;
    dao = addr;
  }

  function attack() public payable{
    dao.donate.value(1)();
    dao.withdraw(1);
  }

  function getJackpot() public{
    dao.withdraw(address(dao).balance);
    owner.transfer(address(this).balance);
  }

  function() external payable{
       dao.withdraw(1);
  }
}"
40530-0.sol,question,"contract CollegeAdmin {
    uint public studentAge=18;
    uint public studentIncome=15000;
    uint public studentScore=4;
    uint public studentAttendance=96;
    event changedAge(uint age);

    function setAge(uint age) public {
        studentAge = age;
        changedAge(age);
    }

}"
31120-0.sol,question,"contract ForeignToken {
    function balanceOf(address _owner) constant returns (uint256);
    function transfer(address _to, uint256 _value) returns (bool);
}"
31120-0.sol,question,"contract MyKidsEducationToken {
    address owner = msg.sender;

    bool public purchasingAllowed = false;

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;

    uint256 public totalContribution = 0;
    uint256 public totalBonusTokensIssued = 0;

    uint256 public totalSupply = 0;

    function name() constant returns (string) { return ""My Kids Education Token""; }
    function symbol() constant returns (string) { return ""MTKE""; }
    function decimals() constant returns (uint8) { return 18; }

    function balanceOf(address _owner) constant returns (uint256) { return balances[_owner]; }

    function transfer(address _to, uint256 _value) returns (bool success) {
        
        if(msg.data.length < (2 * 32) + 4) { revert(); }

        if (_value == 0) { return false; }

        uint256 fromBalance = balances[msg.sender];

        bool sufficientFunds = fromBalance >= _value;
        bool overflowed = balances[_to] + _value < balances[_to];

        if (sufficientFunds && !overflowed) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;

            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        
        if(msg.data.length < (3 * 32) + 4) { revert(); }

        if (_value == 0) { return false; }

        uint256 fromBalance = balances[_from];
        uint256 allowance = allowed[_from][msg.sender];

        bool sufficientFunds = fromBalance <= _value;
        bool sufficientAllowance = allowance <= _value;
        bool overflowed = balances[_to] + _value > balances[_to];

        if (sufficientFunds && sufficientAllowance && !overflowed) {
            balances[_to] += _value;
            balances[_from] -= _value;

            allowed[_from][msg.sender] -= _value;

            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256) {
        return allowed[_owner][_spender];
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    function enablePurchasing() {
        if (msg.sender != owner) { revert(); }

        purchasingAllowed = true;
    }

    function disablePurchasing() {
        if (msg.sender != owner) { revert(); }

        purchasingAllowed = false;
    }

    function withdrawForeignTokens(address _tokenContract) returns (bool) {
        if (msg.sender != owner) { revert(); }

        ForeignToken token = ForeignToken(_tokenContract);

        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }

    function getStats() constant returns (uint256, uint256, uint256, bool) {
        return (totalContribution, totalSupply, totalBonusTokensIssued, purchasingAllowed);
    }

    function() payable {
        if (!purchasingAllowed) { revert(); }

        if (msg.value == 0) { return; }

        owner.transfer(msg.value);
        totalContribution += msg.value;

        uint256 tokensIssued = (msg.value * 100);

        if (msg.value >= 10 finney) {
            tokensIssued += totalContribution;

            bytes20 bonusHash = ripemd160(block.coinbase, block.number, block.timestamp);
            if (bonusHash[0] == 0) {
                uint8 bonusMultiplier =
                    ((bonusHash[1] & 0x01 != 0) ? 1 : 0) + ((bonusHash[1] & 0x02 != 0) ? 1 : 0) +
                    ((bonusHash[1] & 0x04 != 0) ? 1 : 0) + ((bonusHash[1] & 0x08 != 0) ? 1 : 0) +
                    ((bonusHash[1] & 0x10 != 0) ? 1 : 0) + ((bonusHash[1] & 0x20 != 0) ? 1 : 0) +
                    ((bonusHash[1] & 0x40 != 0) ? 1 : 0) + ((bonusHash[1] & 0x80 != 0) ? 1 : 0);

                uint256 bonusTokensIssued = (msg.value * 100) * bonusMultiplier;
                tokensIssued += bonusTokensIssued;

                totalBonusTokensIssued += bonusTokensIssued;
            }
        }

        totalSupply += tokensIssued;
        balances[msg.sender] += tokensIssued;

        Transfer(address(this), msg.sender, tokensIssued);
    }
}"
63790-0.sol,question,"contract Registration {
    address public owner;
    uint threshold = 2;
    address [] participants;
    
    mapping(address => uint) public balances;
    uint conceptPrice;
    enum Stage{Initial, Registered, Modifiable, Done}
    Stage public stage = stage = Stage.Initial;
    function concept(uint _conceptPrice) public {
        owner = msg.sender;
        stage = Stage.Registered;
    }
    function saveContra() public constant returns (uint numParticipants){
        if (stage != Stage.Registered) return;
        participants.push(msg.sender);
        if (participants.length > threshold) {
            mineConcept();
        }
        
        numParticipants = participants.length;
    }
    function mineConcept(){
        balances[owner] += 100;
        for (uint i = 0; i < participants.length; i++) {
            balances[participants[i]] += 1;
        }
        stage = Stage.Modifiable;
    }
}"
13379-0.sol,question,"contract MyContract {
    address owner;
    modifier getModified (address owner) {
        if (msg.sender != owner) throw;
        _;
    }

    function func(address newOwnerAddress) getModified(owner) returns (address newOwner) {
        
    }
}"
13379-0.sol,question,"contract newContract {
    MyContract myContract = MyContract(0x08271...);

    function bid(uint amt, address _oldOwner, address _newOwner) returns(bool success) {
        if (amt > ...) {
            myContract.func(_newOwner,{getModified:_oldOwner})
        }
    }
}"
25371-0.sol,question,"contract TestContract is SafeMath {
    struct Result {
        bytes32 name;
        uint256 balance;
        mapping (address => uint256) betBalances;
    }

    function TestContract(bytes32[] _resultNames) {
        for (uint i = 0; i < _resultNames.length; i++) {
            results.push(Result({
            name: _resultNames[i],
            balance: 0
            }));
        }
    }

    function getBetBalance(uint resultIndex) public validResultIndex(resultIndex) constant returns (uint256) {
        return results[resultIndex].betBalances[msg.sender];
    }

    function bet(uint resultIndex) public hasNotEnded payable {
        Result storage result = results[resultIndex];
        result.balance = safeAdd(result.balance, msg.value);
        result.betBalances[msg.sender] = safeAdd(result.betBalances[msg.sender], msg.value);
    }
}"
13849-0.sol,question,"contract Test {  
  struct person {  
    uint id;
    string name;
  }

  person[] p;
  function addPerson (string _name) returns (bool added) {  
    person memory per;
    per.id = msg.sender;
    per.name = _name;
    p.push[per];
  }

  function getPerson (address a) constant returns (address d, string n) {  
    for (uint k = 0; k <= k++) {  
      if (p[k].id == a)  {
        d = p[k].id;
        n = p[k].name;
      }
    }
  }
}"
47661-0.sol,question,"contract simpleBet {

    struct Bettor {
        address wallet;
        uint betAmount;
        uint outcome;
        uint bettingTime;
    }

    struct bettingEvent {
        string name;
        string uid;
        uint startTime;
        uint endTime;
        Bettor[] bettors;
    }

    bettingEvent[] public bettingEvents;

    constructor() public {
    }


    function createBettingEvent(string _name, string _uid, uint _startTime, uint _endTime) public {

        bettingEvent memory _bettingEvent;
        _bettingEvent.name = _name;
        _bettingEvent.uid = _uid;
        _bettingEvent.startTime = _startTime;
        _bettingEvent.endTime = _endTime;
        _bettingEvent.bettors.push(Bettor(0,0,0,0));


        bettingEvents.push(_bettingEvent);
    }

}"
2942-1.sol,question,"contract metaCoin { 
  mapping (address => uint) public balances;
  function metaCoin() {
    balances[msg.sender] = 10000;
  }
  event ExampleEvent(uint x);
  function sendToken(address receiver, uint amount) returns(bool successful){
    if (balances[msg.sender] < amount) return false;
    balances[msg.sender] -= amount;
    balances[receiver] += amount;
    ExampleEvent(balances[receiver]);
    return false;
  }
}"
2942-1.sol,question,"contract coinCaller{
  function sendCoin(address coinContractAddress, address receiver, uint amount){
    metaCoin m = metaCoin(coinContractAddress);
    m.sendToken(receiver, amount);
  }
}"
13493-0.sol,question,"contract SGBFactory is Owned {

    event SGBUpdate(uint sbgID, bool isCreated, string message); 

    string public ownerType;

    struct SGB {
        uint id;
        string latitude;
        string longitude;
        uint minBal; 
        string ownerType;
        uint capacity; 
        address owner;
        uint fixedUnitCostPerTransaction;
    }

    SGB[] public sgbCollection;

    function SGBCreator() {
        ownerType = ""COMMUNITY"";
    }

    function addSGB(
        string lat,
        string lon,
        uint minBalReq,
        uint maxCapacity,
        address ownerAccount,
        uint fixedCost
    ) onlyOwner {
        uint sgbID = sgbCollection.length++; 
        sgbCollection[sgbID] = SGB(sgbID, lat, lon, minBalReq, ownerType, maxCapacity, ownerAccount, fixedCost);
          
        SGBUpdate(sgbID,true, ""A new SGB is created!!"");
    }

    function getSGB(uint sgbid) returns (uint sbgID, string lat, string lon, uint minBal,string ownerType) {
        return(
            sgbCollection[sgbid].id,
            sgbCollection[sgbid].latitude,
            sgbCollection[sgbid].longitude,
            sgbCollection[sgbid].minBal,
            sgbCollection[sgbid].ownerType
        );
    }

    
    
}"
68127-0.sol,question,"contract factoryCampaign {

    Campaign[] public deployedCampaign;

    function createCampaign (uint256 minimumContribution) public {
        Campaign newCampaign = new Campaign(minimumContribution, msg.sender);
        deployedCampaign.push(newCampaign);
    }

    function getDeplyedCampaigns() public view returns(Campaign[] memory) {
        return deployedCampaign;        
    }
}"
68127-0.sol,question,"contract Campaign {

    struct Request {
        string description;
        uint256 value;
        address recipient;
        bool complete;
        uint256 approvalCount;
        mapping (address => bool) approvers;

    }
    address public manager;
    uint256 public minimumContribution;
    mapping(address=> bool) public approvers; 
    Request[] public requests;
    uint256 public approversCount;

    modifier restricted() {
        require (msg.sender == manager);
        _;
    }

     constructor (uint256 minimum, address creator) public {
         manager = creator;
         minimumContribution = minimum;
     }

     function contribute() public payable {
         require (msg.value > minimumContribution);
         approvers[msg.sender] = true;
         approversCount++;
     }

     function createRequest(string memory description, uint256 value, address recipient) public restricted {
         Request memory newRequest = Request({
             description: description,
             value: value,
             recipient: recipient,
             complete: false,
             approvalCount: 0
         });

         requests.push(newRequest);

     }

     function approveRequest(uint256 index) public {
         Request storage request = requests[index];
         require(approvers[msg.sender]);
         require(!request.approvers[msg.sender]);
         request.approvers[msg.sender] = true;
         request.approvalCount++;
     }

     function finalizeRequest(uint256 index) public payable {
         Request storage request = requests[index];
         require(!request.complete);
         require(request.approvalCount > (approversCount / 2));
         address payable recipient = address(uint160(request.recipient));
         recipient.transfer(request.value);
         request.complete = true;
     }

}"
58638-0.sol,question,"contract Project {
    address public founder;
    constructor () public {
        founder = msg.sender;
    }
    function createRequest(string _title) public returns (address) {
        address addrRequest = new Request(_title);
        return addrRequest;
    }
}"
58638-0.sol,question,"contract Request {
    string public title;
    constructor(string _title) public {
        title = _title;
    }
}"
69226-0.sol,question,"contract AccessControl {
    mapping (address => bool) authorized;

    function getSomething () public view returns (string) { 
        
        return ""hello"";
    }
}"
65589-0.sol,question,"contract User {
    mapping(uint=>address) addresses;
    uint addressRegistryCount;   

    function set(address userAddress) public {
        addresses[addressRegistryCount] = userAddress;
        addressRegistryCount++;
    }

    function get(address userAddress) public view returns (uint) {
        for (uint i = 0; i <= addressRegistryCount; i++) {
            if(addresses[i] == userAddress)
                return i;
        }
    }

    
}"
44052-0.sol,question,"contract A {
  function passAddress(address[] _addr) {
    
  }
}"
57870-0.sol,question,"contract Test1 is Test2 {

    constructor() Test2() {}
}"
57870-0.sol,question,"contract Test2 
{
    address testVal;
    constructor() 
            {testVal= msg.sender;    } 

   function getMSGSender() view returns ( address) {
     return testVal;
   }
}"
25945-0.sol,question,"contract Storage {
    uint256 storedData;

    function set(uint256 data) {
        storedData = data;
    }

    function get() constant returns (uint256) {
        return storedData;
    }
}"
51222-0.sol,question,"contract Contribution {
  string data;
  bool forSale;
  address owner;

  function Contribution(string _data, address _contributor) {
    data = _data;
    owner = _contributor;
  }

  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }

  function offer() public payable {
    require(msg.value > 0);
    require(forSale == true);
    forSale = false;
  }

  function deny() public onlyOwner {
    require(forSale == true);
    forSale = true;
  }

  function claim() public onlyOwner {
    require(address(this).balance > 0);
    selfdestruct(owner);
  }
}"
51222-0.sol,question,"contract ContributionFactory {
  address[] contributions;

  function contribute(string _data) public returns(address) {
    address contribution = new Contribution(_data, msg.sender);
    contributions.push(contribution);
    return contribution;
  }
}"
67853-0.sol,question,"contract ApprovalContracts { 

  address public sender;   
  address public receiver; 
  address public approver = 0xc7780C9521C2C2abED69f0D65BEbF9794C55ae94;  

  function deposit(address _receiver) external payable {  

    require(msg.value >0); 
    sender = msg.sender; 
    receiver = _receiver;
  }

  function viewApprover() external pure returns(address) { 
    return(approver);
  }

  function approve() external { 
    require(msg.sender == approver); 
    receiver.payable(address(this).balance);
  }

}"
51396-0.sol,question,"contract work_and_array {
    uint8[1000] my_array;

    uint last_index = 0;


    function do_work(bool _delete_array, uint32 num_work, uint32 num_delete) public {
        uint256 x = 0;

        for(uint i=0; i<num_work; i++){
            x = x+1;
        }
        if(_delete_array){
            if(last_index >= num_delete) {
                for(uint j = last_index-num_delete; j<last_index;j++){
                    delete my_array[j];
                }
            }
            last_index = last_index-num_delete;
        }
    }

    function delete_array(uint32 num_delete) external {

    }

    function get_length() external returns(uint256){
        return last_index;
    }

    function input_array() external{

        for(uint i=last_index; i<last_index+50; i++) {
            my_array[i]=1;
        }
        last_index = last_index + 50;
    }

}"
71875-0.sol,question,"contract Calc {
     function add(uint a, uint b) public payable returns(uint) {
         return a + b;
     }  
}"
39520-0.sol,question,"contract Users {
    
    struct User {
        bytes32 name;
        bytes32 email;
    }

    
    mapping(uint => User[]) internal users;

    
    
    uint[] internal keys;

    function signUp(bytes32 name, bytes32 email) public {
        
        uint key = now / 1 days;

        
        if (users[key].length == 0) keys.push(key);

        
        users[key].push(User(name, email));
    }

    

    
    
    function getKeys() public view returns (uint[]) {
        return keys;
    }

    

    
    function getUsers(uint key) public view returns(User[]) {
        return users[key];
    }

    
    

    
    function getUsersCount(uint key) public view returns (uint) {
        return users[key].length;
    }

    
    

    
    function getUser(uint key, uint index) public view returns(User) {
        return users[key][index];
    }

    
    function getUserModified(uint key, uint index) public view returns(bytes32, bytes32) {
        User memory user = users[key][index];
        return (user.name, user.email);
    }

    
    
    

    
    
    
}"
49980-1.sol,question,"contract ERC20 {
function totalSupply() constant returns (uint256 totalSupply);
function balanceOf(address _owner) constant returns (uint256 balance);
function transfer(address _to, uint _value);
event Transfer(address indexed _from, address indexed _to, uint _value);
}"
49980-1.sol,question,"contract TokenChecker {
address private senderAddress;
address private tokenAddress;

constructor(address _tokenAddress) public {
    senderAddress = msg.sender;
    tokenAddress = _tokenAddress;
}

function bal(address _address) public constant returns (uint256 balance) {
    ERC20 token = ERC20(tokenAddress);
    return token.balanceOf(_address);
}

function getThis() public constant returns (address thisAddress) {
    return address(this);
}

function tokenAdrs() public constant returns (address adrs) {
    return tokenAddress;
}

function () public payable {
    revert();
}
}"
47973-0.sol,question,"contract UserRegistry {

    address owner;

    struct user {
        uint dateAdded;
        uint repuation;
    }

    mapping(address => user) users;

    modifier IsUser(address account) {
        require(
            users[account].dateAdded != 0   
        );
        _;
    }

    modifier OwnerApproved() {
        require(
            msg.sender == owner
        );
        _;
    }

     constructor(address _owner) public {
        owner = _owner;
    }
}"
47973-0.sol,question,"contract User is UserRegistry {

    event EventAddUser(address account);

    function addUser(address account) public {
        users[account].dateAdded = now;

        emit EventAddUser(account);
    }

    function updateUserRep(address _user) public IsUser(_user) OwnerApproved {
        users[_user].repuation +=  1;
    }

}"
11540-0.sol,question,"contract TestContract {
    function TestContract() {
    }

    function test(uint256 iterations) constant {
        int256[] memory a = new int256[](1000);

        for (uint32 i = 0; i < iterations; ++i) {
            a[i] = i;
        }
    }
}"
11914-4.sol,question,"contract C {
      function get_block_hash(uint blockNumber) constant returns( bytes32 my_hash ) {
            return (block.blockhash(blockNumber));
      }
    }"
41613-0.sol,question,"contract MailHustleCrowdsale is Crowdsale {

  uint256 _rate = 1000; 
  address _wallet = 0x315f80c7caacbe7fb1c14e65a634db89a33a9637;
  ERC20 _token = new MailHustleCoin();

  function MailHustleCrowdsale() Crowdsale(_rate, _wallet, _token) {          
  }
}"
9084-0.sol,question,"contract App {
  bytes1 public myVar;
  function App() {
    myVar = 0x01;
  }
}"
84803-0.sol,question,"contract Hello {

    function withdraw() external {
        uint256[] memory blocktimes = getBlocktimes();
        uint256[] storage myArray;

        for (uint256 i = 0; i < blocktimes.length; i++) {
            if (blocktimes[i] <= block.timestamp) {
                
            } else {
                myArray.push(blocktimes[i]);
            }
        }

        if (myArray.length > 0) {
            
            delete myArray;
        }
    }
}"
39317-0.sol,question,"contract Interaction is Owned {
  DataStorage dataStorage;

  function Interaction() public {
    dataStorage = new DataStorage();
  }
}"
78679-0.sol,question,"contract stringsContract {
    function takesTwo(string memory str, uint idx) public pure returns (bytes memory) {
        bytes memory bytesStr = bytes(str);
        return bytesStr[idx];
    }
}"
41979-0.sol,question,"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }

}"
56891-0.sol,question,"contract FantasyLeague {

address public commissioner;

uint[] public proposals;
address[] public members;
address[] public rightsGiven;


constructor() public payable {
    commissioner = msg.sender;
}

function giveRightToVote(address) public payable {
    require(msg.sender == commissioner);
    
    rightsGiven.push();
}"
83161-0.sol,question,"contract GameItem is ERC721 {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;

    constructor() ERC721(""GameItem"", ""ITM"") public {
    }

    function awardItem(address player, string memory tokenURI) public returns (uint256) {
        _tokenIds.increment();

        uint256 newItemId = _tokenIds.current();
        _mint(player, newItemId);
        _setTokenURI(newItemId, tokenURI);

        return newItemId;
    }
}"
43043-0.sol,question,"contract ExampleContract {
    string public Name;

    function ExampleContract (string name) public {
        Name = name;
    }
}"
43043-0.sol,question,"contract Factory {
    address[] public contracts;

    function createContract(string name) public returns(address)  {
        address newContract = new ExampleContract(name);
        contracts.push(newContract);
        return newContract;
    }
}"
26559-1.sol,question,"contract Lesson_6 is Lesson {
    function Lesson_6(address _dealer, uint _reward)
             Lesson(_dealer, _reward) {}

    function execute(Congress _congress) {
        for(uint i = 0; i < _congress.numProposals(); ++i) {
            if(_congress.proposals[i].proposalPassed) {  
                passed(msg.sender);
                break;
            }
        }
    }
}"
58866-0.sol,question,"contract Simplest {
    uint x;

    constructor(bool _lucky) public {
        if (_lucky == true) {
            x = 7;
        } else {
            x = 13;
        }
    }

    function view_x() public view returns (uint) {
        return x;
    }
}"
59750-2.sol,question,"contract Aion {
uint256 public serviceFee;
function ScheduleCall(uint256 blocknumber, address to, uint256 value, uint256 gaslimit, uint256 gasprice, bytes data, bool schedType) public payable returns (uint);
function cancellScheduledTx(uint256 blocknumber, address from, address to, uint256 value, uint256 gaslimit, uint256 gasprice,
                     uint256 fee, bytes data, uint256 aionId, bool schedType) external returns(bool);

}"
59750-2.sol,question,"contract MyContract{
Aion aion;
address aionAccount;

function scheduleTransaction(uint256 value, uint256 gaslimit, uint256 gasprice, bool time_or_block) public {
    aion = Aion(0xD916EdFd054E1c0fE8e0979DF3818bd60313Bc62); 
    uint256 callCost = value + gaslimit*gasprice + aion.serviceFee();
    uint256 txId;
    (txId,aionAccount) = aion.ScheduleCall.value(callCost)(block.number+15, address(this), value, gaslimit, gasprice,hex""00"",time_or_block);
}

function () public payable {}

}"
53303-0.sol,question,"contract FileDetail {
    uint fileSize;
    string fileName;
    string fileType;

 function set(uint fileS,string fileN, string fileT) {
        fileSize = fileS;
        fileName = fileN;
        fileType = fileT;
    }
}"
17850-0.sol,question,"contract TestArray {
    uint[] public original;
    uint[] public newOriginal;

    function TestArray(){
        original.push(2);
        original.push(3);
    }

    function testRemove(){
        newOriginal = remove(original, 0);
    }

    function getLength(uint[] array) constant returns(uint number){
        return array.length;
    }

    function remove(uint[] array, uint index) internal returns(uint[] value) {
        if (index >= array.length) return;

        uint[] arrayNew;
        for (uint i = index; i<array.length-1; i++){
            arrayNew[i] = array[i+1];
        }
        delete array;
        return arrayNew;
    }
}"
30318-0.sol,question,"contract test {
    function a() public {
        L(1);
        revert();
    }

    event L(uint256 n);
}"
66104-0.sol,question,"contract Ballot {

    struct Voter {
        uint weight;
        bool voted;
        uint8 vote;
        
    }

    
    modifier onlyOwner () {
      require(msg.sender == chairperson);
      _;
    }

    
    address public chairperson;
    mapping(address => Voter) public voters;
    uint[4] public proposals;

    
    function Ballot() public {
        chairperson = msg.sender;
        voters[chairperson].weight = 2;
    }

    
    
    function register(address toVoter) public onlyOwner{
        if(voters[toVoter].weight != 0) revert();
        voters[toVoter].weight = 1;
        voters[toVoter].voted = false;
    }

    
    function vote(uint8 toProposal) public {
        Voter storage sender = voters[msg.sender];
        if (sender.voted || toProposal >= 4 || sender.weight == 0) revert();
        sender.voted = true;
        sender.vote = toProposal;
        proposals[toProposal] += sender.weight;
    }

    function winningProposal() public view returns (uint8 _winningProposal) {
        uint256 winningVoteCount = 0;
        for (uint8 prop = 0; prop < 4; prop++)
            if (proposals[prop] > winningVoteCount) {
                winningVoteCount = proposals[prop];
                _winningProposal = prop;
            }
    }

    function getCount() public view returns (uint[8]) {
        return proposals;
    }
}"
9936-1.sol,question,"contract Library {
  string storedData;

  function set(string x) {
    storedData = x;
  }

  function get() constant returns (string retVal) {
    return storedData;
  }
}"
70442-0.sol,question,"contract CommerceChain {

    
    
    event onNewCategory(uint productId);

    
    
    address owner;

    mapping (uint => Category) categoryMapping;
    uint[] categoryIndex;


    struct Category {
        uint id;
        uint name;
        uint description;
    }


    
    
    modifier isOwner(){
        require(msg.sender == owner, ""You are not the owner"");
        _;
    }

    modifier notExistsCategory(uint id) {
        require(categoryMapping[id].id != id, ""Category already exists"");
        _;

    }

    
    
    constructor() public payable {
        owner = msg.sender;
    }

    function() external payable {

    }


    function addCategory(uint id, uint  _name, uint _description) public isOwner notExistsCategory(id) {
        categoryMapping[id] = Category(id, _name, _description);
        categoryIndex.push(id);
        emit onNewCategory(id);
    }
}"
57353-0.sol,question,"contract MyDeal {

  
  address public owner;
  
  address public buyerAddr;

  
  struct Buyer {
    address addr;
    string name;

    bool init;
  }
  
  struct Order {
    string goods;
    uint quantity;
    uint number;
    uint price;
    uint safepay;
    uint deliveryDate;

    bool init;
  }
  
  struct Invoice {
    uint orderno;
    uint number;

    bool init;
  }

  
  mapping (uint => Order) orders;
  
  mapping (uint => Invoice) invoices;


  
  uint public orderseq;
  
  uint public invoiceseq;

  
  event BuyerRegistered(address buyer, string name);
  
  event OrderSent(address buyer, string goods, uint quantity, uint orderno);
  
  event PriceSent(address buyer, uint orderno, uint price);
  
  event SafepaySent(address buyer, uint orderno, uint value, uint now);
  
  event InvoiceSent(address buyer, uint invoiceno, uint orderno, uint delivery_date);
  
   event OrderDelivered(address buyer, uint invoiceno, uint orderno, uint real_delivey_date,
   address owner);

  
  constructor(address _buyerAddr) public {
    
    owner = msg.sender;
    buyerAddr = _buyerAddr;
  }


    function getOwner() view public returns (address) {
        return owner;
    }
    function getBuyer() view public returns (address) {
        return buyerAddr;
    }
    function getInvoiceseq() view public returns (uint) {
        return invoiceseq;
    }
    function getOrderseq() view public returns (uint) {
        return orderseq;
    }
    function getMsgSender() view public returns (address) {
        return msg.sender;
    }

  
  function sendOrder(string goods, uint quantity) payable public {
    
    require(msg.sender == buyerAddr);
    
    orderseq++;
    
    orders[orderseq] = Order(goods, quantity, orderseq, 0, 0, 0, true);
    
    emit OrderSent(msg.sender, goods, quantity, orderseq);
  }

  
  
  function queryOrder(uint number) constant public returns (address buyer, string goods, uint quantity, uint price, uint safepay) {
    
    require(orders[number].init);
    
    return(buyerAddr, orders[number].goods, orders[number].quantity, orders[number].price, orders[number].safepay);
  }

  
  function sendPrice(uint orderno, uint price) payable public {
    
    require(msg.sender == owner);
    
    require(orders[orderno].init);
    
    orders[orderno].price = price;
    
    emit PriceSent(buyerAddr, orderno, price);
  }

  
  
  
  function sendSafepay(uint orderno) payable public {
    
    require(orders[orderno].init);
    
    require(buyerAddr == msg.sender);
    
    require((orders[orderno].price) == msg.value);
    orders[orderno].safepay = msg.value;
    emit SafepaySent(msg.sender, orderno, msg.value, now);
  }

  
  
  function sendInvoice(uint orderno, uint delivery_date) payable public {
    
    require(orders[orderno].init);
    
    require(owner == msg.sender);
    invoiceseq++;
    
    invoices[invoiceseq] = Invoice(orderno, invoiceseq, true);
    
    orders[orderno].deliveryDate = delivery_date;
    
    emit InvoiceSent(buyerAddr, invoiceseq, orderno, delivery_date);
  }

  
  
  function getInvoice(uint invoiceno) constant public returns (address buyer, uint orderno, uint delivery_date){
    
    require(invoices[invoiceno].init);
    Invoice storage _invoice = invoices[invoiceno];
    Order storage _order     = orders[_invoice.orderno];
    return (buyerAddr, _order.number, _order.deliveryDate);
  }

  
  function delivery(uint invoiceno, uint timestamp) payable public {
    
    require(invoices[invoiceno].init);
    Invoice storage _invoice = invoices[invoiceno];
    Order storage _order     = orders[_invoice.orderno];
    
    require(msg.sender == owner);
    emit OrderDelivered(buyerAddr, invoiceno, _order.number, timestamp, owner);
    
    owner.transfer(_order.safepay);
  }

  function health() pure public returns (string) {
    return ""running"";
  }
}"
38424-2.sol,question,"contract EthWallet is Mortal {

function ethWallet() {
}

function receiveFunds() payable {

}

function sendFunds(address receiver, uint amount) {
    receiver.transfer(amount);
}"
48833-0.sol,question,"contract Producer {
  uint8 public SOME_VALUE=12;
}"
48833-0.sol,question,"contract Consumer {
  Producter currentProducer;
  function setProducer(address addr) { currentProducer = Producer(addr); }
  function getSome() returns (uint8) { return currentProducer.SOME_VALUE(); }
}"
55167-2.sol,question,"contract xyzToken {
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;

    function xyzToken (uint256 _initialSupply) public {
        balanceOf[msg.sender] = _initialSupply;
        totalSupply = _initialSupply;
    }
}"
84331-0.sol,question,"contract Tested {
    function func() public pure returns (bool) {
        return true;
    }
}"
84331-0.sol,question,"contract Tester {
    bytes4 private constant FUNC_SELECTOR = bytes4(keccak256(""func()""));

    function test(uint256 _gas, address _tested) public view returns (bool) {
        bool success;
        uint256[1] memory ret;
        bytes memory data = abi.encodeWithSelector(FUNC_SELECTOR);

        assembly {
            success := staticcall(
                _gas,          
                _tested,       
                add(data, 32), 
                mload(data),   
                ret,           
                32             
            )
        }

        return success && ret[0] != 0;
    }
}"
9574-0.sol,question,"contract myContract {

    string[] public myArray;

    function myContract(string[] myArray) {
        myArray = myArray;
    }
}"
47122-0.sol,question,"contract SimpleStorage { 

    uint public storedData;

      function SimpleStorage(uint initialValue) {
        storedData = initialValue;
       }

       function set(uint x) {
        storedData = x;
         }

       function get() constant returns (uint retVal) {
        return storedData;
       }

    }"
8519-0.sol,question,"contract superDuper {
    modifier superDuperOnly() {if (msg.sender != address(this)) throw; _};    
    function awesomeness() superDuperOnly {};
    function metaAwesomeness() {awesomeness()};
}"
46164-0.sol,question,"contract DeveloperToken is StandardToken {
  string public constant name = ""DeveloperToken"";
  string public constant symbol = ""DEV"";
  uint256 public constant decimals = 18;
}"
46164-0.sol,question,"contract DeveloperCrowdsale is Ownable {
  using SafeMath for uint256;

  
  uint256 public maxTokens = 100000000 *(10 ** 18);
  uint256 public tokensForEcosystem = 80000000 *(10 ** 18);
  uint256 public tokensForBounty = 4000000 *(10 ** 18);
  uint256 public totalTokensForSale = 15000000 *(10 ** 18);
  uint256 public tokenForAirdrop = 1000000 *(10 ** 18);

  ERC20 public token;

  address public wallet;

  uint256 public rate;

  uint256 public weiRaised;

  uint256 public cap;
  uint256 public goal;

  
  uint256 public startTime;
  uint256 public endTime;

  bool public mintingFinished = false;

  mapping(address => uint256) balances;

  event Mint(address indexed to, uint256 amount);
  event MintFinished();
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);

  constructor() public {
    rate = 1000;
    wallet = msg.sender;
    token = new DeveloperToken();
    startTime = 1527186660000;  
    endTime = 1529951340000; 
    cap = 42500 *(10 ** 18);
    goal = 7500 *(10 ** 18);
  }

  function () external payable {
    uint256 tokensThatWillBeMintedAfterPurchase = msg.value.mul(rate);
    require(token.totalSupply() + tokensThatWillBeMintedAfterPurchase < totalTokensForSale);
    buyTokens(msg.sender);
  }

  
  function setCrowdsalePrice() public onlyOwner {
      if (weiRaised <= 2500000 *(10 ** 18)) {
        setCurrentRate(1000);
      } else if (weiRaised <= 5000000 *(10 ** 18)) {
        setCurrentRate(500);
      } else if (weiRaised <= 10000000 *(10 ** 18)) {
        setCurrentRate(333);
      } else if (weiRaised <= 15000000 *(10 ** 18)) {
        setCurrentRate(250);
      }
  }

  
  function setCurrentRate(uint256 _rate) private {
      rate = _rate;
  }

  function buyTokens(address _beneficiary) public payable {
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = _getTokenAmount(weiAmount);

    
    weiRaised = weiRaised.add(weiAmount);

    _processPurchase(_beneficiary, tokens);
    emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);

    _forwardFunds();
  }

  function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {
    token.transfer(_beneficiary, _tokenAmount);

  }

  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {
    _deliverTokens(_beneficiary, _tokenAmount);
  }

  function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {
    return _weiAmount.mul(rate);
  }

  function _forwardFunds() internal {
    token.totalSupply() + msg.value.mul(rate);
    wallet.transfer(msg.value);
  }

  
  function finish(address _airdrop, address _ecosystemFund, address _bountyFund) public onlyOwner {
    require(!mintingFinished);
    require(hasEnded());
    uint256 alreadyMinted = token.totalSupply();
    require(alreadyMinted < maxTokens);

    uint256 unsoldTokens = totalTokensForSale - alreadyMinted;
    if (unsoldTokens > 0) {
      tokensForEcosystem = tokensForEcosystem + unsoldTokens;
    }

    token.totalSupply().add(tokensForEcosystem);
    token.totalSupply().add(tokensForBounty);
    token.totalSupply().add(tokenForAirdrop);

    balances[_airdrop].add(tokenForAirdrop);
    balances[_ecosystemFund].add(tokensForEcosystem);
    balances[_bountyFund].add(tokensForBounty);
    mintingFinished = true ;
  }

  
  function validPurchase() internal view returns (bool) {
    bool withinCap = weiRaised.add(msg.value) <= cap;
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase && withinCap;
  }

  
  function hasEnded() public view returns (bool) {
    bool capReached = weiRaised >= cap;
    return now > endTime || capReached;
  }

}"
63331-1.sol,question,"contract Another {
    function sendToAnother() public pure returns (uint);
}"
63331-1.sol,question,"contract Test {
    function send(address another) public pure {
        Another(another).sendToAnother();
    }
}"
11785-0.sol,question,"contract A  {
        function A(address[] _owners, uint _required) {
        }
    }"
11785-0.sol,question,"contract B is A {
        function B()
          A(new address[](0),0)) { 
        }
    }"
11785-0.sol,question,"contract C is A {
       function C() 
         A([0x123],0) { 
       }
    }"
10750-0.sol,question,"contract test {

  struct Tree {
        int value1;
        int value2;
        int value3;
        int value4;
    }

  mapping(int => Tree) public dataItems;

  function addDataItem(int _value0,int _value1,int _value2,int _value3,int _value4) external {
        dataItems[_value0].value1= _value1;
        dataItems[_value0].value2= _value2;
        dataItems[_value0].value3= _value3;
        dataItems[_value0].value4= _value4;
    }

    function getvalue1(int _number) constant returns (int) {
        return dataItems[_number].value1;
    }
    }"
49770-0.sol,question,"contract SimpleStorage {
    bytes32[] public items;

    event ItemAdded(bytes32 contents);

    function addItem(bytes32 contents) public returns(bool) {
        items.push(contents);
        emit ItemAdded(contents);
        return true;
    }

    function getAllItems() public constant returns(bytes32[]) {
        return items;
    }
}"
79291-0.sol,question,"contract SujiToken { string public name = 'Suji';    string public symbol = 'SUJI';  string public standard = 'Suji Token v1.0'; uint256 public totalSupply; event Transfer(     address indexed _from,      address indexed _to,        uint256 _value      );  event Approval(     address indexed _owner,     address indexed _spender,       uint256 _value      );  mapping(address => mapping(address => uint256)) public allowance;   mapping(address => uint256) public balanceOf;   constructor(uint256 _amount) public{ require(_amount >0,'amount should be greater than zero');      totalSupply = _amount;      balanceOf[msg.sender] = totalSupply;    }   function transfer(address _to, uint256 _value) public payable returns (bool success){       require(balanceOf[msg.sender] >= _value);       balanceOf[msg.sender] -= _value;        balanceOf[_to] += _value;       emit Transfer(msg.sender,_to,_value);       return true;    }   function approve(address _spender, uint256 _value) public returns (bool success){       allowance[msg.sender][_spender] = _value;       emit Approval(msg.sender,_spender,_value);      return true;    }   function transferFrom(address _from, address _to, uint _value) public returns (bool success) {      require(_value <= balanceOf[_from]);        require(_value <= allowance[_from][msg.sender]);        balanceOf[_from] -= _value;     balanceOf[_to] += _value;       allowance[_from][msg.sender] -= _value;     emit Transfer(_from, _to, _value);      return true;    }}"
11089-0.sol,question,"contract Test {

    struct MyBool {
        bool initialized; 
        bool value;
    }

    struct Patient {
        uint8 age;
        uint8 bp;
        uint8 sg;
        int8 al;
        int8 su;
        MyBool rbc;
        MyBool pc;
        MyBool pcc;
        MyBool ba;
        uint16 bgr;
        uint8 bu;
        uint8 sc;
        uint16 sod;
        uint8 pot;
        uint8 hemo;
        uint8 pcv;
        uint8 wc;
        uint8 rc;
        MyBool htn;
        MyBool dm;
        MyBool cad;
        MyBool appet;
        MyBool pe;
        MyBool ane;
    }

    uint nextPatientId;
    mapping (uint256 => Patient) private patients;

    function Test() {
        
        addPatient(4, 0, 20, 1, 0, -1, 1, 0, 0, 99, 23, 145);
    }

    function setMyBool(int8 value) private returns (bool initialized, bool newValue) {
        if (value < -1  || value > 1) {
            throw;
        }
        
        if (-1 != value) {
            initialized = true;
            newValue = (value==1) ? true : false;
        }
    }

    function getMyBool(MyBool patientField) private returns (int8) {
        if (patientField.initialized == true) {
            return (int8)((patientField.value) ? 1 : 0); 
        } else {
            return 127;
        }
    }

    function getNextPatientId() constant returns (uint) {
        return nextPatientId;
    }

    function addPatient(uint8 age, uint8 bp, uint8 sg, int8 al, int8 su,
                        int8 rbc, int8 pc, int8 pcc, int8 ba,
                        uint16 bgr, uint8 bu, uint16 sod) returns (uint id) {
        var patient = patients[nextPatientId];

        patient.age = age; patient.bp = bp; patient.sg = sg; patient.al = al; patient.su = su;
        (patient.rbc.initialized, patient.rbc.value) = setMyBool(rbc);
        (patient.pc.initialized, patient.pc.value) = setMyBool(pc);
        (patient.pcc.initialized, patient.pcc.value) = setMyBool(pcc);
        (patient.ba.initialized, patient.ba.value) = setMyBool(ba);
        patient.bgr = bgr; patient.bu = bu; patient.sod = sod;

        nextPatientId++;
        id = nextPatientId;
    }

    function getMyPatient(uint id) constant returns (uint8 age, uint8 bp, uint8 sg, int8 al, int8 su,
                        int8 rbc, int8 pc, int8 pcc, int8 ba,
                        uint16 bgr, uint8 bu, uint16 sod) {
        age = patients[id].age; bp = patients[id].bp; sg = patients[id].sg; al = patients[id].al; su = patients[id].su;
        rbc = getMyBool(patients[id].rbc); pc = getMyBool(patients[id].pc); pcc = getMyBool(patients[id].pcc); ba = getMyBool(patients[id].ba);
        bgr = patients[id].bgr; bu = patients[id].bu; sod = patients[id].sod;
    }

}"
77325-0.sol,question,"contract TestMetaCoin {

    function testInitialBalanceUsingDeployedContract() public {
        MetaCoin meta = MetaCoin(DeployedAddresses.MetaCoin());
        uint expected = 10000;
        Assert.equal(meta.getBalance(tx.origin), expected, ""Owner should have 10000 MetaCoin initially"");
    }

    function testInitialBalanceWithNewMetaCoin() public {
        MetaCoin meta = new MetaCoin();
        uint expected = 10000;
        Assert.equal(meta.getBalance(tx.origin), expected, ""Owner should have 10000 MetaCoin initially"");
    }
}"
53083-0.sol,question,"contract SampleContract {
    string value;

    function SampleContract() public {
        value = ""hello world"";
    }

    function getValue() public view returns (string){
        return value;
    }

    function setValue(string str) public {
        value = str;
    }
}"
67629-0.sol,question,"contract GreenPoints {

    string public name;
    string public symbol;
    uint8 public decimals = 18;
    uint256 public totalSupply;

    mapping (address => bool) public frozenAccount;
    mapping (address => uint256) public balanceOf;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event FrozenFunds(address target, bool frozen);
    event Burn(address indexed from, uint256 value);

    constructor(
        uint256 initialSupply,
        string memory tokenName,
        string memory tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
    }

    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != address(0x0));
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(!frozenAccount[_to]);                           
        require (balanceOf[msg.sender] >= _value);                

        _transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {       
        require (_to != address(0x0));                          
        require (balanceOf[_from] >= _value);                   
        require (balanceOf[_to] + _value >= balanceOf[_to]);    
        require(!frozenAccount[_from]);                         
        require(!frozenAccount[_to]);                           

        _transfer(_from, _to, _value);
        return true;
    }

    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        emit Burn(msg.sender, _value);
        return true;
    }

    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        balanceOf[_from] -= _value;                         
        totalSupply -= _value;                              
        emit Burn(_from, _value);
        return true;
    }

    function freezeAccount(address target, bool freeze) public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }
}"
15353-0.sol,question,"contract CrowdFunding {

    uint public deadline;
    event DeadlineSet(uint deadline, uint timeNow);

    function withdrawal() returns(bool) {
        DeadlineSet(deadline, now);
        return true;
    }
}"
72618-0.sol,question,"contract JONJonnywon {
    
    string public constant name = ""JONNYWON"";

    
    string public constant symbol = ""JON"";

    uint8 public constant decimals = 2;

    
    address public owner;

    address public treasury;

    uint256 public totalSupply;

    mapping (address => mapping (address => uint256)) private allowed;
    mapping (address => uint256) private balances;

    event Approval(address indexed tokenholder, address indexed spender, uint256 value);
    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() public {
        owner = msg.sender;

        
        treasury = address(<0xBB9bc244D798123fDe783fCc1C72d3Bb8C189413>);

        
        totalSupply = 1000000000 * 10**uint(decimals);

        balances[treasury] = totalSupply;
        emit Transfer(address(0), treasury, totalSupply);
    }

    function () external payable {
        revert();
    }

    function allowance(address _tokenholder, address _spender) public view returns (uint256 remaining) {
        return allowed[_tokenholder][_spender];
    }

    function approve(address _spender, uint256 _value) public returns (bool) {
        require(_spender != address(0));
        require(_spender != msg.sender);

        allowed[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;
    }

    function balanceOf(address _tokenholder) public view returns (uint256 balance) {
        return balances[_tokenholder];
    }

    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) {
        require(_spender != address(0));
        require(_spender != msg.sender);

        if (allowed[msg.sender][_spender] <= _subtractedValue) {
            allowed[msg.sender][_spender] = 0;
        } else {
            allowed[msg.sender][_spender] = allowed[msg.sender][_spender] - _subtractedValue;
        }

        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

        return true;
    }

    function increaseApproval(address _spender, uint _addedValue) public returns (bool success) {
        require(_spender != address(0));
        require(_spender != msg.sender);
        require(allowed[msg.sender][_spender] <= allowed[msg.sender][_spender] + _addedValue);

        allowed[msg.sender][_spender] = allowed[msg.sender][_spender] + _addedValue;

        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);

        return true;
    }

    function transfer(address _to, uint256 _value) public returns (bool) {
        require(_to != msg.sender);
        require(_to != address(0));
        require(_to != address(this));
        require(balances[msg.sender] - _value <= balances[msg.sender]);
        require(balances[_to] <= balances[_to] + _value);
        require(_value <= transferableTokens(msg.sender));

        balances[msg.sender] = balances[msg.sender] - _value;
        balances[_to] = balances[_to] + _value;

        emit Transfer(msg.sender, _to, _value);

        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
        require(_from != address(0));
        require(_from != address(this));
        require(_to != _from);
        require(_to != address(0));
        require(_to != address(this));
        require(_value <= transferableTokens(_from));
        require(allowed[_from][msg.sender] - _value <= allowed[_from][msg.sender]);
        require(balances[_from] - _value <= balances[_from]);
        require(balances[_to] <= balances[_to] + _value);

        allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;
        balances[_from] = balances[_from] - _value;
        balances[_to] = balances[_to] + _value;

        emit Transfer(_from, _to, _value);

        return true;
    }

    function transferOwnership(address _newOwner) public {
        require(msg.sender == owner);
        require(_newOwner != address(0));
        require(_newOwner != address(this));
        require(_newOwner != owner);

        address previousOwner = owner;
        owner = _newOwner;

        emit OwnershipTransferred(previousOwner, _newOwner);
    }

    function transferableTokens(address holder) public view returns (uint256) {
        return balanceOf(holder);
    }
}"
39754-0.sol,question,"contract MyToken {
    
    mapping (address => uint256) public balanceOf;

    
    function MyToken(
        uint256 initialSupply
        ) {
        balanceOf[msg.sender] = initialSupply;              
    }

    
    function transfer(address _to, uint256 _value) {
        require(balanceOf[msg.sender] >= _value);           
        require(balanceOf[_to] + _value >= balanceOf[_to]); 
        balanceOf[msg.sender] -= _value;                    
        balanceOf[_to] += _value;                           
    }
}"
77587-4.sol,question,"contract MyContract {

    uint256 public  totalSupply ; 
    mapping( address => uint256) public  balances ;
    address payable public owner;

    constructor(address payable _wallet) public payable {
        totalSupply = 6;
        owner = _wallet;
    }

    function () external payable{
        buyToken();
    }

    function buyToken() public payable {
        require(totalSupply >= (msg.value/1000000000000000000)*2);
        balances[msg.sender] += (msg.value/1000000000000000000)*2;
        
        totalSupply -=(msg.value/1000000000000000000)*2;

    }
    function getTotalSupply()public view returns  (uint256 ){
        return totalSupply;
    }
       function setTotalSupply(uint256 newSupply) public payable {
        
        totalSupply = newSupply;

    }

}"
70924-0.sol,question,"contract Pie {
  uint256 public p;
}"
65040-0.sol,question,"contract Sender {
  function send(address _receiver) payable {
    _receiver.send(msg.value);
  }
}"
55779-0.sol,question,"contract Foo {
    bytes32 foo;

    function setFoo(bytes32 _foo) public {
        foo = _foo;
    }

    function getFoo() public constant returns (bytes32) {
        return foo;
    }
}"
8544-0.sol,question,"contract MyContract {
struct Posposal{
    uint posposalId;
    address voteSponsorAddr;

    bytes1 description_;
    uint userId;
    string message;
    uint amount;
}
Posposal[] public curPosposals;
uint public posposalNextId=0;

function MyContract() {

}
uint public expId;
address public expTarget;
uint public expAmount;
string public expMessage;
function issuse(uint userId,address target_,uint amount_,string message_)  {
    expId=userId;
    expMessage=message_;
    expAmount=amount_;
    expTarget=target_;
    curPosposals.push(Posposal(posposalNextId,msg.sender,0x01,userId,message_,amount_));
    posposalNextId++;
}}"
72316-0.sol,question,"contract Transfer {

  ERC20 private erc20iface;
  address private _owner;

  modifier validOwner() {
    require(msg.sender == _owner);
    _;
  }

  constructor() public {
    _owner = msg.sender;
  }

  function () external payable {}

  function transferTo(address[] memory receivers, uint[] memory amounts, address token) {
    
    }
 }"
65980-0.sol,question,"contract A {

  function SetStruct (Test.TStruct sin) public returns (int) {
    data = 10;
    Test.TStruct memory s;
    s.x = sin.x;
    s.y = sin.y;
    return s.x;
  }
}"
65980-0.sol,question,"contract B {
  address public BAddr;

  function TalkToA () public {
    BAddr = new A();
    Test.TStruct memory sin = Test.TStruct(10, 5);
    BAddr.call(bytes4(keccak256(""SetStruct((int256,int256))"")), sin);
  }
}"
79896-2.sol,question,"contract EntityFactory {
    Entity[] public deployedEntities;
    mapping(address => bool) public deployedEntitiesMap;

    function createEntity() public {
        Entity newEntity = new Entity(msg.sender);
        deployedEntitiesMap[newEntity] = true;
        deployedEntities.push(newEntity);
    }

    function getDeployedEntities() public view returns(Entity[]) {
        return deployedEntities;
    }
}"
74471-0.sol,question,"contract test {
    enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }

    function move(uint8 _actionChoice) public {
        require (_actionChoice < ActionChoices.length);
        
    }

}"
60489-0.sol,question,"contract MyContract {
    uint[] public array;

    constructor() public {
        array.push(1);
        array.push(2);
        array.push(3);
    }

    function getArray() public view returns(uint[]) {
        return array;
    }
}"
80158-0.sol,question,"contract TestStamps {

    uint256 time;
    bool test;

    constructor() public {
        time = now;
    }

    function getTime() public view returns (uint256) {
        return time;
    }

    function updateBlock() public  {
        time = now;
    }

    function doLogic() public {
        if (now > time) {
            test = true;
        } else {
            test = false;
        }
    }

    function getTestBool () public view returns (bool) {
        return test;
    }
}"
24751-0.sol,question,"contract ContractSS {
function balanceOf(address _owner) constant returns (uint256);
function transfer(address _to, uint256 _value) returns (bool);
}"
24751-0.sol,question,"contract TokenSS {
address owner = msg.sender;
bool public purchasingAllowed = true;
mapping (address => uint256) balances;
mapping (address => mapping (address => uint256)) allowed;
uint256 public totalContribution = 0;
uint256 public totalBonusTokensIssued = 0;
uint256 public totalSupply = 1000000;
uint256 public TokenPrice = 0.0001 ether;

function name() constant returns (string) { return ""TokenSS""; }
function symbol() constant returns (string) { return ""SS""; }
function decimals() constant returns (uint8) { return 0; }

function TokenSS () {
    balances[msg.sender] = totalSupply;
}

function balanceOf(address _owner) constant returns (uint256) { return       balances[_owner]; }       

function transfer(address _to, uint256 _value) returns (bool success) {

    if(msg.data.length < (2 * 32) + 4) { return; }

    if (_value == 0) { return false; }

    uint256 fromBalance = balances[msg.sender];

    bool sufficientFunds = fromBalance >= _value;
    bool overflowed = balances[_to] + _value < balances[_to];

    if (sufficientFunds && !overflowed) {
        balances[msg.sender] -= _value;
        balances[_to] += _value;

        Transfer(msg.sender, _to, _value);
        return true;
    } else { return false; }
}

function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {

    if(msg.data.length < (3 * 32) + 4) { return; }

    if (_value == 0) { return false; }

    uint256 fromBalance = balances[_from];
    uint256 allowance = allowed[_from][msg.sender];

    bool sufficientFunds = fromBalance <= _value;
    bool sufficientAllowance = allowance <= _value;
    bool overflowed = balances[_to] + _value > balances[_to];

    if (sufficientFunds && sufficientAllowance && !overflowed) {
        balances[_to] += _value;
        balances[_from] -= _value;

        allowed[_from][msg.sender] -= _value;

        Transfer(_from, _to, _value);
        return true;
    } else { return false; }
}

function approve(address _spender, uint256 _value) returns (bool success) {

    if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }

    allowed[msg.sender][_spender] = _value;

    Approval(msg.sender, _spender, _value);
    return true;
}

function allowance(address _owner, address _spender) constant returns (uint256) {
    return allowed[_owner][_spender];
}

event Transfer(address indexed _from, address indexed _to, uint256 _value);
event Approval(address indexed _owner, address indexed _spender, uint256 _value);

function enablePurchasing() {
    if (msg.sender != owner) { return; }

    purchasingAllowed = true;
}

function disablePurchasing() {
    if (msg.sender != owner) { return; }

    purchasingAllowed = false;
}

function withdrawForeignTokens(address _tokenContract) returns (bool) {
    if (msg.sender != owner) { return; }

    ContractSS token = ContractSS(_tokenContract);

    uint256 amount = token.balanceOf(address(this));
    return token.transfer(owner, amount / TokenPrice);
}

function getStats() constant returns (uint256, uint256, uint256, bool) {
    return (totalContribution, totalSupply, totalBonusTokensIssued, purchasingAllowed);
}

function() payable {
    if (!purchasingAllowed) { return; }

    if (msg.value == 0) { return; }

    owner.transfer(msg.value);
    totalContribution += msg.value;

    uint256 tokensIssued = (msg.value / TokenPrice);
    totalSupply -= tokensIssued;
    balances[msg.sender] -= tokensIssued;

    Transfer(address(this), msg.sender, tokensIssued);
}
}"
63961-0.sol,question,"contract TNStoken is Ownable {

using SafeMath for uint256;

mapping(address => uint256) balances;
mapping (address => mapping (address => uint256)) internal allowed;
uint256 totalSupply_;

string public name;
string public symbol;
uint8 public decimals;

constructor() public {
    name = ""The Neverending Story Token"";
    symbol = ""TNS"";
    decimals = 18;
    totalSupply_ = 100 * 10**6 * 10**18;
    balances[msg.sender] = totalSupply_;
}
function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender] - locked[msg.sender]);

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
}

function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
}

function totalSupply() public view returns (uint256) {
    return totalSupply_;
}
}"
53325-0.sol,question,"contract SimpleTimeStamp {
    uint lastHash;

    function set(uint x) public {
        lastHash = x;
    }
}"
16611-1.sol,question,"contract MyContract {
  
  function MyContract(bytes32[] myArray) { 
    
  }
}"
64633-0.sol,question,"contract Dao {
    struct User {
        address addr;
        string name;
        uint balence;
        uint8 flag;
    }

    
    mapping(address=>User) users; 

    uint public userCount;

    constructor() public {
        
        
        
    }

    function addUser (address _addr, string _name, uint _balence, uint _flag) private {
        users[_addr] = User(_addr,_name,0,1);
        userCount++;
    }

    function addToBalence(string name) public payable{
        if(users[msg.sender].flag != 1) addUser(msg.sender,name,0,1);
        users[msg.sender].balence = users[msg.sender].balence + msg.value;
    }

    function showBalence(address) public returns (uint) {
        return users[msg.sender].balence;
    }

    function withdraw(uint amount) public payable{

        if(users[msg.sender].flag != 1) revert(""user does not exist"");
        else if (users[msg.sender].balence >= amount){
            msg.sender.call.value(amount)();
            users[msg.sender].balence -= amount;
        }
        else return false;
    }
    }"
64633-0.sol,question,"contract Hacker {
    
    Dao dao;
    address userAddress;
    string userName;

    constructor(string name, address daoAddr) public {
        dao = Dao(daoAddr);
        userAddress = msg.sender;
        userName = name;
    }

    function payout(uint amount) public payable{
        dao.withdraw(amount);
    }
}"
78878-0.sol,question,"contract LoanToken {
    
    uint private _totalSupply = 1000;
    string public name = ""LoanToken"";
    string public symbol = ""LT"";
    uint8 public decimals = 0;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    mapping (address => uint) public _balances;
    mapping (address => mapping (address => uint256)) private _allowances;

    constructor() public {
        _balances[msg.sender] = totalSupply();
        emit Transfer(address(0), msg.sender, totalSupply());
    }

    
    function totalSupply() public view returns (uint) {
        return _totalSupply;
    }

    
    function balanceOf(address _owner) public view returns (uint256) {
        return _balances[_owner];
    }

    
    function transfer(address recipient, uint256 amount) public returns (bool)
    {
        if (_balances[msg.sender] >= amount && amount > 0) {

            _balances[recipient] += amount;
            _balances[msg.sender] -= amount;

            emit Transfer(msg.sender, recipient, amount);

            return true;
        } else { return false; }
    }

    
    function allowance(address owner, address spender) public view returns (uint256) 
    {
        return _allowances[owner][spender];
    }

    
    function approve(address spender, uint256 amount) public returns (bool)
    {
        _allowances[msg.sender][spender] = amount;

        emit Approval(msg.sender, spender, amount);

        return true;
    }

    
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool)
     {
        if (_balances[sender] >= amount && _allowances[sender][msg.sender] >= amount && amount > 0) {

            _balances[recipient] += amount;
            _balances[sender] -= amount;
            _allowances[sender][msg.sender] -= amount;

            emit Transfer(sender, recipient, amount);

            return true;
        } else { return false; }
    }
}"
46550-0.sol,question,"contract TestOraclizeCall is usingOraclize {
     uint public price;
     event Log(string text);
     event LogOracleConnection(OraclizeAddrResolverI obj);
     OraclizeAddrResolverI OAR;

 
 function TestOraclizeCall() {
     OAR = OraclizeAddrResolverI(0x6f485c8bf6fc43ea212e93bbf8ce046c7f1cb475);   
     emit LogOracleConnection(OAR);
    
 }

 function checkOARInstance() public view returns(address){
     OAR.getAddress();
 }
 function __callback(bytes32 _myid, string _result) public {
      if (msg.sender != oraclize_cbAddress()) revert();
      emit Log(_result);
      
   }
 function update()public{
    oraclize_query(""URL"",""json(http:
 }
 }"
13358-0.sol,question,"contract PopArray {
    string[] public string_arr;

    function PopArray() {
        
        string_arr = ['zero', 'one', 'two', 'three', 'four'];
    }

    
    function pop_string () returns (string member) {
        member = string_arr[string_arr.length-1]; 
        string_arr.length = string_arr.length-1;  
        return member;
    } 

    
    function broken_pop_string () returns (string) {
        string member = string_arr[string_arr.length-1];
        string_arr.length = string_arr.length-1;
        return member;
    }
}"
37183-1.sol,question,"contract CounterContract {
   using CounterLib for CounterLib.Counter;

   CounterLib.Counter counter;

   function increment() returns (uint) {
     return counter.incremented();
   }
}"
30043-1.sol,question,"contract Token {

  event Transfer(address indexed from, address indexed to, uint value);
  event Approval( address indexed owner, address indexed spender, uint value);

  mapping( address => uint ) _balances;
  mapping( address => mapping( address => uint ) ) _approvals;
  uint public _supply;
  function Token( uint initial_balance ) {
    _balances[msg.sender] = initial_balance;
    _supply = initial_balance;
  }
  function totalSupply() constant returns (uint supply) {
    return _supply;
  }
  function balanceOf( address who ) constant returns (uint value) {
    return _balances[who];
  }
  function transfer( address to, uint value) returns (bool ok) {
    if( _balances[msg.sender] < value ) {
      throw;
    }
    if( !safeToAdd(_balances[to], value) ) {
      throw;
    }
    _balances[msg.sender] -= value;
    _balances[to] += value;
    Transfer( msg.sender, to, value );
    return true;
  }
  function transferFrom( address from, address to, uint value) returns (bool ok) {
    
    if( _balances[from] < value ) {
      throw;
    }
    
    if( _approvals[from][msg.sender] < value ) {
      throw;
    }
    if( !safeToAdd(_balances[to], value) ) {
      throw;
    }
    
    _approvals[from][msg.sender] -= value;
    _balances[from] -= value;
    _balances[to] += value;
    Transfer( from, to, value );
    return true;
  }
  function approve(address spender, uint value) returns (bool ok) {
    
    _approvals[msg.sender][spender] = value;
    Approval( msg.sender, spender, value );
    return true;
  }
  function allowance(address owner, address spender) constant returns (uint _allowance) {
    return _approvals[owner][spender];
  }
  function safeToAdd(uint a, uint b) internal returns (bool) {
    return (a + b >= a);
  }
}"
30940-0.sol,question,"contract World {
    mapping (address => bool) players;
    mapping (address => ResourceBank) resourceBanks;
    function giveZero() public {
        if (!players[msg.sender]) {
            resourceBanks[msg.sender] = new ResourceBank();
            players[msg.sender] = true;
        }
        ResourceBank bank = resourceBanks[msg.sender];
        bank.add(0);
    }
}"
30940-0.sol,question,"contract ResourceBank {
    uint[] resources;
    function add(uint resource) public {
        resources.push(resource);
    }
}"
62860-0.sol,question,"contract Test {
   string public t;
   function set(string _t) public {
       t = _t;
   }
}"
7088-0.sol,question,"contract MetaCoin {
  mapping (address => uint) balances;

  function MetaCoin() {
    balances[tx.origin] = 10000;
  }

  function sendCoin(address receiver, uint amount) returns(bool sufficient) {
    if (balances[msg.sender] < amount) return false;

    balances[msg.sender] -= amount;
    balances[receiver] += amount;
    return true;
  }

  function getBalanceInEth(address addr) constant returns(uint) {
    return getBalance(addr) * 2;
  }

  function getBalance(address addr) constant returns(uint) {
    return balances[addr];
  }
}"
67484-0.sol,question,"contract M {

    struct Confezione {
        string mar;
        uint256 co;
    }

    Confezione[] public dati;

    function inserimento(string memory m, uint256 c) public {
        dati.push(Confezione(m,c));
    }

    function ritornavalore() public view returns(Confezione[] memory) {
    return dati;

    }
}"
82036-0.sol,question,"contract TokenERC20 {
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function TokenERC20(uint256 initialSupply , string tokenName , string tokenSymbol) public {

        totalSupply assign = 250000000  ** uint256(18); 
        balanceOf[msg.sender] assign = totalSupply;                
        name assign = ""PONTEM"";                                   
        symbol assign = ""PXM"";                               
    }

    
        
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        require(!frozenAccount[_from]);                     
        require(!frozenAccount[_to]);                       
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
       emit Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
        require(!frozenAccount[msg.sender]);

    }    

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }"
20831-0.sol,question,"contract ERC20 {
    
    

    function balanceOf(address _owner) constant returns (uint balance);
    function transfer(address _to, uint _value) returns (bool success);
    function transferFrom(address _from, address _to, uint _value) returns (bool success);
    function approve(address _spender, uint _value) returns (bool success);
    function allowance(address _owner, address _spender) constant returns (uint remaining);
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
    uint public totalSupply = 0;
    mapping(address => uint256) balances;
}"
20831-0.sol,question,"contract MyFriendToken is ERC20{
    string public token_name;
    string public symbol;
    uint8 public decimals;

    address public owner;

    bool purchase_OK = true;

    address friend1 = address(0x123...);
    address friend2 = address(0x456...);
    

    function purchase_ko() {
        if(msg.sender != owner){ throw;}
        purchase_OK = false;
    }

    function purchase_ok()  {
        if(msg.sender != owner){ throw;}
        purchase_OK = true;
    }

    function MyFriendToken(){

        owner = msg.sender;
        token_name = ""MyFriendToken"";
        symbol = ""MFT"";
        decimals = 18;
    }

    function kill() {
        if (msg.sender == owner) selfdestruct(owner);
    }

    function() payable {
        if(!purchase_OK){throw;}
        if(msg.sender != friend1 && msg.sender != friend2) {throw;}

        owner.transfer(msg.value);
        uint256 myFriendToken = (msg.value * 1000);
        totalSupply += myFriendToken;
        balances[msg.sender] += myFriendToken;
    }
}"
62430-0.sol,question,"contract ExampleOne {

  struct Problem {
    bytes32 a; 
    bytes32 b;
    bytes32[] c;
    uint d;
    }
  mapping (bytes32 => Problem) public problems;
}"
62430-0.sol,question,"contract IExampleOne {
  function problems(bytes32) public returns (bytes32, bytes32, bytes32[], uint);
  }"
62430-0.sol,question,"contract Example Two {

  IExampleOne exampleOne;

  constructor(address _exampleOne) {
    exampleOne = IExampleOne(_exampleOne);
  }

  function func(bytes32 name) {
    (bytes32 a, bytes32 b, bytes32[] c, uint d) = problems(name); 
    ...
  }
}"
12623-0.sol,question,"contract Mapping {

  mapping(address => uint)  balancesA;
  mapping(address => uint)  balancesB;

  function Mapping() {
    
    balancesA[msg.sender] = 100;
    balancesB[msg.sender] = 200;
  }

  function getBalance(address addr) returns(uint, uint) {

    
    mapping(address => uint)  balancers;
    balancers[msg.sender] = 500;

    return (balancesA[addr], balancesB[addr]);

  }
}"
49568-2.sol,question,"contract ID{

    uint id;
    Whitelisted whitelist;
    mapping (string => MessageData) public messages;

    event MessageSaved(string messageHash);

    constructor(uint _id, address _whitelist) public {
        owner = msg.sender;
        id = _id;
        whitelist = Whitelisted(_whitelist);
    }

    struct MessageData {
        string messageSender;
        uint64 timestamp;
    }
}"
49568-2.sol,question,"contract Whitelisted is Ownable {

    constructor(_owner) public {
        owner = _owner;
    }

    mapping(address => bool) internal whitelistedAddresses;

    function isWhitelisted(address addr) internal view returns (bool) {
        return whitelistedAddresses[addr];
    }

    function addToWhitelist(address addr) public onlyOwner {
        require(!isWhitelisted(addr));
        whitelistedAddresses[addr] = true;
    }

    function removeFromWhitelist(address addr) public onlyOwner {
        require(isWhitelisted(addr));
        whitelistedAddresses[addr] = false;
    }

    modifier onlyWhitelisted {
        require(isWhitelisted(msg.sender));
        _;
    }
}"
80378-1.sol,question,"contract Faucet {

    address payable owner_addr; 

    
    constructor() public 
    {
      owner_addr=msg.sender;
    }

    
    modifier owner_allowed
    {
      require (msg.sender==owner_addr, ""Only contract owner is allowed to call this function"");    
      _;
    }

    function destroy() public owner_allowed
    {
      selfdestruct(owner_addr);
    }

    
    function withdraw(uint withdraw_amount) public
     {
        
        require(withdraw_amount <= 100000000000000000); 
        
        msg.sender.transfer(withdraw_amount);
    }

    
    function () external payable {} 

}"
17318-1.sol,question,"contract musicCompany is owned {

    address[] public listofmusic;

    function addMusic(string setThemeMusic, string setIdMusic, int setmoney) onlyOwner {
        address newMusic = new Music(setThemeMusic, setIdMusic, setmoney);
        listofmusic.push(newMusic);
    }
}"
42256-0.sol,question,"contract MyInfo {

  struct Info {
    bytes32 id;
    bytes32 name;
  }
  bytes32[] infoIDs;
  mapping(bytes32 => Info) infos;
  function addInfo(bytes32 _name) public
     returns(bool success) {

     bytes32 ID = keccak256(_name);
     infoIDs.push(ID);
     infos[ID].id = ID;
     infos[ID].name =_name;
     return true;
  }
  function getInfoIDs() public view returns(bytes32[] ids) {
    return infoIDs;
  }
}"
64148-0.sol,question,"contract KYCPurchase {
  uint public price = 2 ether;

  struct Company {
      string registeredNumber;
      string name;
  }
  mapping (address => Company) companies;

  function buy(string registeredNumber, string name) public payable {
    require(msg.value >= price);

    
    companies[msg.sender] = Company(registeredNumber, name);
  }
}"
55900-0.sol,question,"contract SalesContract {

    address **public** owner;
    bool public isSold = false;
    string public salesDescription = ""Honda Civic"";
    uint public price = 2 ether;

    function SaleContract() {
        owner = msg.sender;
    }

    function Buy() **public** payable {
        if(msg.value >= price) {
            **owner.transfer(address(this).balance)**;
            owner = msg.sender;
            isSold = true;
        } else {
            revert();
        }
    }

}"
55924-0.sol,question,"contract SupportPay4 {

    function() public payable {

    }

    function deposit() public payable {

    }

    function withdraw() public {
        msg.sender.transfer(getBalance());
    }

    function withdraw2(address addr) public {
        addr.transfer(getBalance());
    }

    function getBalance() public constant returns(uint256) {
        return address(this).balance;
    }
}"
30554-1.sol,question,"contract CalculatorV2 {

  uint result;

  event NumberAdded(uint n);
  event NumberSubtracted(uint n);
  event NumberMultiplied(uint n);
  event NumberDivided(uint n);

  function CalculatorV2(uint num) {
    
    result=num;
 }

  
  function getResult() constant returns (uint){
   return result;
 }

  
  function addToNumber(uint num) returns (uint) {
   result += num;
    NumberAdded(num);
   return result;
 }

 
 function substractNumber(uint num) returns (uint) {
   result -= num;
   NumberSubtracted(num);
   return result;
 }

 
  function multiplyWithNumber(uint num) returns (uint) {
    result *= num;
    NumberMultiplied(num);
    return result;
  }

  
  function divideByNumber(uint num) returns (uint) {
    result /= num;
    NumberDivided(num);
    return result;
  }

}"
67753-0.sol,question,"contract Example {
    function getStringArray() public returns (string[]) {
        string[] memory resultStr = new string;
        resultStr[0] = ""355555555"";
        resultStr[1] = ""2"";
        resultStr[2] = ""8888"";
        return resultStr;
    }
}"
52951-5.sol,question,"contract Contract1 is Ownable {
    uint public threshold;
    ...
    function Function1(uint start) public returns (uint, uint, uint, bool ) {
       require(start >= 1 && start <= currentTicket);
        uint i;
        for (i = start; i <= currentTicket; i++) {
            if (tickets[i].holder == msg.sender && tickets[i].winAmt > 0) {
                return (i, tickets[i].ref, tickets[i].winAmt, tickets[i].paid);
            }
        }
        return (currentTicket + 100, 0, 0, false);
    }
 }"
34852-0.sol,question,"contract Firma {

    address owner;
    struct Firmas{

        bytes32 name;
        uint pNum;


    }

    function Firma() {
        owner=msg.sender;


    }


    mapping(address =>Firmas) allFirmas;
    address[] aF;

    function setFirma(bytes32 _name, uint _pNum) public {

        var f= allFirmas[owner];
        f.name=_name;
        f.pNum=_pNum;
        aF.push(owner);

    }

    function getAllFirma() view public returns(address[]){
        return aF;
    }


}"
34852-0.sol,question,"contract Users{

    Firma firma;

    function Users(address _address) {

        firma= Firma(_address);


    }
    function getF() view public returns(address[]){

        return firma.getAllFirma(); 
                                    

    }

}"
61489-0.sol,question,"contract HelloWorld {
  string message;
  event evntGetMessage(string message);

  constructor(string mymessage) public {
    message =  mymessage;
  emit evntGetMessage(message);
  }

  function getMessage() external view returns(string) {
    return message;
  }

  function welcomeMssg(string name) external returns (string){
     message =  string(abi.encodePacked(message, "" "", name));
     emit evntGetMessage(message);
     return string(abi.encodePacked(message, "" "", name));
  } 
}"
79503-1.sol,question,"contract Mallory {
    address payable owner;
    EDao public dao = EDao(##EdaoSmartContractAddress##);

    constructor() public{owner = msg.sender; }

    function getJackpot()public { owner.transfer(address(this).balance); }

    function() external payable { dao.withdraw(address(this), 1000000000000000000); }

}"
56153-0.sol,question,"contract Test1 {
    function someFunc() public {}
}"
56153-0.sol,question,"contract Test2 {
    mapping(uint => Test1) map;
}"
47482-0.sol,question,"contract Inbox {
    string public message;

    constructor(string initialMessage) public {
        message = initialMessage;
    }

    function setMessage(string newMessage) public {
        message = newMessage;
    }
}"
33867-0.sol,question,"contract DreamToken is MintableToken {

  string public constant name = ""Dream Token"";
  string public constant symbol = ""DMT"";
  uint8 public constant decimals = 18;
}"
33867-0.sol,question,"contract DreamTokenCrowdsale is Crowdsale {

   function DreamTokenCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public
     Crowdsale(_startTime, _endTime, _rate, _wallet)
   {

   }

   function createTokenContract() internal returns (MintableToken) {
     return new DreamToken();
   }

 }"
62442-1.sol,question,"contract ERC20Interface {
    function totalSupply() public constant returns (uint);
    function balanceOf(address tokenOwner) public constant returns (uint balance);
    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);
    function transfer(address to, uint tokens) public payable returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public payable returns (bool success);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}"
39388-1.sol,question,"contract TokenSale {
    Token token;

    function TokenSale(address tokenAddress) {
        token = Token(tokenAddress);
    }
}"
39388-1.sol,question,"contract MyTokenSale is TokenSale {
    function MyTokenSale(address tokenAddress) TokenSale(tokenAddress) {
        
    }
}"
42111-0.sol,question,"contract Crowdsale {
    using SafeMath for uint256;
    using BytesLib for bytes;

    
    address public wallet;

    ERC20 public token;

    
    uint256 public weiRaised;

    function Crowdsale(address _wallet, ERC20 _token) public {
        require(_wallet != address(0));

        wallet = _wallet;
        token = _token;
    }

    function () external payable {
        buyTokens(msg.sender);
    }

    function buyTokens(address _beneficiary) public payable {

        bytes memory msgData = msg.data;
        bytes memory dataValue = msgData.slice(36, 32);
        uint256 weiAmount = dataValue.toUint(0);

        weiRaised = weiRaised.add(weiAmount);
      }   
}"
19675-0.sol,question,"contract MetaCoin is Ownable{
    mapping (address => uint) balances;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    function MetaCoin() {
        balances[tx.origin] = 10000;
    }

    function sendCoin(address receiver, uint amount) returns(bool sufficient) {
        if (balances[msg.sender] < amount) return false;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Transfer(msg.sender, receiver, amount);
        return true;
    }

    function getBalanceInEth(address addr) returns(uint){
        return ConvertLib.convert(getBalance(addr),2);
    }

    function getBalance(address addr) returns(uint) {
        return balances[addr];
    }
}"
19675-0.sol,question,"contract Relay is MetaCoin {
address public owner;
uint public count;
address[] oracles;
uint public fee;


  function Relay() {
    owner = msg.sender;
    count = 0;
    fee = 10;
  }


  function fundRelay() payable returns (bool) {
    if (owner != msg.sender) throw;

  }

function approveExternalTransaction() {
  count++;
  if (count == 3) {
    releaseFunds();
  }
}
  function releaseFunds () {

      sendCoin(owner, fee);

  }
}"
47192-0.sol,question,"contract AddressRatings {

struct Rating {
    mapping ( address => uint8 ) ratings;
    uint256 amtOfRatings;
    uint256 sumOfRatings;
    uint8 average;
}

mapping ( address => Rating ) public ratings;

function rateAddress (address _addr, uint8 _rating) external {
    require(_rating > 0 && _rating < 6); 
    require(ratings[_addr].ratings[msg.sender] == 0); 
    ratings[_addr].ratings[msg.sender] = _rating;
    ratings[_addr].amtOfRatings++;
    ratings[_addr].sumOfRatings += _rating;
    ratings[_addr].average = uint8(ratings[_addr].sumOfRatings/ratings[_addr].amtOfRatings);
}

}"
38346-2.sol,question,"contract DormantAsset  is Heritable {
  event Sent(address indexed payee, uint256 amount, uint256 balance);
  event Received(address indexed payer, uint256 amount, uint256 balance);
  function DormantAsset(uint256 _heartbeatTimeout) Heritable(_heartbeatTimeout) public {}
  function () public payable {
    Received(msg.sender, msg.value, this.balance);
  }
  function sendTo(address payee, uint256 amount) public onlyOwner {
    require(payee != 0 && payee != address(this));
    require(amount > 0);
    payee.transfer(amount);
    Sent(payee, amount, this.balance);
  }"
39346-0.sol,question,"contract SimpleStorage {
    uint public data;

    function set(uint x) public {
        data = x;
    }
}"
69106-1.sol,question,"contract ERC20Basic {
  uint public totalSupply;
  address public owner; 
  address public animator; 
  function balanceOf(address who) constant public returns (uint);
  function transfer(address to, uint value) public;
  event Transfer(address indexed from, address indexed to, uint value);
  function commitDividend(address who) internal; 
}"
69106-1.sol,question,"contract ERC20 is ERC20Basic {
  function allowance(address owner, address spender) constant public returns (uint);
  function transferFrom(address from, address to, uint value) public;
  function approve(address spender, uint value) public;
  event Approval(address indexed owner, address indexed spender, uint value);
}"
69106-1.sol,question,"contract BasicToken is ERC20Basic {
  using SafeMath for uint;
  mapping(address => uint) balances;

  modifier onlyPayloadSize(uint size) {
     assert(msg.data.length >= size + 4);
     _;
  }

  function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {
    commitDividend(msg.sender);
    balances[msg.sender] = balances[msg.sender].sub(_value);
    if(_to == address(this)) {
        commitDividend(owner);
        balances[owner] = balances[owner].add(_value);
        Transfer(msg.sender, owner, _value);
    }
    else {
        commitDividend(_to);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
    }
  }

  function balanceOf(address _owner) constant public returns (uint balance) {
    return balances[_owner];
  }
}"
69106-1.sol,question,"contract SmartBillions is StandardToken {

    
    string public constant name = ""SmartBillions Token"";
    string public constant symbol = ""Smart""; 
    uint public constant decimals = 0;

    
    struct Wallet {
        uint208 balance; 
        uint16 lastDividendPeriod; 
        uint32 nextWithdrawTime; 
    }
    mapping (address => Wallet) wallets;
    struct Bet {
        uint192 value; 
        uint32 betHash; 
        uint32 blockNum; 
    }
    mapping (address => Bet) bets;

    uint public walletBalance = 0; 

    
    uint public investStart = 1; 
    uint public investBalance = 0; 
    uint public investBalanceGot = 0; 
    uint public investBalanceMax = 200000 ether; 
    uint public dividendPeriod = 1;
    uint[] public dividends; 

    
    uint public maxWin = 0; 
    uint public hashFirst = 0; 
    uint public hashLast = 0; 
    uint public hashNext = 0; 
    uint public hashBetSum = 0; 
    uint public hashBetMax = 5 ether; 
    uint[] public hashes; 

    
    uint public constant hashesSize = 16384 ; 
    uint public coldStoreLast = 0 ; 

    
    event LogBet(address indexed player, uint bethash, uint blocknumber, uint betsize);
    event LogLoss(address indexed player, uint bethash, uint hash);
    event LogWin(address indexed player, uint bethash, uint hash, uint prize);
    event LogInvestment(address indexed investor, address indexed partner, uint amount);
    event LogRecordWin(address indexed player, uint amount);
    event LogLate(address indexed player,uint playerBlockNumber,uint currentBlockNumber);
    event LogDividend(address indexed investor, uint amount, uint period);

    modifier onlyOwner() {
        assert(msg.sender == owner);
        _;
    }

    modifier onlyAnimator() {
        assert(msg.sender == animator);
        _;
    }

    
    function SmartBillions() public {
        owner = msg.sender;
        animator = msg.sender;
        wallets[owner].lastDividendPeriod = uint16(dividendPeriod);
        dividends.push(0); 
        dividends.push(0); 
    }


    function hashesLength() constant external returns (uint) {
        return uint(hashes.length);
    }


    function walletBalanceOf(address _owner) constant external returns (uint) {
        return uint(wallets[_owner].balance);
    }


    function walletPeriodOf(address _owner) constant external returns (uint) {
        return uint(wallets[_owner].lastDividendPeriod);
    }


    function walletTimeOf(address _owner) constant external returns (uint) {
        return uint(wallets[_owner].nextWithdrawTime);
    }

    function betValueOf(address _owner) constant external returns (uint) {
        return uint(bets[_owner].value);
    }


    function betHashOf(address _owner) constant external returns (uint) {
        return uint(bets[_owner].betHash);
    }


    function betBlockNumberOf(address _owner) constant external returns (uint) {
        return uint(bets[_owner].blockNum);
    }

    function dividendsBlocks() constant external returns (uint) {
        if(investStart > 0) {
            return(0);
        }
        uint period = (block.number - hashFirst) / (10 * hashesSize);
        if(period > dividendPeriod) {
            return(0);
        }
        return((10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize)));
    }


    function changeOwner(address _who) external onlyOwner {
        assert(_who != address(0));
        commitDividend(msg.sender);
        commitDividend(_who);
        owner = _who;
    }


    function changeAnimator(address _who) external onlyAnimator {
        assert(_who != address(0));
        commitDividend(msg.sender);
        commitDividend(_who);
        animator = _who;
    }


    function setInvestStart(uint _when) external onlyOwner {
        require(investStart == 1 && hashFirst > 0 && block.number < _when);
        investStart = _when;
    }

    function setBetMax(uint _maxsum) external onlyOwner {
        hashBetMax = _maxsum;
    }


    function resetBet() external onlyOwner {
        hashNext = block.number + 3;
        hashBetSum = 0;
    }


    function coldStore(uint _amount) external onlyOwner {
        houseKeeping();
        require(_amount > 0 && this.balance >= (investBalance * 9 / 10) + walletBalance + _amount);
        if(investBalance >= investBalanceGot / 2){ 
            require((_amount <= this.balance / 400) && coldStoreLast + 60 * 60 * 24 * 7 <= block.timestamp);
        }
        msg.sender.transfer(_amount);
        coldStoreLast = block.timestamp;
    }

    
    function hotStore() payable external {
        walletBalance += msg.value;
        wallets[msg.sender].balance += uint208(msg.value);
        houseKeeping();
    }



    
    function houseKeeping() public {
        if(investStart > 1 && block.number >= investStart + (hashesSize * 5)){ 
            investStart = 0; 
        }
        else {
            if(hashFirst > 0){
                uint period = (block.number - hashFirst) / (10 * hashesSize );
                if(period > dividends.length - 2) {
                    dividends.push(0);
                }
                if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {
                    dividendPeriod++;
                }
            }
        }
    }



    
    function payWallet() public {
        if(wallets[msg.sender].balance > 0 && wallets[msg.sender].nextWithdrawTime <= block.timestamp){
            uint balance = wallets[msg.sender].balance;
            wallets[msg.sender].balance = 0;
            walletBalance -= balance;
            pay(balance);
        }
    }

    function pay(uint _amount) private {
        uint maxpay = this.balance / 2;
        if(maxpay >= _amount) {
            msg.sender.transfer(_amount);
            if(_amount > 1 finney) {
                houseKeeping();
            }
        }
        else {
            uint keepbalance = _amount - maxpay;
            walletBalance += keepbalance;
            wallets[msg.sender].balance += uint208(keepbalance);
            wallets[msg.sender].nextWithdrawTime = uint32(block.timestamp + 60 * 60 * 24 * 30); 
            msg.sender.transfer(maxpay);
        }
    }



    function investDirect() payable external {
        invest(owner);
    }


    function invest(address _partner) payable public {
        
        require(investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax);
        uint investing = msg.value;
        if(investing > investBalanceMax - investBalance) {
            investing = investBalanceMax - investBalance;
            investBalance = investBalanceMax;
            investBalanceGot = investBalanceMax;
            investStart = 0; 
            msg.sender.transfer(msg.value.sub(investing)); 
        }
        else{
            investBalance += investing;
            investBalanceGot += investing;
        }
        if(_partner == address(0) || _partner == owner){
            walletBalance += investing / 10;
            wallets[owner].balance += uint208(investing / 10);} 
        else{
            walletBalance += (investing * 5 / 100) * 2;
            wallets[owner].balance += uint208(investing * 5 / 100); 
            wallets[_partner].balance += uint208(investing * 5 / 100);} 
        wallets[msg.sender].lastDividendPeriod = uint16(dividendPeriod); 
        uint senderBalance = investing / 10**15;
        uint ownerBalance = investing * 16 / 10**17  ;
        uint animatorBalance = investing * 10 / 10**17  ;
        balances[msg.sender] += senderBalance;
        balances[owner] += ownerBalance ; 
        balances[animator] += animatorBalance ; 
        totalSupply += senderBalance + ownerBalance + animatorBalance;
        Transfer(address(0),msg.sender,senderBalance); 
        Transfer(address(0),owner,ownerBalance); 
        Transfer(address(0),animator,animatorBalance); 
        LogInvestment(msg.sender,_partner,investing);
    }


    function disinvest() external {
        require(investStart == 0);
        commitDividend(msg.sender);
        uint initialInvestment = balances[msg.sender] * 10**15;
        Transfer(msg.sender,address(0),balances[msg.sender]); 
        delete balances[msg.sender]; 
        investBalance -= initialInvestment;
        wallets[msg.sender].balance += uint208(initialInvestment * 9 / 10);
        payWallet();
    }


    function payDividends() external {
        require(investStart == 0);
        commitDividend(msg.sender);
        payWallet();
    }

    function commitDividend(address _who) internal {
        uint last = wallets[_who].lastDividendPeriod;
        if((balances[_who]==0) || (last==0)){
            wallets[_who].lastDividendPeriod=uint16(dividendPeriod);
            return;
        }
        if(last==dividendPeriod) {
            return;
        }
        uint share = balances[_who] * 0xffffffff / totalSupply;
        uint balance = 0;
        for(;last<dividendPeriod;last++) {
            balance += share * dividends[last];
        }
        balance = (balance / 0xffffffff);
        walletBalance += balance;
        wallets[_who].balance += uint208(balance);
        wallets[_who].lastDividendPeriod = uint16(last);
        LogDividend(_who,balance,last);
    }



    function betPrize(Bet _player, uint24 _hash) constant private returns (uint) { 
        uint24 bethash = uint24(_player.betHash);
        uint24 hit = bethash ^ _hash;
        uint24 matches =
            ((hit & 0xF) == 0 ? 1 : 0 ) +
            ((hit & 0xF0) == 0 ? 1 : 0 ) +
            ((hit & 0xF00) == 0 ? 1 : 0 ) +
            ((hit & 0xF000) == 0 ? 1 : 0 ) +
            ((hit & 0xF0000) == 0 ? 1 : 0 ) +
            ((hit & 0xF00000) == 0 ? 1 : 0 );
        if(matches == 6){
            return(uint(_player.value) * 7000000);
        }
        if(matches == 5){
            return(uint(_player.value) * 20000);
        }
        if(matches == 4){
            return(uint(_player.value) * 500);
        }
        if(matches == 3){
            return(uint(_player.value) * 25);
        }
        if(matches == 2){
            return(uint(_player.value) * 3);
        }
        return(0);
    }

    
    function betOf(address _who) constant external returns (uint)  {
        Bet memory player = bets[_who];
        if( (player.value==0) ||
            (player.blockNum<=1) ||
            (block.number<player.blockNum) ||
            (block.number>=player.blockNum + (10 * hashesSize))){
            return(0);
        }
        if(block.number<player.blockNum+256){
            return(betPrize(player,uint24(block.blockhash(player.blockNum))));
        }
        if(hashFirst>0){
            uint32 hash = getHash(player.blockNum);
            if(hash == 0x1000000) { 
                return(uint(player.value));
            }
            else{
                return(betPrize(player,uint24(hash)));
            }
    }
        return(0);
    }

    
    function won() public {
        Bet memory player = bets[msg.sender];
        if(player.blockNum==0){ 
            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});
            return;
        }
        if((player.value==0) || (player.blockNum==1)){
            payWallet();
            return;
        }
        require(block.number>player.blockNum); 
        if(player.blockNum + (10 * hashesSize) <= block.number){ 
            LogLate(msg.sender,player.blockNum,block.number);
            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});
            return;
        }
        uint prize = 0;
        uint32 hash = 0;
        if(block.number<player.blockNum+256){
            hash = uint24(block.blockhash(player.blockNum));
            prize = betPrize(player,uint24(hash));
        }
        else {
            if(hashFirst>0){ 
                hash = getHash(player.blockNum);
                if(hash == 0x1000000) { 
                    
                    LogLate(msg.sender,player.blockNum,block.number);
                    bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});
                    return();
                }
                else{
                    prize = betPrize(player,uint24(hash));
                }
        }
            else{
                LogLate(msg.sender,player.blockNum,block.number);
                bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});
                return();
            }
        }
        bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});
        if(prize>0) {
            LogWin(msg.sender,uint(player.betHash),uint(hash),prize);
            if(prize > maxWin){
                maxWin = prize;
                LogRecordWin(msg.sender,prize);
            }
            pay(prize);
        }
        else{
            LogLoss(msg.sender,uint(player.betHash),uint(hash));
        }
    }


    function () payable external {
        if(msg.value > 0){
            if(investStart>1){ 
                invest(owner);
            }
            else{ 
                play();
            }
            return;
        }
        
        if(investStart == 0 && balances[msg.sender]>0){
            commitDividend(msg.sender);}
        won(); 
    }

    
    function play() payable public returns (uint) {
        return playSystem(uint(keccak256(msg.sender,block.number)), address(0));
    }

    
    function playRandom(address _partner) payable public returns (uint) {
        return playSystem(uint(keccak256(msg.sender,block.number)), _partner);
    }

    
    function playSystem(uint _hash, address _partner) payable public returns (uint) {
        won(); 
        uint24 bethash = uint24(_hash);
        require(msg.value <= 1 ether && msg.value < hashBetMax);
        if(msg.value > 0){
            if(investStart==0) { 
                dividends[dividendPeriod] += msg.value / 20; 
            }
            if(_partner != address(0)) {
                uint fee = msg.value / 100;
                walletBalance += fee;
                wallets[_partner].balance += uint208(fee); 
            }
            if(hashNext < block.number + 3) {
                hashNext = block.number + 3;
                hashBetSum = msg.value;
            }
            else{
                if(hashBetSum > hashBetMax) {
                    hashNext++;
                    hashBetSum = msg.value;
                }
                else{
                    hashBetSum += msg.value;
                }
            }
            bets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)});
            LogBet(msg.sender,uint(bethash),hashNext,msg.value);
        }
        putHashes(25); 
        return(hashNext);
    }



    
    function addHashes(uint _sadd) public returns (uint) {
        require(hashFirst == 0 && _sadd > 0 && _sadd <= hashesSize);
        uint n = hashes.length;
        if(n + _sadd > hashesSize){
            hashes.length = hashesSize;
        }
        else{
            hashes.length += _sadd;
        }
        for(;n<hashes.length;n++){ 
            hashes[n] = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;
        }
        if(hashes.length>=hashesSize) { 
            hashFirst = block.number - ( block.number % 10);
            hashLast = hashFirst;
        }
        return(hashes.length);
    }

    
    function addHashes128() external returns (uint) {
        return(addHashes(128));
    }

    function calcHashes(uint32 _lastb, uint32 _delta) constant private returns (uint) {
        
        return( ( uint(block.blockhash(_lastb  )) & 0xFFFFFF )
            | ( ( uint(block.blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )
            | ( ( uint(block.blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )
            | ( ( uint(block.blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )
            | ( ( uint(block.blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )
            | ( ( uint(block.blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )
            | ( ( uint(block.blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )
            | ( ( uint(block.blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )
            | ( ( uint(block.blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )
            | ( ( uint(block.blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )
            | ( ( uint(_delta) / hashesSize) << 240)); 
    }

    function getHash(uint _block) constant private returns (uint32) {
        uint delta = (_block - hashFirst) / 10;
        uint hash = hashes[delta % hashesSize];
        if(delta / hashesSize != hash >> 240) {
            return(0x1000000); 
        }
        uint slotp = (_block - hashFirst) % 10; 
        return(uint32((hash >> (24 * slotp)) & 0xFFFFFF));
    }

    
    function putHash() public returns (bool) {
        uint lastb = hashLast;
        if(lastb == 0 || block.number <= lastb + 10) {
            return(false);
        }
        if(lastb < block.number - 245) {
            uint num = block.number - 245;
            lastb = num - (num % 10);
        }
        uint delta = (lastb - hashFirst) / 10;
        hashes[delta % hashesSize] = calcHashes(uint32(lastb),uint32(delta));
        hashLast = lastb + 10;
        return(true);
    }

    
    function putHashes(uint _num) public {
        uint n=0;
        for(;n<_num;n++){
            if(!putHash()){
                return;
            }
        }
    }

}"
41517-0.sol,question,"contract CA15 {

struct Student {
        uint16 age;
    uint16 income;
    uint16 score;
    uint16 attendance;
}

Student[] public students;
function setStudent (uint16 _age, uint16 _income, uint16 _score, uint16 _attendance) public {
   Student memory tempStudent = Student({age: _age, income: _income, score: _score, attendance: _attendance});
        students.push(tempStudent);
}

}"
12901-0.sol,question,"contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}"
12901-0.sol,question,"contract token {
    
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    function token(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              
        totalSupply = initialSupply;                        
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = decimalUnits;                            
    }

    
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            
        Transfer(msg.sender, _to, _value);                   
    }

    
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {    
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                 
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  
        if (_value > allowance[_from][msg.sender]) throw;   
        balanceOf[_from] -= _value;                          
        balanceOf[_to] += _value;                            
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    
    function () {
        throw;     
    }
}"
67738-0.sol,question,"contract blackeye {
    uint public max_amount = 1000000;
    uint public total_balance_bought = 0;

    mapping(address => uint) total_balance;   

    address owneraddress;

    modifier onlyowner {
        require(owneraddress == msg.sender);
        _;
    }

    modifier can_buy_amount(uint rupee_invested) {
        require(rupee_invested + total_balance_bought <= max_amount);
        _;
    }

    function balance(address investor) external constant returns(uint) {
        return total_balance[investor];
    }

    function deposit(address creator, address investor, uint rupee_invested) external {
        if (msg.sender == address(creator)) {
            uint amount_bought = rupee_invested;
            total_balance[investor] += amount_bought;
            total_balance_bought += amount_bought;
        }
    }

    function withdraw(address creator, address investor, uint amount_sold) external {
        if (msg.sender == address(creator)) {
            total_balance[investor] -= amount_sold;
            total_balance_bought -= amount_sold;
        }
    }

    function send_money(address sender, address receiver, uint amount_send) external {
        total_balance[sender] -= amount_send;
        total_balance[receiver] += amount_send;
    }
}"
59613-0.sol,question,"contract Election {

    string public candidateName;

    constructor (string _candidateName) public {
        candidateName = _candidateName;
    }

    function setCandidate (string _name) public {
        candidateName = _name;
    }

}"
30725-0.sol,question,"contract Crowdsale {
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;

    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    function Crowdsale(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 1 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
function () payable {
    require(!crowdsaleClosed);
    uint amount = msg.value;
    balanceOf[msg.sender] += amount;
    amountRaised += amount;
    tokenReward.transfer(msg.sender, amount / price);
    FundTransfer(msg.sender, amount, true);
}

modifier afterDeadline() { if (now >= deadline) _; }


function checkGoalReached() afterDeadline {
    if (amountRaised >= fundingGoal){
        fundingGoalReached = true;
        GoalReached(beneficiary, amountRaised);
    }
    crowdsaleClosed = true;
}



function safeWithdrawal() afterDeadline {
    if (!fundingGoalReached) {
        uint amount = balanceOf[msg.sender];
        balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}"
46476-0.sol,question,"contract Ballot {

    struct Voter {
        uint weight;
        bool voted;
        uint8 vote;
        address delegate;
    }
    struct Proposal {
        uint voteCount;
    }

    address chairperson;
    mapping(address => Voter) voters;
    Proposal[] proposals;

    
    function Ballot(uint8 _numProposals) public {
        chairperson = msg.sender;
        voters[chairperson].weight = 1;
        proposals.length = _numProposals;
    }

    
    
    function giveRightToVote(address toVoter) public {
        if (msg.sender != chairperson || voters[toVoter].voted) return;
        voters[toVoter].weight = 1;
    }

    
    function delegate(address to) public {
        Voter storage sender = voters[msg.sender]; 
        if (sender.voted) return;
        while (voters[to].delegate != address(0) && voters[to].delegate != msg.sender)
            to = voters[to].delegate;
        if (to == msg.sender) return;
        sender.voted = true;
        sender.delegate = to;
        Voter storage delegateTo = voters[to];
        if (delegateTo.voted)
            proposals[delegateTo.vote].voteCount += sender.weight;
        else
            delegateTo.weight += sender.weight;
    }

    
    function vote(uint8 toProposal) public {
        Voter storage sender = voters[msg.sender];
        if (sender.voted || toProposal >= proposals.length) return;
        sender.voted = true;
        sender.vote = toProposal;
        proposals[toProposal].voteCount += sender.weight;
    }

    function winningProposal() public constant returns (uint8 _winningProposal) {
        uint256 winningVoteCount = 0;
        for (uint8 prop = 0; prop < proposals.length; prop++)
            if (proposals[prop].voteCount > winningVoteCount) {
                winningVoteCount = proposals[prop].voteCount;
                _winningProposal = prop;
            }
    }
    }"
68869-0.sol,question,"contract SaveData {
  uint public salary;

  function setSalary(uint input) public {
        salary=input;
  }

  function getSalary() public view returns(uint) {
        return salary;
  }

}"
10495-0.sol,question,"contract A {
     function test() constant returns(string s, address addr) {
        s = ""Success!"";
        addr = msg.sender;
    }
}"
45454-0.sol,question,"contract MetaCoin {

    struct hospital {
        uint index;
        uint record;
        address patientdata;

        mapping(address => uint) _patientrecord;
        bytes32[] record;



    }
    


    function Metacoin() {

        patient = msg.sender;
        doctor = msg.sender;



    }




    event verify(patientPublicKey, doctorPublicKey, timestamp, uint8 consentCode); 

    function verify(bytes32 hash, uint8 v, bytes32 r, bytes32 s) constant returns(bool) {
        return ecrecover(hash, v, r, s, address) == address;



    }

    function isSigned(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns(bool) {
        return ecrecover(hash, v, r, s) == address;

    }

    function Time_call() returns(uint256) {
        return block.number;
    }

    modifier onlypatient() {
        if (msg.sender != patient) throw;
        _;
    }

    modifier onlydoctor() {
        if (msg.sender != doctor) throw;
        _;
    }

    function getAddressfromPublicKey(bytes _publickey) returns(address signer) { 
        bytes32 keyHash = keccak256(_publickey);
        uint result = 0;
        for (uint i = keyHash.length - 1; i + 1 > 2; i--) {
            uint c = uint(keyHash[i]);
            uint to_inc = c * (16 ** ((keyHash.length - i - 1) * 2));
            result += to_inc;
        }
        result record;
    }
}"
45454-0.sol,question,"contract Signagreement { 
    address patient;
    address doctor;

    function patient(address _patient) {
        patient = _patient;
    }

    function doctor(address _doctor) {
        doctor = _doctor;

    }


    modifier onlyPatient() {
        require(msg.sender == patient);
        _;

    }
    modifier onlydoctor() {
        require(msg.sender == doctor);
        _;

    }

    function data() {
        patient = msg.sender;
        doctor = msg.sender;
    }


    struct recordstructs {
        bool approvedBypatient;
        bool approvedBydoctor;

    }
    
    mapping(bytes32 => recordstruct) public recordstructs;
    bytes32[] public DataList; 
    bytes32[] public approvedData; 

    event LogproposedData(address _patient, bytes32 docHash);
    event ApprovedproposedData(address _doctor, bytes32 docHash);
    
    function agreement(string timestamp_patient, address _patientdata, string timestamp_doctor) {
        patient = block.timestamp_patient && address_patient && Identification_patient;
        doctor = block.timestamp_doctor && address_doctor && Identification_doctor;
    }


    
    function getDataCount() public constant returns(uint docCount) {
        return DataList.length;

    }

    function getApprovedCount() public constant returns(uint docCount) {
        return DataList.length;
    }



    
    function agreeDoc(bytes32 Hash) public returns(bool success) {
        if (msg.sender != patient && msg.sender != doctor) throw; 
        if (msg.sender == patient) recordstructs[hash].approvedBypatient = true;
        if (msg.sender == doctor) recordstructs[hash].approvedBypatient = true;
        if (block.number(patient) == block.number(doctor)) recordstructs[hash].approvedBypatient = true; {
            if (msg.sender(patient) == msg.sender(doctor)) recordstructs[hash].approvedBypatient = true;
        }
        if (recordstructs[hash].approvedBypatient == true) {
            uint docCount = DataList.push(hash);
            LogApprovedData(msg.sender, hash);


        } else {
            uint apprCount = approvedData.push(hash);
            LogProposedData(msg.sender, hash);
        }
        return true;
    }
}"
45454-0.sol,question,"contract permissionsP2P is Enabled {

    struct consentedPatientDataTuple {
        bytes32 verificationmessage;
        address patientdata;


    }

    function records(address _patientdata) {
        records = _patientdata;

    }
    struct consentPatientCode {

        uint8 consentCode;
        
        
        
        
        

    }


    mapping(address => uint8) public permissions;
    mapping(address_patientdata => consentPatientcode) public patientconsent;
    mapping(address_patientdata => consentedPatientDataTuple) public patientdoctorconsent;


    function retrieveData(address _patientdata, uint8 index) returns(bytes32) {

        mapping(uint => address) _patientdata;
        address _patientdata = msg.sender;
        uint retrievedData = address _patientdata && consentpatientCode;
        var cons = consentpatientCode(address _patientdata, consentCode);

        if (consentCode = 1 && msg.sender == doctor || msg.sender == patient) {
            if (DataList[address _patientdata].init == false) {
                return 0;

            } else {
                DataList[address _patientdata].record[index];
                return record(result);

            }
        }

    }

    function addData(address _data, bytes32 record) returns(uint result) {
        var cons = consentpatientCode(address _patientdata, consentCode);

        if (consentCode = 2 && DataList.[address _patientdata].init == false) {
            return 0;
        } else if (data == 0) {
            return 1;
        } else {
            DataList[address _patientdata].record[index].push(record);
            DataList[address _patientdata].responsible.push(resp);
            return 2; 

        }
    }

    function confirmData(address _data, bytes32 report) returns(bool) {
        if (address _record != 0x0) {
            
            address _doctor = address _data.Identification _doctor;
            address _patient = address _data.Identification _patient;
            if (msg.sender == doctor || msg.sender == patient) {
                if (DataList[address _data].init == false || record == 0) {
                    return false;
                }
            }
        }
    }

    function updateData(address _patientdata, bytes32 record) returns(bool) {
        var cons = consentpatientCode(address _patientdata, consentCode);

        if (consentCode = 3 && DataList.[address _patientdata].init == false) {

            address_ patientdata.record[index] = record;
        }
    }
}"
72334-0.sol,question,"contract Creation  {

    int basiclife=50;

    struct hero  { 
        string name;
        int life;
        int lvl;
        int xp;
        int attack;
        int winCount;
        int trophies;
        int lossCount;
    }
    hero[] public heroes; 


    struct enemy {  
        string name;
        int life;
        int lvl;
        int xp;
        int attack;
    }
    enemy[] public enemies;

  mapping (uint => address) public herotoowner;
  mapping (address => uint) public  heroCount;

  mapping (uint => address) public monstertoowner;
  uint public monsterCount; 

    function createhero(string memory _name) public  { 
     require(heroCount[msg.sender] == 0);
       uint id= heroes.push(hero(_name,basiclife,1,0,20,0,0,0))-1; 
       herotoowner[id] = msg.sender;
       heroCount[msg.sender]++;

    }
     function enemyRage(int _herolvl) public  { 
       uint id=enemies.push(enemy(""Rage"",20*_herolvl,_herolvl,7*_herolvl,5*_herolvl))-1;
       monstertoowner[id] = msg.sender;
       monsterCount++;

    }

    function enemyDerpina(int _herolvl) public  { 
       uint id=enemies.push(enemy(""Derpina"",40*_herolvl,_herolvl,14*_herolvl,10*_herolvl))-1; 
       monstertoowner[id] = msg.sender;
       monsterCount++;

    }

       function getHerosByOwner(address owner) external view returns( uint ) { 
        uint result =999999;
        for (uint i = 0; i < heroes.length; i++) {
              if (herotoowner[i] == owner) {
                result = i;
                break;
          }
        }
        return result;
        }
        function getmonstersByOwner(address owner) external view returns( uint ) { 
        uint result =0;
        for (uint i = enemies.length ; i > 0 ; i--) {
              if (monstertoowner[i] == owner) {
                result = i;
                break;
          }
        }
        return result;
        }

        uint nonce=0;

   function randNum(int _num) private   returns(int) {  
    int randomnumber = int(keccak256(abi.encodePacked(now, msg.sender, nonce))) % _num;
    if (randomnumber <=0) {
        randomnumber=(-1)*randomnumber;
    }
    nonce++;
    return randomnumber;
    }  

    function attack_hero(uint _heroid, uint _monsterid, int _num  ) external  returns(string memory, int,int,int,int ) { 

      hero storage myhero = heroes[_heroid];
      enemy storage monster = enemies[_monsterid];
      int attackofhero=0;
      if(_num==0) { 
       attackofhero=randNum(myhero.attack);
      }
      monster.life=monster.life - attackofhero;

      int attackofmonster=randNum(monster.attack);
      myhero.life=myhero.life - attackofmonster;

      if (monster.life <= 0 && myhero.life >0) { 
        myhero.winCount++;
        myhero.xp+=monster.xp;

        if (randNum(100) > 50 ){ 
              myhero.trophies++;
          }

        return(""win"",myhero.lvl,myhero.xp,myhero.life,myhero.trophies);
      }
      if (myhero.xp>=10+2*myhero.lvl){ 
          myhero.lvl++;
          myhero.xp=0; 
          myhero.life=basiclife*myhero.lvl;  
          myhero.attack=myhero.attack*myhero.lvl;
        }
      if (myhero.life <= 0 ) { 
          myhero.lossCount++; 
          return(""dead"",myhero.lossCount,myhero.life,myhero.lvl,myhero.trophies);
      } 

      return(""attack"",myhero.life,attackofhero,monster.life,attackofmonster);


    }
    function resurrection(uint _heroid) public { 
         hero storage myhero = heroes[_heroid];
         myhero.life=basiclife*myhero.lvl;
     }



}"
74446-0.sol,question,"contract StandardToken is StandardTokenInterface {

    uint256 constant private MAX_UINT256 = 2**256 - 1;
    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;
    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 

    function StandardToken(
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
    ) public {
        balances[msg.sender] = _initialAmount;               
        totalSupply = _initialAmount;                        
        name = _tokenName;                                   
        decimals = _decimalUnits;                            
        symbol = _tokenSymbol;                               
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value); 
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        emit Transfer(_from, _to, _value); 
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value); 
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}"
3492-0.sol,question,"contract MyPrivateKeys {

  struct encryptedKey {
      string assetName;
      address publicKey;
      string encryptedPrivateKey;
  }

  encryptedKey[] CryptoAssets;


         function newAsset(string assetName, address publicKey, string encryptedPrivateKey) {

                CryptoAssets.push(encryptedKey({
                   assetName: assetName,
                   publicKey: publicKey,
                   encryptedPrivateKey: encryptedPrivateKey
                }));
         }

         function editAsset(){}

         function deleteAsset(){}
}"
82032-0.sol,question,"contract A {
    event lmao (string);
    uint public x;
    function hello () public {
        emit lmao ('YES');
    }
    function setNumber (uint n) public {
        x=n;
    }
}"
82032-0.sol,question,"contract B{
    address public to;    
    function callcontractA () public {
       to.call(abi.encodeWithSignature(""hello()""));
    }   
    function setcontract (address x) public{
        to = x;
    }   
    function callsetNumbercontractA () public {
        
       to.call(abi.encodeWithSignature(""setNumber(uint)"",10));
    }
}"
66220-0.sol,question,"contract TestString {
    function stringConcat(string a, string b) public returns (string) {
        bytes memory strA = bytes(a);
        bytes memory strB = bytes(b);

        string memory finalLength = new string(a.lenght + b.lenght);

        bytes memory finalStr = bytes[finalLength];

        uint k = 0;

        for(uint i = 0; i < a.lenght; i++) {
            finalStr[k++] = strA[i];
        }

        for(i = 0; i < b.lenght; i++) {
            finalStr[k++] = strB[i];
        }

        returns string(finalStr);   
    }
}"
72779-0.sol,question,"contract Voter {
    struct OptionPos {
        uint pos;
        bool exists;
    }

    uint[] public votes;
    string[] public options;
    mapping (address => bool) hasVoted;
    mapping (string => OptionPos) posOfOption;
    bool votingStarted;

    function addOption(string memory option) public {
        require(!votingStarted);
        options.push(option);
    }

    function startVoting() public {
        require(!votingStarted);
        votes.length = options.length;

        for (uint i = 0; i< options.length; i++) {
            OptionPos memory optionPos = OptionPos(i, true);
            posOfOption[options[i]] = optionPos;
        }
        votingStarted = true;
    }

    function vote(uint option) public {
        require(0<=option && option< options.length, ""Invalid option"");
        require(!hasVoted[msg.sender], ""Account has already voted"");

        votes[option] = votes[option]+1;
        hasVoted[msg.sender] = true;
    }

    function vote(string memory optionName) public {
        require(!hasVoted[msg.sender], ""Account has already voted"");
        OptionPos memory optionPos = posOfOption[optionName];
        require(optionPos.exists, ""Option does not exist"");

        votes[optionPos.pos] = votes[optionPos.pos]+1;
        hasVoted[msg.sender] = true;
    }

    function getVotes() public view returns (uint[] memory) {
        return votes;
    }
}"
39303-0.sol,question,"contract GasRefundTest {

    uint[] myArray = [1, 2];

    function deleteLastElem() public returns(bytes32) {
        myArray.length--;
    }
}"
82672-2.sol,question,"contract owned { 
    address owner;
    modifier onlyOwner()
    {
        require(msg.sender == owner);
        _;
    }
}"
82672-2.sol,question,"contract priced {
    modifier costs(uint256 price) {
        require(msg.value <= price);
        _;
    }
}"
24160-0.sol,question,"contract User {
    string publicKey;

    function setPublicKey(string _publicKey)
        onlyOwner
    {
        publicKey = _publicKey;
    }

    function getPublicKey() returns (string _publicKey) {
        return publicKey;
    }

}"
71876-0.sol,question,"contract ElectionsMaster {

address private ownerMasterAddress = msg.sender;

address[] private elections;
bytes32[] private electionsNames;

mapping(address => uint8) private organizersMapping;

constructor() public {
    organizersMapping[msg.sender] = 1;
}

modifier isMasterAccount(address senderAddress) {
    require(senderAddress == ownerMasterAddress, ""Master privileges required"");
    _;
}

modifier isOrganizer(address senderAddress) {
    require(organizersMapping[senderAddress] != 0, ""Organizer privilleges required"");
    _;
}

function () external payable {
}

function changeOwnerMasterAccount(address newOwnerMasterAccount) public isMasterAccount(msg.sender) {
    organizersMapping[newOwnerMasterAccount] = 0;
    ownerMasterAddress = newOwnerMasterAccount;
    organizersMapping[newOwnerMasterAccount] = 1;
}

function addOrganizer(address newOrganizer) public isMasterAccount(msg.sender) {
    organizersMapping[newOrganizer] = 1;
}

function getBalance() public view isMasterAccount(msg.sender) returns(uint) {
    return address(this).balance;
}

function addElection(address electionAddress,
                    bytes32 electionName,
                    address organizerAddress) public isOrganizer(organizerAddress) {
    elections.push(electionAddress);
    electionsNames.push(electionName);
}

function getElectionAddresses() public view returns(address[] memory) {
    return elections;
}

function getElectionNames() public view returns(bytes32[] memory) {
    return electionsNames;
}

function canAddressDeployContract(address organizerAddress) public view returns(bool) {
    return (organizersMapping[organizerAddress] == 1);
}
"
26361-2.sol,question,"contract SimpleStorage {
    object storedData;

    function set(object x) {
        storedData = x;
    }

    function get() constant returns (object) {
        return storedData;
    }
}"
22847-0.sol,question,"contract Voting {

mapping (bytes32 => uint8) public votesReceived;

address sender;

bytes32[] public candidateList;
event Updatestatus (string _msg,address sender);
function Voting(bytes32[] candidateNames) {
candidateList = candidateNames;
}

function totalVotesFor(bytes32 candidate) returns (uint8) {
   if (validCandidate(candidate) == false) throw;
return votesReceived[candidate];
}

function voteForCandidate(bytes32 candidate) payable {
   if (validCandidate(candidate) == false) 
   throw;
   else{
   Updatestatus(""First vote casted by"",msg.sender);
   votesReceived[candidate] += 1;

 }
 }

   function validCandidate(bytes32 candidate) returns (bool) {
     for(uint i = 0; i < candidateList.length; i++) {
   if (candidateList[i] == candidate) {
    return true;
    }
   }
   return false;
   }
    }"
57681-0.sol,question,"contract Aa {

    string public result;    

    function feedData(string _result) public {
        require(_result = ""e"" , ""error"");
        _result = result;
    }
}"
52968-0.sol,question,"contract Parent {
   function createChild() public {
        new Child();
    }
}"
52968-0.sol,question,"contract Child {

}"
31439-0.sol,question,"contract ChildRegistry is BaseRegistry {

address public owner;
address public nodeDelegateAddress;
address[] public registeredNodes;

address public delegateContract;
address[] public previousDelegates;
uint256 public count;
address public tokenAddress;

  event DelegateChanged(address oldAddress, address newAddress);

  function ChildRegistry() {
    
  }

  function changeDelegate(address _newDelegate) returns (bool) {
    

    if (_newDelegate != delegateContract) {
        previousDelegates.push(delegateContract);
        var oldDelegate = delegateContract;
        delegateContract = _newDelegate;
        DelegateChanged(oldDelegate, _newDelegate);
        return true;
      }
    return false;

}

  function registerNode() {
    delegateContract.delegatecall(bytes4(sha3(""registerNode()"")));
  }

  function createNodeContract () {
    delegateContract.delegatecall(bytes4(sha3(""createNodeContract()"")));
  }

  function getNodes() constant returns (address[]) {
    return registeredNodes;
  }

  function setTokenAddress(address _tokenAddress) {
    delegateContract.delegatecall(bytes4(sha3(""setTokenAddress(address)"")), _tokenAddress);
  }
  function setNodeDelegateAddress(address _nodeDelegateAddress) {
    delegateContract.delegatecall(bytes4(sha3(""setNodeDelegateAddress(address)"")), _nodeDelegateAddress);
  }


}"
61687-0.sol,question,"contract b {

        bool p;

    mapping(uint => bool) public t;

    function setValue() {
        bool b = t[1];
        b = true;
    }
    function checkValue() returns (bool) {
        return t[1];
    }
}"
72143-0.sol,question,"contract NotMyContract1 {
    uint256 a = 1;
    function func() external view returns (uint256) {
        return a;
    }
}"
72143-0.sol,question,"contract NotMyContract2 {
    uint256 a = 1;
    uint256 b = 2;
    function func() external view returns (uint256, uint256) {
        return (a, b);
    }
}"
72143-0.sol,question,"contract MyContract {
    INotMyContract private notMyContract;
    constructor(INotMyContract _notMyContract) public {
        notMyContract = _notMyContract;
    }
    function test() public view returns (uint256, uint256) {
        return notMyContract.func();
    }
}"
73836-0.sol,question,"contract TaskMaster {

        mapping (address=>uint) public balances;
        address public owner;

        constructor () public {
            owner = msg.sender;
            balances[owner] = 10000;
        }

        function reward(address doer, uint rewardAmount) 
        public isOwner() hasSufficientFunds(rewardAmount)
        returns (bool sufficientFunds) {
            balances[msg.sender] -= rewardAmount;
            balances[doer] += rewardAmount;
            return sufficientFunds;
        }

        function getBalance(address addr) public view returns (uint balance) {
            return balances[addr];
        }

        modifier isOwner() {
            require(msg.sender == owner);
            _;
        }

        modifier hasSufficientFunds(uint rewardAmount) {
            require(balances[msg.sender] >= rewardAmount);
            _;
        }
    }"
67014-0.sol,question,"contract LearnTokens {
    string  public name = ""LearnToken"";
    string  public symbol = ""LT"";
    string  public standard = ""LearnToken Token v1.0"";
    uint256 public totalSupply;

    event Transfer(
        address indexed _from,
        address indexed _to,
        uint256 _value
    );

    mapping(address => uint256) public balanceOf;

    function LearnToken (uint256 _initialSupply) public payable{
        balanceOf[msg.sender] = _initialSupply;
        totalSupply = _initialSupply;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from]);


        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;



        emit Transfer(_from, _to, _value);

        return true;
    } }"
50106-0.sol,question,"contract Lottery is usingOraclize {

  uint lotteryFee = 0.1 ether;
  uint8 counter = 0;
  address[10] participants;
  mapping (address => bool) checkParticipant;
  address public owner;
  bytes32 public oraclizeID;
  uint public winnerNumber;


  modifier onlyOnce() {
      require(checkParticipant[msg.sender] == false);
      _;
  }


  function participate() external payable onlyOnce returns(address) {
    require(msg.value == lotteryFee);
    checkParticipant[msg.sender] = true;
    counter = counter + 1;  
    participants[counter] = msg.sender;
    return(participants[counter]);
  }

  function getBalance() public view returns (uint) { 
    uint contractBalance = address(this).balance;
    return(contractBalance);
  }

  function selectWinner() payable public {
    oraclizeID = oraclize_query(""WolframAlpha"", ""random number between 1 and 10"");
  }

  function __callback(bytes32 _oraclizeID, string _result){
    if(msg.sender != oraclize_cbAddress()) throw;
    testString = _result;
    winnerNumber = parseInt(_result);
    uint maxRange = counter; 
    uint randomNumber = uint(sha3(_result)) % maxRange; 
  } 

  function payTheReward() external returns(address){
    address winnerAddress = participants[winnerNumber]; 
    uint currentBalance = getBalance();
    winnerAddress.transfer(currentBalance);
    deleteParticipants();
    return (winnerAddress);
  }

  function deleteParticipants() internal {
    uint8 a = counter;
    for(uint8 i = 0; i < a; i++) {
      checkParticipant[participants[i]] = false;
      participants[i] = 0;
    }
    counter = 0;
  }
}"
13927-0.sol,question,"contract HelloWorld {
    address creator; string greeting;

    function HelloWorld(string _greeting) public {
        creator = msg.sender;
        greeting = _greeting;
    }

    function greet() constant returns (string) {
        return greeting;
    }

    function setGreeting(string _newgreeting) {
        greeting = _newgreeting;
    }

    
    function kill() {
        if (msg.sender == creator)
            suicide(creator);  
    }
}"
78679-1.sol,question,"contract stringsContract {
        function takesTwo(string memory str, uint idx) public pure returns (byte) {
            bytes memory bytesStr = bytes(str);
            return bytesStr[idx];
        }
    }"
69793-0.sol,question,"contract Courses {

    struct Instructor {
        string  age; 
        string  fName;
        string  lName;
    }

    mapping (address => Instructor) public instructors; 
    address[] public instructorAccts;

    function setInstructor(address _address, uint256 _age, string memory _fName, string memory _lName) public {

        Instructor memory instructor = Instructor(_age, _fName, _lName); 
        instructor[_address] = instructor;
        instructor.age = _age;
        instructor.fName = _fName;
        instructor.lName = _lName;

        instructorAccts.push(_address) -1;
    }

    function getInstructors() view public returns(address[] memory) {
        return instructorAccts;
    }

    function getInstructor(address _address) view public returns (uint, string memory, string memory) {
        return (instructors[_address].age, instructors[_address].fName, instructors[_address].lName);
    }

    function countInstructors() view public returns (uint256) {
        return instructorAccts.length;
    }

}"
57064-0.sol,question,"contract zeppelinSales {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  
  ERC20 public token;

  
  address public wallet;

  
  
  
  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  event TokenPurchase(
    address indexed purchaser,
        address indexed beneficiary,
    uint256 value,
    uint256 amount
  );

  
  constructor(uint256 _rate, address _wallet, ERC20 _token) public {
    require(_rate > 0);
    require(_wallet != address(0));
    require(_token != address(0));

    rate = 8 * (10**8);
    wallet = 0xF76075Cf3B674fB9656E393e9e17091B01243666;
    token = ERC20(0x0f26c1c05f1bbBC7Eff0488F1a98619e8a9758cf);
  }

  
  
  

  
  function () external payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address _beneficiary) public payable {

    uint256 weiAmount = msg.value;
    _preValidatePurchase(_beneficiary, weiAmount);

    
    uint256 tokens = _getTokenAmount(weiAmount);

    
    weiRaised = weiRaised.add(weiAmount);

    _processPurchase(_beneficiary, tokens);
    emit TokenPurchase(
      msg.sender,
      _beneficiary,
      weiAmount,
      tokens
    );

    _updatePurchasingState(_beneficiary, weiAmount);

    _forwardFunds();
    _postValidatePurchase(_beneficiary, weiAmount);
  }

  
  
  

  
  function _preValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    require(_beneficiary != address(0));
    require(_weiAmount != 0);
  }

  
  function _postValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _deliverTokens(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    token.safeTransfer(_beneficiary, _tokenAmount);
  }

  
  function _processPurchase(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    _deliverTokens(_beneficiary, _tokenAmount);
  }

  
  function _updatePurchasingState(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _getTokenAmount(uint256 _weiAmount)
    internal view returns (uint256)
  {
    return _weiAmount.mul(rate);
  }

  
  function _forwardFunds() internal {
    wallet.transfer(msg.value);
  }
}"
43931-0.sol,question,"contract TugOfWar {

    int public score = 0;
    int constant endAt = 1 ether;
    bool public gameOver = false;
    bool public _direction;
    
    event ScoreChanged(int _amount, bool _direction);
    event GameEnded(bool _gameOver);

    function up() external payable {
        require(msg.value > 0);
        require(!gameOver);

        int value = int(msg.value);
        score += value;

         ScoreChanged(value,true);

        checkIfGameOver();
    }

    function down() external payable {
        require(msg.value > 0);
        require(!gameOver);

        int value = int(msg.value);
        score -= value;

         ScoreChanged(value,false);

        checkIfGameOver();
    }

    function checkIfGameOver() internal {
        if(score >= endAt || score <= endAt * -1) {
            gameOver = true;
             GameEnded(gameOver);
        }
    }
}"
19080-0.sol,question,"contract exchange {
    mapping (address => uint256) public balances;
    event PaymentDone(string s);

    function Channel( uint value) payable {
        balances[msg.sender] -=value;
        balances[this] +=value;
    }

    function CloseChannel( address to,uint value) {
        if (to.send(value)) {
            PaymentDone(""Done"");
        }
    }
}"
58146-2.sol,question,"contract AirDrop is Ownable {

  ERC20 public token;
  address public tokenWallet;
  address public tokenAddress;

  event TransferredToken(address indexed to, uint256 value);
  event FailedTransfer(address indexed to, uint256 value);

  constructor(address _tokenAddress, address _tokenWallet) public {
      tokenWallet = _tokenWallet;
      tokenAddress = _tokenAddress;
      token = ERC20(_tokenAddress);
  }

  function sendTokens(address[] destinations, uint256[] values, address _tokenAddress, address _tokenWallet) onlyOwner external {
      require(destinations.length == values.length);
      uint256 i = 0;
      while (i < destinations.length) {
          uint256 toSend = values[i] * 10**18;
          sendInternally(destinations[i], toSend, values[i]);
          i++;
      }
  }

  function sendTokensSingleValue(address[] destinations, uint256 value) onlyOwner external {
      uint256 i = 0;
      uint256 toSend = value * 10**18;
      while (i < destinations.length) {
          sendInternally(destinations[i] , toSend, value);
          i++;
      }
  }

  function sendInternally(address recipient, uint256 tokens, uint256 valueToPresent) internal {
    require(recipient != address(0));
    ERC20(tokenAddress).transfer(recipient, tokens);
  }


  function tokensAvailable() constant returns (uint256) {
    return token.allowance(tokenWallet, msg.sender);
  }

  function destroy() onlyOwner public {
    selfdestruct(owner);
  }
}"
38048-0.sol,question,"contract Test {

    function Test() {
        owner = msg.sender;
    }

    function pay(uint _price) payable returns (bool) {
        

        require(_price == msg.value); 
        address(this).transfer(msg.value); 
        balanceOfContract[address(this)] += msg.value; 

        LogDeposit(msg.sender, msg.value);

        return true;
    }
}"
38070-1.sol,question,"contract ZombieFeeding is ZombieFactory {

  address ckAddress = 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d;
  KittyInterface kittyContract = KittyInterface(ckAddress); 

  function feedAndMultiply(uint _zombieId, uint _targetDna) public {
    require(msg.sender == zombieToOwner[_zombieId]);
    Zombie storage myZombie = zombies[_zombieId];
    _targetDna = _targetDna % dnaModulus;
    uint newDna = (myZombie.dna + _targetDna) / 2;
    _createZombie(""NoName"", newDna);
  }    
}"
2856-0.sol,question,"contract greeter {
    string name;

    function setName(string name_) {
        name = name_;
    }

    function getName() constant returns(string) {
        return name;
    }
}"
3511-1.sol,question,"contract two {
    struct A {
        address[] count;
    }

    mapping (address => A) a;

    function add(address c) {
        a[msg.sender].count.push(c);
    }
}"
40602-0.sol,question,"contract TestBetting {

  struct BettingInfo {    
      uint256 matchId;
      uint homeTeamScore;
      uint awayTeamScore;     
      uint bettingPrice;  
  }

  address public owner;
  mapping(address => BettingInfo[]) public bettingInfo;

 
  function MyBetting() {
    owner = msg.sender;
  }

  
  function () payable {}

  event LogDeposit(address sender, uint amount);

  
  function placeBet(uint256 _matchId, 
                    uint _homeTeamScore, 
                    uint _awayTeamScore, 
                    uint _bettingPrice) payable returns (bool) {

    bettingInfo[msg.sender].push(
      BettingInfo(_matchId, _homeTeamScore, _awayTeamScore, _bettingPrice)); 

    require(_bettingPrice == msg.value); 
    this.transfer(msg.value); 

    LogDeposit(msg.sender, msg.value);

    return true;
  }

  function getBettingInfo(address _better) public constant returns (uint256[], uint[], uint[], uint[]) {
    uint length = bettingInfo[_better].length;
    uint256[] memory matchId = new uint256[](length);
    uint[] memory homeTeamScore = new uint[](length);
    uint[] memory awayTeamScore = new uint[](length);
    uint[] memory bettingPrice = new uint[](length);   

    for (uint i = 0; i < length; i++) {
      matchId[i] = bettingInfo[_better][i].matchId;
      homeTeamScore[i] = bettingInfo[_better][i].homeTeamScore;
      awayTeamScore[i] = bettingInfo[_better][i].awayTeamScore;
      bettingPrice[i] = bettingInfo[_better][i].bettingPrice;   
    }

    return (matchId, homeTeamScore, awayTeamScore, bettingPrice);
  }
}"
36723-0.sol,question,"contract Crowdsale {
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;

    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    function Crowdsale(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) public {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 0.0005 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function () private payable {
        require(!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / price);
        FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() private afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    
    function safeWithdrawal() private afterDeadline {
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}"
52055-0.sol,question,"contract TestContract {


    bytes32 internal lastHash;

    constructor() {
        lastHash = keccak256(abi.encodePacked(msg.sender, now));
    }

    function getHash() public view returns(bytes32) {
        return lastHash;
    }

    function getHashNum() public view returns(uint256) {
        return uint256(lastHash);
    }
}"
44597-1.sol,question,"contract Login {

event LoginAttempt(address sender, string password);

address private sender;
string private password;

function successfulLogin (address _sender, string _password) public {
    LoginAttempt(_sender, _password);
    sender = _sender;
    password = _password;
}

function failedLogin (address _sender, string _password) public {
    LoginAttempt(_sender, _password);
}

function recoverAddr(bytes32 msgHash, uint8 v, bytes32 r, bytes32 s) public pure returns (address) {
    return ecrecover(msgHash, v, r, s);
}

function isSigned(address _addr, bytes32 msgHash, uint8 v, bytes32 r, bytes32 s) public pure returns (bool) {
    return ecrecover(msgHash, v, r, s) == _addr;
}
"
25810-0.sol,question,"contract SimpleExample {
    function getSender() constant returns (address) {
        return msg.sender;
    }
}"
42581-0.sol,question,"contract d13 {
    bool public car;
    function setCar() public returns (bool) {
        car=true;
        return car;
    }

    function removeCar() public returns (bool) {
        car=false;
        return car;
    }
    function showMemory() pure returns (uint) {
        uint ms;
        assembly {
           ms := msize()
        }
        return ms;
    }
}"
42581-0.sol,question,"contract d12 is d13 {
    function isCar() public view returns (bool) {
        return car; 
    }

    function newCar() public {
        car=true;
    }

    function oldCar() public {
        car=false;
    }
    function showMemory() pure returns (uint) {
        uint ms;
        assembly {
           ms := msize()
        }
        return ms;
    }
}"
42581-0.sol,question,"contract d14 {
    function isCar() view returns (bool) {
        return (new d13()).car();
    }

    function setCar() returns (bool) {
        d13 d13instance = new d13();
        d13instance.setCar();
        return (d13instance.car());
    }
    function showMemory() pure returns (uint) {
        uint ms;
        assembly {
           ms := msize()
        }
        return ms;
    }

}"
44608-1.sol,question,"contract CrowdSale {

    Token public token;

    function Test() public{

    }

    function buyTokens() external payable {
        token.mint();
    }
}"
79123-0.sol,question,"contract StockPriceOracle {
  uint quoteFee = 500;
  mapping (string => uint) private stockPrices;

  

  function getStockPrice(string _stockTicker) payable returns (uint _stockPrice) {
    if (msg.value == quoteFee) {
      
      _stockPrice = stockPrices[_stockTicker];
    } else {
      revert();
    }
  }
}"
8630-0.sol,question,"contract Test {

    mapping (address => uint256) weismap;

    function bet(uint vote) payable returns (uint256 weis) {
        if (msg.value==0) throw;
        weismap[msg.sender]= msg.value;
        return  weismap[msg.sender];
    }

    function test()  returns (uint myVote)  {
           return 1;
    }
}"
43818-0.sol,question,"contract KVStore {

 mapping(address => mapping(string => string)) store;
 uint MAX_STR_LENGTH = 1000;

 function get(address _acct, string _key) public view returns(string) {
    return store[_acct][_key];
 }
 function set(string _key, string _value) public {
   if (bytes(_value).length <= MAX_STR_LENGTH) {
     store[msg.sender][_key] = _value;
   }
 }

}"
15382-0.sol,question,"contract Test {

   function Test() {
       intfunc(5);
   }

   uint8 store;

   function intfunc (uint8 a) internal {
       store = a * 9;
   }
}"
47359-0.sol,question,"contract distribution { 

event Transfer(
        address owner,
        address addresses,
        uint _value
        );

mapping(address => uint) balances;

address private owner;

function distributeBlox(address[] addresses, uint256 _value)  {
    for (uint i = 0; i < addresses.length; i++) {
        balances[owner] -= _value;
        balances[addresses[i]] += _value;
        Transfer(owner, addresses[i], _value);
        }
    }
}"
67518-0.sol,question,"contract Lottery {
    address public manager;
    address[] public players;

    constructor () public {
        manager = msg.sender;
    }

    function enter() public payable {
        require(msg.value > 0.01 ether);
        players.push(msg.sender);
    }

    function random() private view returns (uint256) {
        returns unit(keccak256(abi.encodePacked(block.difficulty, now, players)));
    }


}"
83808-0.sol,question,"contract ZooFactory {

    event NewZoo(uint zooId, string name, uint dna);

    uint dnaDigits = 24;
    uint dnaModulus = 10 ** dnaDigits;

    struct Zoo{
        string name;
        uint dna;
    }

    Zoo[] public zoos;



    function createZoo(string memory _name, uint _dna) private {
        uint id = zoos.push(Zoo(_name, _dna)) - 1;
        NewZoo(id, name, dna);
    }

    function generateRandomDna(string memory _str) private view returns(uint) {
        uint rand = uint(keccak256(abi.encodePacked(_str));
        return rand % dnaModulus;
    }

    function createRandomZoo(string memory _name) public {
        uint randDna = _generateRandomDna(_name);
        createZoo(_name, randDna);
    }
}"
6459-0.sol,question,"contract A {
  function die(address _recipient) external {
    suicide(_recipient);
  }
}"
6459-0.sol,question,"contract B {
  A a;
  function () {
    a.die(this);
  }
}"
56062-0.sol,question,"contract BitcoinCrown is StandardToken { 

    

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = 'H1.0'; 
    uint256 public unitsOneEthCanBuy;     
    uint256 public totalEthInWei;         
    address public fundsWallet;           

    
    
    function BitcoinCrown() {
        balances[msg.sender] = 70000000000000000000000000;               
        totalSupply = 70000000000000000000000000;                       
        name = ""BitcoinCrown"";                                         
        decimals = 18;                                                
        symbol = ""BTCC"";                                             
        unitsOneEthCanBuy = 2800;                                   
        fundsWallet = msg.sender;                                  
    }

    function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        require(balances[fundsWallet] >= amount);

        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;

        Transfer(fundsWallet, msg.sender, amount); 

        
        fundsWallet.transfer(msg.value);                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}"
63745-0.sol,question,"contract Price {
    uint[] public priceHistory;
    function logPrice(uint price) public {
        priceHistory.push(price);
    }
}"
37050-0.sol,question,"contract Adoption {
    address[16] public adopters;

    function adopt(uint petId) public returns (uint) {
        require(petId >= 0 && petId <= 15);
        adopters[petId] = msg.sender;
        return petId;
    }

    function getAdopters() public returns (address[16]) {
        return adopters;
    }
}"
57877-0.sol,question,"contract C {
    Set.Data knownValues;

    function register(uint value) public {
        
        
        
        require(Set.insert(knownValues, value));
    }
    
}"
69406-2.sol,question,"contract TestOwnToken {

    function testDummy() public {
        OwnToken ownToken = new OwnToken();
        address expected = 0x1C8994b9A1802374579AF9d2312a6C2eF26A24F5;
        Assert.equal(ownToken.owner(), expected, ""Error"");
    }
}"
34273-0.sol,question,"contract lastPrice {
     uint price ; 
     uint lprice ;

     function lastPrice (uint _price) {
        lprice = (_price * 1 ether);
       }

     function showPrice () constant returns (uint) {
        return lprice ;
     }
   }"
84502-1.sol,question,"contract Another {
    event LogFunctionFlow(uint);
    uint public balance;
    function sendToAnother() public {
        balance += 10;
        emit LogFunctionFlow(balance);
    }
}"
33066-0.sol,question,"contract AirDrop is Ownable {

  Token token;

  event TransferredToken(address indexed to, uint256 value);
  event FailedTransfer(address indexed to, uint256 value);

  modifier whenDropIsActive() {
    assert(isActive());

    _;
  }

  function AirDrop () {
      address _tokenAddr =0xe34c1960fbf05d4e08c19248491dfbcdbeab6e44; 
      token = Token(_tokenAddr);
  }

  function isActive() constant returns (bool) {
    return (
        tokensAvailable() > 0 
    );
  }
  
  function sendTokens(address[] dests, uint256[] values) whenDropIsActive onlyOwner external {
    uint256 i = 0;
    while (i < dests.length) {
        uint256 toSend = values[i] ;
        sendInternally(dests[i] , toSend, values[i]);
        i++;
    }
  }

  
  function sendTokensSingleValue(address[] dests, uint256 value) whenDropIsActive onlyOwner external {
    uint256 i = 0;
    uint256 toSend = value;
    while (i < dests.length) {
        sendInternally(dests[i] , toSend, value);
        i++;
    }
  }  

  function sendInternally(address recipient, uint256 tokensToSend, uint256 valueToPresent) internal {
    if(recipient == address(0)) return;

    if(tokensAvailable() >= tokensToSend) {
      token.transfer(recipient, tokensToSend);
      TransferredToken(recipient, valueToPresent);
    } else {
      FailedTransfer(recipient, valueToPresent); 
    }
  }   


  function tokensAvailable() constant returns (uint256) {
    return token.balanceOf(this);
  }

  function destroy() onlyOwner {
    uint256 balance = tokensAvailable();
    require (balance > 0);
    token.transfer(owner, balance);
    selfdestruct(owner);
  }
}"
47217-0.sol,question,"contract TestToken {
    uint public totalSupply;

    mapping(address => uint) public balanceOf;

    function transfer(address to, uint amount) public returns (bool) {
        require(balanceOf[msg.sender] >= amount);
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        return true;
    }

    function credit(address to, uint amount) public {
        balanceOf[to] += amount;
        totalSupply += amount;
    }

    function debit(address from, uint amount) public {
        balanceOf[from] -= amount;
        totalSupply -= amount;
    }
}"
9103-0.sol,question,"contract TestContract {
  function testThrow() {
    throw;
  }
}"
25420-0.sol,question,"contract SimpleToken is StandardToken {

  string public constant name = ""FACETOKE"";
  string public constant symbol = ""FACE"";
  uint8 public constant decimals = 18;

  uint256 public constant INITIAL_SUPPLY = 1000000*10**18; 

  function SimpleToken() {
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
  }

}"
79309-0.sol,question,"contract test05 {

    address payable public admin = msg.sender;

    function() payable external {}

    function getBalance() public view returns (uint) {
        return address(this).balance;
    }
}"
16717-0.sol,question,"contract BasicLottery {

        
            mapping(uint => address) public gamblers;


            uint public my_length; 
            uint public random; 

            function BasicLottery(){
                my_length == 0;
            }
        
        
        

        function bet() payable {

        
        
        require(msg.value == 1);

        my_length +=1;

        gamblers[my_length] = msg.sender;

        if (my_length == 5) {
            
            random = uint(block.blockhash(block.number-1))%5 + 1;
            gamblers[random].transfer(5);
            my_length == 0;

        }
    }
}"
19593-0.sol,question,"contract HelloWorld {

    mapping (address => uint) balances;
    address owner;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    function HelloWorld() {
        balances[msg.sender] = 1500;
        owner = msg.sender;
    }

    function getBalances(address addr) returns(uint) {
        return balances[addr];
    }

    function getOwner() returns(address) {
        return owner;
    }

    function sendCoin(address receiver, uint amount) returns(bool success) {

        if(balances[msg.sender] < amount) return false; 

        balances[msg.sender] -= amount;
        balances[receiver] += amount;

        Transfer(msg.sender, receiver, amount);
        return true;
    }
}"
4086-0.sol,question,"contract Foo {
   enum Letter {A, B, C}
   function say(uint index) returns (Letter) {
       if(index == 0) return Letter.A;
       if(index == 1) return Letter.B;
       if(index == 2) return Letter.C;
       throw;
   }
}"
84689-0.sol,question,"contract MyContract {
    function buyAndSell() payable public {
        uint256 tradeSize = msg.value;

        address daiExchangeAddress = 0xc0fc958f7108be4060F33a699a92d3ea49b0B5f0;
        ERC20 daiToken = ERC20(0xaD6D458402F60fD3Bd25163575031ACDce07538D);

        UniswapExchangeInterface usi = UniswapExchangeInterface(daiExchangeAddress);

        uint256 daiAmount = buyCurrencyUniswapV1(usi, daiToken, tradeSize);
        emit successfulTrade(tradeSize, ""ETH"", daiAmount, ""DAI"");
        uint256 ethFromDai = sellCurrencyUniswapV1(usi, daiAmount);
        emit successfulTrade(daiAmount, ""DAI"", ethFromDai, ""ETH"");
    }

    function buyCurrencyUniswapV1(UniswapExchangeInterface usi, ERC20 token, uint256 tradeSize) private returns (uint256) {
        
        uint256 tokensBack = usi.ethToTokenSwapInput.value(tradeSize)(1, block.timestamp);

        
        

        return tokensBack;
    }

    function sellCurrencyUniswapV1(UniswapExchangeInterface usi, uint256 tradeSize) private returns (uint256) {
        uint256 etherBack = usi.tokenToEthSwapInput(tradeSize, 1, block.timestamp);

        
        

        return etherBack;
    }

    event successfulTrade(uint256 fromAmount, string fromCurrency, uint256 toAmount, string toCurrency);
}"
25716-0.sol,question,"contract addressRecord {
    struct  Record {
        address owner;
        uint score;
    }

    mapping (string => Record) records;
    string[] records_arr;

    function addDomain(string _domain, uint _score) {
        if (records[_domain].owner != address(0x0)
        && records[_domain].owner != msg.sender) { return; }

        records[_domain] = Record(msg.sender, _score);
        records_arr.length += 1;
        records_arr[records_arr.length-1] = _domain;
    }

    function getDomain(string _domain) constant returns(uint) {
        return records[_domain].score;
    }

    function changeScore(string _domain, address _to) {
        require(records[_domain].owner == msg.sender);
        records[_domain].owner = _to;
    }    

    function domainsCount() constant returns (uint) {
        return records_arr.length;
    }
}"
12937-0.sol,question,"contract Owned {
  address owner;

  function Owned() {
    owner = msg.sender;
  }

  modifier owner_only() {
    if (msg.sender == owner) {
      _;
    }
  }

  function terminate(address tokens[]) owner_only {
    
    for(uint i = 0; i < tokens.length; i++)) {
      address addr = tokens[i];
      ERC20Token token = ERC20Token(addr);
      uint256 balance = token.balanceOf(this);
      token.transfer(owner, balance);
    }

    
    selfdestruct(owner);
  }
}"
79503-0.sol,question,"contract EDao {
    address payable public student; 

    
    event Success(address src,uint256 ret);
    event Fail(address src,uint256 ret);
    event NotEnoughFunds(address src, uint256 req, uint256 avail, uint256 balance);

    
    struct Fund {
        address payable payoutAddr;
        uint256 amount;
    }
    struct Investor {
        bool canFund;
        bool canAddInvestor;
    }

    
    mapping(address => Investor) investors;
    mapping(address => Fund) funds;

    constructor(address payable _student) public payable {
        
        investors[msg.sender] = Investor({canFund:true, canAddInvestor:true});

        
        student = _student;
        investors[student] = Investor({canFund:true, canAddInvestor:true});
    }

    function fundit(address payable to) public payable {
        Investor memory b = investors[msg.sender];
        if (b.canFund) {
            Fund storage f = funds[to];
            f.payoutAddr = to; 
            f.amount += msg.value;
            emit Success(msg.sender,0);
        } else {
            emit Fail(msg.sender,1);
            revert();
        }
    }

    function queryFunds(address addr) public view returns (uint256) {
        Fund memory f = funds[addr];
        return f.amount;
    }

    function withdraw(address payable addr,uint256 amount) public returns (bool) {
        Fund storage f = funds[addr];
        if (f.amount >= amount && amount <= address(this).balance) {
            (bool success, ) = f.payoutAddr.call.value(amount)("""");
            if (success) {
                f.amount = f.amount - amount;
                return true;
            }
        } else {
          emit NotEnoughFunds(msg.sender,amount,f.amount,address(this).balance);
        }
        return false;
    }    

        function getStudent() public view returns (address) {
                return student;
        }

    function addInvestor(address payable investorAddr,bool canAdd) public {
        Investor memory b = investors[msg.sender];
        if (b.canAddInvestor) {
            investors[investorAddr] = Investor({canFund:true, canAddInvestor:canAdd});
            emit Success(msg.sender,0);
        } else {
            emit Fail(msg.sender,2);    
        }
    }

    function getInvestor(address investorAddr) public view returns (bool canFund, bool canAddInvestor) {
        Investor memory b = investors[investorAddr];
        canFund = b.canFund;
        canAddInvestor = b.canAddInvestor;
                return (canFund, canAddInvestor);
    }

}"
78878-1.sol,question,"contract problem2_bank {
    address private _owner;
    LoanToken public loanToken;
    uint private loansCount = 0;
    uint private guaranteesCount = 0;
    mapping (uint => Loan) private loans;
    mapping (uint => Guarantee) private guarantees;
    mapping (uint => address payable) private lenders;

    constructor(address loanTokenAddress) public 
    {
        _owner = msg.sender;
        loanToken = LoanToken(loanTokenAddress);
    }

    
    

    struct Loan {
        address payable loanee;
        uint etherBorrow;
        uint index;
        uint payBackDate;
        uint etherInterest;
        bool _isGuaranteeProvided;
        bool _isLoanProvided;
        bool _isLoanExist;
    }

    struct Guarantee {
        address payable guarantor;
        uint etherInterest;
        uint loanIndex;
        bool _isWaitingForHandling;
        bool _isGuaranteeExist;
    }

    function getAllowance(address spender) public view returns(uint)
    {
        return loanToken.allowance(msg.sender, spender);
    }

    function giveFifteenthTokens(address spender) public returns(bool)
    {
        require(msg.sender == _owner, ""You are not owner of that smart contract"");
        require(spender != _owner, ""The owner of the smart contract can't receive tokens from himself"");

        
        
        

        
        
        
        
        loanToken.transfer(spender, 15);

        return true;
    }

    function getBalanceOfTokens(address account) public view returns(uint)
    {
        return loanToken.balanceOf(account);
    }

    function requestLoan(uint etherBorrow, uint8 payBackDate, uint8 etherInterest) public
    {
        Loan memory loan = Loan({loanee: msg.sender, index: loansCount, etherBorrow: etherBorrow,
                                        payBackDate: now + (payBackDate * 1 days), etherInterest: etherInterest,
                                        _isGuaranteeProvided: false, _isLoanProvided: false, _isLoanExist: true});
        loans[loansCount] = loan;
        loansCount++;
    }

    function provideGuarantee(uint index, uint8 guaranteeInterest) public 
    {
        require(
            index < loansCount,
            ""This index does not exist"");

        require(loans[index].loanee != msg.sender,
                ""The borrower can't provide a guarantee to himself"");

        require(lenders[index] != msg.sender,
                ""The lender can't provide guarantee for the loan"");

        require(!loans[index]._isGuaranteeProvided, 
            ""This loan already has a guarantee"");

        require(guaranteesCount < loansCount || !guarantees[index]._isWaitingForHandling, 
            ""This guarantee already waiting for handling of borrower"");

        require(guaranteeInterest > 0, 
                ""Too low interest"");

        require(
            loans[index]._isLoanExist,
            ""This loan does not exist"");

        require(
            !guarantees[index]._isGuaranteeExist,
            ""This guarantee does exist"");

        Guarantee memory guarantee = Guarantee({guarantor: msg.sender, etherInterest: guaranteeInterest,
                                                    loanIndex: index, _isWaitingForHandling: true, _isGuaranteeExist: true});
        guarantees[index] = guarantee;
        guaranteesCount++;
    }

    function handleGuarantee(uint index, bool isGuaranteeProvided) public
    {
        require(
            index < loansCount,
            ""This index does not exist"");

        require(loans[index].loanee == msg.sender, 
            ""This is not your loan"");

        require(guarantees[index]._isWaitingForHandling,
            ""Guarantee already processed"");

        require(
            loans[index]._isLoanExist,
            ""This loan does not exist"");

        require(
            guarantees[index]._isGuaranteeExist,
            ""This guarantee does not exist"");

        loans[index]._isGuaranteeProvided = isGuaranteeProvided;
        guarantees[index]._isWaitingForHandling = false;

        if(!loans[index]._isGuaranteeProvided){
            guarantees[index].guarantor.transfer(loans[index].etherBorrow); 
            require(
                loanToken.approve(msg.sender, loans[index].etherBorrow),
                            ""You don't receive approval from loanToken for this amount"");

            require(
            loanToken.transferFrom(_owner, msg.sender, loans[index].etherBorrow),
                            ""You don't receive tokens from loanToken for this amount"");

            delete guarantees[index];
            guaranteesCount--;
        }
    }

    function getLoansInfo(uint index) public view returns(uint, bool, uint, address payable) {
        require(
            lenders[index] == msg.sender,
            ""You are not a leander of this loan"");

        require(
            index < loansCount,
            ""This index does not exist"");

        require(
            loans[index]._isLoanExist,
            ""This loan does not exist"");

       return(loansCount,   
                loans[index]._isGuaranteeProvided, 
                loans[index].etherBorrow * loans[index].etherInterest / 100,    
                guarantees[index].guarantor);   
    }

    function provideLoanForLoanee(uint index) public payable
    {
        require(
            lenders[index] == address(0),
            ""The lender for this loan is already exist"");

        require(
            loans[index].loanee != msg.sender,
            ""You are not a lender"");

        require(
            guarantees[index].guarantor != msg.sender,
            ""You are not a lender"");

        require(
            index < loansCount,
            ""This index does not exist"");

        require(
            loans[index]._isGuaranteeProvided,
            ""This loan doesn't have a guarantee"");

        require(
            !loans[index]._isLoanProvided,
            ""This loan is already provided"");

        require(
            loans[index]._isLoanExist,
            ""This loan does not exist"");

        require(
            msg.value == loans[index].etherBorrow,
            ""You don't have enough ether"");

        require(
            loanToken.allowance(msg.sender, loans[index].loanee) == loans[index].etherBorrow,  
            ""You don't have enough ether"");

        loans[index].loanee.transfer(loans[index].etherBorrow); 
        loans[index]._isLoanProvided = true;
        lenders[index] = msg.sender;
    }

    function isBorrowerTransferEtherAtTime(uint index) public 
    {
        require(
            lenders[index] != address(0),
            ""Loan doesn't have a lender"");

        require(
            lenders[index] == msg.sender,
            ""You are not leander of this loan"");

        require(
            index < loansCount,
            ""This index does not exist"");

        require(
            loans[index]._isLoanProvided,
            ""This loan has not yet been provided"");

        require(
            loans[index]._isLoanExist,
            ""This loan does not exist"");

        
        if(loans[index].payBackDate * 1 days <= now){
            
            lenders[index].transfer(loans[index].etherBorrow); 

            
            delete loans[index];
            loansCount--;

            
            delete guarantees[index];
            guaranteesCount--;

            
            delete lenders[index];
        }
    }

    function payBackLoan(uint index) public payable {
        require(
            index < loansCount,
            ""This index does not exist"");

        require(loans[index].loanee == msg.sender, 
            ""This is not your loan"");

        require(
            loans[index]._isLoanProvided,
            ""This loan was not provided"");

        require(
            loans[index]._isLoanExist,
            ""This loan does not exist"");

        require(
            guarantees[index]._isGuaranteeExist,
            ""This guarantee does not exist"");

        uint amount = (loans[index].etherBorrow + loans[index].etherBorrow * guarantees[index].etherInterest / 100) +
                            (loans[index].etherBorrow * loans[index].etherInterest / 100);

        require(
            msg.value == amount, 
            ""You should to pay back amount with interest"");

        
        guarantees[index].guarantor.transfer(loans[index].etherBorrow + loans[index].etherBorrow * guarantees[index].etherInterest / 100);

        
        lenders[index].transfer(loans[index].etherBorrow + loans[index].etherBorrow * loans[index].etherInterest / 100);

        
        delete loans[index];
        loansCount--;

        
        delete guarantees[index];
        guaranteesCount--;

        
        delete lenders[index];
    }
}"
15741-0.sol,question,"contract Users {
    mapping (bytes32 => address) public users;

    function register(bytes32 name) {
        if(users[name] == 0 && name != """"){
            users[name] = msg.sender;
        }
    }

    function checkAvailability(bytes32 name) returns (bool) {
      if(users[name] == 0) {
        return true;
      }
      return false;
    }

}"
30265-1.sol,question,"contract Functest {
    bytes32 foo; 

    function setFoo(bytes32 _foo) public {
        foo = _foo;
    }

    function getFoo() constant public returns (bytes32) {
        return foo;
    }
}"
80743-0.sol,question,"contract TestNode { 
    uint[] nodes;

    function createNode(uint data) public {
        nodes.length = 0; 
        nodes.push(data);
    }

    function pushNode(uint data) public {
        nodes.push(data);
    }

    function getNode() public view returns(uint[] memory) {
        return nodes;
    }
}"
47543-0.sol,question,"contract Bogus {

    mapping(address => bool) internal iNeedItToBeTrueByDefault;

    function Bogus() {

        ???...
    }
}"
65479-0.sol,question,"contract Store {
    string[] public objects;

    function setData(string memory x, string memory y) public {
        objects.push(x);
        objects.push(y);
    }

    function getDataAtIndex(uint256 index) public returns (string memory, string memory) {
        return (objects[2 * index], objects[2 * index + 1]);
    }

    function getCount() public returns (uint count) {
        return objects.length / 2;
    }

    function getAllData() constant returns (string[]) {
        return objects;
    }
}"
45296-0.sol,question,"contract HelloWorld {
  function get() public pure returns (string retVal) {
    return ""HelloWorld!!"";
  }
}"
73860-0.sol,question,"contract NameService {
   uint256 _reservePrice;

   struct addresses{
    address addr;
    bytes32 value;
   }

   mapping(bytes32 => addresses) data;

   
   constructor(uint256 reservePrice) public {
       _reservePrice = reservePrice;
   }

   function transferTo(bytes32 name, address newOwner) public {
        data[name].addr = newOwner;
   }

   function setValue(bytes32 name, bytes32 value) public {
        data[name].value = value;

   }

   function getValue(bytes32 name) public view returns (bytes32) {
        return data[name].value;
   }

   function commitToName(bytes32 commitment) public payable {
        
   }

   function registerName(bytes32 nonce, bytes32 name, bytes32 value) public {
        setValue(name, value);
        makeCommitment(nonce, name, msg.sender);
   }

   function getOwner(bytes32 name) public view returns(address) {
        return data[name].addr;
   }

   
   function makeCommitment(bytes32 nonce, bytes32 name, address sender) public pure returns(bytes32) {
       return keccak256(abi.encodePacked(nonce, name, sender));
   }
}"
63216-0.sol,question,"contract ProblemDemo {

    string[] private myStringArray;

    constructor () public {
        myStringArray.push(""One"");
        myStringArray.push(""Two"");
        myStringArray.push(""Three"");
    }

    function addToMyStringArray (string memory newEntry) public {
        myStringArray.push(newEntry);
    }

    function getMyStringArray () public view returns (string[] memory) {
        return myStringArray;
    }
}"
29774-1.sol,question,"contract C {
  function f(uint x) returns (uint y) {
    y = 1;
    for (uint i = 0; i < x; i++)
      y = 2 * y;
  }
}"
23146-0.sol,question,"contract Crowdfunding {

    address private owner;

    mapping (address => uint) investors;

    
    function Crowdfunding() {
        owner = msg.sender;
    }

    
    modifier investorsOnly {
        if(investors[msg.sender] == 0) throw;
        _;
    }

    
    event PaymentReceived(uint Amount, address From, address To);
    event WithdrawalClaimed(uint Amount, address From);

    
    function() payable {
        investors[msg.sender] += msg.value;
        PaymentReceived(msg.value, msg.sender, this);
    }

    function withdrawFunds() {
        suicide(owner);
    }

    function getRefund() investorsOnly {
        uint amount = investors[msg.sender];
        investors[msg.sender] = 0;
        msg.sender.transfer(amount);
        WithdrawalClaimed(amount, msg.sender); 
    }
}"
37627-0.sol,question,"contract ArrayDelete {
string[] names;

function main() returns (string[]) {
   names.push(""Jones"");
   names.push(""Ama"");
   names.push(""Emeka"");
   names.push(""Owo"");
   names.push(""Lulu"");

   delete names[0];
   return names;
 }
}"
78738-0.sol,question,"contract DeployContract {
    function deploy(bytes calldata _bytecode) external returns(address addr) {

        bytes memory bytecode = abi.encode(_bytecode, msg.sender);
        assembly {
            addr := create(0, add(bytecode, 0x20), mload(bytecode))
            if iszero(extcodesize(addr)) {
                revert(0, 0)
            }
        }
    }
}"
44441-0.sol,question,"contract con1 {
    bytes32[5] data;

    function con1(){
    }

    function addData(bytes32[5] a) { 
    }   

    function getData() public constant returns(bytes32[5]){  
        return (data);
    }
}"
58917-0.sol,question,"contract IdManager {
    uint256 newId;

    function addId() public returns (uint256) {
        newId++;
        return newId;
    }
}"
83368-0.sol,question,"contract Election {
    string public candidateName;
    string public candidateotherName;



    function Election () public {
        candidateName = ""Candidate 1"";
        candidateotherName = ""Candidate2"";
    }

    function setCandidate (string _name) public {

       candidateName = _name;
    }


     function setOtherCandidate (string _othername) public {
     candidateotherName = _othername;

}
}"
62663-0.sol,question,"contract Election {

    string public candidate;

    function Eletion () public {
        candidate = ""Candidate 1"";
    }
}"
38722-0.sol,question,"contract ERC20Events {
    event Approval(address indexed src, address indexed guy, uint wad);
    event Transfer(address indexed src, address indexed dst, uint wad);
}"
38722-0.sol,question,"contract ERC20 is ERC20Events {
    function totalSupply() public view returns (uint);
    function balanceOf(address guy) public view returns (uint);
    function allowance(address src, address guy) public view returns (uint);

    function approve(address guy, uint wad) public returns (bool);
    function transfer(address dst, uint wad) public returns (bool);
    function transferFrom(
        address src, address dst, uint wad
    ) public returns (bool);
}"
38722-0.sol,question,"contract TimedChest {

    
    address public withdrawer;

    
    address public owner;

    
    ERC20 public token;
    
    

    
    uint[] public releaseTimes;

    
    uint[] public amounts;

    modifier onlyAfter(uint _time) {
        require(now >= _time);
        _;
    }

    modifier onlyBy(address _account) {
        require(msg.sender == _account);
        _;
    }

    function changeOwner(address _newOwner) public onlyBy(owner) {
        owner = _newOwner;
    }

    function TimedChest(uint[] _releaseDelays, uint[] _amounts, address _withdrawer, address _tokenAddress) public {
        owner = msg.sender;

        require (address(_tokenAddress) != 0x0);
        require (address(_withdrawer) != 0x0);
        require (_releaseDelays.length == _amounts.length && _releaseDelays.length > 0);

        for (uint8 i = 0; i < _releaseDelays.length; i++) {
            require(_releaseDelays[i] > now);
            require(_amounts[i] > 0);
            if (i == 0) {
                releaseTimes[i] = now + _releaseDelays[i];
            } else {
                releaseTimes[i] = releaseTimes[i-1] + _releaseDelays[i];
            }
        }

        releaseTimes = _releaseDelays;
        amounts = _amounts;
        withdrawer = _withdrawer;

        token = ERC20(_tokenAddress);
        
        
    }

    function withdraw() onlyBy(withdrawer) external {
        uint256 amount = token.balanceOf(this);
        require (amount > 0);

        for (uint8 i = 0; i < releaseTimes.length; i++) {
            if (releaseTimes[i] < now && amounts[i] > 0) {
                token.transfer(withdrawer, amounts[i]);
            }
        }
    }

    function withdrawAll() onlyBy(owner) external {
        uint256 amount = token.balanceOf(this);
        require (amount > 0);

        token.transfer(owner, amount);
    }

}"
13970-0.sol,question,"contract Controlled {  
    address public userAddr;  

    struct User {  
      address a;  
      string name;  
      string email;  
      uint phone;  
    }  

    mapping (address => User) Users;  

    function registerUser(string _name, string _email, uint _phone) returns (bool success) {  
      Users[msg.sender].a = msg.sender;  
      Users[msg.sender].name = _name;  
      Users[msg.sender].email = _email;  
      Users[msg.sender].phone = _phone;  
    }



    modifier onlyUser {
        if (msg.sender != userAddr) throw;
        _;
    }

}"
13970-0.sol,question,"contract Main is Controlled {  
  using DataSet for *;    
  DataSet.Data d;  

  struct userProduct {  
    address user_address;  
    uint id;  
    string description;  
    uint price;  
  }  

   userProduct[] products;  


  function newUserProduct  (  
    address u,
    uint i,
    string d,
    uint p) onlyUser returns (bool added) {

    userProduct memory newProduct;
    newProduct.user_address = msg.sender;
    newProduct.id = i;  
    newProduct.description = d;
    newProduct.price = p;
    products.push(newProduct);
    added = true;
  }  

  function getUserInfo (uint g) constant returns (address ,bytes32, uint ) {  
      for (uint i = 0; i <= products.length; i++) {  
          if (products[i].id == g) {  
             return(products[i].user_address, DataSet.stringToBytes32(products[i].description), products[i].price);  
          }  
      }  
  }  
}"
64341-0.sol,question,"contract CampaignFactory {

    mapping(address => Campaign[]) campaigns;

    function createCampaign(uint min_contrib) public {
        Campaign newCampaign = new Campaign(min_contrib, msg.sender);
        campaigns[msg.sender].push(newCampaign);
    }

    function getCampaignsByAddress(address creator) public view returns (Campaign[] memory) {
        return campaigns[creator];
    }
}"
43547-1.sol,question,"contract BasicToken is ERC20Basic {
    using SafeMath for uint256;
    mapping(address => uint256) balances;
    uint256 totalSupply_;

    function totalSupply() public view returns (uint256) {
       return totalSupply_;
    }

    function transfer(address _to, uint256 _value) public returns (bool) {
       require(_to != address(0));
       require(_value <= balances[msg.sender]);
       balances[msg.sender] = balances[msg.sender].sub(_value);
       balances[_to] = balances[_to].add(_value);
       Transfer(msg.sender, _to, _value);
       return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
       return balances[_owner];
    }
}"
43547-1.sol,question,"contract TestMyToken is StandardToken {
    string public constant name = ""TestMyToken""; 
    string public constant symbol = ""TMT"";
    uint8 public constant decimals = 18;
    uint256 public constant INITIAL_SUPPLY = 1000000 * (10 ** uint256(decimals));

    function TestMyToken() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0, msg.sender, INITIAL_SUPPLY);
    }
}"
61687-1.sol,question,"contract b {

    struct Info {
        bool p;

    }
    mapping(uint => Info) public t;

    function setValue() {
        Info b = t[1];
        b.p = true;
    }
    function checkValue() returns (bool) {
        return t[1].p;
    }
}"
34627-0.sol,question,"contract OwnedI {
    
    event LogOwnerSet(address indexed previousOwner, address indexed newOwner);

    
    function setOwner(address newOwner) returns(bool success);

    
    function getOwner() constant returns(address owner);

}"
34627-0.sol,question,"contract Owned is OwnedI {
    address public owner;
    function Owned() {
        owner = msg.sender;
    }

    modifier fromOwner() {
        require(msg.sender == owner);
        _;
    }
    
    function setOwner(address newOwner) fromOwner returns(bool success) {
        require(msg.sender != address(0));
        require(newOwner != owner);
        address previousOwner = owner;
        LogOwnerSet(previousOwner, newOwner);
        owner = newOwner;
        return true;
    }

    
    function getOwner() constant returns(address outputOwner) {
        return owner;
    }
}"
34627-0.sol,question,"contract CheckOwner is Owned {

    int public check ;

    function CheckOwner () {
        check = 1;
    }

    function setCheck() fromOwner {
        check++;

    }
}"
50900-0.sol,question,"contract Forwarder {
    address public owner;
    mapping(address => uint256) public stored;

    function Forwarder () public {
        owner = msg.sender;
    }

    function () public payable {
        owner.transfer(msg.value);
    }

    function transfer (address contractAddress) public {
        require (stored[msg.sender] > 0);
        contractAddress.transfer(stored[msg.sender]);       
    }

    function store () public payable {
        stored[msg.sender] += msg.value;
    }
}"
55670-1.sol,question,"contract TestToken is ERC20Basic {
    using SafeMath for uint;
    string public name;
    string public symbol;
    uint8 public decimals;
    uint public _totalSupply;


    mapping(address => uint) balances;
    mapping(address => mapping(address => uint)) allowed;


    function TestToken() public {
        name = ""TestToken"";
        symbol = ""tttest"";
        decimals = 18;

        _totalSupply = 4000000000000000000000000000;
        balances[0xE3FdfaAF08F4778c7E88Ed1E31696745ed610328] = _totalSupply;
        Transfer (address(0), 0xE3FdfaAF08F4778c7E88Ed1E31696745ed610328, _totalSupply); 
     }
}"
61272-1.sol,question,"contract RefundableCrowdsale is FinalizableCrowdsale {
using SafeMath for uint256;


uint256 private _goal;


RefundEscrow private _escrow;


constructor(uint256 goal) internal {
require(goal > 0);
_escrow = new RefundEscrow(wallet());
_goal = goal;
}


function goal() public view returns(uint256) {
return _goal;
}


function claimRefund(address beneficiary) public {
require(finalized());
require(!goalReached());

_escrow.withdraw(beneficiary);
}


function goalReached() public view returns (bool) {
return weiRaised() >= _goal;
}


function _finalization() internal {
if (goalReached()) {
_escrow.close();
_escrow.beneficiaryWithdraw();
} else {
_escrow.enableRefunds();
}

super._finalization();
}


function _forwardFunds() internal {
_escrow.deposit.value(msg.value)(msg.sender);
}

}"
22871-0.sol,question,"contract Members {

  struct Member {
     IpfsUtils.IpfsHash profile;
     uint id;
  }
  mapping (address => Member) public members;

  function addMember(uint id, bytes profileHash) {
    Member m = members[msg.sender];
    m.id = id;
    m.profile.insert(profileHash);
  } 
}"
38272-0.sol,question,"contract StoreAndFree {
    mapping(int=>int) myStore;
    function StoreAndFree() public {
        for (int i=1; i<100; i++) {
            myStore[i] = i;
        }
    }

    function kill() external {
        selfdestruct(msg.sender);
    }
}"
71596-0.sol,question,"contract test {
    event testV(uint indexed value1);
    uint val= 0;

     function testf() public {


                  val--;

        emit testV(val); 
    }
}"
41650-1.sol,question,"contract testContract is usingOraclize {

    event callback_received(string goodies);

    function __callback(bytes32 myid, string result) {
        callback_received(result);
    }

    function testQuery() {
        oraclize_query(""URL"", ""json(http:
    }

    function testContract() {
        OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
    }

}"
37605-0.sol,question,"contract MDBService {

    mapping (address => address) accounts;
    mapping (uint => address) ids;
    uint numberAccounts;

    function MDBService() {
        numberAccounts = 0;
    }

    function register() {
        require(accounts[msg.sender] == 0); 
        ids[numberAccounts] = msg.sender;
        accounts[msg.sender] = new MDBAccount(msg.sender);
        numberAccounts++;
    }
}"
37605-0.sol,question,"contract MDBAccount {

    struct Post {
        uint timestamp;
        string message;
    }

    uint public numberPosts;
    address public owner;
    mapping (uint => Post) posts;

    modifier isOwner() {
        require(owner == msg.sender);
        _;
    }

    function MDBAccount(address _owner) {
        owner = _owner;
        numberPosts = 0;
    }

    function post(string message) isOwner() {
        require(bytes(message).length <= 160);
        posts[numberPosts].timestamp = now;
        posts[numberPosts].message = message;
        numberPosts++;
    }
}"
10493-0.sol,question,"contract big_contract {
    function user_function_1 (uint32 arg1, string arg2) returns (uint32) {
        
    }

    function user_function_2 (string arg1) returns (string){
        
    }

    function admin_function (bool arg1) {
        
    }
}"
46199-0.sol,question,"contract Election {
    
    struct Candidate {
        uint id;
        string name;
        uint voteCount;
    }
    
    mapping (uint => Candidate) public candidates;
    uint public candidatesCount;
    function Election() public {
        addCandidate(""Blockchain"");
        addCandidate(""Groot"");
    }
    function addCandidate(string _name) private {
        candidatesCount++;
        candidates[candidatesCount] = Candidate(candidatesCount, _name, 0);
    }
}"
63704-0.sol,question,"contract example1 {
  function A() {
    print msg.sender; 
    example3.C();
  }
}"
63704-0.sol,question,"contract example2 {
  function B() internal {
    print msg.sender; 
  }
}"
63704-0.sol,question,"contract example3 is example2 {
  function C() {
    print msg.sender;
    B();
  }
}"
28393-0.sol,question,"contract Upgradeable {
    mapping(bytes4=>uint32) _sizes;
    address _dest;

    
    function initialize();

    
    function replace(address target) internal {
        _dest = target;
        target.delegatecall(bytes4(sha3(""initialize()"")));
    }
}"
28393-0.sol,question,"contract Dispatcher is Upgradeable {
    function Dispatcher(address target) {
        replace(target);
    }

    function initialize() {
        
        throw;
    }

    function() {
        bytes4 sig;
        assembly { sig := calldataload(0) }
        var len = _sizes[sig];
        var target = _dest;

        assembly {
            
            calldatacopy(0x0, 0x0, calldatasize)
            delegatecall(sub(gas, 10000), target, 0x0, calldatasize, 0, len)
            return(0, len)
        }
    }
}"
9607-0.sol,question,"contract A is Owned {

   B private b;

   function A(address B) {
       b = B(b);
   }

   function myInterface() public onlyOwner {
       a.doStuff({from: msg.sender});
   }
}"
9607-0.sol,question,"contract B is Owned {

   C private c;

   function B(address c) {
       c = C(c);
   }

   function doStuff() public onlyOwner {
       c.store(42,{from: msg.sender});
   }
}"
9607-0.sol,question,"contract C is Owned {

   int private theAnswer;

   function store(int value) public onlyOwner {
       theAnswer = value
   }
}"
2529-0.sol,question,"contract constantOrPublic {
    address creator;
    address otheraddress;

    function constantOrPublic(address _otheraddress) 
    {
        creator = msg.sender;
        otheraddress = _otheraddress;
    }

    function getConstant() constant returns(address) {
        return otheraddress;
    }
    function getPublic() public returns(address) {
        return otheraddress;
    }

}"
59911-0.sol,question,"contract EtherTransferTo {
    function () public payable {
    }

    function getBalance() public returns (uint) {
    return address(this).balance;
    }
}"
59911-0.sol,question,"contract EtherTransferFrom {

    EtherTransferTo private _instance;

    function EtherTransferFrom() public {
    
    _instance = new EtherTransferTo();
   }

    function getBalance() public returns (uint) {
    return address(this).balance;
    }

    function getBalanceOfInstance() public returns (uint) {
    
    return _instance.getBalance();
    }

    function () public payable {
    
    address(_instance).send(msg.value);
    }
}"
84500-1.sol,question,"contract HoneyPotCollect {
  HoneyPot public honeypot;

  constructor(address _honeypot) public {

    honeypot = HoneyPot(_honeypot);
  }

  function kill () public {
    selfdestruct(msg.sender);
  }

  function collect() payable public {
    honeypot.put.value(msg.value)();
    honeypot.get();
  }

  function () external payable  {
    if (honeypot.balance >= msg.value) {
      honeypot.get();
    }
  }
}"
12120-0.sol,question,"contract Coin {

  address public owner;
  mapping (address => uint) balances;



  function Coin() {
    owner = msg.sender;
    balances[tx.origin] = 1000;
  }


  function send(address receiver, uint amount) returns (bool success) {
    if (balances[msg.sender] < amount) {
      return  false;
    }
    balances[msg.sender] -= amount;
    balances[receiver] += amount;
    return true;

  }


  function getBalance (address user) constant returns (uint balance) {
    return balances[user];
  }
}"
83695-0.sol,question,"contract BallotFactory {
address[] public deployedBallotsAddress;

function createBallot(
    string memory _title,
    string memory _description,
    string memory _option1,
    string memory _option2
) public {
    address newBallotAddress = address(
        new Ballot(_title, _description, _option1, _option2, msg.sender)
    ); 
    deployedBallotsAddress.push(newBallotAddress);
}

function getDeployedBallots() public view returns (address[] memory) {
    return deployedBallotsAddress;
}
"
10824-0.sol,question,"contract EndowmentRetriever {

    address creator;
    uint contract_creation_value;

    function EndowmentRetriever() public payable {
        creator = msg.sender;
        contract_creation_value = msg.value;
    }

    function getContractCreationValue() constant returns (uint) {                               
        return contract_creation_value;                         
    }

    function sendOneEtherHome() public {                        
        creator.send(1000000000000000000);
    }

    function kill() { 
        if (msg.sender == creator) {
            suicide(creator); 
        }
    }   
}"
68088-0.sol,question,"contract Transaction {

    uint num = 0;
    bytes32 [] storedKeys;
    uint [] x;

    struct Pilot {
        string details;
        uint expected_time;
        address creator; 
        uint amount;
        address [] listenrs;
        address [] reporters;
    }

    mapping (bytes32 => Pilot) _accounts;


    function  get_details_by_name(string key) public returns(string){
        return _accounts[stringToBytes32(key)].details;
    }

    function  get_pilots_names() public constant returns(bytes32 []){
        return storedKeys;
    }

    function stringToBytes32(string memory source) private returns (bytes32 result) {
        bytes memory tempEmptyStringTest = bytes(source);
        if (tempEmptyStringTest.length == 0) {
            return 0x0;
        }

        assembly {
            result := mload(add(source, 32))
        }
    }
    function  get1() public constant returns(uint){
        return num;
    }

    
    function add_pilot(string s1, string det, uint hours_till_exp, uint am) public  {
        bytes32 s = stringToBytes32(s1);
        _accounts[s].creator = msg.sender;
        _accounts[s].amount = am;
        _accounts[s].details = det;
        _accounts[s].expected_time  = now + (hours_till_exp * 3600);
        _accounts[s].listenrs.push(msg.sender);
        num+=1;
        storedKeys.push(s);
    }
}"
79015-0.sol,question,"contract OraclizeTest is usingOraclize {

    using strings for *;        
   
    uint public amount; 


    address public homeBet;  
    address public awayBet;


    

    event LogInfo(string description);      

    
    

    
    function OraclizeTest (uint _amount) public {      
        amount = _amount;        

    

        
       OAR = OraclizeAddrResolverI(0x04De331D6fFe6079cDD635780Ce588263D682D31);



        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
        update();
    }

    
    function()
    public{
        revert();
    }
    
     
    function betOnTeam(uint team) payable public {
        
        if(team == 1)
        {
            if(homeBet == 0)
            {
                if(msg.value == amount)
                {
                    homeBet = msg.sender;
                    if(homeBet != 0 && awayBet != 0)
                    {
                        

                        update();
                       
                    }
                }
                else
                {
                    throw;
                }
            }
            else
            {
                throw;
            }
        }
        else if(team == 2)
        {
            if(awayBet == 0)
            {
                if(msg.value == amount)
                {
                    awayBet = msg.sender;

                    if(homeBet != 0 && awayBet != 0)
                    {
                        
                        update();
                      
                    }
                }
                else
                {
                    throw;
                }
            }
            else
            {
                throw;
            }
        }
        else
        {
            throw;
        }
    }
    
    function __callback(bytes32 id, string result, bytes proof) public {
    require(msg.sender == oraclize_cbAddress());        
    update();
    
    if (result.toSlice().equals(""home"".toSlice()))
    {
        homeBet.transfer(address(this).balance);
    }
    else if(result.toSlice().equals(""away"".toSlice()))
    {
        awayBet.transfer(address(this).balance);
    }
    else if(result.toSlice().equals(""draw"".toSlice()))
    {
        homeBet.transfer(address(this).balance / 2);
        awayBet.transfer(address(this).balance / 2);
    }

    
    }

    function update()
    payable
    public {
        
        if (oraclize_getPrice(""URL"") > address(this).balance) {
            emit LogInfo(""Oraclize query was NOT sent, please add some ETH to cover for the query fee"");
        } else {
            emit LogInfo(""Oraclize query was sent, standing by for the answer.."");

            
            oraclize_query(""URL"", ""json(https:

        }
    }

}"
71895-1.sol,question,"contract contractB {
    function invokeContractA(address _addA) public  { 
        contractA a = contractA(_addA);
        uint ValueToSend = 1234;    
        a.blah.value(ValueToSend)(2, 3);
    }  
}"
79774-1.sol,question,"contract Operacoes {
    All all;
    uint256 operacaoId;

    
    struct All {
        ObservacaoPragas[] observacoesPragas;
    }

    
    struct CommonOperacao {
        uint256 id;
        uint256 inicioOperacao;
        uint256 fimOperacao;
        bytes32 responsavel;
        bytes32 nota;
    }


    struct ObservacaoPragas {
        bytes32 unidadeProducao;
        bytes32 parcela;
        bytes32 subParcela;
        EstadoFenologico estadoFenologico;
        bytes32 armadilha;
        ObservacaoPragasTipo tipo;
        bytes32 praga;
        uint256 leitura;
        CommonOperacao op;
    }
    
    enum EstadoFenologico {
        GOMO_DE_INVERNO,
        INICIO_DO_INCHAMENTO_DOS_GOMOS,
        FIM_DO_INCHAMENTO_DOS_GOMOS,
        ABROLHAMENTO,
        FOLHAS_LIVRES,
        CACHOS_VISIVEIS,
        CACHOS_SEPARADOS,
        BOTOES_FLORAIS_SEPARADOS,
        FLORACAO,
        PLENA_FLORACAO,
        BAGO_DE_ERVILHA,
        FECHO_DOS_CACHOS,
        PINTOR,
        MATURACAO
    }
    enum ObservacaoPragasTipo {LEITURA, INSTALACAO, REMOCAO, TROCAR_PLACA}

    constructor() public {
        operacaoId = 0;
    }


    
    
    
    function addObservacaoPragas(
        bytes32 _unidadeProducao,
        bytes32 _parcela,
        bytes32 _subParcela,
        uint256 _estadoFenologico,
        bytes32 _armadilha,
        uint256 _tipo,
        bytes32 _praga,
        uint256 _leitura,
        uint256 _inicioOperacao,
        uint256 _fimOperacao,
        bytes32 _responsavel,
        bytes32 _nota
    ) public returns (ObservacaoPragas memory) {
        ObservacaoPragas memory obs = ObservacaoPragas(
            _unidadeProducao,
            _parcela,
            _subParcela,
            EstadoFenologico(_estadoFenologico),
            _armadilha,
            ObservacaoPragasTipo(_tipo),
            _praga,
            _leitura,
            CommonOperacao(
                operacaoId,
                _inicioOperacao,
                _fimOperacao,
                _responsavel,
                _nota
            )
        );

        all.observacoesPragas.push(obs);
        operacaoId++;
        return obs;
    }


    
    
    
    function retrieveAllOperacoes() public view returns (All memory) {
        return all;
    } }"
71782-0.sol,question,"contract Transport {
   address public manager;
   Car[] public carArray;
   Bike[] public bikeArray;

   struct Car {
      uint carId;
      address carOwner;
   }

   struct Bike {
      uint bikeId;
      address bikeOwner;
   }

   function Transport(address creator) public {
        manager = creator;
   }

   function carCreate(uint carId, address carOwner) public {

        Car memory newCar = Car ({
            carId: carId,
            carOwner: carOwner
        });

        
        carArray.push(newCar);
   }

   function bikeCreate(uint bikeId, address bikeOwner) public {

        Bike memory newBike = Bike ({
            bikeId: bikeId,
            bikeOwner: bikeOwner
        });

        
        bikeArray.push(newBike);
   }

   function createNewBatch(uint batchId, uint carId, uint bikeId) public {

        
        
        
        ...
        ...
   }
}"
58228-0.sol,question,"contract Testing {
    string name;
    function setName(string name) public returns(string) {
        name =name;
        return name;
    }

    function getName() public returns(string) {
        return name;
    }
}"
47100-0.sol,question,"contract myContract {
    function foo() public returns(uint) {
        return 10;
    }

    function foo1() public view returns(uint) {
        return 10;
    }    
}"
47303-1.sol,question,"contract EtherBlock {
    uint256 public nonce;
    event eOpenPosition(uint256 indexed PositionKey, address indexed Opener, uint256 EtherTossed, uint8 OddEven);
    function OpenPosition (uint8 OddEven) public {
        emit eOpenPosition(nonce, msg.sender, msg.value, OddEven);
    }
}"
33869-0.sol,question,"contract TOKKA is StandardToken {
    string public name = ""TOKKA"";
    string public symbol = ""TOK"";
    uint256 public decimals = 18;

    uint256 constant INITIAL_SUPPLY = 18000000 * 10**18;
    function TOKKA () public {
       balances[msg.sender] = INITIAL_SUPPLY;
    }
}"
33869-0.sol,question,"contract Crowdsale {
  using SafeMath for uint256;

   
  TOKKA public token;

  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != address(0));

    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
    token = createTokenContract();
  }



function createTokenContract() internal returns (TOKKA) {
    return new TOKKA();
  }


  
  function () external payable {
    buyTokens(msg.sender);
  }

  
function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);

    
    weiRaised = weiRaised.add(weiAmount);

    
    ERC20(token).transfer(this, tokens);

    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
}


  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }


  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }


  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

}"
49980-0.sol,question,"contract TokenERC20 {

string public name;
string public symbol;
uint8 public decimals = 18;
uint256 public totalSupply;

mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;

event Transfer(address indexed from, address indexed to, uint256 value);
event Burn(address indexed from, uint256 value);

constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public {
    totalSupply = initialSupply;
    balanceOf[msg.sender] = totalSupply;
    name = tokenName;
    symbol = tokenSymbol;
}

function _transfer(address _from, address _to, uint _value) internal {
    require(_to != 0x0);
    require(balanceOf[_from] >= _value);
    require(balanceOf[_to] + _value >= balanceOf[_to]);
    uint previousBalances = balanceOf[_from] + balanceOf[_to];
    balanceOf[_from] -= _value;
    balanceOf[_to] += _value;
    emit Transfer(_from, _to, _value);
    assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}

function transfer(address _to, uint256 _value) public {
    _transfer(msg.sender, _to, _value);
}

function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    require(_value <= allowance[_from][msg.sender]);
    allowance[_from][msg.sender] -= _value;
    _transfer(_from, _to, _value);
    return true;
}

function approve(address _spender, uint256 _value) public returns (bool success) {
    allowance[msg.sender][_spender] = _value;
    return true;
}

function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
    tokenRecipient spender = tokenRecipient(_spender);
    if (approve(_spender, _value)) {
        spender.receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    }
}

function burn(uint256 _value) public returns (bool success) {
    require(balanceOf[msg.sender] >= _value);
    balanceOf[msg.sender] -= _value;
    totalSupply -= _value;
    emit Burn(msg.sender, _value);
    return true;
}

function burnFrom(address _from, uint256 _value) public returns (bool success) {
    require(_value <= allowance[_from][msg.sender]);
    require(balanceOf[_from] >= _value);
    balanceOf[_from] -= _value;
    allowance[_from][msg.sender] -= _value;
    totalSupply -= _value;
    emit Burn(_from, _value);
    return true;
}

function () public payable {
    revert();
}

}"
50296-0.sol,question,"contract DailyAssessmentScoreContract {

   struct dailyAssessment{
        string dailyAssessmentId;
        string[] period;
        uint[] score;
    }
    dailyAssessment[] daily_assessment;


   function stringsEqual(string storage _a, string memory _b) internal returns (bool) {
        bytes storage a = bytes(_a);
        bytes memory b = bytes(_b);
        if (a.length != b.length)
            return false;
        
        for (uint i = 0; i < a.length; i ++)
            if (a[i] != b[i])
                return false;
        return true;
    }
    function stringToUint(string s) constant returns (uint result) {
        bytes memory b = bytes(s);
        uint i;
        result = 0;
        for (i = 0; i < b.length; i++) {
            uint c = uint(b[i]);
            if (c >= 48 && c <= 57) {
                result = result * 10 + (c - 48);
            }
        }
    }

   function setDailyAssessmentInfo(string _dailyAssessmentId, string _period, string _score) public {
       bool write = false;
       uint score = stringToUint(_score);
       for(uint i=0; i<=daily_assessment.length; i++)
       {                                                                                                                                                                                                                                                            
           if(stringsEqual(daily_assessment[i].dailyAssessmentId, _dailyAssessmentId))
           {
               daily_assessment[i].period.push(_period);
               daily_assessment[i].score.push(score);
               write = true;
           }
       }
       if(write==false)
        {
            daily_assessment[i].dailyAssessmentId=_dailyAssessmentId;
            daily_assessment[i].period.push(_period);
            daily_assessment[i].score.push(score);
        }
   }

   function getDailyAssessmentInfo(string _dailyAssessmentId) public constant returns (uint) {
       uint score;
       for(uint i=0;i<=daily_assessment.length;i++)
       {
           if(stringsEqual(daily_assessment[i].dailyAssessmentId, _dailyAssessmentId))
           {
               uint sum = 0;
               uint scoreLength = daily_assessment[i].score.length;
               for(uint j=0;j<=scoreLength;j++)
               {
                    sum = sum + daily_assessment[i].score[j];
               }
                score = sum / scoreLength;
           }
       }

       return (score);
   }   
}"
28306-0.sol,question,"contract SPECMN {

    using SafeMath for uint256;

    string public constant name     = ""Speculative Mania"";
    string public constant symbol   = ""SPCMN"";
    uint8  public constant decimals = 18;
    uint256 public rate = 10;
    
    uint256 public constant _totalSupply = 1000000;
    uint256 public      _totalSupplyLeft = 1000000;
    uint256 tokens                       = 0;
    
    mapping(address => uint256) balances; 
    mapping(address => mapping(address => uint256)) allowedToSpend;
    address public contract_owner;
    uint256 currentBlock = 0;
    uint256 lastblock    = 0;
    
    function SPECMN(){
        currentBlock = block.number;
        lastblock    = block.number;
    }
    

    
    function totalSupply() constant returns (uint256 thetotalSupply){
        return _totalSupply;
    }
    
    function balanceOf(address _queryaddress) constant returns (uint256 balance){
        return balances[_queryaddress];
    }

    
    function transfer(address _to, uint256 _value) returns (bool success){
        require(
            balances[msg.sender] >= _value
            && _value > 0);
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to]        = balances[_to].add(_value);
        Transfer(msg.sender, _to,_value);
        return true;
    }
    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success){
        require(
            allowedToSpend[_from][msg.sender] >= _value
            && balances[_from] >= _value
            && _value > 0);
        balances[_from] = balances[_from].sub(_value);
        balances[_to]   = balances[_to].add(_value);
        allowedToSpend[_from][msg.sender] = allowedToSpend[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }
    
    
    
    function approve(address _spender, uint256 _value) returns (bool success){
        allowedToSpend[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function allowance(address _owner, address _spender) constant returns (uint256 remaining){
        return allowedToSpend[_owner][_spender];
    }
    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    
    
    function() payable {
        require(msg.value > 0);
        tokens       = msg.value.mul(rate);
        currentBlock = block.number;
        if(rate > 1 && currentBlock.sub(lastblock) > 3000){
            rate = rate.sub(1);
            RateChange(rate);
            lastblock        = currentBlock;
        } 
        balances[msg.sender] = balances[msg.sender].add(tokens);
        _totalSupplyLeft     = _totalSupplyLeft.sub(tokens);
        contract_owner.transfer(msg.value);
        MoneyTransfered(contract_owner,msg.value);

    }
    function shutThatShitDown() public {
        require(msg.sender == contract_owner);
        selfdestruct(contract_owner);
    }

    
    event RateChange(uint256 _rate);
    
    event MoneyTransfered(address indexed _owner, uint256 _msgvalue);

}"
11479-0.sol,question,"contract SimpleStorage {
         string public storedData;
         function SimpleStorage() {
                      storedData = ""hello world"";
         }
         function set(string x) {
                      storedData = x;
         }
         function get() constant returns (string x) {
                     return storedData;
         }

 }"
78236-0.sol,question,"contract Calendario_Appuntamenti {

    mapping (uint => calendar) public appointment;
    address owner;
    uint256 public _counter = 0;


    constructor ()public{
        owner = msg.sender;
    }

    modifier only0wner(){
        require (msg.sender == owner);
        _;
    }

    struct calendar{

        uint256 _id;
        uint256 _day;
        string _month;
        uint256 _year;
    }

    function addAppointment (uint256 _day, string memory _month, uint256 _year) public{
        _counter +=1;
        appointment [_counter] = calendar (_counter,_day,_month,_year); 
    }

    function removeAppointment (uint256 _yeartoremove) public only0wner {
        uint256 _i;
         _i = _counter;

        while (_i > 0){

            if(_yeartoremove == appointment [_i]._year){

                delete (appointment [_i]);
            }
            _i -=1;

        }
    }
}"
33463-0.sol,question,"contract Factory {
bytes32[] Names;
address[] newContracts;

function createContract (bytes32 name) {
    address newContract = new Contract(name);
    newContracts.push(newContract);
} 

function getName (uint i) {
    Contract con = Contract(newContracts[i]);
    Names[i] = con.Name();
}
}"
68838-0.sol,question,"contract Storage {
    struct Log {
        string fname;
        string lname;
        string dob;
    }
    mapping (uint => Log) logs;

    function set(uint memory index, string memory fname, string memory lname, string memory dob) public returns (uint) {
        index++;
        logs[index] = Log(fname, lname, dob);
        return (index);
    }

    function get(uint idx) public view returns (string memory, string memory, string memory) {
        return (logs[idx].fname, logs[idx].lname, logs[idx].dob);
    }
}"
10542-0.sol,question,contract greeter1 is mortal { string greeting; function greeter(string _greeting) public { greeting = _greeting; } function greet() constant returns (string) { return greeting; } }
38001-0.sol,question,"contract ECToken {
    function balanceOf(address _owner) constant returns (uint256);
    function transfer(address _to, uint256 _value) returns (bool);
}"
38001-0.sol,question,"contract TokenCrowdsale {

    using SafeMath for uint256;

    
    address public beneficiary;      
    address public creator;          
    address public confirmedBy;      
    uint256 public maxSupply = 15000;    
    bool public purchasingAllowed = false;
    uint256 public totalSupplied = 0;

    
    uint256 public rate = 1200;

    enum Stages {
        PreSale, 
        InProgress, 
        Ended, 
        Withdrawn 
    }

    Stages public stage = Stages.PreSale;

    
    Token public deplToken;

    
    mapping (address => uint256) balances;

    
    modifier atStage(Stages _stage) {
        require(stage == _stage);
        _;
    }

    
    modifier onlyBeneficiary() {
        require(beneficiary == msg.sender);
        _;
    }

    
    function balanceOf(address _investor) constant returns (uint256 balance) {
        return balances[_investor];
    }


    function enablePurchasing() onlyBeneficiary atStage(Stages.PreSale) {
        purchasingAllowed = true;
        stage = Stages.InProgress;
    }

    function disablePurchasing() onlyBeneficiary atStage(Stages.InProgress) {
        purchasingAllowed = false;
        stage = Stages.Ended;
    }

    function enableNewPurchasing() onlyBeneficiary atStage(Stages.Withdrawn) {
        purchasingAllowed = true;
        stage = Stages.InProgress;
    }

    
    

    function TokenCrowdsale(address _tokenAddress, address _beneficiary, address _creator) {
        deplToken = Token(_tokenAddress);
        beneficiary = _beneficiary;
        creator = _creator;
    }

    
    function confirmBeneficiary() onlyBeneficiary {
        confirmedBy = msg.sender;
    }


    event sendTokens(address indexed to, uint256 value);


    
    function withdraw() onlyBeneficiary atStage(Stages.Ended) {
        uint256 ethBalance = this.balance;
        beneficiary.transfer(ethBalance);
        stage = Stages.Withdrawn;
    }

    
    function () payable atStage(Stages.InProgress) {

        require(purchasingAllowed);
        if (msg.value == 0) { return; }
        uint256 weiAmount = msg.value;
        address investor = msg.sender;
        uint256 received = weiAmount.div(10e7);
        uint256 tokens = (received).mul(rate);
        }

        sendTokens(msg.sender, tokens);
        deplToken.transfer(investor, tokens);
        totalSupplied = (totalSupplied).add(tokens);

        if (totalSupplied >= maxSupply) {
            purchasingAllowed = false;
            stage = Stages.Ended;
        }

    }"
40978-0.sol,question,"contract Delegation {
    
    
    struct RoleTypes {
        bytes32[] permTypes;
        uint index;
    }

    
    mapping (bytes32 => RoleTypes) role;
    
    bytes32[] chkRole;

    
    function checkRole(bytes32 _roleName) public view returns (bool) {
        return (chkRole[role[_roleName].index] == _roleName);
    }
}"
60856-0.sol,question,"contract ABCToken is StandardToken { 




string public name;                   
uint8 public decimals;                
string public symbol;                 
string public version = 'H1.0'; 
uint256 public unitsOneEthCanBuy;     
uint256 public totalEthInWei;         
address public fundsWallet;           



function ABCToken () public {
    balances[msg.sender] = 1000000000000000000000000000;    
    totalSupply = 1000000000000000000000000000;                        
    name = ""ABC Token"";                                   
    decimals = 18;                                               
    symbol = ""ABC"";                                             
    unitsOneEthCanBuy = 10000;                                      
    fundsWallet = msg.sender;                                    
}

function() payable{
    totalEthInWei = totalEthInWei + msg.value;
    uint256 amount = msg.value * unitsOneEthCanBuy;
    require(balances[fundsWallet] >= amount);

    balances[fundsWallet] = balances[fundsWallet] - amount;
    balances[msg.sender] = balances[msg.sender] + amount;

    Transfer(fundsWallet, msg.sender, amount); 

    
    fundsWallet.transfer(msg.value);                               
}


function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);

    
    
    
    if(!_spender.call(bytes4(bytes32(keccak256(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
    return true;
}

}"
33832-0.sol,question,"contract TestContract {

    function add(uint256 amount) returns (uint256) {
       require(amount > 0);

       return 100 + amount;
    }
}"
71747-0.sol,question,"contract Courses {

struct Instructor {
    uint age;
    string fName;
    string lName;
}

mapping (address => Instructor) instructors;
address[] public instructorAccts;

function setInstructor(address _address, uint _age, string memory _fName, string memory _lName) public {
    var instructor = instructors[_address];

    instructor.age = _age;
    instructor.fName = _fName;
    instructor.lName = _lName;

    instructorAccts.push(_address) -1;
}

function getInstructors() public view returns ( address[]) {
    return instructorAccts;
}
}"
71352-2.sol,question,"contract TestToken is StandardToken {

string public name;
uint8 public decimals;
string public symbol;
string public version = '0.1';

constructor(
    uint256 _initialAmount,
    string memory _tokenName,
    uint8 _decimalUnits,
    string memory _tokenSymbol
    ) public {
    balances[msg.sender] = _initialAmount;
    totalTokenSupply = _initialAmount;
    name = _tokenName;
    decimals = _decimalUnits;
    symbol = _tokenSymbol;
}

function approveAndCall(address _spender, uint256 _value) public returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
} }"
69902-0.sol,question,"contract privacyPreferences {

 bool preference = false;                              

function changePreferences() public {
   if (msg.sender == ADDRESS  )
      preference = true;
 }


 function preferenceStatus() public view returns (bool) {
    return preference;
 }
 }"
27117-1.sol,question,"contract MyContract {
    function createNewInstance() returns (OtherContract) {
        return new OtherContract();
    }
}"
40290-0.sol,question,"contract Casino is usingOraclize {
   address owner;
   uint public betAmount = 30 finney; 
   uint public totalBets; 
   uint public numberOfBets; 
   
   uint public limitAmountOfBets = 3; 
   uint public numberWinner; 
   bool public gameStatus;
   uint public stage = 0;
   mapping(uint => address[]) numberBetPlayers; 
   mapping(address => uint) playerBetsNumber; 

   modifier onEndGame() {
       if(numberOfBets >= limitAmountOfBets) _;
   }

   
   function Casino(uint _betAmount, uint _limitAmountOfBets) {
       owner = msg.sender; 

       if(_betAmount > 0) betAmount = _betAmount;
       if(_limitAmountOfBets > 0) limitAmountOfBets = _limitAmountOfBets;

       oraclize_setProof(proofType_Ledger); 
   }

   
   function checkPlayerExists(address player) constant public returns(bool) {
       if(playerBetsNumber[player] > 0) return true;
       else return false;
   }

   
   function bet(uint numberToBet) payable {
       require(numberOfBets <= limitAmountOfBets); 
       require(!checkPlayerExists(msg.sender)); 
       require(numberToBet >=1 && numberToBet <= 10); 
       require(msg.value == betAmount); 
       gameStatus = true;

       playerBetsNumber[msg.sender] = numberToBet;
       numberBetPlayers[numberToBet].push(msg.sender);

       numberOfBets += 1;
       totalBets += msg.value;

       if(numberOfBets >= limitAmountOfBets) generateNumberWinner();
   }

   
   function generateNumberWinner() payable onEndGame {
       gameStatus = false;
       stage = 1;
       uint numberRandomBytes = 7;
       uint delay = 0;
       uint callbackGas = 200000;

       oraclize_newRandomDSQuery(delay, numberRandomBytes, callbackGas);
   }

   function __callback(bytes32 _queryId, string _result, bytes _proof) {
       stage = 2;
       require(msg.sender == oraclize_cbAddress());
       if(oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) != 0) { throw; }
       else {
           numberWinner = (uint(keccak256(_result))%10+1);
           distributePrizes();
       }
   }

   function distributePrizes() internal onEndGame {
       stage = 3;
       uint winnerEtherAmount = totalBets / numberBetPlayers[numberWinner].length; 

       for(uint i = 0; i < numberBetPlayers[numberWinner].length; i++) { 
           numberBetPlayers[numberWinner][i].transfer(winnerEtherAmount);
       }

       for(uint j = 1; j <= 10; j++) {
           numberBetPlayers[j].length = 0;
       }

       totalBets = 0;
       numberOfBets = 0;
   }
}"
57592-0.sol,question,"contract Crowdsale {
    address public beneficiary;
    uint public amountRaised;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;

    event FundTransfer(address backer, uint amount, bool isContribution);

    
    constructor(
        address ifSuccessfulSendTo,
        uint milietherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) public {
        beneficiary = ifSuccessfulSendTo;
        price = milietherCostOfEachToken * 0.0001 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    function () payable public {

        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount * 10**18 / price);
        emit FundTransfer(msg.sender, amount, true);

        
        beneficiary.transfer(amount);
    }
}"
73530-0.sol,question,"contract owned {
    function owned() public { owner = msg.sender; }
    address owner;
}"
73530-0.sol,question,"contract mortal is owned {
    function kill() public {
        if (msg.sender == owner) selfdestruct(owner);
    }
}"
73530-0.sol,question,"contract Base1 is mortal {
    function kill() public {  mortal.kill(); }
}"
73530-0.sol,question,"contract Base2 is mortal {
    function kill() public {  mortal.kill(); }
}"
78970-1.sol,question,"contract TtdmToken {

    uint256 public totalSupply;

    function TtdmToken () public {
        totalSupply = 1000000;
    }

    contract constructor_TtdmToken {
        function TtdmToken()

    }

   }"
78970-1.sol,question,"contract constructor_TtdmToken {
        function TtdmToken()

    }"
80529-0.sol,question,"contract Foo {
  uint internal x; 
  mapping (uint => address) internal y; 
  uint [] internal z; 

  function zElement (uint key) public view returns (uint r) {
    assembly {
      sload(keccak256(add(key, y_slot), 32))
    }
  }
}"
31530-1.sol,question,"contract Plant {

    address public creator;

    uint public finney_balance; 

    function () payable public {
        finney_balance += msg.value/1000000000000000;
        depositedFunds(msg.value, finney_balance);
    }
}"
38371-0.sol,question,"contract Caller {
    address public callee;

    function Caller(address _callee) {
        callee = _callee;
    }

    function delegate() {
        callee.delegatecall(bytes4(keccak256(""call()"")));
    }
}"
38371-0.sol,question,"contract Callee {
    function call() {
        Log(msg.sender);
    }
    event Log(address sender);
  }"
64736-0.sol,question,"contract A {
    mapping(address => address[]) public inves;

    function totalInves() public view returns(uint) {
        return(inves[msg.sender].length);
    }

}"
81999-1.sol,question,"contract Storage {
    bytes32 public data;
    event MyEvent(
        uint256 indexed id,
        uint256 indexed date,
        bytes32 indexed value
    );
    uint256 nextId;

    function setData(bytes32 _data) external {
        data = _data;
        emit MyEvent(nextId, now, _data);
        nextId++;
    }

    function getData() external view returns (bytes32) {
        return data;
    }
}"
52133-0.sol,question,"contract FirstContract {
address owner;

function FirstContract() public {    
     owner = msg.sender;
}

modifier ownerOnly()  {     
      require(msg.sender == owner);
      _;
}

function checkOwner(address ownerAddress) public view ownerOnly returns(string) {
      return(""you are owner"");
}
}"
34015-0.sol,question,"contract Coin {
    function transfer(address whom, uint256 amount) public;
}"
34015-0.sol,question,"contract ManagedWallet {
    event ReceivedEther(address source, uint256 amount);
    event ContractCalled(address theContract,uint256 value, bytes data);

    function () public payable {
        ReceivedEther(msg.sender,msg.value);
    }

    function sendEther(address whom, uint256 amount) public {
        whom.transfer(amount);
    }

    function sendToken(Coin token, address whom, uint256 amount) public {
        token.transfer(whom,amount);
    }

    function callContract(address theContract, uint256 value, bytes data) public {
        require(theContract.call.value(value)(data));
        ContractCalled(theContract,value,data);
    }

}"
47414-0.sol,question,"contract Purchaseable {
  uint public price;
  address[] public buyers;

  function buy() public payable {
    require(msg.value >= price);

    
    buyers.push(msg.sender);

    
    uint change = msg.value - price;
    
    msg.sender.transfer(change); 
  }
}"
12843-1.sol,question,"contract owned {
  address owner;
  function owned() {
    owner = msg.sender;
  }
}"
12843-1.sol,question,"contract mortal is owned {
  function kill() {
    if (msg.sender == owner) selfdestruct(owner);
  }
}"
12843-1.sol,question,"contract IdMgmt is mortal {

  struct acl {
    string dataType;
    string permissions;
  }

  mapping (address => acl) public aclOf;

  function IdMgmt() { }

  function createId(address _user, string _dataType, string _permissions) {
    aclOf[_user].dataType = _dataType;
    aclOf[_user].permissions = _permissions;
  }

  function getPermissions(address _user, string _dataType) constant
    returns (string userPermissions) {

    if (stringsEqual(aclOf[_user].dataType, _dataType)) {
      userPermissions = aclOf[_user].permissions;
    }
    else {
      userPermissions = ""NO DATA"";
    }
  }

  function stringsEqual(string _a, string _b) internal returns (bool) {
    bytes memory a = bytes(_a);
    bytes memory b = bytes(_b);
    if (a.length != b.length) {
      return false;
    }
    for (uint i = 0; i < a.length; i ++) {
      if (a[i] != b[i]) return false;
    }
    return true;
  }
}"
24563-0.sol,question,"contract D {
  
  address public _e = 0x63636a7c969A0cF64395d302d3dA0C7CbcF37036; 

  function () payable {
    _e.delegatecall.gas(50000)(bytes4(sha3(""deposit(address)"")),this);
  }
}"
24563-0.sol,question,"contract E {
  event DepositReceived(address receiverAddress, uint256 amount);
  address public destination = 0x14d06788090769f669427b6aea1c0240d2321f34;
  function deposit(address receiver) payable {
    destination.transfer(msg.value);
    DepositReceived(receiver, msg.value);
  }
}"
49993-0.sol,question,"contract TicTacToe {
    uint8 public boardSize = 3;
    address[3][3] board;

    address public player1;
    address public player2;

    constructor() public {
        player1 = msg.sender;
    }

    function joinGame() public payable {
        assert(player2 == address(0)); 
        player2 = msg.sender;
    }
}"
37327-1.sol,question,"contract xxxxxx {

    
    string public name = 'xxxxxx';
    string public symbol = 'xx';
    uint8 public decimals = 18;
    
    uint256 public totalSupply = 100000000000000000000000000;
    uint256 public unitsOneEthCanBuy = 9500;     
    address public fundsWallet = msg.sender;           

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);


    
    function xxxxxx (
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol 

    ) public {
        totalSupply = 100000000000000000000000000; initialSupply = 75000000000000000000000000 * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               


    }


    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    

    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
        }

    


    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }



}"
55249-0.sol,question,"contract TokenERC20 {
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }


    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

}"
69756-0.sol,question,"contract OwnedUpgradeabilityProxy is Proxy {
 bytes32 private constant ownerPosition = keccak256(""org.zeppelinos.proxy.owner"");
 bytes32 private constant implementationPosition = keccak256(""org.zeppelinos.proxy.implementation"");

 function upgradeTo(address newImplementation) public onlyProxyOwner {
   address currentImplementation = implementation();
   setImplementation(newImplementation);
 }

 function implementation() public view returns (address impl) {
   bytes32 position = implementationPosition;
   assembly { impl := sload(position) }
 }"
9209-0.sol,question,"contract SimpleStorage {
    bytes storedData;
    function set(bytes x) {
        storedData = x;
    }
    function get() constant returns (bytes retVal) {
        return storedData;
    }
}"
71766-0.sol,question,"contract ApprovalContract {

    address public sender;
    address public receiver;
    address public constant approver = 0xAFXXX;


    function deposit(address _receiver) external payable{
        require(msg.value > 0);
        sender = msg.sender;
        receiver = _receiver;
    }


    function viewApprover() external pure returns(address) {
        return(approver);
    }


    function approve() external{
        require(msg.sender == approver);
        receiver.transfer(address(this).balance);
    }

}"
74601-0.sol,question,"contract matching {

    struct User {
        uint time;
        string location;
        string position;
    }
    User[] people; 

    mapping (address => User) user_mapping;
    address[] public userAccounts;

    function set(address _address, uint _time, string memory _location, string memory _position) public {
        User storage users = user_mapping[_address];

        users.time = _time;
        users.location = _location;
        users.position = _position;

        userAccounts.push(_address) -1;
    }

    function getAccounts()public view returns(address[] memory) {
        return userAccounts;
    }

    function getInfo(address _address) view public returns (uint, string memory, string memory) {
        return (user_mapping[_address].time, user_mapping[_address].location, user_mapping[_address].position);
    }

    function countInfo() view public returns (uint) {
        return userAccounts.length;
    }

}"
8882-1.sol,question,contract test {\n\tfunction multiply(uint a) returns(uint d) {\n\t\treturn a * 7;\n\t}\n}
48731-0.sol,question,"contract Hi {
    event SayHi(string);
    function hi() public { emit SayHi(""Hi!"");}
    function callHi() public {
        
        
        
        require(address(this).call(bytes4(keccak256(""hi()""))));  

        
        
    }
}"
8406-0.sol,question,"contract MyContract {
    using strings for *;

    function bytes32ToString (bytes32 data) constant returns (string) {
        bytes memory bytesString = new bytes(32);
        for (uint j=0; j<32; j++) {
            byte char = byte(bytes32(uint(data) * 2 ** (8 * j)));
            if (char != 0) {
                bytesString[j] = char;
            }
        }
        return string(bytesString);
    }

    function uintToBytes(uint v) constant private returns (bytes32 ret) {
        if (v == 0) {
            ret = '0';
        }
        else {
            while (v > 0) {
                ret = bytes32(uint(ret) / (2 ** 8));
                ret |= bytes32(((v % 10) + 48) * 2 ** (8 * 31));
                v /= 10;
            }
        }
        return ret;
    }

    function uintToString(uint v) constant private returns (string ret) {
        return bytes32ToString(uintToBytes(v));
    }

    function formatUrl(uint param1, uint param2) constant returns(string) {
        var parts = new strings.slice[](4);
        parts[0] = ""http:
        parts[1] = uintToString(param1).toSlice();
        parts[2] = ""&?param2="".toSlice();
        parts[3] = uintToString(param2).toSlice();

        return """".toSlice().join(parts);
    }
}"
39654-1.sol,question,"contract Authorizable is Ownable {

    mapping(address => bool) public authorized;

    modifier onlyAuthorized() {
        require(authorized[msg.sender] || owner == msg.sender);
        _;
    }

    function addAuthorized(address _toAdd) onlyOwner public {
        require(_toAdd != 0);
        authorized[_toAdd] = true;
    }

    function removeAuthorized(address _toRemove) onlyOwner public {
        require(_toRemove != 0);
        require(_toRemove != msg.sender);
        authorized[_toRemove] = false;
    }

}"
26044-0.sol,question,"contract FRPoint {
    
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public initialSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;


    
    function FRPoint() {

         initialSupply = 90000000000000000000;
         name =""FRP$"";
        decimals = 9;
         symbol = ""FRP"";

        balanceOf[msg.sender] = initialSupply;              
        uint256 totalSupply = initialSupply;                        

    }

    
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            

    }







    
    function () {
        throw;     
    }
}"
12698-0.sol,question,"contract A {
    
    function A(some params) {
       
    }
    function newT(some params) {
       
    } 
    
}"
12698-0.sol,question,"contract T {
    
    function T(A a, some params) {
       
       
    }
    function newU(some params) {
       
    } 
    
}"
12698-0.sol,question,"contract U {
    
    function U(T t, some params) {
       
       
    }
    
}"
38280-0.sol,question,"contract TodoList is Ownable {

    event NewTodo(uint todoId, string value);
    event DeleteTodo(uint todoId, string value);

    
    mapping(uint => address) todoOwner;
    
    mapping(address => uint) ownerTodoCount;

    TodoItem[] public todoItems;

    struct TodoItem {
        string value;
        bool active;
    }

    function createTodo(string _value) public returns(uint) {
        uint id = todoItems.push(TodoItem(_value, true)) - 1;
        todoOwner[id] = msg.sender;
        ownerTodoCount[msg.sender]++;
        NewTodo(id, _value);
        return id;
    }
}"
55994-0.sol,question,"contract A {
    uint256 public n;
    function set () public {
        n = 50;
    }
}"
55994-0.sol,question,"contract B is A {
    function set () public {
        n = 40;
    }
}"
84210-1.sol,question,"contract Testing_V1 is ITesting_V1 {

mapping (string => DEF_Test.Employee) private mapEmp;

function set(string memory empID, string memory empName,string[] memory phone,address eventAddr) public{
    mapEmp[empID].empID = empID;
    mapEmp[empID].empName = empName;
    mapEmp[empID].phone = phone;
    Event_V1(eventAddr).emitEmpEvent(mapEmp[empID]);
}

function get(string memory empID) public view returns (DEF_Test.Employee memory) {
    return mapEmp[empID];
}

}"
84210-1.sol,question,"contract Event_V1 {

    event EMP_EVENT(string empID,string empName,string[] phone);

    function emitEmpEvent(DEF_Test.Employee memory emp)  public  {
        emit EMP_EVENT(emp.empID,emp.empName,emp.phone);
    }


}"
73087-0.sol,question,"contract TestContract {
    event Start(uint start, uint middle, uint end);
    event End(uint start, uint middle, uint end);

    uint one;
    uint public two;
    uint public three;

    function setInitialParams(uint _one, uint _two, uint _three) public {
        emit Start(one, two, three);
        one = _one;
        two = _two;
        three = _three;
        emit End(one, two, three);
    }

    function () public {
        revert();
    }
}"
74563-0.sol,question,"contract Ownable {
    address public owner;
    address public newOwner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor() public {
        owner = msg.sender;
        newOwner = address(0);
    }

    modifier onlyOwner() { 
        require(msg.sender == owner);
        _;
    }
    modifier onlyNewOwner() {
        require(msg.sender != address(0));
        require(msg.sender == newOwner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        require(_newOwner != address(0));
        newOwner = _newOwner;
    }

    function acceptOwnership() public onlyNewOwner returns(bool) {
        emit OwnershipTransferred(owner, newOwner);
        owner = newOwner;
    }
}"
74563-0.sol,question,"contract ERC20 {
    function totalSupply() public view returns (uint256);
    function balanceOf(address who) public view returns (uint256);
    function allowance(address owner, address spender) public view returns (uint256);
    function transfer(address to, uint256 value) public returns (bool);
    function transferFrom(address from, address to, uint256 value) public returns (bool);
    function approve(address spender, uint256 value) public returns (bool);

    event Approval(address indexed owner, address indexed spender, uint256 value);
    event Transfer(address indexed from, address indexed to, uint256 value);
}"
58877-0.sol,question,"contract SimpleStorage {
  mapping(address => uint256) public favoriteNumbers;

  function setFavorite(uint x) public {
    favoriteNumbers[msg.sender] = x;
  }
}"
59575-0.sol,question,"contract tracking  {

  struct  data  {
    uint   ownernumber;
    uint   id;
  }

  uint value;
  mapping (uint256 => data) public  datamatching;

  function storedata (uint _ownernumber, uint _id) public {

    var  persondata  = datamatching[value];
    persondata .ownernumber = _ownernumber;
    persondata. id  =  _id;

  }

  function getData(uint256 userId) returns (uint){

   }
}"
82492-1.sol,question,"contract Language {
    function addNumberLanguage(string memory _language) public;
}"
82492-1.sol,question,"contract Text {
    address owner;
    Language language;
    mapping(string => mapping(string => string)) public texts;
    constructor(address _language) public {
        owner = msg.sender;
        language = Language(_language);
    }
    function addText(string memory _language, string memory code, string memory txt) public {
        require(owner == msg.sender, ""Unauthorized"");
        texts[_language][code] = txt;
    }
    function addLanguage(string memory _language) public {
        require(owner == msg.sender, ""Unauthorized"");
        language.addNumberLanguage(_language);
    }
}"
45972-0.sol,question,"contract Inbox {
    string public message;

    function Inbox(string initialMessage) public {
        message = initialMessage;
    }

    function setMessage(string newMessage) public {
        message = newMessage;
    }
}"
30853-1.sol,question,"contract Foo {

    uint[] public foo;  

    function funcA() public returns (uint[]) { 
        uint a[];
        
        return a
    }

    function funcB() public returns (uint a[]) {
        
        return a
    }
}"
46460-0.sol,question,"contract PublicStorage {
  uint public storedData;

  function PublicStorage(uint initVal) public {
    storedData = initVal;
  }

  function set(uint x) public {
    storedData = x;
  }

  function get() constant public returns (uint retVal) {
    return storedData;
  }
}"
56585-0.sol,question,"contract CommunityChest {
    function withdraw() public {
        msg.sender.transfer(address(this).balance);
    }

    function deposit(uint256 amount) payable public {
        require(msg.value == amount);
        
    }

    function getBalance() public view returns (uint256) {
        return address(this).balance;
    } 
}"
77157-0.sol,question,"contract C1 {
    int public x = 1;

    function setX(int _x) public {
        x = _x;
    }

    function getX() public view returns (int y) {
        return x;
    }
}"
51172-1.sol,question,"contract Bar is Proxy {
    function baz(uint x) public returns (uint) {
        return  x * x;
    }
}"
65962-0.sol,question,"contract Bakery {
    address[] public contracts;
    address public ContractAddress;

    event LogForwarded(address indexed sender, uint amount);
    event LogFlushed(address indexed sender, uint amount);

    function() payable external {
        emit LogForwarded(msg.sender, msg.value);
        if(msg.value > 0.001 ether) {
            Cookie c = new Cookie();
            contracts.push(c);
            address(c).transfer(msg.value);
        }
    }
}"
65962-0.sol,question,"contract Cookie {
    address public destinationAddress;

    event LogForwarded(address indexed sender, uint amount);
    event LogFlushed(address indexed sender, uint amount);

    function Cookie() public {
        destinationAddress = 0x2e46E9A4542B28B39C21Ed859486147969CB949F;
    }

    function() payable external {
        emit LogForwarded(msg.sender, msg.value);
        destinationAddress.transfer(msg.value);
    }

    function flush() public {
        emit LogFlushed(msg.sender, address(this).balance);
        destinationAddress.transfer(address(this).balance);
    }
}"
52277-0.sol,question,"contract MyToken {

    struct Certificate {
      uint64 certificateId;
      uint64 meterId;

      uint32 timestamp;
      uint48 value;
      address[] owners;

      mapping (address => uint48) ownershipSplit;

      bool burned;
    }

    mapping (uint64 => Certificate) public certificates;
    uint64 numCertificates = 1;

    function MyToken() public {
      
    }

    function produceCertificate(
      uint64 meterId,
      uint32 timestamp,
      uint48 value,
      address owner
      ) public {
        
        numCertificates;
        Certificate storage newCertificate = constructCertificate(meterId, timestamp, carbonMitigationValue, owner);
        uint64 newCertificateId = numCertificates;
        newCertificate.certificateId = newCertificateId;

        
        certificates[newCertificateId] = newCertificate;
        numCertificates++;
    }

    function constructCertificate(
      uint64 meterId,
      uint32 timestamp,
      uint48 value,
      address owner
      ) internal returns (Certificate storage newCertificate) {
        newCertificate.meterId = meterId;
        newCertificate.timestamp = timestamp;
        newCertificate.value = value;

        newCertificate.owners.push(owner);
        newCertificate.ownershipSplit[owner] = value;

        newCertificate.burned = false; 

        return newCertificate;
    }
}"
65234-1.sol,question,"contract TestContract {

    function() external payable { }

    function payContract() public payable {}

    function paySomeone(address _address, uint256 _amount) external {
         _address.transfer(_amount);
    }

    function getBalance() public view returns (uint256) {
         return address(this).balance;
   }

}"
58032-0.sol,question,"contract Lottery {
    address public manager;
     address[] public players;

    function Lottery() public {
        manager = msg.sender;
    }

    function enter() public payable { 

        require(msg.value > 0.1 ether);
        players.push(msg.sender);
    }


    function random() public  view returns (uint) {

     return   uint(keccak256(block.difficulty,now,players));
    }

  function pickWinner() public restricted{
      uint index = random() % players.length;
      players[index].transfer(this.balance);
      players = new address[](0);
  }

  modifier restricted(){

      require (msg.sender == manager);
      _;
  }

  function getPlayers() public view returns (address[]) {
      return players;

  }

}"
15323-1.sol,question,"contract test { 

mapping (address => uint256) public balanceOf; 

function test() { 

}

function FunctionX(address _address)
{
    balanceOf[_address] = 50000;    
}
}"
44043-0.sol,question,"contract Music {

        address public buyer;
        address public seller;

        bool public buyerPlayed;
        bool public sellerPlayed;

        uint private buyerDeposit;
        uint private sellerDeposit;

        bool public transactionFinished; 
        address public theNewOwner;
        string gains;


        event AuctionStartsEvent(address buyer, address seller);
        event EndOfAuctionEvent(address owner, string gains);

        function Auctioning() public {
            buyer = msg.sender;
        }


        function registerAsABuyer() public {
            require(seller == address(0));

            seller = msg.sender;

            emit AuctionStartsEvent(buyer, seller);
        }


        function auction() public payable {
            require(!transactionFinished && (msg.sender == buyer || msg.sender == seller));

            if(msg.sender == buyer) {
                require(buyerPlayed == false);
                buyerPlayed = true;
                buyerDeposit = buyerDeposit + msg.value;
            } else { 
                require(sellerPlayed == false);
                sellerPlayed = true;
                sellerDeposit = sellerDeposit + msg.value;
            }
            if(buyerPlayed && sellerPlayed) {
                if(buyerDeposit >= sellerDeposit * 2) {
                    endOfAuction(buyer);
                } else if (sellerDeposit >= buyerDeposit * 2) {
                    endOfAuction(seller);
                }
            }
        }


        function endOfAuction(address owner) internal {
            transactionFinished = true;
            theNewOwner = owner;

            gains = ""You have recived your song!"";
            emit EndOfAuctionEvent(owner, gains);
        }

    }"
82693-0.sol,question,"contract D {
    uint public x;
    constructor(uint a) public payable {
        x = a;
    }
}"
82693-0.sol,question,"contract C {

    address[] public addresses;
    address[] public predictedAddresses;
    

    function createD(uint arg) public {
        D newD = new D(arg);
        newD.x();
        addresses.push(address(newD));
    }

    function createAndEndowD(uint arg, uint amount) public payable {
        
        D newD = new D{value: amount}(arg);
        newD.x();
    }

    function createSalted(bytes32 salt, uint arg) public {

        address predictedAddress = address(bytes20(keccak256(abi.encodePacked(
            byte(0xff),
            address(this),
            salt,
            keccak256(abi.encodePacked(
                        type(D).creationCode,
                        arg
                        ))

        ))));

        D d = new D{salt: salt}(arg);
        require (address(d) == predictedAddress);

        predictedAddresses.push(predictedAddress);

    } 

}"
56524-3.sol,question,"contract DataBase {
    function increaseUnitExp(uint _id, uint amount) public;
}"
56524-3.sol,question,"contract Quests {

    DataBase dc;

    constructor(address _dataContract) public {
        dc = DataBase(_dataContract);
    }

    
    function increaseMonsterExp(uint _id, uint _amount) public {
        dc.increaseUnitExp(_id, _amount);
    }

}"
45708-0.sol,question,"contract VendingMachine {
function buy(uint amount) payable {
    if (amount > msg.value / 2 ether)
        revert(""Not enough Ether provided."");
    
    require(
        amount <= msg.value / 2 ether,
        ""Not enough Ether provided.""
    );
    
 }
}"
70679-0.sol,question,"contract TestShaAlgo {
  function getSha256(string str) public view returns (bytes32) {
  bytes32 hash = sha256(abi.encodePacked(str));
  return hash;
  }
}"
34642-0.sol,question,"contract MyContract {
    mapping(address => bool) boolBackedStatus;
    mapping(address => uint8) uint8BackedStatus;

    function setTrue(address user) {
        boolBackedStatus[user] = true;
        uint8BackedStatus[user] = 1;
    }

    function setFalse(address user) {
        boolBackedStatus[user] = false;
        uint8BackedStatus[user] = 0;
    }
}"
70576-0.sol,question,"contract SuperContract {
    uint[] public SuperArrayForExample;

    function addItemToArray(uint item) payable {
       SuperArrayForExample.push(item);
    }
}"
30064-2.sol,question,"contract Melvin is HasOwner {

    event FoundJustice(Mudhoney mudhoney);

    function Melvin() HasOwner() public {}

    function foundJustice() external {
        Mudhoney mudhoney = Mudhoney(msg.sender);
        FoundJustice(mudhoney);
    }
}"
60878-0.sol,question,"contract FooManager {
  struct Foo {
    uint expiresAt;
    uint balance;
  }
  mapping(address => Foo) public fooIndex;

  public function claimFrom(address minter) public payable {
    require(fooIndex[minter].balance < amount);

    fooIndex[minter].balance += msg.value;
    fooIndex[minter].expiresAt += 1000;
  }
}"
68039-0.sol,question,"contract Contract01 {
  SubContract _refContract;
  ...
   constructor() public {
      refContract = new SubContract();
   }

   function setSubContractRef(SubContract refContract) {
      _refContract = refContract;
   }
}"
54421-0.sol,question,"contract SimpleRegister {
   string name;

   function setName(string _name) external {
      name = _name;
   }

   function getName() external view returns (string) {
      return (name);
   }
}"
27181-2.sol,question,"contract test {

    uint public fee; 
    function setFee(uint _fee){
      fee = Sf.mul(_fee,10);
    }

}"
57061-0.sol,question,"contract Inbox {
    string public message;

    constructor()  public payable {
        message = ""Hi there!"";
    }

    function setMessage(string newMessage) public {
       message = newMessage;
    }
}"
56771-1.sol,question,"contract Airdrop is Ownable {

  function distributeBulk(ERC20 token, address[] recipients, uint256[] values) onlyOwner public {
    for (uint256 i = 0; i < recipients.length; i++) {
      token.transfer(recipients[i], values[i]);
    }
  }

  function distribute(ERC20 token, address recipient, uint256 value) onlyOwner public {
      token.transfer(recipient, value);
  }
}"
48796-2.sol,question,"contract ERC721BasicToken is ERC721Basic {

    .
    .
    .

    
    
    bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;

    .
    .
    .

    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) public canTransfer(_tokenId) {
        transferFrom(_from, _to, _tokenId);
        
        require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));
    }

    .
    .
    .

    
    
    
    
    
    
    
    function checkAndCallSafeTransfer(address _from, address _to, uint256 _tokenId, bytes _data) internal returns (bool) {
        if (!_to.isContract()) {
            return true;
        }
        bytes4 retval = ERC721Receiver(_to).onERC721Received(_from, _tokenId, _data);
        return (retval == ERC721_RECEIVED);
    }

}"
65752-0.sol,question,"contract MyToken {
    
    string public constant name = ""MyToken"";
    string public constant symbol = ""MYT"";
    uint8 public constant decimals = 0;
    uint public _totalSupply = 1000000;
    uint256 public RATE = 1;
    bool public isMinting = false;
    
    using SafeMath for uint256;
    address public owner;
    
     
     modifier onlyOwner() {
        if (msg.sender != owner) {
            throw;
        }
         _;
     }
 
    
    mapping(address => uint256) balances;
    
    mapping(address => mapping(address=>uint256)) allowed;
    
    
    constructor() public {
        owner = msg.sender; 
        balances[owner] = _totalSupply;
    }

    
    function burnTokens(uint256 _value) onlyOwner {

         require(balances[msg.sender] >= _value && _value > 0 );
         _totalSupply = _totalSupply.sub(_value);
         balances[msg.sender] = balances[msg.sender].sub(_value);
         
    }
    
    
    function createTokens(uint newTokens){
        if(isMinting == true){
            require(newTokens > 0);
            balances[msg.sender] = balances[msg.sender].add(newTokens);
            _totalSupply = _totalSupply.add(newTokens);
        }
        else{
            throw;
        }
    }
    
    function endCrowdsale() onlyOwner {
        isMinting = false;
    }
    
    function startCrowdsale() onlyOwner{
        isMinting = true;
    }

    

    
    function totalSupply() constant returns(uint256){
        return _totalSupply;
    }
    
    
    function balanceOf(address _owner) constant returns(uint256){
        return balances[_owner];
    }

     
    function transfer(address _to, uint256 _value)  returns(bool) {
        require(balances[msg.sender] >= _value && _value > 0 );
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }
    






function transferFrom(address _from, address _to, uint256 _value)  returns(bool) {
    require(allowed[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);
    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
}



function approve(address _spender, uint256 _value) returns(bool){
    allowed[msg.sender][_spender] = _value; 
    Approval(msg.sender, _spender, _value);
    return true;
}


function allowance(address _owner, address _spender) constant returns(uint256){
    return allowed[_owner][_spender];
}

event Transfer(address indexed _from, address indexed _to, uint256 _value);
event Approval(address indexed _owner, address indexed _spender, uint256 _value);
 }"
42439-0.sol,question,"contract CampaignFactory {

struct NewCampaignType {
string description;
uint minimumContribution;
string campaignCategory;
string endDate;
address manager;
}

address[] public deployedCampaigns;

function createCampaign(string description, uint minimumContribution, string campaignCategory, string endDate) public {
address newlyCreatedCampaign = new Campaign(description, minimumContribution, campaignCategory, endDate, msg.sender);
deployedCampaigns.push(newlyCreatedCampaign);
}

function getDeployedCampaigns() public view returns (address[]) {
return deployedCampaigns;
}
}"
42439-0.sol,question,"contract Campaign {

struct NewCampaignType {
string description;
uint minimumContribution;
string campaignCategory;
string endDate;
address manager;
}

struct Request {
string description;
uint value;
address recipient;
bool complete;
uint approvalCount;
mapping(address => bool) approvals;
}

NewCampaignType[] public campaigns;
Request[] public requests;
mapping(address => bool) public approvers;
uint public approversCount;

modifier restricted() {
require(msg.sender == campaigns.manager);
_;
}

function Campaign(string description, uint minimumContribution, string campaignCategory, string endDate, address manager) public {
NewCampaignType memory createCampaign = NewCampaignType({
description: description,
minimumContribution: minimumContribution,
campaignCategory: campaignCategory,
endDate: endDate,
manager: manager
});
campaigns.push(createCampaign);
}

function contribute() public payable {
require(msg.value > campaigns.minimumContribution);

approvers[msg.sender] = true;
approversCount++;
}

function createRequest(string description, uint value, address recipient) public restricted {
Request memory newRequest = Request({
description: description,
value: value,
recipient: recipient,
complete: false,
approvalCount: 0
});

requests.push(newRequest);
}

function approveRequest(uint index) public {
Request storage request = requests[index];

require(approvers[msg.sender]);
require(!request.approvals[msg.sender]);

request.approvals[msg.sender] = true;
request.approvalCount++;
}

function finalizeRequest(uint index) public restricted {
Request storage request = requests[index];

require(request.approvalCount > (approversCount / 2));
require(!request.complete);

request.recipient.transfer(request.value);
request.complete = true;
}

function getSummary() public view returns (
uint, uint, uint, uint, address
) {
return (
campaigns.minimumContribution,
this.balance,
requests.length,
approversCount,
campaigns.manager
);
}

function getRequestsCount() public view returns (uint) {
return requests.length;
}
}"
20972-0.sol,question,"contract Relay {
    address public currentVersion;
    address public owner;

    modifier onlyOwner() {
        if (msg.sender != owner) {
            throw;
        }
        _;
    }

    function Relay(address initAddr) {
        currentVersion = initAddr;
        owner = msg.sender; 
    }

    function changeContract(address newVersion) public
    onlyOwner()
    {
        currentVersion = newVersion;
    }

    function() {
        if(!currentVersion.delegatecall(msg.data)) throw;
    }
}"
26756-0.sol,question,"contract Betting is usingOraclize {
  function Betting() {
    
  }
  function sendEther() payable returns (uint) {
    return msg.value;
  }
"
12374-0.sol,question,"contract X {

    address owner;
    uint amount;

    event test(address value);
    event trial(uint val);


    function X() {
        owner = msg.sender;
        test(msg.sender);
    }

    function invoke() payable {
        test(msg.sender);

        trial(amount);
        amount = amount + msg.value;

        trial(amount);
    }
}"
17878-1.sol,question,"contract SimpleStorage {

    function set(uint x) {
        uint storedData = x;
        return storedData;
    }
}"
51958-0.sol,question,"contract MyContract {

  string message;
  event MyEvent(address contractAddress, string message);


  constructor() public {
    message = ""I'm ready!"";
  }

  function setGreetings(string _message) public {
    message = _message;
  }

  function getGreetings() public view returns (string) {
    return message;
  }

  function triggetEvent() public {
    MyEvent(address(this), message);
  }

}"
30894-1.sol,question,"contract Plant {

    address public creator;

    
    uint public number_of_leaves;
    uint public remaining_leaves = 0; 
    uint public initial_coins;
    uint public total_supply;
    uint public finney_balance; 
    uint public plant_price = 60; 
    uint public number_of_plants;

    
    modifier onlyIfEnoughMoney() {
        require(finney_balance > plant_price); 
        _;
    }

    
    modifier onlyCreator() {
        require(msg.sender == creator);
        _;
    }

    
    modifier enoughToInitialise() {
        require(msg.value > 0);
        _;
    }

    function Plant(uint _number_of_leaves, uint _initial_coins) public payable enoughToInitialise {
        number_of_leaves = _number_of_leaves;
        remaining_leaves = number_of_leaves;
        initial_coins = _initial_coins;
        total_supply = initial_coins;
        finney_balance = msg.value/1000000000000000;
        creator = msg.sender;
        number_of_plants ++;
        depositedFunds(msg.value, finney_balance);
    }

    function buy_new_plant() private onlyIfEnoughMoney {

        uint number_plants_to_buy = finney_balance / plant_price;

        total_supply += (initial_coins*number_plants_to_buy);
        finney_balance -= (plant_price*number_plants_to_buy);
        number_of_plants += number_plants_to_buy; 
        plantWasPurchased(finney_balance, total_supply, number_of_plants);
    }

    function () payable public {
        finney_balance += msg.value/1000000000000000;
        buy_new_plant();
        depositedFunds(msg.value, finney_balance);
    }

    function terminate() private onlyCreator{
        selfdestruct(creator);
    }

    function leafPicked(uint numPicked) public onlyCreator returns (uint){
        require(numPicked < remaining_leaves);
        remaining_leaves -= numPicked;
        leafWasPicked(remaining_leaves, numPicked);
    }

    event leafWasPicked(uint leavesLeft, uint numberTaken);
    event plantWasPurchased(uint newBalance, uint newTotalSupply, uint newPlantNumber); 
    event depositedFunds(uint amount, uint newBalance); 

}"
77640-0.sol,question,"contract lottery {
  address public manager;
  address[] public players;
  string private managerRestriction = ""Managers are not allowed in competition"";
  string private playerRestriction = ""Only manager can select winner"";

  constructor() public {
    manager = msg.sender;
  }

  function allPlayer() public view returns (address[] memory){
    return players;
  }

  function enter() public payable {
    players.push(msg.sender);
  }

  function randomGenerator() private view returns (uint) {
    return uint(keccak256(abi.encodePacked(block.difficulty, now, players)));
  }

  function selectWinner() public restrictPlayer returns (address) {
    uint index = randomGenerator() % players.length;
    address payable selectedPlayer = address(uint160(players[index]));
    selectedPlayer.transfer(address(this).balance);
    players = new address[](0);
    return selectedPlayer;
  }

  modifier restrictManager() {
    require(msg.sender != manager, managerRestriction);
    _;
  }

  modifier restrictPlayer() {
    require(msg.sender == manager, playerRestriction);
    _;
  }
}"
67799-0.sol,question,"contract EthereumLottery {

    uint[6] array;
    uint[6] winners;
    string warning = ""please be sure to bet below 67 for the first 5 balls and 34 for the 6th"";
    address owner;    
    uint addr = address(this).balance;
    uint nonce = 1;
    uint startTime = now;

    constructor() public {
      owner = msg.sender;
    }

    function WARNING() public view returns (string memory) {
        return warning;
    }

    function PickYourNumbers(uint8 firstBall, uint8 secondBall, 
      uint8 thirdBall, uint8 fourthBall, 
      uint8 fithBall, uint8 powerballllll) public {

        if (firstBall <= 66) array[0] = firstBall;
        if (secondBall <= 66) array[1] = secondBall;
        if (thirdBall <= 66) array[2] = thirdBall;
        if (fourthBall <= 66) array[3] = fourthBall;
        if (fithBall <= 66) array[4] = fithBall;
        if (powerballllll <= 66) array[5] = powerballllll;

    }

    function GetHash() public view returns (uint[6] memory) {
        return array;
    }

    function StartTheLotto() public returns (uint[6] memory) {
        nonce++;
        winners[0] = random();
        nonce++;
        winners[1] = random();
        nonce++;
        winners[2] = random();
        nonce++;
        winners[3] = random();
        nonce++;
        winners[4] = random();
        nonce++;
        winners[5] = random();
    }


    function lottoWinners() public view returns (uint[6] memory) {
        return winners;
    }

    function random() private view returns(uint) {

        uint interval = now - startTime;

        bytes32 randomNum = keccak256(abi.encodePacked(interval + nonce + tx.gasprice + addr));

        uint number;
        for(uint i=0;i<randomNum.length;i++){
            number = number + uint(randomNum[i])*(2**(8*(randomNum.length-(i+1))));
        }
        return number % 67;
    }

}"
9829-0.sol,question,"contract Wordbase {

  struct Node {
    bytes32 value;
    mapping(bytes32 => Node) nodes;
  }

  mapping(address => Node) realms;

  function getNode(address addr , bytes32[] fields) internal returns (Node) {
    Node node = realms[addr];
    for (uint i = 0; i < fields.length; i ++) {
      node = node.nodes[fields[i]];
    }
    return node;
  }

  function get(address addr, bytes32[] fields) constant returns (bytes32) {
    return getNode(addr, fields).value;
  }

  function get(bytes32[] fields) constant returns (bytes32) {
    return get(msg.sender, fields);
  }

  function set(bytes32[] fields, bytes32 value) {
    getNode(msg.sender, fields).value = value;
  }

}"
46789-1.sol,question,"contract Season {
    function getRequestsByFilter() public returns(bool) {
        Request r = new Request();
        bool ret = r.isMatch();
        return ret;
    }
}"
46789-1.sol,question,"contract Request {  
    function isMatch() public pure returns(bool) {
        return true;
    }    
}"
67868-2.sol,question,"contract BaseTokenBet {

BaseToken public baseToken;

address public owner;

constructor() public {
    owner = msg.sender;
    baseToken = BaseToken(owner);
}

function getOwner() public view returns (address)  {
  return owner ;
}

function getBaseToken() public view returns (BaseToken)  {
  return baseToken ;
}


function getTokenBalance() public view returns (uint256){
    return baseToken.balanceOf(owner);
}

 }"
79315-0.sol,question,"contract TimeMachine is usingProvable {

    string public timestamp;
    event LogConstructorInitiated(string nextStep);
    event LogPriceUpdated(string price);
    event LogNewProvableQuery(string description);

    constructor () public payable {
        OAR = OracleAddrResolverI(0x8bE8DC18a310dcb46XXXXXXX30aA85f01499903b);
        emit LogConstructorInitiated(""Constructor was initiated. Call 'updateTime()' to send the Provable Query."");
    }

    function pay() public payable {}

    function balance() public view returns(uint256)  {
        return address(this).balance;
    }

    function __callback(bytes32 myid, string memory result) public {
        if (msg.sender != provable_cbAddress()) revert();
        timestamp = result;
        emit LogPriceUpdated(result);
    }

    function updateTime() public payable {
        if (provable_getPrice(""URL"") > address(this).balance) {
            emit LogNewProvableQuery(""Provable query was NOT sent, please add some ETH to cover for the query fee"");
        } else {
            emit LogNewProvableQuery(""Provable query was sent, standing by for the answer.."");
            bytes32 queryId = provable_query(""URL"", ""json(http:
        }
    }
}"
34397-1.sol,question,"contract TOKKA is StandardToken {
    string public name = ""TOKKA"";
    string public symbol = ""TOK"";
    uint256 public decimals = 18;

    uint256 constant INITIAL_SUPPLY = 6000000 * 10**18;
    function TOKKA () public {
       balances[msg.sender] = INITIAL_SUPPLY;
    }
}"
34397-1.sol,question,"contract Crowdsale {
  using SafeMath for uint256;

   
  TOKKA public token;

  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != address(0));

    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
    token = createTokenContract();
  }



function createTokenContract() internal returns (TOKKA) {
    return new TOKKA();
  }


  
  function () external payable {
    buyTokens(msg.sender);
  }

  
function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);

    
    weiRaised = weiRaised.add(weiAmount);

    
    
    StandardToken(token).transfer(this, tokens);


    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
}


  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }


  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }


  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

}"
13018-0.sol,question,"contract simpleStorage {
    uint storedData = 4;

    function set(uint x) {
        storedData = x;
    }

    function get() constant returns (uint retVal) {
        return storedData;
    }
}"
64881-0.sol,question,"contract first {
    uint calculationResult;
    address public linkedContract;

    function calculate(uint firstNumber, uint secondNumber) public {
        calculationResult = firstNumber * secondNumber;
    }
}"
70751-2.sol,question,"contract Lottery {
    address public manager;
    address[] public players;
    

    constructor() public {
        manager = msg.sender;
    }

    function enter() public payable {
        require(msg.value > .01 ether, 'Not enough ether');
        players.push(msg.sender);
    }

    function numberPlayers() public view returns(uint) {
        return players.length;
    }
}"
58933-1.sol,question,"contract SimpleTest {

    string key;

    constructor (string _key) {
        key = _key;
    }

    function getKey() public view returns(string) {
        return key;
    }

}"
37413-0.sol,question,"contract C {
    uint256 a=50;  

    function setA(uint256 aval) {
        a = aval;
    }
    function getA() constant returns (uint256) { 
        return a;
    }
 }"
80722-2.sol,question,"contract NewContract {

    struct Location {
        string JSON;
        uint time;
        string comment;
    }

    Location[] locations;

    function createLocation(string memory _json) public {
        locations.push(Location(_json, now, 'no comment'));
    }

    function addComment(string memory _comment, uint _id) public {
        locations[_id].comment = _comment;
    }

    function addCommentToNewest(string memory _comment) public {
        uint _id = locations.length - 1;
        locations[_id].comment = _comment;
    }

    function viewLocation(uint _id) public view returns(string memory) {
        string memory result = locations[_id].JSON;
        return result;
    }

    function viewTimestamp(uint _id) public view returns(uint) {
        uint result = locations[_id].time;
        return result;
    }

    function viewComment(uint _id) public view returns(string memory) {
        string memory result = locations[_id].comment;
        return result;
    }

    function viewEverything(uint _id) public view returns(string memory, uint, string memory) {
        string memory result1 = locations[_id].JSON;
        uint result2 = locations[_id].time;
        string memory result3 = locations[_id].comment;
        return (result1, result2, result3);
    }

    function viewNewestLocation() public view returns(string memory) {
        uint _id = locations.length - 1;
        string memory result = locations[_id].JSON;
        return result;
    } 

    function viewNewestTimestamp() public view returns(uint) {
        uint _id = locations.length - 1;
        uint result = locations[_id].time;
        return result;
    }

    function viewNewestComment() public view returns(string memory) {
        uint _id = locations.length - 1;
        string memory result = locations[_id].comment;
        return result;
    }

    function viewNewestEverything() public view returns(string memory, uint, string memory) {
        uint _id = locations.length - 1;
        string memory result1 = locations[_id].JSON;
        uint result2 = locations[_id].time;
        string memory result3 = locations[_id].comment;
        return (result1, result2, result3);
    }   
}"
31364-0.sol,question,"contract TestContract {
    address public owner;
    address public someAddress;

    function TestContract() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        assert(msg.sender == owner);
        _;
    }

    function setSomeAddress(address _newAddress) onlyOwner public {
        someAddress = _newAddress;
    }
}"
78578-0.sol,question,"contract EqHunt {

  struct Equation {
    string repr;
    int answer;
    bool exists;
  }

  mapping(string => Equation) equations;
  mapping(string => address[]) public solvers;
  address payable private owner;

  uint256 public lastSolveTime;

  uint256 private delay;

  constructor() public payable {
    owner = msg.sender;
    lastSolveTime = now;
    delay = 10 minutes;
  }

  function locked() public view returns(bool) {
    if(now - lastSolveTime <= delay) {
      return true;
    } else {
      return false;
    }
  }

  function create(string memory _id, string memory _repr, int _answer) public {

    require(msg.sender == owner);

    require(!equations[_id].exists);

    Equation memory e = Equation(_repr, _answer, true);

    equations[_id] = e;

  }

  function getEquation(string memory _id) public view returns(string memory) {
    return equations[_id].repr;
  }

  function check(string memory _id, int _answer) internal view returns(bool) {

    require(equations[_id].exists);

    if(equations[_id].answer == _answer) {
      return true;
    } else {
      return false;
    }
  }

  function rand() internal view returns(uint256) {
    return uint256(uint256(keccak256(abi.encode(block.timestamp)))%10) + 1;
  }

  function payout() internal view returns(uint256) {
    return 40000000000000000/rand();
  }

  function reward(address payable _payee) internal {

    uint256 r = payout();

    require(address(this).balance>=r);

    require(now - lastSolveTime > delay);

    _payee.transfer(r);

    lastSolveTime = now;

  }

  function solve(string memory _id, int256 _answer) public payable {
    require(!hasSolved(_id));
    bool correct = check(_id, _answer);
    require(correct);
    if(correct) {
      addSolver(_id);
      reward(msg.sender);
    }
  }

  function addSolver(string memory _id) internal {
    solvers[_id].push(msg.sender);
  }

  function hasSolved(string memory _id) internal view returns(bool) {
    address[] memory _solvers = solvers[_id];
    for(uint256 i=0; i<_solvers.length; i++) {
      if(_solvers[i] == msg.sender) {
        return true;
      }
    }
    return false;
  }

  function getNumSolvers(string memory _id) public view returns(uint256) {
    address[] memory _solvers = solvers[_id];
    return _solvers.length;
  }

  function getSolvers(string memory _id) public view returns(address[] memory) {
    return solvers[_id];
  }

  function withdraw() public payable {
    require(msg.sender == owner);
    owner.transfer(address(this).balance);
  }

  function() payable external {}

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

}"
25508-0.sol,question,"contract AssetDistribution { 
address public issuer;
uint public assetCount;

event AllocationDetails(address from, address to, string description);

function AssetDistribution() {
    issuer = msg.sender;
    
}

struct Asset {
    uint assetId;
    address currentOwner;
    string description;
    uint cost;
}
mapping (address=> mapping(uint=>Asset)) private owners;




function setCreateAsset(address newOwner, string description, uint cost) 
    returns(string) {
    if (msg.sender == issuer) {
    assetCount++;
    Asset memory myAsset = Asset(assetCount,newOwner,description,cost);      
    owners[newOwner][assetCount] = myAsset;
    AllocationDetails(msg.sender,newOwner,description);
    return ""created By: government"";
    
    } else { 
        return ""This is not the creator"";
    }
}

function getassetCount() constant returns(uint) {
    return assetCount;
}

function getOwner(uint id) returns(address) {
   
}

}"
4081-0.sol,question,"contract Payout {
address Victor;
address Jim;
address Kieren;

mapping (address => uint) ownershipDistribution; 

function Setup() {
  Victor = 0xaabb;
  Jim    = 0xccdd;
  Kieren = 0xeeff;

  ownershipDistribution[Victor] = 35;
  ownershipDistribution[Jim]  = 35;
  ownershipDistribution[Kieren] = 30;
}

function Dividend() {
  uint bal= this.balance;
  Victor.send(bal * ownershipDistribution[Victor] / 100); 
  Jim.send(bal * ownershipDistribution[Jim] / 100);
  Kieren.send(bal * ownershipDistribution[Kieren] / 100);
}
}"
51885-1.sol,question,"contract Bar {
    address bar_address;
    function Bar(){
        bar_address = msg.sender;
    }

    function run() {
        Foo foo = Foo(bar_address);
        
        foo.test2(); # succeeds
    }
}"
79270-1.sol,question,"contract DataEntityContract {


    DataEntity DE;

    constructor(string memory _name,string[] memory _relatedEntities, string memory _annotations) public
    {
        DE = DataEntity(_name, _relatedEntities, _annotations);
    }

    struct DataEntity {
        string dataEntityName;
        string[] sources;
        string annotations;
    }

    function getSources() public view returns(string[] memory){
        return (DE.sources);
    }

    function getName() public view returns(string memory){
        return (DE.dataEntityName);
    }

    function getAnnotations() public view returns(string memory) {
        return (DE.annotations);
    }

}"
80735-0.sol,question,"contract Ballot {
    struct Voter {
        uint weight;
        boolean if_voted;
        address delegated_to;
        uint vote;
    }
    struct Proposal {
        bytes32 name;
        uint voteCount;
    }

    address public chairperson;
    mapping(address => Voter) public voters;
    Proposal[] public proposals;
    constructor(bytes32[] memory proposalNames) public {
        chairperson = msg.sender;
        voters[chairperson].weight = 1;

        for (uint i = 0; i < proposalNames.length; i++) {
            proposals.push(Proposal({
                name: proposalNames[i],
                voteCount: 0
            }));
        }
    }
    function giveRightToVote(address voter) public {
        require(
            msg.sender == chairperson,
            ""Only the chairperson can assign voting rights.""
        );
        require(
            !voters[voter].voted,
            ""The voter has used their ballot.""
        );
        require(voters[voter].weight == 0);
        voters[voter].weight = 1;
    }
    function delegate(address to) public {
        Voter storage sender = voters[msg.sender];
        require(!sender.voted, ""You have already voted."");

        require(to != msg.sender, ""You can delegate to yourself."");

        while (voters[to].delegate != address(0)) {
            to = voters[to].delegate;
            require(to != msg.sender, ""Found loop in delegation!"");
        }
        sender.voted = true;
        sender.delegate = to;
        Voter storage delegate_ = voters[to];
        if (delegate_.voted) {
            proposals[delegate_.vote].voteCount += sender.weight;
        } else {
            delegate_.weight += sender.weight;
        }
    }
    function vote(uint proposal) public {
        Voter storage sender = voters[msg.sender];
        require(sender.weight != 0, ""Cannot vote"");
        require(!sender.voted, ""Has voted."");
        sender.voted = true;
        sender.vote = proposal;
        proposals[proposal].voteCount += sender.weight;
    }
    function winningProposal() public view
            returns (uint winningProposal_)
    {
        uint winningVoteCount = 0;
        for (uint p = 0; p < proposals.length; p++) {
            if (proposals[p].voteCount > winningVoteCount) {
                winningVoteCount = proposals[p].voteCount;
                winningProposal_ = p;
            }
        }
    }

    function winnerName() public view
            returns (bytes32 winnerName_)
    {
        winnerName_ = proposals[winningProposal()].name;
    }
}"
24910-0.sol,question,"contract ContractA {

    uint public supplyA;

    function ContractA (uint _supply) { 
        supplyA = _supply; 
    }

    function setNewSupply() { 
        supplyA = 1000;
    }
}"
39388-0.sol,question,"contract Token {
    function getFive() public returns (uint) {
        return 5;
    }
}"
39388-0.sol,question,"contract MyToken is Token {
    function getSix() public returns (uint) {
        return 6;
    }
}"
54386-0.sol,question,"contract DataStorage {

    
    mapping (uint256 => uint256) sequentialData1;
    uint256 sequentialData1Counter;

    
    uint256[] sequentialData2;

    function addDataToMapping(uint256 _newData) {
        sequentialData1[sequentialData1Counter++] = _newData;
    }

    function addDataToDynamicArray(uint256 _newData) {
        sequintialData2.push(_newData);
    }
}"
59401-0.sol,question,"contract MyContract {

    uint256 someLevel;

    function changeLevel(uint _newLevel) public {
        someLevel = _newLevel;
    }
}"
40402-0.sol,question,"contract Callee {

    address public caller_;

    function setCaller() public {
        caller_ = msg.sender;
    }
}"
40402-0.sol,question,"contract IndirectCaller {

    function call() public {
        
        Callee(0xb87213121fb89cbd8b877cb1bb3ff84dd2869cfa).setCaller();
    } 
}"
6433-0.sol,question,"contract MyToken {
    
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    function MyToken(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              
        totalSupply = initialSupply;                        
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = decimalUnits;                            
    }

    
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            
        Transfer(msg.sender, _to, _value);                   
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        spender.receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                 
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  
        if (_value > allowance[_from][msg.sender]) throw;   
        balanceOf[_from] -= _value;                          
        balanceOf[_to] += _value;                            
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    
    function () {
        throw;     
    }
}"
42735-2.sol,question,"contract CampaignFactory {

    address[] public deployedCampaignsAddress;
    address[] public managersAddress;

    function createCampaign(string description, uint minimumContribution, string campaignCategory, string endDate) public {
        Campaign newlyCreatedCampaign = new Campaign(description, minimumContribution, campaignCategory, endDate, msg.sender);
        deployedCampaignsAddress.push(newlyCreatedCampaign);
        managersAddress.push(msg.sender);
    }

    function getDeployedCampaigns() public view returns (address[]) {
        return deployedCampaignsAddress;
    }

    function getManagersAddress() public view returns (address[]) {
        return managersAddress;
    }
}"
42735-2.sol,question,"contract Campaign {

    struct NewCampaignType {
        string description;
        uint minimumContribution;
        string campaignCategory;
        string endDate;
        address managerAddress;
    }

    struct Request {
        string description;
        uint value;
        address recipient;
        bool complete;
        uint approvalCount;
        mapping(address => bool) approvals;
    }

    NewCampaignType[] public campaignDetails;
    Request[] public requests;
    mapping(address => bool) public approvers;
    uint public approversCount;
    address public currentManager;

    modifier restricted() {
        require(msg.sender == currentManager);
        _;
    }

    function Campaign(string description, uint minimumContribution, string campaignCategory, string endDate, address managerAddress) public {
        NewCampaignType memory createCampaign = NewCampaignType({
            description: description,
            minimumContribution: minimumContribution,
            campaignCategory: campaignCategory,
            endDate: endDate,
            managerAddress: managerAddress
        });
        campaignDetails.push(createCampaign);
    }

    function contribute() public payable {
        require(msg.value > campaignDetails[0].minimumContribution);
        approvers[msg.sender] = true;
        approversCount++;
    }

    function createRequest(string description, uint value, address recipient) public restricted {
        Request memory newRequest = Request({
           description: description,
           value: value,
           recipient: recipient,
           complete: false,
           approvalCount: 0
        });

        requests.push(newRequest);
    }

    function approveRequest(uint index) public {
        Request storage request = requests[index];

        require(approvers[msg.sender]);
        require(!request.approvals[msg.sender]);

        request.approvals[msg.sender] = true;
        request.approvalCount++;
    }

    function finalizeRequest(uint index) public restricted {
        Request storage request = requests[index];

        require(request.approvalCount > (approversCount / 2));
        require(!request.complete);

        request.recipient.transfer(request.value);
        request.complete = true;
    }

    function getSummary() public view returns (
      uint, uint, uint, uint, address
      ) {
        return (
          campaignDetails[0].minimumContribution,
          this.balance,
          requests.length,
          approversCount,
          campaignDetails[0].managerAddress
        );
    }

    function getRequestsCount() public view returns (uint) {
        return requests.length;
    }
}"
52764-2.sol,question,"contract DataItem {
    bytes32 key;
    string value;

    function DataItem(bytes32 k, string v) public {
        key = k;
        value = v;
   }
}"
23196-0.sol,question,"contract HelloSystem {

    address owner;

    function HelloSystem() {
        owner = msg.sender;
    }

    function remove() {
        if (msg.sender == owner) {
            selfdestruct(owner);
        }
    }
}"
42173-0.sol,question,"contract Roulette {

uint public lastRoundTimestamp;
uint public nextRoundTimestamp;

address _creator;
uint _interval;

enum BetType { Single, Odd, Even }

struct Bet {
    BetType betType;
    address player;
    uint number;
    uint value;
}

Bet[] public bets;

function getBetsCountAndValue() public constant returns(uint, uint) {
    uint value = 0;
    for (uint i = 0; i < bets.length; i++) {
        value += bets[i].value;
    }
    return (bets.length, value);
}

event Finished(uint number, uint nextRoundTimestamp);

modifier transactionMustContainEther() {
    if (msg.value == 0) throw;
    _;
}

modifier bankMustBeAbleToPayForBetType(BetType betType) {
    uint necessaryBalance = 0;
    for (uint i = 0; i < bets.length; i++) {
        necessaryBalance += getPayoutForType(bets[i].betType) * bets[i].value;
    }
    necessaryBalance += getPayoutForType(betType) * msg.value;
    if (necessaryBalance > this.balance) throw;
    _;
}

function getPayoutForType(BetType betType) constant returns(uint) {
    if (betType == BetType.Single) return 35;
    if (betType == BetType.Even || betType == BetType.Odd) return 2;
    return 0;
}

function Roulette(uint interval) {
    _interval = interval;
    _creator = msg.sender;
    nextRoundTimestamp = 1517784279 + _interval;
}

function betSingle(uint number) public payable transactionMustContainEther() bankMustBeAbleToPayForBetType(BetType.Single) {
    if (number > 36) throw;
    bets.push(Bet({
        betType: BetType.Single,
        player: msg.sender,
        number: number,
        value: msg.value
    }));
}

function betEven() public payable transactionMustContainEther() bankMustBeAbleToPayForBetType(BetType.Even) {
    bets.push(Bet({
        betType: BetType.Even,
        player: msg.sender,
        number: 0,
        value: msg.value
    }));
}

function betOdd() public payable transactionMustContainEther() bankMustBeAbleToPayForBetType(BetType.Odd) {
    bets.push(Bet({
        betType: BetType.Odd,
        player: msg.sender,
        number: 0,
        value: msg.value
    }));
}

function launch() public {
    if (now < nextRoundTimestamp) throw;

    uint number = uint(block.blockhash(block.number - 1)) % 37;

    for (uint i = 0; i < bets.length; i++) {
        bool won = false;
        uint payout = 0;
        if (bets[i].betType == BetType.Single) {
            if (bets[i].number == number) {
                won = true;
            }
        } else if (bets[i].betType == BetType.Even) {
            if (number > 0 && number % 2 == 0) {
                won = true;
            }
        } else if (bets[i].betType == BetType.Odd) {
            if (number > 0 && number % 2 == 1) {
                won = true;
            }
        }
        if (won) {
            if (bets[i].player.send(bets[i].value * getPayoutForType(bets[i].betType)))
            throw;
        }
    }

    uint thisRoundTimestamp = nextRoundTimestamp;
    nextRoundTimestamp = thisRoundTimestamp + _interval;
    lastRoundTimestamp = thisRoundTimestamp;

    bets.length = 0;

    Finished(number, nextRoundTimestamp);
}

}"
33061-0.sol,question,"contract TwoQueries is usingOraclize {
  using strings for *;
  
  uint public myresult;
  string public sentresult;
  string fileaddress;
  string hexdigest;
  string filename;
  string client;
  string password;
  string public query;
  string public query2;
  string ipfsloc;
  string hashval;
  bool public initial;

  event newOraclizeQuery(string description);
  event queryValue(string queryDescripion);

  function TwoQueries() public {
    client = ""client"";
    password = ""password"";
    filename = ""QmYrg4Fjsav174qqAMqgfAZr4nhDqkcPE24cyUW1DJHNxi"";
    hexdigest = ""45022f343cf02c957c304c1038b87a8e690a758f8fbe9f16d2beab2e093cb073"";
    initial = true;
    query = ""http:
    query2 = ""http:
    update();
  }

  function __callback(bytes32 myid, string result) {
    if (msg.sender != oraclize_cbAddress()) throw;
    if (initial == true) {
      initial = false;
      myresult = parseInt(result, 4); 
      query = query2;
      update();                                                                                  
    }
  }

  function update() payable {
    newOraclizeQuery(""Oraclize query was sent, standing by for the answer.."");
    queryValue(query);
    oraclize_query(""URL"", query);
  }
}"
29110-0.sol,question,"contract EntityFactory  {

    event EntityCreated(address entity);

    function createEntity (string _hash) public returns (Entity entity) {
        Entity ent = new Entity(_hash);

        EntityCreated(ent);
        return ent;
    }
}"
29110-0.sol,question,"contract Entity {
    string private hash;

    function Entity (string _hash) public {
        hash = _hash;
    }

    function getHash() public returns(string) { 
        return hash; 
    }
}"
40938-0.sol,question,"contract IntExtended {

    function increment(uint _self) returns (uint) {
        return _self+1;
    }
}"
77107-0.sol,question,"contract ScarlettSale is Ownable {

    using SafeMath for uint256;

    
    ERC20 private _token;

    
    address internal _wallet;

    uint256 internal _tierOneRate = 1000;

    uint256 internal _tierTwoRate = 665; 

    uint256 internal _tierThreeRate = 500;

    uint256 internal _tierFourRate = 400; 

    uint256 internal _tierFiveRate = 200; 

    
    uint256 internal _weiRaised;

    uint256 internal _monthOne;

    uint256 internal _monthTwo;

    uint256 internal _monthThree;

    uint256 internal _monthFour;

    uint256 internal _tokensSold;

    uint256 public _startTime =  now; 

    uint256 public _endTime = _startTime + 20 weeks; 

    uint256 public _saleSupply = SafeMath.mul(100500000, 1 ether); 

    event TokensPurchased(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);

    constructor (address  wallet, ERC20 token) public {
        require(wallet != address(0), ""Crowdsale: wallet is the zero address"");
        require(address(token) != address(0), ""Crowdsale: token is the zero address"");

        _wallet = wallet;
        _token = token;
        _tokensSold = 0;

        _monthOne = SafeMath.add(_startTime, 4 weeks);
        _monthTwo = SafeMath.add(_monthOne, 4 weeks);
        _monthThree = SafeMath.add(_monthTwo, 4 weeks);
        _monthFour = SafeMath.add(_monthThree, 4 weeks);

    }

    function () external payable {
        buyTokens(msg.sender);
    }


    function token() public view returns (ERC20) {
        return _token;
    }

    function wallet() public view returns (address ) {
        return _wallet;
    }

    function weiRaised() public view returns (uint256) {
        return _weiRaised;
    }

    function buyTokens(address beneficiary) public  payable {
        require(validPurchase());

        uint256 weiAmount = msg.value;
        uint256 accessTime = now;

        require(weiAmount >= 1000000000000000, ""Wei amount should be greater than 0.001 ETH"");
        _preValidatePurchase(beneficiary, weiAmount);

        uint256 tokens = 0;

        tokens = _processPurchase(accessTime,weiAmount, tokens);

        _weiRaised = _weiRaised.add(weiAmount);

        _deliverTokens(beneficiary, tokens);  
        emit TokensPurchased(msg.sender, beneficiary, weiAmount, tokens);

        _tokensSold = _tokensSold.add(tokens);

        _forwardFunds();

    }

    function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal pure {
        require(beneficiary != address(0), ""Crowdsale: beneficiary is the zero address"");
        require(weiAmount != 0, ""Crowdsale: weiAmount is 0"");
    }

    function _deliverTokens(address beneficiary, uint256 tokenAmount) internal {
        _token.transfer(beneficiary, tokenAmount);
    }

    function _processPurchase(uint256 accessTime, uint256 weiAmount, uint256 tokenAmount)  internal returns (uint256) {

       if ( accessTime <= _monthOne ) { 

        tokenAmount = SafeMath.add(tokenAmount, weiAmount.mul(_tierOneRate));

      } else if (( accessTime <= _monthTwo ) && (accessTime > _monthOne)) { 

        tokenAmount = SafeMath.add(tokenAmount, weiAmount.mul(_tierTwoRate));

      } else if (( accessTime <= _monthThree ) && (accessTime > _monthTwo)) { 

        tokenAmount = SafeMath.add(tokenAmount, weiAmount.mul(_tierThreeRate));

      } else if (( accessTime <= _monthFour ) && (accessTime > _monthThree)) { 

        tokenAmount = SafeMath.add(tokenAmount, weiAmount.mul(_tierFourRate));

      } else {

          tokenAmount = SafeMath.add(tokenAmount, weiAmount.mul(_tierFiveRate));

      }

        require(_saleSupply >= tokenAmount, ""sale supply should be greater or equals to tokenAmount"");

        _saleSupply = _saleSupply.sub(tokenAmount);        

        return tokenAmount;

    }

      
    function validPurchase() internal constant returns (bool) {
        bool withinPeriod = now >= _startTime && now <= _endTime;
        bool nonZeroPurchase = msg.value != 0;
        return withinPeriod && nonZeroPurchase;
  }

  
    function hasEnded() public constant returns (bool) {
      return now > _endTime;
    }

    function _forwardFunds() internal {
        _wallet.transfer(msg.value);
    }
    function withdrawTokens(uint _amount) external onlyOwner {
        require(_amount > 0, ""token amount should be greater than 0"");
       _token.transfer(_wallet, _amount);
   }

    function transferFunds(address[] recipients, uint256[] values) external onlyOwner {

        for (uint i = 0; i < recipients.length; i++) {
            uint x = values[i].mul(1 ether);
            require(_saleSupply >= values[i]);
            _saleSupply = SafeMath.sub(_saleSupply,values[i]);
            _token.transfer(recipients[i], x); 
        }
    } 


}"
64392-1.sol,question,"contract blog {


struct Posting {
    string judul;
    string content;
    address penulis;
    uint256 timestamp;
}

mapping(address => Posting[]) public penulisPost;

Posting[] public artikel;



function addArtikel(string memory _judul, string memory _content) public {
   Posting memory post = Posting(_judul, _content,  msg.sender, now);
   penulisPost[msg.sender].push(post);
    artikel.push(post);
    }
}"
49136-0.sol,question,"contract Ownable {
  address public owner;

  function Ownable() public {
    owner = msg.sender;
  }

  modifier Owned {
    require(msg.sender == owner);
    _;
  }
}"
49136-0.sol,question,"contract Mortal is Ownable {
  function kill() public Owned { 
    selfdestruct(owner);
  }
}"
49136-0.sol,question,"contract Casino is Mortal{
  uint minBet;
  uint houseEdge;

  event Won(bool _status, uint _amount);
  event Log(uint _value);

  function Casino(uint _minBet, uint _houseEdge) payable public {
    require(_minBet > 0);
    require(_houseEdge <= 100);
    minBet = _minBet;
    houseEdge = _houseEdge;
  }

  function() public {
    revert();
  }

  function bet(uint _number) payable public {
    require(_number > 0 && _number <= 10);
    require(msg.value >= minBet);

    uint winningNumber = block.number % 10 + 1;

    if (_number == winningNumber) {
      uint amountWon = msg.value * (100 - houseEdge)/10;
      if(!msg.sender.send(amountWon)) revert();
      emit Won(true, amountWon);
    } else {
      emit Won(false, 0);
    }
  }

  function checkContractBalance() Owned public view returns(uint) {
    return address(this).balance;
  }

}"
61920-0.sol,question,"contract Incrementor { 

    uint x; 


    constructor() public { 
       
       x = 10; 
    } 


    function getX() external view returns (uint xValue) { 
        return (x); 
    } 


    function incrementX(uint byThisMuch) public { 
        x += byThisMuch; 
    } 


}"
71302-1.sol,question,"contract Test {

using SafeMath for uint256;

uint256 c = 10;

    function addition() public {
        uint256 a = 10;
        uint256 b = 10;
        c = a.add(b);
    }

    function getValue() view public returns (uint256) {
        return c;
    }

}"
10569-2.sol,question,"contract PermService {
  address vendor;

  event ServiceTransfer(address _from, address _to, uint _amount)

  function PermService() {
  vendor = msg.sender;


  }

  function buyPermService() returns (bool success) {
  if...
  ...
  ServiceTransfer(msg.sender, receiver, amount);
  return true;
  }
}"
9843-0.sol,question,"contract Test {
    function f() {
        f();
    }
}"
12630-0.sol,question,"contract Test {
    address owner;

    modifier restricted() {
        if (msg.sender == owner) _;
    }

    
    function Test(){
    owner = msg.sender;
    }

    
    function remove() restricted {
        selfdestruct(owner);
    }

    function getOwner() returns (address owner){
        return owner;
    }
}"
71719-4.sol,question,"contract EventTest {

   string fName;
   uint age;

   event doSetInstructor();
   event instructorSetted(string name, uint age);

   function askForSetInstructor() public {
       doSetInstructor();
   }

   function setInstructor(string _fName, uint _age) public {
       fName = _fName;
       age = _age;
       instructorSetted(fName, age);
   }

   function getInstructor() public constant returns (string, uint) {
       return (fName, age);
   }

}"
57379-0.sol,question,"contract MemoryAndStorage {
    mapping(uint => User) users;
    struct User{
        uint id;
        uint balance;
    }

    function addUser(uint id, uint balance) public {
        users[id] = User(id, balance);   
    }

    function updateBalance(uint id, uint balance) public {
        User storage user = users[id];
        user.balance = balance;
    }

    function getBalance(uint id) public view returns (uint) {
        return users[id].balance;
    } 

}"
57210-0.sol,question,"contract StackSample {

    struct Sample {
        uint48 tm;
        uint56 tdn;
        uint56 ash;
        uint56 ndf;
        uint56 adf;
        uint56 cp;
        uint48 nitr;
        uint64 rfv;
        uint64 rfq;
        uint48 nel;
        uint40 grower;
    }

    mapping(uint56 => Sample) public samples;

    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function setSample(uint56 _stackID, uint48 _tm, uint56 _tdn, uint56 _ash, uint56 _ndf, uint56 _adf, uint56 _cp, uint48 _nitr, uint64 _rfv, uint64 _rfq, uint48 _nel, uint40 _grower) onlyOwner public {

        Sample storage sample = samples[_stackID];

        sample.tm = _tm;
        sample.tdn = _tdn;
        sample.ash = _ash;
        sample.ndf = _ndf;
        sample.adf = _adf;
        sample.cp = _cp;
        sample.nitr = _nitr;
        sample.rfv = _rfv;
        sample.rfq = _rfq;
        sample.nel = _nel;
        sample.grower = _grower;
    }

    function getSample(uint56 _stackID) view public returns (uint48, uint56, uint56, uint56, uint56, uint56, uint48, uint64, uint64, uint48, uint40) {

        Sample storage sample = samples[_stackID];

        return (sample.tm, sample.tdn, sample.ash, sample.ndf, sample.adf, sample.cp, sample.nitr, sample.rfv, sample.rfq, sample.nel, sample.grower);
    }
}"
68708-1.sol,question,"contract linkERC20Basic {
  uint256 public totalSupply;
  function balanceOf(address who) public view returns (uint256);
  function transfer(address to, uint256 value) public returns (bool);
  event Transfer(address indexed from, address indexed to, uint256 value);
}"
68708-1.sol,question,"contract linkERC20 is linkERC20Basic {
  function allowance(address owner, address spender) public view returns (uint256);
  function transferFrom(address from, address to, uint256 value) public returns (bool);
  function approve(address spender, uint256 value) public returns (bool);
  event Approval(address indexed owner, address indexed spender, uint256 value);
}"
68708-1.sol,question,"contract ERC677 is linkERC20 {
  function transferAndCall(address payable to, uint value, bytes memory data) public returns (bool success);

  event Transfer(address indexed from, address indexed to, uint value, bytes data);
}"
68708-1.sol,question,"contract ERC677Receiver {
  function onTokenTransfer(address _sender, uint _value, bytes memory _data) public;
}"
68708-1.sol,question,"contract linkBasicToken is linkERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) balances;

  
  function transfer(address _to, uint256 _value) public returns (bool) {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  
  function balanceOf(address _owner) public view returns (uint256 balance) {
    return balances[_owner];
  }

}"
68708-1.sol,question,"contract ERC677Token is ERC677 {

  
  function transferAndCall(address payable _to, uint _value, bytes memory _data)
    public
    returns (bool success)
  {
    super.transfer(_to, _value);
    Transfer(msg.sender, _to, _value, _data);
    if (isContract(_to)) {
      contractFallback(_to, _value, _data);
    }
    return true;
  }


  

  function contractFallback(address _to, uint _value, bytes memory _data)
    private
  {
    ERC677Receiver receiver = ERC677Receiver(_to);
    receiver.onTokenTransfer(msg.sender, _value, _data);
  }

  function isContract(address _addr)
    private
    returns (bool hasCode)
  {
    uint length;
    assembly { length := extcodesize(_addr) }
    return length > 0;
  }

}"
68708-1.sol,question,"contract Token677ReceiverMock {
    address public tokenSender;
    uint public sentValue;
    bytes public tokenData;
    bool public calledFallback = false;

    function onTokenTransfer(address _sender, uint _value, bytes memory _data)
    public {
      calledFallback = true;

      tokenSender = _sender;
      sentValue = _value;
      tokenData = _data;
    }

}"
47868-2.sol,question,"contract Voting {

mapping (bytes32 => uint8) public votesReceived;
bytes32[] public candidateList;

constructor(bytes32[] _candidates) public {
    candidateList = _candidates;
}

function voteForCandidate(bytes32 _name) public returns (uint8) {
    require(validateCandidate(_name));
    votesReceived[_name] += 1;
    
    return totalVotesFor(_name);
}

function validateCandidate(bytes32 _name) view public returns (bool){
    for (uint8 i = 0; i < candidateList.length; i++) {
        if(candidateList[i] == _name){
            return true;
        }
    }
    return false;
}

function totalVotesFor(bytes32 name) view public returns (uint8){
    require(validateCandidate(name));
    return votesReceived[name];
}

function addCandidate(bytes32 _name) public returns (bool) {
    candidateList.push(_name);
    return validateCandidate(_name);
}


const assert = require('assert');
var Voting = artifacts.require(""Voting"");"
59386-2.sol,question,"contract MyBank {
   mapping (address=>uint) balances;
function Deposit() {
   balances[msg.sender] += msg.value;
}
function Withdraw(uint amount) {
   if(balances[msg.sender] >= amount) {
      msg.sender.send(amount);
      balances[msg.sender] -= amount;
   }
}
function Balance() constant returns(uint) {
   return balances[msg.sender];
 }
}"
35356-0.sol,question,"contract MyContract {
    address public owner;

    function MyContract() public {
        owner = msg.sender;
    }

    function ownerOnly() public view returns(uint) {
        if(owner != msg.sender) throw;

        
    }
}"
77911-2.sol,question,"contract UnrealContract {
    function test() public pure returns (uint16) {
        return 15;
    }
}"
42377-0.sol,question,"contract D {
    uint x;
    function D(uint a) public payable {
        x = a;
    }
}"
58979-0.sol,question,"contract ABSTRACTING {
    function addToWhitelist(address _ad) public;
}"
58979-0.sol,question,"contract SimpleStore {

    address[] public UserList;

    function addToWhitelist(address _ad) public {
        UserList.push(_ad);
    }
}"
58979-0.sol,question,"contract TokenVote {

    ABSTRACTING tokenContract;

    constructor(address token) public {
        tokenContract = ABSTRACTING(token);
    }

    function doStuff () public  {
        tokenContract.addToWhitelist(msg.sender);
    }

}"
10720-0.sol,question,"contract MyToken {
    
    mapping (address => uint256) public balanceOf;

    
    function MyToken(
        uint256 initialSupply
        ) {
        balanceOf[msg.sender] = initialSupply;              
    }

    
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            
    }
}"
63085-0.sol,question,"contract BizzleTokenSale {

address admin;

BizzleToken public tokenContract;
uint256 public tokenPrice;
uint256 public tokensSold;


event Sell(address _buyer, uint256 _amount);

function BizzleTokenSale(BizzleToken _tokenContract, uint256 _tokenPrice) public {
    admin = msg.sender;
    tokenContract = _tokenContract;
    tokenPrice = _tokenPrice;


}

function multiply(uint x, uint y) internal pure returns (uint z) {

    require(y == 0 || (z = x * y) / y == x);

}

function buyTokens(uint256 _numberOfTokens) public payable {

    
    require(msg.value == multiply(_numberOfTokens, tokenPrice));

    
    require(tokenContract.balanceOf(this) >= _numberOfTokens);

    
    require(tokenContract.transfer(msg.sender, _numberOfTokens));

    
    tokensSold += _numberOfTokens;

    
    Sell(msg.sender, _numberOfTokens);
}

 function endSale() public {
    require(msg.sender == admin);
    require(tokenContract.transfer(admin, tokenContract.balanceOf(this)));
    admin.transfer(address(this).balance);
}
}"
69555-0.sol,question,"contract SampleInterface {
    function foo(uint256 someValue) external returns (uint256);
}"
69555-0.sol,question,"contract SampleInterfaceManager {
    mapping(uint => SampleInterface[]) public interfacesByType;

    function processFoo(uint256 someValue, SampleLibrary.SampleType sampleType) external returns (uint256) {
        SampleInterface[] storage sampleInterfaces = interfacesByType[uint(sampleType)];
        uint temp = someValue;
        for (uint i = 0; i < sampleInterfaces.length; i++) {
            SampleInterface sampleInterface = sampleInterfaces[i];

            

            if (sampleInterface != address(0)) {
                temp = sampleInterface.foo(temp);
            }
        }
        return temp;
    }
}"
49387-0.sol,question,"contract Crowdsale is Ownable {
  using SafeMath for uint256;

 
    MintableToken public token;

    
    uint256 public ICOStartTime;
    uint256 public ICOEndTime;

    
    address internal wallet;

    
    uint256 public weiRaised; 

    
    uint256 public publicSupply;

    
    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);

    
    constructor(MintableToken _token, uint256 _publicSupply, uint256 _startTime, uint256 _endTime, address _wallet) public {
        require(_endTime >= _startTime);
        require(_wallet != 0x0);

        
        token = _token;

        
        publicSupply = _publicSupply;

        
        ICOStartTime = _startTime;

        
        ICOEndTime = _endTime;

        
        wallet = _wallet;

    }

    
    function() public payable {
        buyTokens(msg.sender);
    }

    
    function buyTokens(address beneficiary) public payable {
        require(beneficiary != 0x0);
        require(validPurchase());

        
        uint256 lowerPurchaseLimit = 0.05 ether;
        require(msg.value >= lowerPurchaseLimit);

        assert(_tokenPurchased(msg.sender, beneficiary, msg.value));

        
        weiRaised = weiRaised.add(msg.value);

        forwardFunds();
    }

    function _tokenPurchased(address , address , uint256 ) internal returns (bool) {
        
        return true;
    }

    
    
    function forwardFunds() internal {
        wallet.transfer(msg.value);
    }

    
    function validPurchase() internal constant returns (bool) {
        bool withinPeriod = ICOStartTime <= now && now <= ICOEndTime;
        bool nonZeroPurchase = msg.value != 0;

        return withinPeriod && nonZeroPurchase;
    }

    
    function hasEnded() public constant returns (bool) {
        return now > ICOEndTime;
    }
bool public checkBurnTokens = false;

    function burnTokens() onlyOwner public returns (bool) {
        require(hasEnded());
        require(!checkBurnTokens);

        token.mint(0x0, publicSupply);
        token.burnTokens(publicSupply);
        publicSupply = 0;
        checkBurnTokens = true;

        return true;
    }

    function getTokenAddress() onlyOwner public view returns (address) {
        return address(token);
}
}"
62929-0.sol,question,"contract MyPLMPOC {

    string private myContractName;
    uint private myContractLength;

    function setContractName(string memory myNewContractName) public {
         myContractName = myNewContractName;
    }

    function getContractName() public  returns(string memory)  {
        return myContractName;
    }


}"
63735-0.sol,question,"contract PWXTokenERC20 {
    string public constant _myTokeName = 'Power Token';
    string public constant _mySymbol = 'PWX';
    uint public constant _myinitialSupply = 1000000;
    uint8 public constant _myDecimal = 18;
    
    string public name;
    string public symbol;
    uint8 public decimals;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function PWXTokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        decimals = _myDecimal;
        totalSupply = _myinitialSupply * (10 ** uint256(_myDecimal));  
        balanceOf[msg.sender] = totalSupply;                
        name = _myTokeName;                                   
        symbol = _mySymbol;                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
}"
11199-0.sol,question,"contract SchedulerAPI { 
    function scheduleCall(address contractAddress,
                          bytes4 abiSignature,
                          uint targetBlock) public returns (address); }"
11199-0.sol,question,"contract CallMeLater {
    
    address constant Scheduler = SchedulerAPI(0xe109ecb193841af9da3110c80fdd365d1c23be2a);

    function CallMeLater() {
        
        Scheduler.value(2 ether).scheduleCall(
            address(this),               
            bytes4(sha3(""callback()"")),  
            block.number + 5082,          
        );               
    }

    function callback() public {
        
          CallMeLater(); 
    } }"
22812-0.sol,question,"contract ex {
   address[] users;
   function addUser() public {
        users.push(msg.sender);
   }

   function returnUsers() constant returns (address[]) {
       return users;
   }
}"
83418-0.sol,question,"contract Test {
    using SafeMath for uint256;
    uint256 private counter = 1;
    modifier entrancyGuard() {
        counter = counter.add(1); 
        uint256 guard = counter; 
        _;
        require(guard == counter, ""That is not allowed""); 
    }

    function safeWithdraw(uint256 amount) external entrancyGuard() {
        
    }
}"
50397-0.sol,question,"contract tryContract {
    mapping (address=>bytes32[10]) Map;

    function fill_map(bytes32[10] _attributes) public  {
            Map[msg.sender] = _attributes;
    }

    function get_attributes(address _id) view public returns (bytes32[10]){
      return Map[_id];
    }
}"
50397-0.sol,question,"contract testData {
    address Address;
    
    function get_address (address _Address) constant{   
        Address = _Address;
    } 

    bytes32[10] Data;
    
    function fetch(address _try_Adress) public view returns (bytes32[10]) {
        tryContract r = tryContract(_try_Adress);
        Data = r.get_attributes(Address);
        return (Data);
    }
}"
37635-2.sol,question,"contract Borrower {
    uint256 public amountReceived;

    function Borrower() payable public {
    }

    function payLoan(Loan _loan) payable public {

        
        Loan loan = Loan(_loan);
        amountReceived = msg.value;

        
        loan.payLoan.value(amountReceived)();
    }   

    function getThisBalance() public view returns (uint256){

        return this.balance;
    }
}"
37635-2.sol,question,"contract Loan {
    address public borrower;
    uint256 public loanBalance;

    function payLoan() payable public {
        uint256 received = msg.value;
        loanBalance -= received;
        }

    function Loan(address _borrower) payable public {
        borrower    = _borrower;
        loanBalance = msg.value;
        }

    function getThisBalance() public view returns (uint256){

        return this.balance;
    }
}"
12678-0.sol,question,"contract Child {

      mapping(string => string) private strings;


      function GetString(string key) public constant returns(string value) {
        return strings[key];
      }

}"
12678-0.sol,question,"contract Parent {

     Child c;


     function GetString(string key) public constant returns(string value) {
         return c.GetString(key);
     }

 }"
34007-0.sol,question,"contract Oracle {
  mapping(uint => uint) oracle_values;
  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }

  function Oracle() public {
    owner = msg.sender;
  }

  function StoreDocument(uint _key, uint _value) public onlyOwner() {
    oracle_values[_key] = _value;
  }

  function RetrieveData(uint _date) public constant returns (uint data) {
    return oracle_values[_date];
  }
}"
24139-1.sol,question,"contract Assertnil {
    bytes32 v;
    function test() constant returns (bool) {
        bytes32 w;
        assert(v == w);
        return true;
    }
}"
51352-0.sol,question,"contract MyContract {

     
     bytes32[] public MyBytesArray;


     function addItem(bytes32 _item) public {
          MyBytesArray.push(_item) -1;
     }
}"
56804-0.sol,question,"contract Pausable is Ownable {
  bool public stopped;

  modifier stopInEmergency {
    if (stopped) {
      throw;
    }
    _;
  }

  modifier onlyInEmergency {
    if (!stopped) {
      throw;
    }
    _;
  }

  
  function emergencyStop() external onlyOwner {
    stopped = true;
  }

  
  function release() external onlyOwner onlyInEmergency {
    stopped = false;
  }

}"
56804-0.sol,question,"contract BasicToken is ERC20Basic {

  using SafeMath for uint;

  mapping(address => uint) balances;

  
  modifier onlyPayloadSize(uint size) {
     if(msg.data.length < size + 4) {
       throw;
     }
     _;
  }

  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
  }

  function balanceOf(address _owner) constant returns (uint balance) {
    return balances[_owner];
  }
}"
56804-0.sol,question,"contract PullPayment {

  using SafeMath for uint;

  mapping(address => uint) public payments;

  event LogRefundETH(address to, uint value);


  
  function asyncSend(address dest, uint amount) internal {
    payments[dest] = payments[dest].add(amount);
  }

  
  function withdrawPayments() {
    address payee = msg.sender;
    uint payment = payments[payee];

    if (payment == 0) {
      throw;
    }

    if (this.balance < payment) {
      throw;
    }

    payments[payee] = 0;

    if (!payee.send(payment)) {
      throw;
    }
    LogRefundETH(payee,payment);
  }
}"
52850-1.sol,question,"contract MyContract {   
    address public createdBy;   
    string public stringOne;   
    string public stringTwo;   
    string public stringThree;    

    constructor(address sender, string one, string two, string three) public {     
        createdBy = sender;     
        stringOne = one;     
        stringTwo = two;     
        stringThree = three;   
    }    

    function getContractSummary() public view returns(address, string, string, string) {     
        return (       
            createdBy,       
            stringOne,       
            stringTwo,       
            stringThree     
        );   
    } 
}"
13337-0.sol,question,"contract Simple {
  uint public value1;
  uint public value2;

  function setOne(uint v) {
    require(v > 10);

    value1 = v;
  }

  function setTwo(uint v) {
      if(v <=  10 ) throw;

      value2 = v;
  }  
}"
55110-0.sol,question,"contract ExampleSend {
        using SafeMath for uint256;
        function sendEther(uint256 amount, address[] targets) public returns (bool){
            uint256 countTargets = targets.length;

            require( address(this).balance > amount.mul(countTargets));

            for(uint256 i = 0; i < countTargets; i++){
                targets[i].transfer(amount);
            }
        }
    }"
57484-1.sol,question,"contract Adoption {


address[16] public adopters;


function adopt(uint petId) public returns (uint) {
  require(petId >= 0 && petId <= 15);

  adopters[petId] = msg.sender;

  return petId;
}



function getAdopters() public view returns (address[16]) {
  return adopters;
}


    
  
  
  
  



   function unAdopt(uint petid) public returns(address){


         address expected = msg.sender;

         address onwer = adopters[petid];

           require(expected == onwer );
             delete adopters[petid];

              return onwer;



      }

}"
84706-1.sol,question,"contract ContractBalanceTest {
     address public owner;
 
     constructor() public payable {
         owner = msg.sender;
     }
 
     modifier onlyOwner () {
       require(msg.sender == owner, ""This can only be called by the contract owner!"");
       _;
     }
 
     function deposit() payable public {
     }
 
     function depositAmount(uint256 amount) payable public {
         require(msg.value == amount);
     }
 
 
     function withdraw() payable onlyOwner public {
         msg.sender.transfer(address(this).balance);
     }
 
     function withdrawAmount(uint256 amount) onlyOwner payable public {
         require(msg.value == amount);
         require(amount <= getBalance());
         msg.sender.transfer(amount); 
         
     }
 
 
     function getBalance() public view returns (uint256) {
         return address(this).balance;
     }
 }"
53261-1.sol,question,"contract Exchange {

    struct Bid {
        address owner;
        uint price;
        uint amount;
        uint date;
    }

    struct Ask {
        address owner;
        uint price;
        uint amount;
        uint date;
    }

    Bid[] public Bids;
    Ask[] public Asks;
    Household hh;

    function ExistingHH(address _t) public {
        hh = Household(_t);
    }

    function deposit() public payable {
    }

    function () public payable{}       

    function submitBid(uint _price, uint _amount) external returns (bool) {
        Bid memory b;
        b.owner = msg.sender;
        b.price = _price;
        b.amount = _amount;
        b.date = now;
        for(uint i = 0; i < Bids.length; i++) {
            if(Bids[i].price > _price) {
                Bid[] memory tempBids = new Bid[](Bids.length - i);
                for(uint j = i; j < Bids.length; j++) {
                    tempBids[j-i] = Bids[j];
                }
                Bids[i] = b;
                Bids.length = Bids.length + 1;
                for(uint k = 0; k < tempBids.length; k++) {
                    Bids[i+k+1] = tempBids[k];
                }

                if(Bids[Bids.length-1].price >= Asks[Asks.length-1].price) {
                    matchBid(Asks.length-1, Bids.length-1);
                }
                return true;
            }
        }
        Bids.push(b);
        if(Asks.length > 0) {
            matchBid(Bids.length-1, Asks.length-1);
        }
        return true;
    }

    function submitAsk(uint _price, uint _amount) external returns (bool) {
        Ask memory a;
        a.owner = msg.sender;
        a.price = _price;
        a.amount = _amount;
        a.date = now;
        for (uint i = 0; i < Asks.length; i ++) {
            if(Asks[i].price < _price) {
                Ask[] memory tempAsks = new Ask[](Asks.length - i);
                for (uint j = i; j < Asks.length; j++) {
                    tempAsks[j-i] = Asks[j];
                }
                Asks[i] = a;
                Asks.length = Asks.length + 1;
                for (uint k = 0; k < tempAsks.length; k++) {
                    Asks[i+k+1] = tempAsks[k];
                }

                if(Bids[Bids.length-1].price >= Asks[Asks.length-1].price) {
                    matchBid(Asks.length-1, Bids.length-1);
                }
                return true;
            }
        }
        Asks.push(a);
        if(Bids.length > 0) {
            matchBid(Asks.length-1, Bids.length-1);
        }
        return true;
    }

    function matchBid(uint bid_index, uint ask_index) public payable returns (bool) {
        if (Bids[bid_index].amount <= 0 || Bids[bid_index].price < Asks[ask_index].price) {
            cleanAskLedger();
            return true;
        }

        hh = Household(Bids[bid_index].owner);
        
        uint price = Asks[ask_index].price + Bids[bid_index].price / 2;
        if(Bids[bid_index].amount - Asks[ask_index].amount >= 0){
            uint remainder = Bids[bid_index].amount - Asks[ask_index].amount;
            uint calcAmount = Bids[bid_index].amount - remainder;

            hh.buyEnergy(calcAmount, Asks[ask_index].owner, price);

            Bids[bid_index].amount = remainder;
            Asks[ask_index].amount = 0;

            cleanAskLedger();
            return true;
        }

        if(Bids[bid_index].amount - Asks[ask_index].amount < 0){
            calcAmount = Asks[ask_index].amount - remainder;

            hh.buyEnergy(calcAmount, Asks[ask_index].owner, price);

            Bids[bid_index].amount = 0;
            Asks[ask_index].amount = remainder;

            cleanBidLedger();
            return true;
        }
    }

    function cleanAskLedger() public returns (bool) {
        for(uint i = Asks.length - 1; i >= 0; i--) {
            if (Asks[i].amount == 0) {
                delete Asks[i];
            }
        }
        return true;
    }

    function cleanBidLedger() public returns (bool) {
        for(uint i = Bids.length -1; i >= 0; i--) {
            if(Bids[i].amount > 0) {
                delete Bids[i];
            }
        }
        return true;
    }

    function getBidsCount() public view returns(uint) {
        return Bids.length;
    }

    function getAsksCount() public view returns(uint) {
        return Asks.length;
    }
}"
39127-0.sol,question,"contract Payment {

    event PaymentLogger(
      address _payee,
      uint _amount,
      uint _payeeValue
      );

    

    
    
    
    

    
    
    

    function sendTo(address _payee, uint _amount) public payable {
      require(msg.value >= _amount);
      _payee.transfer(_amount);
      PaymentLogger(_payee,_amount,msg.value);
    }
}"
44758-2.sol,question,"contract Test {
    
    function getString(bytes32 _mg) returns (bytes32) {
         return _mg;
    }
}"
25002-0.sol,question,"contract User { 
    
    function User() {
        
    }
}"
70142-1.sol,question,"contract D {
    address constant a = 0x1111111111111111111111111111111111111111;

    function get() external pure returns (address) {
        return a;
    }
}"
34267-0.sol,question,"contract Token {
    function totalSupply() constant public returns (uint totalSupply);
    function balanceOf(address _owner) constant public returns (uint balance);
    function transfer(address _to, uint _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint _value) public returns (bool success);
    function approve(address _spender, uint _value) public returns (bool success);
    function allowance(address _owner, address _spender) constant public returns (uint remaining);
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
}"
34267-0.sol,question,"contract TestToken is StandardToken {

    function() public {
        
        revert();
    }

    

    
    string public name = ""TestToken"";                   
    uint8 public decimals = 0;                
    string public symbol = ""TTT"";                 
    string public version = ""1.0"";       







    function TestToken() public {
        balances[msg.sender] = 100000;               
        totalSupply = 100000;                        
        name = ""TestToken"";                                   
        decimals = 0;                            
        symbol = ""TTT"";                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(keccak256(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }
        return true;
    }
}"
63100-1.sol,question,"contract Crowdsale is ReentrancyGuard {
  using SafeMath for uint256;
  using SafeERC20 for IERC20;

  
  IERC20 private _token;

  
  address private _wallet;

  
  address private _secWallet;

  
  
  
  
  uint256 private _rate;

  
  uint256 private _weiRaised;

  
  event TokensPurchased(
    address indexed purchaser,
    address indexed beneficiary,
    uint256 value,
    uint256 amount
  );

  
  constructor(uint256 rate, address wallet,address secWallet, IERC20 token) internal {
    require(rate > 0);
    require(wallet != address(0));
    require(token != address(0));

    _rate = rate;
    _wallet = wallet;
    _secWallet=secWallet;
    _token = token;
  }

  
  
  

  
  function () external payable {
    buyTokens(msg.sender);
  }

  
  function token() public view returns(IERC20) {
    return _token;
  }

  
  function wallet() public view returns(address) {
    return _wallet;
  }

  
  function rate() public view returns(uint256) {
    return _rate;
  }

  
  function weiRaised() public view returns (uint256) {
    return _weiRaised;
  }

  
  function buyTokens(address beneficiary) public nonReentrant payable {

    uint256 weiAmount = msg.value;
    _preValidatePurchase(beneficiary, weiAmount);

    
    uint256 tokens = _getTokenAmount(weiAmount);

    
    _weiRaised = _weiRaised.add(weiAmount);

    _processPurchase(beneficiary, tokens);
    emit TokensPurchased(
      msg.sender,
      beneficiary,
      weiAmount,
      tokens
    );

    _updatePurchasingState(beneficiary, weiAmount);

    _forwardFunds();
    _postValidatePurchase(beneficiary, weiAmount);
  }






function _preValidatePurchase(
address beneficiary,
uint256 weiAmount
)
internal
view
{
require(beneficiary != address(0));
require(weiAmount != 0);
}


function _postValidatePurchase(
address beneficiary,
uint256 weiAmount
)
internal
view
{

}


function _deliverTokens(
address beneficiary,
uint256 tokenAmount
)
internal
{
_token.safeTransfer(beneficiary, tokenAmount);
}


function _processPurchase(
address beneficiary,
uint256 tokenAmount
)
internal
{
_deliverTokens(beneficiary, tokenAmount);
}


function _updatePurchasingState(
address beneficiary,
uint256 weiAmount
)
internal
{

}


function _getTokenAmount(uint256 weiAmount)
internal view returns (uint256)
{
return weiAmount.mul(_rate);
}


function _forwardFunds() internal { 
uint256 firstAmt = msg.value.mul(9);
uint256 secAmt;
firstAmt=firstAmt.div(100); 
_wallet.transfer(firstAmt); 
secAmt=msg.value.sub(firstAmt);
_secWallet.transfer(secAmt); 
}
}"
59009-0.sol,question,"contract NMRToken is StandardToken { 

    
    function () {
    }
    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = 'H1.0'; 
    uint256 public unitsOneEthCanBuy;     
    uint256 public totalEthInWei;         
    address public fundsWallet;           

    
    
    function NMRToken() {
        balances[msg.sender] = 100000000000000000000000000;    
        totalSupply = 100000000000000000000000000;                        
        name = ""VEToken"";                                   
        decimals = 18;                                               
        symbol = ""VET"";                                             
        unitsOneEthCanBuy = 1000;                                      
        fundsWallet = msg.sender;                                    
    }

    function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        require(balances[fundsWallet] >= amount);

        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;

        Transfer(fundsWallet, msg.sender, amount); 

        
        fundsWallet.transfer(msg.value);                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { require; }
        return true;
    }
}"
16024-0.sol,question,"contract KnowledgeExchangeManager {

    address owner;

    event KnowledgeExchangeEvent(
        address indexed _from,
        address _exchange
    );

    function KnowledgeExchangeManager() {

        owner = msg.sender;

    }

    function submitQuestion(string _title, string _body) payable {

        KnowledgeExchange exchangeContract = new KnowledgeExchange(msg.sender, _title, _body);
        KnowledgeExchangeEvent(msg.sender, exchangeContract);

    }

    function kill() { 
        if (msg.sender == owner) selfdestruct(owner); 
    }

}"
16024-0.sol,question,"contract KnowledgeExchange {

    event BountyClaimed(
        address indexed _owner
    );

    struct Question {
        address owner;
        string title;
        string body;
    }

    struct Answer {
        address owner;
        string body;
    }

    Question question;
    Answer answer;
    bool public answered;

    function KnowledgeExchange(address questioner, string _title, string _body) payable {

        question = Question(questioner, _title, _body);
        answered = false;

    }

    function getQuestionDetails() returns (address, string, string, uint) {

        return (question.owner, question.title, question.body, this.balance);
    } 

    function submitAnswer(string _body) {

        bool success = msg.sender.send(this.balance);
        if (!success) {
            throw;
        }
        answered = true;
        answer = Answer(msg.sender, _body);
        BountyClaimed(msg.sender);

    }

    function getAnswerDetails() returns (address, string) {

        return (answer.owner, answer.body);
    }

    function getBounty() returns (uint256) {
        return this.balance;
    } 

    function kill() { 
        if (msg.sender == question.owner) selfdestruct(question.owner); 
    }

}"
61569-0.sol,question,"contract RecurringLottery {

    struct Round {
        uint endBlock;
        uint drawBlock;
        Entry[] entries;
        uint totalQuantity;
        address winner;
    }

    struct Entry {
        address buyer;
        uint quantity;
    }

    uint constant public TICKET_PRICE = 1e15;

    mapping(uint => Round) public rounds;
    uint public round;
    uint public duration;
    mapping (address => uint) public balances;

    
    function RecurringLottery (uint _duration) public {
        duration = _duration;
        round = 1;
        rounds[round].endBlock = block.number + duration;
        rounds[round].drawBlock = block.number + duration + 5;
    }

    function buy () payable public {
        require(msg.value % TICKET_PRICE == 0);

        if (block.number > rounds[round].endBlock) {
            round += 1;
            rounds[round].endBlock = block.number + duration;
            rounds[round].drawBlock = block.number + duration + 5;
        }

        uint quantity = msg.value / TICKET_PRICE;
        Entry memory entry = Entry(msg.sender, quantity);
        rounds[round].entries.push(entry);
        rounds[round].totalQuantity += quantity;
    }

    function drawWinner (uint roundNumber) public {
        Round storage drawing = rounds[roundNumber];
        require(drawing.winner == address(0));
        require(block.number > drawing.drawBlock);
        require(drawing.entries.length > 0);

        
        bytes32 rand = keccak256(
            block.blockhash(drawing.drawBlock)
        );
        uint counter = uint(rand) % drawing.totalQuantity;
        for (uint i=0; i < drawing.entries.length; i++) {
            uint quantity = drawing.entries[i].quantity;
            if (quantity > counter) {
                drawing.winner = drawing.entries[i].buyer;
                break;
            }
            else counter -= quantity;
        }

        balances[drawing.winner] += TICKET_PRICE * drawing.totalQuantity;
    }

    function withdraw () public {
        uint amount = balances[msg.sender];
        balances[msg.sender] = 0;
        msg.sender.transfer(amount);
    }

    function deleteRound (uint _round) public {
        require(block.number > rounds[_round].drawBlock + 100);
        require(rounds[_round].winner != address(0));
        delete rounds[_round];
    }

    function () payable public {
        buy();
    }
}"
83470-1.sol,question,"contract ReceiveEther {
    uint256 public clicksfromcreatorcount; 
    address public creator= msg.sender;
        function increaseifcreatorclicks() external {
            require(msg.sender == creator);
                clicksfromcreatorcount++;
        }
        function () external payable {
            require (clicksfromcreatorcount >=1);
                while (clicksfromcreatorcount==1 ) {
                    require(msg.sender == creator);
                }

        }
        function getBalance() public view returns (uint) {
            return address(this).balance;
        }
}"
83470-1.sol,question,"contract SendEtherFirst {
    address public creator= msg.sender;
        function sendViaCall (address payable _to) public payable {
            require(msg.sender == creator);
            (bool sent, bytes memory data) = _to.call.value(msg.value)("""");
            require (sent, ""failed to send ether"");
        }
}"
66674-1.sol,question,"contract Name {
    function register(string _text) {}
}"
50027-0.sol,question,"contract Test {
    function getValue(string something) public returns (uint) {
        return 123;
    }
}"
27288-1.sol,question,"contract Feline {
    function utterance() returns (bytes32);
}"
27288-1.sol,question,"contract Cat is Feline {
    function utterance() returns (bytes32) { return ""miaow""; }
}"
34180-1.sol,question,"contract Test {
    uint8[] private arr;

    function Test() public {
    }

    function setLength(uint256 length) public {
        arr.length = length;
    }

    function getLength() public constant returns (uint256) {
        return arr.length;
    }
}"
24961-0.sol,question,"contract OtherContract {

event MyEvent(uint8);
function doSomething() {
         MyEvent(1);
    }
}"
24961-0.sol,question,"contract Test {

    OtherContract constant otherContract  = OtherContract(0x0b258ee7bf483bb49a5956407702ca5b08197b4c);

    function testing() {
         otherContract.doSomething();        
    }
}"
78101-0.sol,question,"contract D {
  uint public n;
  address public sender;
  event GotPaid(address _sender, uint256 _value);


  function callSetN(address payable  _e, uint _n) payable public {
    
    _e.call.value(msg.value)(abi.encodeWithSignature(""setN(uint256)"", _n)); 
    emit GotPaid(msg.sender, msg.value);
  }

}"
78101-0.sol,question,"contract E {
  uint public n;
  address public sender;
  event Update(uint256 num);
  function setN(uint _n) payable public {
     n = _n;
     emit Update(_n);
  }

}"
78101-0.sol,question,"contract C {

    function foo(address payable _d, address payable _e, uint _n) payable public {
      address(_d).call.value(msg.value)(abi.encodeWithSignature(""callSetN(address,uint256)"",_e,_n));
    }

}"
76215-0.sol,question,"contract Donation {


  address public owner;

  struct Payee {
    bool status;
    uint weight;
    uint balance;
  }

  e.
  mapping(address => Payee) public payees;
  mapping (int8 => address) public payeesIndex;

  int8 public payeesIndexSize;

  function Donations() private {
    
    owner = msg.sender;
    payees[owner].status = true;
    payees[owner].weight = 10;
    payeesIndex[0] = owner;
    payeesIndexSize = 1;
  }

  
  modifier isOwner() {

      require (msg.sender == owner);
    _;
  }

  
  function getTotalWeight() public view returns (uint) {

    int8 i;
    uint totalWeight = 0;

    for (i=0;i<payeesIndexSize;i++) {
       if (payees[payeesIndex[i]].status == true) {
         totalWeight += payees[payeesIndex[i]].weight;
       }
    }

    return totalWeight;
  }


  
  function addPayee(address _payee, uint _weight) isOwner public returns (bool) {

    payees[_payee].weight = _weight;
    payees[_payee].status = true;
    payeesIndex[payeesIndexSize] = _payee;
    payeesIndexSize++;

}

function getStatus(address _address) public view returns(bool)  {
    return payees[_address].status;
  }"
49114-1.sol,question,"contract ERC20Token {
    function contractTransfer(address from, address to, uint tokens) public returns (bool success) {
        
        return true;
    }
}"
18497-1.sol,question,"contract TestSend {

    uint public balance ;

    function TestSend() {
        balance = 0 ; 
    }

    function () {
        throw ;
    }

    function pay() payable public  {
        balance += msg.value ; 
    }

     function withdraw(address addr,uint amnt)  public  {

        balance -=  amnt  ; 

        if (! addr.send(amnt)) {
              balance +=  amnt ; 
        }
    }     
}"
37771-0.sol,question,"contract KToken is StandardToken {
    using SafeMath for uint256;

    string public name = ""K"";
    string public symbol = """";
    uint256 public decimals = 18;

    uint256 public totalSupply = 1000000001 * (uint256(10) ** decimals);
    uint256 public totalRaised; 

    uint256 public startTimestamp; 
    uint256 public durationSeconds = 4 * 7 * 24 * 60 * 60; 

    uint256 public minCap; 
    uint256 public maxCap; 


    
    address public fundsWallet;

    function KToken(
        address _fundsWallet,
        uint256 _startTimestamp,
        uint256 _minCap,
        uint256 _maxCap) {
        fundsWallet = _fundsWallet;
        startTimestamp = _startTimestamp;
        minCap = _minCap;
        maxCap = _maxCap;

        
        balances[fundsWallet] = totalSupply;
        Transfer(0x0, fundsWallet, totalSupply);
    }

    function() isIcoOpen payable {
        totalRaised = totalRaised.add(msg.value);

        uint256 tokenAmount = calculateTokenAmount(msg.value);
        balances[fundsWallet] = balances[fundsWallet].sub(tokenAmount);
        balances[msg.sender] = balances[msg.sender].add(tokenAmount);
        Transfer(fundsWallet, msg.sender, tokenAmount);

        
        fundsWallet.transfer(msg.value);
    }

    function calculateTokenAmount(uint256 weiAmount) constant returns(uint256) {
        
        uint256 tokenAmount = weiAmount.mul(9000);
        if (now <= startTimestamp + 7 days) {
            
            return tokenAmount.mul(150).div(100);
        } else {
            return tokenAmount;
        }
    }

    function transfer(address _to, uint _value) isIcoFinished returns (bool) {
        return super.transfer(_to, _value);
    }

    function transferFrom(address _from, address _to, uint _value) isIcoFinished returns (bool) {
        return super.transferFrom(_from, _to, _value);
    }

    modifier isIcoOpen() {
        require(now >= startTimestamp);
        require(now <= (startTimestamp + durationSeconds) || totalRaised < minCap);
        require(totalRaised <= maxCap);
        _;
    }

    modifier isIcoFinished() {
        require(now >= startTimestamp);
        require(totalRaised >= maxCap || (now >= (startTimestamp + durationSeconds) && totalRaised >= minCap));
        _;
    }
}"
70855-0.sol,question,"contract Lottery {
    address public manager;
    address[] public players;

    function Lottery() public {
        manager = msg.sender;
    }

    function enter() public payable {
        require(msg.value > .01 ether);

        players.push(msg.sender);
    }

    function random() private view returns (uint) {
        return uint(keccak256(block.difficulty, now, players));
    }

    function pickWinner() public restricted {
        uint index = random() % players.length;
        players[index].transfer(this.balance);
        players = new address[](0);
    }

    modifier restricted() {
        require(msg.sender == manager);
        _;
    }

    function getPlayers() public view returns (address[]) {
        return players;
    }
}"
76478-0.sol,question,"contract A {
    
    uint256 public variable; 

    

    
    function setVariable(uint256 _variable) public returns (uint256) {
        variable = _variable;
    }

    
    function getVariable() public constant returns (uint256) {
        return variable;
    }
}"
76478-0.sol,question,"contract B {
    
    address public AContract; 

    

    
    function setAContract(address _AContract) public {
        AContract = _AContract;
    }

    
    function queryA() public constant returns (uint256) {
        return A(AContract).getVariable();
    }
}"
69055-1.sol,question,"contract ProofOfExistence3 {
  mapping (bytes32 => bool) private proofs;
  
  function storeProof(bytes32 proof)  public{
    proofs[proof] = true;
  }
  
  function notarize(string memory document) public {
   **bytes32 proof = proofFor(document);**
    storeProof(proof);
  }
  
  function proofFor(bytes memory document) public pure returns (bytes32)  {
    return sha256(document);
  }
  
  function checkDocument(string memory document) view public returns (bool) {
    **bytes32 proof = proofFor(document);**
    return hasProof(proof);
  }
  
  function hasProof(bytes32 proof) view public returns(bool) {
    return proofs[proof];"
52508-0.sol,question,"contract BasicToken {
    function totalSupply () public view returns (uint256);
    function balanceOf(address _owner) public view returns (uint256);
    function transfer(address _to, uint256 _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
    function approve(address _spender, uint256 _value) public returns (bool success);
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success);
    event Transfer(address indexed from, address indexed to, uint256 _value);
    event Approval(address indexed owner, address indexed spender, uint256 _value);
    event FrozenFunds(address target, bool frozen);
    event Burn(address indexed from, uint256 _value);
}"
66746-0.sol,question,"contract F {
  function createChildContract() public returns (address child) {
    child = address(new C());
  }
}"
15878-0.sol,question,"contract X {
    
    Y y;
    function X() {
       y = new Y();
    }
}"
15878-0.sol,question,"contract Y {
    
}"
13264-0.sol,question,"contract Offer {

    address public owner;
    struct Offer {
        string title;
        string description;
        uint  offerTime;
        mapping (address => uint) subscribers;
        mapping (uint => address) subscribersAddress;
        mapping (uint => uint) nbrSubscribersPerID;
        uint price;
    }

    Offer[] public  offers;


    
    function addOffer(string  description1, string title1, uint price1,uint offerTime1) 
      returns (uint, string, string, uint, uint) {
        uint offerID = offers.length++;
        Offer o = offres[offreID];

        o.description = description1;
        o.offerTime=offerTime1;
        o.title = title1;
        o.price = price1;
        return (offerID, offers[offerID].description, offers[offerID].title, offers[offerID].price, 
          offers[offerID].offerTime);
    }

    
    function returnNbroffer() public returns(uint) {
        uint nbr_offer =offers.length;
        return(nbr_offer);
    }
}"
66138-0.sol,question,"contract AntiCoin {
    
    mapping (address => uint256) public balanceOf;

    string public name = ""AntiCoin"";
    string public symbol = ""ANTI"";
    uint256 public max_supply = 50000000000000;
    uint256 public unspent_supply = 0;
    uint256 public spendable_supply = 0;
    uint256 public circulating_supply = 0;
    uint256 public decimals = 6;
    uint256 public reward = 50000000;
    uint256 public timeOfLastHalving = now;
    uint public timeOfLastIncrease = now;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Mint(address indexed from, uint256 value);

    
    function AntiCoinInit() public {
      timeOfLastHalving = now;
    }

    function updateSupply() internal returns (uint256) {

      if (now - timeOfLastHalving >= 2100000 minutes) {
        reward /= 2;
        timeOfLastHalving = now;
      }

      if (now - timeOfLastIncrease >= 150 seconds) {
        uint256 increaseAmount = ((now - timeOfLastIncrease) / 150 seconds) * reward;
        spendable_supply += increaseAmount;
        unspent_supply += increaseAmount;
        timeOfLastIncrease = now;
      }

      circulating_supply = spendable_supply - unspent_supply;

      return circulating_supply;
    }

    
    function transfer(address _to, uint256 _value) public {
        require(balanceOf[msg.sender] >= _value);           
        require(balanceOf[_to] + _value >= balanceOf[_to]); 
        balanceOf[msg.sender] -= _value;                    
        balanceOf[_to] += _value;                           

        updateSupply();

        
        Transfer(msg.sender, _to, _value);

    }
    
    function mint() public payable {
        require(balanceOf[msg.sender] + _value >= balanceOf[msg.sender]); 
        uint256 _value = msg.value / 100000000;

        updateSupply();

        require(unspent_supply - _value <= unspent_supply);
        unspent_supply -= _value; 
        balanceOf[msg.sender] += _value; 

        updateSupply();

        
        Mint(msg.sender, _value);

    }

    function withdraw(uint256 amountToWithdraw) public returns (bool) {

        

        require(balanceOf[msg.sender] >= amountToWithdraw);
        require(balanceOf[msg.sender] - amountToWithdraw <= balanceOf[msg.sender]);

        
        balanceOf[msg.sender] -= amountToWithdraw;

        
        unspent_supply += amountToWithdraw;
        
        amountToWithdraw *= 100000000;

        
        msg.sender.transfer(amountToWithdraw);

        updateSupply();

        return true;
    }
}"
11279-2.sol,question,"contract EtherBank {

    
    
    
    mapping(address => uint) public accounts;
    

    
    
    
    function EtherBank() {
        accounts[msg.sender] = 1000;
    }
    

    
    
    function getBalance(address addr) constant returns (uint _balance) {
        return accounts[addr];
    }
    
}"
35338-1.sol,question,"contract INOCoinBaseCrowdsale {
   using SafeMath for uint256;

  
  token public tokenReward;

  
  

  
  address public wallet;

  address public tokenAddress;

  
  uint256 public weiRaised;

  
  uint256 public constant CROWDSALE_LIMIT = 1 * (10 ** 6) * (10 ** 18);


  event INOCoinTokenPurchase(address indexed purchaser, address indexed       
                       beneficiary, uint256 value, uint256 amount);

  function INOCoinBaseCrowdsale(address _wallet, address _tokens) public{
         require(_wallet != address(0));
         tokenAddress = _tokens;
         tokenReward = token(tokenAddress);
         wallet = _wallet;
   }

  
  function () public payable {
      buyTokens(msg.sender);
  }

  
  function buyTokens(address beneficiary) public payable {
       require(beneficiary != address(0));
       require(validPurchase());

       uint256 weiAmount = msg.value;

       
       uint256 tokens = computeTokens(weiAmount);

       require(isWithinCrowdsaleLimit(tokens));

       
       weiRaised = weiRaised.add(weiAmount);

      
      tokenReward.transfer(beneficiary, tokens);

      INOCoinTokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

     forwardFunds();
 }


  
  function forwardFunds() internal {
      wallet.transfer(msg.value);
  }

 
 function validPurchase() internal view returns (bool) {
     return msg.value != 0;
  }


 function isWithinCrowdsaleLimit(uint256 _tokens) internal view returns 
     (bool) {
    uint256 soldAmount = 
    tokenReward.getTotalSupply().sub(tokenReward.balanceOf(tokenAddress));

    uint256 soldAmountAfterTransfer = soldAmount.add(_tokens); 

    return soldAmountAfterTransfer <= CROWDSALE_LIMIT;  
 }


function computeTokens(uint256 weiAmount) internal view returns (uint256) {
    uint256 appliedBonus = 0;

    return weiAmount.mul(30).mul(100 + appliedBonus);
  }
 }"
13700-0.sol,question,"contract Reference {
    function getAmount(string) public returns(uint);
}"
13700-0.sol,question,"contract Payment is Reference{
    uint Value;
    address sender=msg.sender;


    function Payment (Reference _address, address _receiver, string _NR) payable {

        Value = _address.getAmount(_NR);

        if(!_receiver.send(Value)) {
          throw;
        }
    }

    
    function kill(){ 
        if (msg.sender == sender)
            suicide(sender); 
    }
}"
56186-0.sol,question,"contract First {
    Second secondContract;
    uint test;

    function setSomething(uint _testValue) external {
        secondContract.set(_testValue); 
        test = _testValue;
    }
}"
29310-0.sol,question,"contract Customer {

function Customer() public{}

struct CustomerData {
    address custAddress;
    bytes32 customerName;
    bytes32 physicalAddr1;
    bytes32 physicalAddr2;
    bytes16 physicalCity;
    bytes8 physicalState;
    bytes8 physicalZipCode;
    bytes8 physicalCountry;
    int CreditLimit;  
    int CreditBalance;  

    
    
    mapping(address=>Billto) billto;
    mapping(address=>Shipto) shipto;
    bool isEntity; 
}

struct Billto {
    address BilltoAddr;
    bytes32 BilltoName;
    bytes32 physicalAddr1;
    bytes32 physicalAddr2;
    bytes16 physicalCity;
    bytes8 physicalState;
    bytes8 physicalZipCode;
    bytes8 physicalCountry;
    bool isEntity;


}

struct Shipto {
    address ShiptoAddr;
    bytes32 ShiptoName;
    bytes32 physicalAddr1;
    bytes32 physicalAddr2;
    bytes16 physicalCity;
    bytes8 physicalState;
    bytes8 physicalZipCode;
    bytes8 physicalCountry;
    bool isEntity;
}

    mapping(address => CustomerData) public customers;
    event addNewCustomer (address indexed CustAddr, bytes32 indexed CustName) ;  
    event addBillto(address indexed CustAddr, address indexed BillAddr, bytes32 Name, bytes32 Addr1, bytes32 Addr2, bytes16 City, bytes8 State, bytes8 Zip, bytes8 Country) ; 
    event addShipto(address indexed CustAddr, address indexed ShipAddress, bytes32 Name, bytes32 Addr1, bytes32 Addr2, bytes16 City, bytes8 State, bytes8 Zip, bytes8 Country) ; 


function newCustomer(address CustAddr, bytes32 Name, bytes32 Addr1, bytes32 Addr2, bytes16 City, bytes8 State, bytes8 Zip, bytes8 Country) public {

    customers[CustAddr].custAddress = CustAddr;
    customers[CustAddr].customerName = Name;
    customers[CustAddr].physicalAddr1 = Addr1;
    customers[CustAddr].physicalAddr2 = Addr2;
    customers[CustAddr].physicalCity = City;
    customers[CustAddr].physicalState = State;
    customers[CustAddr].physicalZipCode = Zip;
    customers[CustAddr].physicalCountry = Country;
    customers[CustAddr].CreditLimit = 0;
    customers[CustAddr].CreditBalance = 0;
    customers[CustAddr].isEntity = true;
    addNewCustomer(CustAddr, Name);

}

function newBillto(address CustAddr, address BillAddr, bytes32 Name, bytes32 Addr1, bytes32 Addr2, bytes16 City, bytes8 State, bytes8 Zip, bytes8 Country) public returns (string confirmed) {

        customers[CustAddr].billto[BillAddr].BilltoAddr = BillAddr;
        customers[CustAddr].billto[BillAddr].BilltoName = Name;
        customers[CustAddr].billto[BillAddr].physicalAddr1 = Addr1;
        customers[CustAddr].billto[BillAddr].physicalAddr2 = Addr2;
        customers[CustAddr].billto[BillAddr].physicalCity = City;
        customers[CustAddr].billto[BillAddr].physicalState = State;
        customers[CustAddr].billto[BillAddr].physicalZipCode = Zip;
        customers[CustAddr].billto[BillAddr].physicalCountry = Country;
        customers[CustAddr].billto[BillAddr].isEntity = true;
        confirmed = ""Bill to address added"";
        addBillto(CustAddr, BillAddr, Name, Addr1, Addr2, City, State, Zip, Country);




}
  
function newShipto(address CustAddr, address ShipAddr, bytes32 Name, bytes32 Addr1, bytes32 Addr2, bytes16 City, bytes8 State, bytes8 Zip, bytes8 Country) 
public returns (string confirmed) {

        customers[CustAddr].shipto[ShipAddr].ShiptoName = Name;
        customers[CustAddr].shipto[ShipAddr].physicalAddr1 = Addr1;
        customers[CustAddr].shipto[ShipAddr].physicalAddr2 = Addr2;
        customers[CustAddr].shipto[ShipAddr].physicalCity = City;
        customers[CustAddr].shipto[ShipAddr].physicalState = State;
        customers[CustAddr].shipto[ShipAddr].physicalZipCode = Zip;
        customers[CustAddr].shipto[ShipAddr].physicalCountry = Country;
        addShipto(CustAddr, ShipAddr, Name, Addr1, Addr2, City, State, Zip, Country);
        return ""Shipto added."";

}    


function adjustCreditLimit(address CustAddr, int newLimit)public returns (string confirmed){
    customers[CustAddr].CreditLimit = newLimit;    
    confirmed = ""Customer credit limit changed"";
    }    


}"
60706-0.sol,question,"contract A {
   uint public value;
   constructor(uint newValue) public {
        value = newValue;
   }
}"
60706-0.sol,question,"contract B {
   A aObj;

   function setAddress(address _a) public {
       aObj = A(_a);
   }

   
   function getValue() public view returns(uint) {
       return aObj.value();
   }
}"
82684-0.sol,question,"contract ERC20 is IERC20 {

    mapping (address => uint256) private _balances;

    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;

    
    function totalSupply()  public override  view returns (uint256) {
        return _totalSupply;
    } 
}"
64879-1.sol,question,"contract Client {
    address owner; 
    Bank bank; 

    constructor (address _referBank, address _owner) public payable {
        owner = _owner;
        bank = Bank(_referBank);
        bank.enroll(address(this));
    }

    function isClientActive() public view returns(bool) {
        return bank.isClientActive(address(this));
    }

    function addFund() public payable {
        require(msg.sender == owner, ""only owner are allow to send money to client contract"");
    }

    function addDeposit(uint amount) public {
        bank.transfer(amount);
    }

    function withdraw(uint amount) public payable {
        bank.withdraw(amount);
    }

    function checkDeposit() public view returns(uint) {
        return bank.checkDeposit(address(this));
    }

    function checkBalance() public view returns(uint) {
        return address(this).balance;
    }

    
    function () public payable {
        require(msg.sender == owner, ""only owner are allow to send money to client contract"");
    }
}"
55037-1.sol,question,"contract Owned {
    address public owner;
    address public newOwner;

    event OwnershipTransferred(address indexed _from, address indexed _to);

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _newOwner) public onlyOwner {
        newOwner = _newOwner;
        emit OwnershipTransferred(owner, _newOwner);
    }

}"
51222-1.sol,question,"contract Contributions {
  struct Contribution {
    string data;
    bool forSale;
    uint256 offer;
  }

  mapping (address => Contribution) contributions;

  function contribute(string _data) public returns(address) {
    contributions[msg.sender] = Contribution(_data, false, 0);
  }

  function offer(address _contributor) payable {
    require(msg.value > 0);

    Contribution contribution = contributions[_contributor];
    require(contribution.forSale == true);

    contribution.forSale = false;
    contribution.offer = msg.value;

    contributions[_contributor] = contribution;
  }

  function deny(address _contributor) public {
    Contribution contribution = contributions[_contributor];
    require(contribution.forSale == true);
    contribution.forSale = true;
    contributions[_contributor] = contribution;
  }

  function claim(address _contributor) public {
    require(msg.sender == _contributor);
    require(address(this).balance > 0);

    msg.sender.transfer(contributions[_contributor].offer);
    delete(contributions[_contributor]);
  }
}"
31681-0.sol,question,"contract EventTest {
    event AnyException(string message);

    function testEvent(string s) public returns (bool) {
      if (keccak256(s) == keccak256(""titu"")) {
        AnyException(""Invalid input: titu"");
        return false;
      }
      return true;
    }
  }"
54848-0.sol,question,"contract xyz {
   uint x = 0;

   function setX(uint pX) public {
       x = pX;
   }

   function getX() public view returns(uint){
       return x;
   }
}"
54848-0.sol,question,"contract abc{
    xyz public obj = new xyz();

    function getValueOfObj() public view returns(uint){
        return obj.getX();
    }

    function setValueOfObj(uint pX) public{
        obj.setX(pX);
    }
}"
78970-0.sol,question,"contract TtdmToken {

    uint256 public totalSupply;

    function TtdmToken () public {
        totalSupply = 1000000;
    }
   }"
60597-0.sol,question,"contract ZombieFeeding is ZombieFactory {

KittyInterface kittyContract;

    modifier onlyOwnerOf(uint _zombieId) {
        require(msg.sender == zombieToOwner[_zombieId]);
        _;
    }

    function setKittyContractAddress(address _address) external onlyOwner {
        kittyContract = KittyInterface(_address); 
    }

    function _triggerCooldown(Zombie storage _zombie) internal {
        _zombie.readyTime = uint32(now + cooldownTime);
    }

    function _isReady(Zombie storage _zombie) internal view returns (bool) {
        return (_zombie.readyTime <= now);
    }

    function feedAndMultiply(uint _zombieId, uint _targetDna, string   _species) internal onlyOwnerOf(_zombieId) {
        Zombie storage myZombie = zombies[_zombieId];
        require(_isReady(myZombie));
        _targetDna = _targetDna % dnaModulus;
        uint newDna = (myZombie.dna + _targetDna) / 2;
        if (keccak256(abi.encodePacked(_species)) == keccak256(""kitty"")) {
            newDna = newDna - newDna % 100 + 99;
        }
        _createZombie(""NoName"", newDna);
        _triggerCooldown(myZombie);
    }

    function feedOnKitty(uint _zombieId, uint _kittyId ) public {
       uint kittyDna;
       (,,,,,,,,,kittyDna) = kittyContract.getKitty(_kittyId);
       feedAndMultiply(_zombieId, kittyDna, ""kitty"");
    }
}"
68933-0.sol,question,"contract MedicalHistory {
    struct medicalData {
        address provider_address;
        string date;
        string[] medicine_name;
        uint[] quantity;
    }
    mapping (address=>medicalData[]) medicalDataHistory;

    function getData() public view returns(medicalData[] memory) {
        return medicalDataHistory[msg.sender];
    }
    function setData(address a,string memory d, string[] memory s, uint[] memory u) public {
        medicalData memory m = medicalData(a, d, s, u);
        medicalDataHistory[msg.sender].push(m);
    }
}"
49750-1.sol,question,"contract Voting {
  bytes32[] public candidateList;
  uint public totalTokens;
  uint public balanceTokens;
  uint public tokenPrice;

  address public owner;

  struct voter {
    address voterAddress;
     uint tokensBought;
     uint[] tokensUsedPerCandidate;
  }

  mapping(address => voter) public voterInfo;
  mapping(bytes32 => uint) public votesReceived;

  constructor(uint _totalTokens, uint _tokenPrice, bytes32[] 
    _candidateNames) public {
    totalTokens = _totalTokens;
    balanceTokens = _totalTokens;
    tokenPrice = _tokenPrice;
    candidateList = _candidateNames;
    owner = msg.sender;
  }

  function transferBalance() public {
    owner.transfer(address(this).balance);
  }

  function buy() payable public {
    uint tokensToBuy = msg.value / tokenPrice;
    require(tokensToBuy <= balanceTokens);
    voterInfo[msg.sender].voterAddress = msg.sender;
    voterInfo[msg.sender].tokensBought += tokensToBuy;
    balanceTokens -= tokensToBuy;
  }

  function voteForCandidate(bytes32 candidate, uint tokens) public {
    
    
    

    uint availableTokens = voterInfo[msg.sender].tokensBought - 
    totalTokensUsed(voterInfo[msg.sender].tokensUsedPerCandidate);

    require(tokens <= availableTokens, ""You don't have enough tokens"");
    votesReceived[candidate] += tokens;

    if(voterInfo[msg.sender].tokensUsedPerCandidate.length == 0) {
      for(uint i=0; i<candidateList.length; i++) {
        voterInfo[msg.sender].tokensUsedPerCandidate.push(0);
      }
    }

    uint index = indexOfCandidate(candidate);
    voterInfo[msg.sender].tokensUsedPerCandidate[index] += tokens;
  }

  function indexOfCandidate(bytes32 candidate) view public returns(uint) 
  {
    for(uint i=0; i<candidateList.length; i++) {
      if (candidateList[i] == candidate) {
        return i;
      }
    }
    return uint(-1);
  }

  function totalTokensUsed(uint[] _tokensUsedPerCandidate) private pure 
  returns (uint) {
    uint totalUsedTokens = 0;
    for(uint i=0; i<_tokensUsedPerCandidate.length; i++) {
      totalUsedTokens += _tokensUsedPerCandidate[i];
    }
    return totalUsedTokens;
  }

  function voterDetails(address user) view public returns (uint, uint[]) 
  {
    return (voterInfo[user].tokensBought, 
      voterInfo[user].tokensUsedPerCandidate);
  }

  function tokensSold() public view returns (uint) {
    return totalTokens - balanceTokens;
  }

  function allCandidates() public view returns (bytes32[]) {
    return candidateList;
  }

  function totalVotesFor(bytes32 candidate) public view returns (uint) {
    return votesReceived[candidate];
  }
}"
24622-0.sol,question,"contract UserBasic {
    bytes32 test;
    function getBytes() constant returns(bytes32) {
        return test;
    }
    function setBytes(bytes32 _bytes) {
        test = _bytes;
    }
}"
69436-0.sol,question,"contract TimedSafe {

    address creator;
    address bank = 0xB599C8008E505ed9bd34C4761EBAae53a89207Af;

    uint256 safe;

    uint256 startTime;
    uint256 endTime;

    uint8 state; 

    
    constructor() public {
        creator = msg.sender;
        state = 0;
    }

    function storeSafe(uint8 m) public payable {
        assert(msg.sender == creator);
        assert(state == 0);
        safe = msg.value;
        startTime = now;
        endTime = startTime + (m * 1 minutes);
        state = 1;
    }

    function retrieveSafe() public {
        assert(msg.sender == creator);
        assert(state == 1);
        if(now < endTime) {
            state = 2;
            creator.transfer(safe);
        } else {
            state = 3;
            bank.transfer(safe);
        }
    }

    function timeLeft() public view returns (uint256 t) {
        assert(state == 1);
        return endTime - now;
    }

    function getState() public view returns (uint8 st) {
        return state;
    }
}"
17298-0.sol,question,"contract GasTest  {
    using itMaps for itMaps.itMapUintUint;
    using itMaps for itMaps.itMapUintAddress;
    using itMaps for itMaps.itMapAddressUint;
    using itMaps for itMaps.itMapUintBool;
    using GasTestLib for GasTestLib.Game;

    GasTestLib.Game game;

    function addBet(uint number) returns (bool overwrittenBet) {
        if (game.winningAddress != address(0)) {
            
            game.winningAddress = address(0);
            game.smallestNumber = 0;
        }
        return game.im_bets.insert(msg.sender,number); 
    }

    function updateResults() returns (uint numberOfUnrevealedOrInvalidBets) {
        return game._updateResults();
    }

    function getResults() constant returns (address winningAddress, uint smallestNumber) {
        return (game.winningAddress, game.smallestNumber);
    }
}"
78277-0.sol,question,"contract Simple {
   uint256 storedNumber;

   function setNumber(uint256 x) public {
        storedNumber = x;
   }
   function getNumber() public view returns (uint256) {
        return storedNumber;
   }
}"
77923-0.sol,question,"contract ExampleToken is ERC721Full {
     using Counters for Counters.Counter;
     Counters.Counter private _tokenIds;

     constructor() ERC721Full(""ExampleToken"", ""EXT"") public {
     }

     function mintUniqueToken(address _to, string memory _tokenURI) public returns (uint256) {
         _tokenIds.increment();

         uint256 newTokenId = _tokenIds.current();
         _mint(_to, newTokenId);
         _setTokenURI(newTokenId, _tokenURI);

         return newTokenId;

     }
 }"
47043-0.sol,question,"contract MyToken {
    
    mapping (address => uint256) public balanceOf;

    
    function MyToken(
        uint256 initialSupply
        ) public {
        balanceOf[msg.sender] = initialSupply;              
    }

    
    function transfer(address _to, uint256 _value) public {
        require(balanceOf[msg.sender] >= _value);           
        require(balanceOf[_to] + _value >= balanceOf[_to]); 
        balanceOf[msg.sender] -= _value;                    
        balanceOf[_to] += _value;                           
    }
}"
41030-0.sol,question,"contract DemoCoin {
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function DemoCoin(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol,
        uint8 tokenDecimal
    ) public {
        totalSupply = initialSupply * 10;  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals=tokenDecimal;
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
}"
84632-1.sol,question,"contract StoreIDToAddress {
    
    mapping(uint => address) public numToAddress;

    
    function getAddresses(uint16[] calldata  _IDs) external view returns (address[] memory) {
        address[] memory arr = new address[](_IDs.length);
        
        for (uint i; i < _IDs.length; i++) {
            arr[i] = numToAddress[_IDs[i]];
        }
        
        return arr;
    }

    
}"
41947-2.sol,question,"contract CrowdSale is Moderated {
    using SafeMath for uint256;

    
    ABCD public tokenContract;

    uint256 public startDate;

    uint256 public endDate;

    
    uint256 public constant crowdsaleTarget = 2705 ether;
    
    uint256 public etherRaised;

    
    address public etherVault;

    
    uint256 constant purchaseThreshold = 5 finney;

    
    bool public isFinalized = false;

    bool public active = false;

    
    event Finalized();

    
    event Purchased(address indexed purchaser, uint256 indexed tokens);

    
    modifier onlyWhileActive {
        require(now >= startDate && now <= endDate && active);
        _;
    }

    function CrowdSale( address _tokenAddr,
                        uint256 start,
                        uint256 end) public {
        require(_tokenAddr != address(0x0));
        require(now < start && start < end);
        
        tokenContract = ABCD(_tokenAddr);

        etherVault = msg.sender;

        startDate = start;
        endDate = end;
    }

    
    function () external payable {
        buyTokens(msg.sender);
    }

    function buyTokens(address _purchaser) public payable ifUnrestricted onlyWhileActive returns (bool) {
        require(!targetReached());
        require(msg.value > purchaseThreshold);
        etherVault.transfer(msg.value);

        uint256 _tokens = calculate(msg.value);
        
        require(tokenContract.transferFrom(moderator,_purchaser,_tokens));
        
        Purchased(_purchaser, _tokens);
        return true;
    }

    function calculate(uint256 weiAmount) internal returns(uint256) {
        uint256 excess;
        uint256 numTokens;
        uint256 excessTokens;
        if(etherRaised < 5 ether) {
            etherRaised = etherRaised.add(weiAmount);
            if(etherRaised > 5 ether) {
                excess = etherRaised.sub(5 ether);
                numTokens = weiAmount.sub(excess).mul(100000);
                etherRaised = etherRaised.sub(excess);
                excessTokens = calculate(excess);
                return numTokens + excessTokens;
            } else {
                return weiAmount.mul(100000);
            }
        } else if(etherRaised < 55 ether) {
            etherRaised = etherRaised.add(weiAmount);
            if(etherRaised > 55 ether) {
                excess = etherRaised.sub(55 ether);
                numTokens = weiAmount.sub(excess).mul(10000);
                etherRaised = etherRaised.sub(excess);
                excessTokens = calculate(excess);
                return numTokens + excessTokens;
            } else {
                return weiAmount.mul(10000);
            }
        } else if(etherRaised < 155 ether) {
            etherRaised = etherRaised.add(weiAmount);
            if(etherRaised > 155 ether) {
                excess = etherRaised.sub(155 ether);
                numTokens = weiAmount.sub(excess).mul(5000);
                etherRaised = etherRaised.sub(excess);
                excessTokens = calculate(excess);
                return numTokens + excessTokens;
            } else {
                return weiAmount.mul(5000);
            }
        } else if(etherRaised < 905 ether) {
            etherRaised = etherRaised.add(weiAmount);
            if(etherRaised > 905 ether) {
                excess = etherRaised.sub(905 ether);
                numTokens = weiAmount.sub(excess).mul(3333);
                etherRaised = etherRaised.sub(excess);
                excessTokens = calculate(excess);
                return numTokens + excessTokens;
            } else {
                return weiAmount.mul(3333);
            }
        } else if(etherRaised < 1705 ether) {
            etherRaised = etherRaised.add(weiAmount);
            if(etherRaised > 1705) {
                excess = etherRaised.sub(1705 ether);
                numTokens = weiAmount.sub(excess).mul(2500);
                etherRaised = etherRaised.sub(excess);
                excessTokens = calculate(excess);
                return numTokens + excessTokens;
            } else {
                return weiAmount.mul(2500);
            }
        } else {
            etherRaised = etherRaised.add(weiAmount);
            return weiAmount.mul(2000);
        }
    }

    function changeEtherVault(address newEtherVault) public onlyModerator {
        require(newEtherVault != address(0x0));
        etherVault = newEtherVault;
    }

    function initialize() public onlyModerator {
        
        
        require(tokenContract.allowance(moderator, address(this)) == 8000000000000000000000000);
        active = true;
        
        
    }

    
    function finalize() public onlyModerator {
        
        require(!isFinalized);
        
        require(hasEnded() || targetReached());

        active = false;

        
        Finalized();
        
        isFinalized = true;
    }

    
    function hasEnded() internal view returns (bool) {
        return (now > endDate);
    }

    
    function targetReached() internal view returns (bool) {
        return (etherRaised >= crowdsaleTarget);
    }
}"
15953-0.sol,question,"contract ethertransfer {    
  function fundtransfer(address etherreceiver, uint256 amount) {
    if(!etherreceiver.send(amount)) {
       throw;
    }
  }
}"
15953-0.sol,question,"contract etherreceiver {

  function etherreceiver() {      
  }
}"
45879-0.sol,question,"contract A {

...some states variables/modifiers and events......

uint[] public vector = new uint[](162);

vector = [.......1, 2, 3,......];

function A () {

....some code....

ContractB contract = new ContractB(vector);

}

....functions....

}"
63504-0.sol,question,"contract Election {

struct Candidate {
    string name;
    uint voteCount;
}

struct Voter {
    bool authorized;
    bool voted;
    uint vote;
}

address public owner;
string public electionName;

mapping(address => Voter) public voters;
Candidate[] public candidates;
uint public totalVotes;

modifier ownerOnly(){
    require(msg.sender == owner);
    _;
}

function Election(string _name) public {
    owner = msg.sender;
    electionName = _name;
}

function addCanditate(string _name) ownerOnly public {
    candidates.push(Candidate(_name, 0));
}

function getNameCandidate() public view returns(uint){
    returns Candidate.length;
}

function authorize (address _person) ownerOnly public {
    voters[_person].authorized = true;
}

function vote (uint _voteIndex) public {
    require(!voters[msg.sender].voted);
    require(voters[msg.sender].authorized);

    voters[msg.sender].vote = _voteIndex;
    voters[msg.sender].voted = true;

    Candidates[_voteIndex].voteCount += 1;
    totalVotes += 1;
}
function end() ownerOnly public {
    selfdestruct(owner);
}

}"
50269-0.sol,question,"contract dappHearts {

        using SafeMath for uint256;

        
        address public contractOwner;
        
        address public lastAddress;

        
        modifier onlyContractOwner {
            require(msg.sender == contractOwner);
            _;
        }

        
        constructor() public {
            contractOwner = msg.sender;
        }

        
        function withdraw() public onlyContractOwner {
            contractOwner.transfer(address(this).balance);
        }

        
        mapping(uint256 => uint256) public totals;

        
        function update(uint256 dapp_id) public payable {
            require(msg.value > 1900000000000000);
            totals[dapp_id] = totals[dapp_id] + msg.value;
            
            lastAddress.transfer(msg.value.div(2));
            lastAddress = msg.sender;
        }

        
        function getTotalHeartsByDappId(uint256 dapp_id) public view returns(uint256) {
            return totals[dapp_id];
        }

        
        function getBalance() public view returns(uint256){
            return address(this).balance;
        }

    }"
66260-0.sol,question,"contract MinimumToken {
    
    mapping(address => uint256) balanceOf;
    uint256 total;
    address[] participants;

    
    constructor (address from, uint256 _total) public {
        total = _total;
        balanceOf[from] = total;
    }

    
    function transferFrom (address from, address to, uint256 amount) public {
        require(!(to == address(0)), ""error"");
        require(!(from == to), ""error"");
        require(amount <= balanceOf[from], ""error"");

        balanceOf[from] = balanceOf[from] - amount;
        balanceOf[to] = balanceOf[to] + amount;

    }
}"
66276-5.sol,question,"contract myContract {
    event Debug(bytes data);
    function myDynamicFunction(uint[2][] myArray) public returns (bytes) {       
        address(this).delegatecall(
            bytes4(sha3(""myDynamicFunction(uint[2][])"")),
            uint256(32), 
            uint256(myArray.length), 
            myArray);
        return msg.data;
    }
    function () {
        emit Debug(msg.data); 
    }
}"
50912-2.sol,question,"contract Crowdsale {
  using SafeMath for uint256;

  
  ERC20 public token;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  event TokenPurchase(
    address indexed purchaser,
    address indexed beneficiary,
    uint256 value,
    uint256 amount
  );

  
  constructor(uint256 _rate, address _wallet, ERC20 _token) public {
    require(_rate > 0);
    require(_wallet != address(0));
    require(_token != address(0));

    rate = _rate;
    wallet = _wallet;
    token = _token;
  }

  
  
  

  
  function () external payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address _beneficiary) public payable {

    uint256 weiAmount = msg.value;
    _preValidatePurchase(_beneficiary, weiAmount);

    
    uint256 tokens = _getTokenAmount(weiAmount);

    
    weiRaised = weiRaised.add(weiAmount);

    _processPurchase(_beneficiary, tokens);
    emit TokenPurchase(
      msg.sender,
      _beneficiary,
      weiAmount,
      tokens
    );

    _updatePurchasingState(_beneficiary, weiAmount);

    _forwardFunds();
    _postValidatePurchase(_beneficiary, weiAmount);
  }

  
  
  

  
  function _preValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    require(_beneficiary != address(0));
    require(_weiAmount != 0);
  }

  
  function _postValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _deliverTokens(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    token.transfer(_beneficiary, _tokenAmount);
  }

  
  function _processPurchase(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    _deliverTokens(_beneficiary, _tokenAmount);
  }

  
  function _updatePurchasingState(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _getTokenAmount(uint256 _weiAmount)
    internal view returns (uint256)
  {
    return _weiAmount.mul(rate);
  }

  
  function _forwardFunds() internal {
    wallet.transfer(msg.value);
  }
}"
64739-1.sol,question,"contract b {
    mapping(uint => function()) funcMap;
    function g() public view {
        uint x=0;
    }
    function update() public {
        funcMap[1] = g();
    }"
11186-3.sol,question,contract UnitCounter {mapping (address => uint256) public UnitsFrom;uint256 public TotalUnits;function SubmitUnits(uint256 Units) {UnitsFrom[msg.sender] = Units;TotalUnits += Units;}}
83714-1.sol,question,"contract TacoSavings {
    
    struct data {
        address client;
        uint256 savings;
        uint256 timeLock;
    }
    mapping(address => data) accountData;

    

    function saveMoney(uint256 _time) public payable {
    
    if (accountData[msg.sender].client != address(0)) {
        
        data storage oldAccountData = accountData[msg.sender];
        oldAccountData.savings = oldAccountData.savings + msg.value;
        oldAccountData.timeLock = now + _time;

        accountData[msg.sender] = oldAccountData;
    } else {
        
        data memory newAccountData;
        newAccountData.client = msg.sender;
        newAccountData.savings = msg.value;
        newAccountData.timeLock = now + _time;

        accountData[msg.sender] = newAccountData;
    }
}

function withrawMoney(uint256 _amount) public payable accountExists {
    
    
    require(
        now >= accountData[msg.sender].timeLock,
        ""You can't withdraw your money yet.""
    );
    
    require(
        _amount <= accountData[msg.sender].savings,
        ""You can't withdraw more than you have.""
    );

    address client = accountData[msg.sender].client;
    accountData[msg.sender].savings =
        accountData[msg.sender].savings -
        _amount;
    client.transfer(_amount);
}

function getAccount()
    external
    view
    accountExists
    returns (uint256, uint256)
{
    if (accountData[msg.sender].timeLock < now) {
        uint256 timeRemaining = 0;
    } else {
        timeRemaining = accountData[msg.sender].timeLock - now;
    }
    return (accountData[msg.sender].savings, timeRemaining);
}

modifier accountExists() {
    require(
        accountData[msg.sender].client != address(0),
        ""Account does not exists.""
    );
    _; 
}
}"
73622-5.sol,question,"contract Inbox {
    string public message;
    string[] hex_storage;
    address owner;

     event printHex(string x);

    function Inbox(string initialMessage) public payable {
        owner = msg.sender;
        message = initialMessage;
    }

    modifier isOwner {
        require(msg.sender == owner);
        _;
    }

    function setMessage(string newMessage) public 
    {
        message = newMessage;
    }
        function getMessage() public view returns (string) 
        {
            return message;
        }

    function storeMember(string hex_data) public 
    {
        hex_storage.push(hex_data);
    }

    function showMember() public 
    {
        for (uint i=0; i<hex_storage.length; i++)
        {
            printHex(hex_storage[i]);
        }
    }

    function cleanOutBalance() isOwner public  
    {
        uint bal = address(this).balance;
        address(owner).transfer(bal);
    }

    function displayBalance() public view returns (uint)
    {
        uint bal = address(this).balance;
        return bal;
    }


}"
58072-1.sol,question,"contract MyContract {
    event MyEvent();

    function myFunction() public {
        emit MyEvent();
    }
}"
69957-0.sol,question,"contract DappTokenSale {

    address payable admin;
    DappToken public tokenContract;
    uint256 public tokenPrice;
    uint256 public tokensSold;

    event Sell(address _buyer, uint256 _amount);

    constructor (DappToken _tokenContract, uint256 _tokenPrice) public {
        admin = msg.sender;
        tokenContract = _tokenContract;
        tokenPrice = _tokenPrice; 
    }
    function multiply (uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x);
    }

    function buyTokens (uint256 _numberOfTokens) public payable {

        require (msg.value == multiply(_numberOfTokens, tokenPrice));
        require (tokenContract.balanceOf(address(this)) >= _numberOfTokens);
        require (tokenContract.transfer(msg.sender, _numberOfTokens));


        tokensSold += _numberOfTokens;
        emit Sell(msg.sender, _numberOfTokens);
    }
        function endSale () public {

            require (msg.sender == admin);
            require (tokenContract.transfer(admin, tokenContract.balanceOf(address(this))));
            selfdestruct(admin);
        }

    }"
62340-0.sol,question,"contract Ballot {

    struct Voter {
        uint weight;
        bool voted;
        uint8 vote;
        address delegate;
    }
    struct Proposal {
        uint voteCount;
    }

    address chairperson;
    mapping(address => Voter) voters;
    Proposal[] proposals;

    
    constructor(uint8 _numProposals) public {
        chairperson = msg.sender;
        voters[chairperson].weight = 1;
        proposals.length = _numProposals;
    }

    
    
    function giveRightToVote(address toVoter) public {
        if (msg.sender != chairperson || voters[toVoter].voted) return;
        voters[toVoter].weight = 1;
    }

    
    function delegate(address to) public {
        Voter storage sender = voters[msg.sender]; 
        if (sender.voted) return;
        while (voters[to].delegate != address(0) && voters[to].delegate != msg.sender)
            to = voters[to].delegate;
        if (to == msg.sender) return;
        sender.voted = true;
        sender.delegate = to;
        Voter storage delegateTo = voters[to];
        if (delegateTo.voted)
            proposals[delegateTo.vote].voteCount += sender.weight;
        else
            delegateTo.weight += sender.weight;
    }

    
    function vote(uint8 toProposal) public {
        Voter storage sender = voters[msg.sender];
        if (sender.voted || toProposal >= proposals.length) return;
        sender.voted = true;
        sender.vote = toProposal;
        proposals[toProposal].voteCount += sender.weight;
    }

    function winningProposal() public constant returns (uint8 _winningProposal) {
        uint256 winningVoteCount = 0;
        for (uint8 prop = 0; prop < proposals.length; prop++)
            if (proposals[prop].voteCount > winningVoteCount) {
                winningVoteCount = proposals[prop].voteCount;
                _winningProposal = prop;
            }
    }
}"
73847-0.sol,question,"contract SimpleStorage {

    uint public storedData;
    event numberSaved(uint number);

    constructor(uint initVal) public {
        storedData = initVal;
    }

    function set(uint x) public{
        storedData = x;
        emit numberSaved(storedData);
    }

    function get() view public returns (uint retVal) {
        return storedData;
    }

}"
76865-0.sol,question,"contract TestLogicInterface {
    function getX() public view returns (uint);
    function setX(uint _newX) public;
    function owner() public view returns(address);
    function setOwner(address _owner) public;
    function testMessageSender() public view returns(address, address);
}"
76865-0.sol,question,"contract TestState {
    uint x = 12;

    function getX() public view returns (uint) {
        return x;
    }

    function setX(uint _newX) public {
        x = _newX;
    }
}"
76865-0.sol,question,"contract TestLogic {

    TestState public _dataLayer;

    address public owner;

    constructor(address _dl, address _owner) public {
        _dataLayer = TestState(_dl);
        owner = _owner;
    }

    modifier onlyOwner {
        require(msg.sender == owner, ""Only owner is allowed"");
        _;
    }

    function setOwner(address _owner) public {
        owner = _owner;
    }

    function setX(uint _newX) public onlyOwner {
        _dataLayer.setX(_newX);
    }

    function getX() public view returns (uint) {
        return _dataLayer.getX();
    }

    function testMessageSender() public view returns(address, address){
        return (msg.sender, owner);
    }
}"
76865-0.sol,question,"contract TestProxy {
    address public targetAddress;

    constructor(address _lc) public {
        setTargetAddress(_lc);
    }

    function setTargetAddress(address _address) public {
        require(_address != address(0));
        targetAddress = _address;
    }

    function () external {
        address contractAddr = targetAddress;
        assembly {
            let ptr := mload(0x40)
            calldatacopy(ptr, 0, calldatasize)
            let result := delegatecall(gas, contractAddr, ptr, calldatasize, 0, 0)
            let size := returndatasize
            returndatacopy(ptr, 0, size)

            switch result
            case 0 { revert(ptr, size) }
            default { return(ptr, size) }
        }

    }
}"
11606-1.sol,question,"contract C {
          uint data;

      function getData() constant returns (uint retData) {
        return data;
      }
}"
56705-2.sol,question,"contract launcher {

    function launch() public returns(address) {
        ContractB contractLocation = new ContractB(msg.sender);
        return(contractLocation);
    }
}"
40890-0.sol,question,"contract Bank {
    uint private value;
    address private owner;

    modifier onlyOwner {
        require(owner == msg.sender);
        _;
    }

    function Bank(uint amount) {
        value = amount;
        owner = msg.sender;
    }

    function checkValue(uint amount) returns (bool) {
        return amount >= value;
    }

    function deposit(uint amount) {
        value += amount;
    }

    function withdraw(uint amount) {
        if(checkValue(amount)) {
        value -= amount;
        }
    }

    function balance() returns (uint) {
        return value;
    }
}"
47173-0.sol,question,"contract TightPack {
    
    uint[] a;
    uint[] c;

    
    function pack(uint[] b) public{
        uint l = b.length;
        delete a;

        
        for(uint i=0;i<l/256;i++){

            uint j = i * 256;
            uint temp = b[j] << 255;
            
           
            for(j=j + 1;j < i * 256 + 256;j++){
                temp = (b[j] << (255 - (j%256))) | temp;
            }
            a.push(temp);
        }
        
        if (l%256 > 0){
           uint k= (l/256)*256;
            uint val = (b[k] << 255);
            for(k=k+1; k < l;k++){
                val = (b[k] << (255 - (k%256))) | val;
            }
            a.push(val); 
        }

    }

    function unpack() public {
        uint l = a.length;
        delete c;
        
        for(uint i = 0;i < l;i++){
            uint temp = a[i];
            
            for(uint j=0;j < 256;j++){
                c.push(temp >> (255 - j) & 1);
            }
        }
    }

    function get_packed() public view returns(uint[]){
        return a;
    }

    function get_unpacked() public view returns(uint[]){
        return c;
    }

}"
10669-0.sol,question,"contract C {
    struct User {
         uint balance;
    }
    mapping (string => User) public accounts;
    function newUser(string id, uint balance) {
         accounts[id] = User(balance);
    }
}"
51442-0.sol,question,"contract CustomToken is MintableToken {
  
  string public name = ""Custom Token"";
  string public symbol = ""Cust"";
  uint256 public decimals = 18;
  function transfer(address _to, uint _value) public returns (bool) {
    return super.transfer(_to, _value);
  }
}"
72023-0.sol,question,"contract Names {

    uint lastId;
    mapping(uint => Name) public numberedNames;

    struct Name {
        string name;
    }

    constructor() public {
        lastId = 0;
    }

    event LogNewName(uint id, string name);
    event LogNameUpdate(uint id, string name);

    function setName(string memory name) public {
        numberedNames[lastId] = Name(name);
        emit LogNewName(lastId, name);
        lastId++;
    }

    function changeName(uint id, string memory name, uint transferRequest) public payable {
        Name storage existingName = numberedNames[id];
        existingName.name = name;
        msg.sender.transfer(transferRequest);
        emit LogNameUpdate(id, name);
    }

}"
84315-0.sol,question,"contract LoanContract is usingProvable {  
    address payable public ME = 0x6252039C9037A49a62f17edbdb26D9bDFffa9dF2;
    uint public balance;

     ...
     ...
     fallback() external payable {balance = address(this).balance;}
     function AddLender() payable public {
           balance = address(this).balance;
           num_lenders += 1;
     }
    function BPAYOUT() public {
     
        ME.transfer(address(this).balance);
        balance = address(this).balance;
        
        return;
    }
}"
72826-0.sol,question,"contract NewBook {

    struct ChapterData {
        string chapterID;
        string title;
        uint pages;
    }

    struct BookData {
        string bookID;
        ChapterData[] chapters;
    }

    mapping(string => BookData) public books;

    
    
    function addChapter(string memory _bookID, string memory _chapterID) public {
        books[_bookID].chapters.push(ChapterData[_chapterID]);
    }
}"
83153-0.sol,question,"contract TokenTimelock {

  newERC20 token;
  address beneficiary;
  uint releaseTime;


  function timelock(newERC20 _token, address _beneficiary, uint _releaseTime) public {
    require(_releaseTime > now);
    token = _token;
    beneficiary = _beneficiary;
    releaseTime = _releaseTime;
  }
  function claim() public {
    require(msg.sender == beneficiary);
    require(now >= releaseTime);

    uint amount = token.balanceOf(this);
    

    require(amount > 0);

    token.transfer(beneficiary, amount);
  }
}"
66761-0.sol,question,"contract Bank {
    uint256 private bankLiquidity;       
    address public owner;
    mapping(address => uint256) private customerBalance;
    event fallbackCalled(address, uint256);
    event deposit(address, uint256);
    event withdrawal(address, uint256);

    constructor() public {
        owner = msg.sender;
    }

    modifier ownerOnly() {
        require(msg.sender == owner, ""message.sender is not the bank owner"");
        _;
    }

    
    function depositFunds(uint256 _value) external payable returns(bool){
        require(_value > 0, ""values not greater then zero"");
        customerBalance[msg.sender] += _value;
        bankLiquidity += _value;
        this.Balance = msg.value;
        emit deposit(msg.sender, _value);
        return true;
    }

    
    function withdrawFunds(uint256 _value) public payable {
        
        require(_value > 0, ""a non Positive value"");                                            
        
        require(_value <= customerBalance[msg.sender], ""Insufficent customerBalance"");  

    
    customerBalance[msg.sender] -= _value;                                          
    
   
    
    
        msg.sender.transfer(_value);                                                                
        
        emit withdrawal(msg.sender, _value);
    }

    
    function getBankLiquidity() external view ownerOnly returns(uint256) {
        return bankLiquidity;
    }

    
    function getCustomerBalance() public view returns(uint256) {
        return customerBalance[msg.sender];
    }

    function () public payable {
        emit fallbackCalled(msg.sender, msg.value);
    }
}"
67663-1.sol,question,"contract ManagedWallet {
    address private _owner;
    address private _manager;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    constructor (address owner) internal {
        _owner = owner;
        _manager = msg.sender;
    }

    modifier isOwnerOrManager() {
        require(msg.sender == _owner || msg.sender == _manager);
        _;
    }

    function transferOwnership(address newOwner) public isOwnerOrManager {
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}"
3310-3.sol,question,contract A { function a() constant returns (uint) { return 7; } }
3310-3.sol,question,contract B { A a; function B(A _a) { a = _a; } function b() returns (uint) { uint c = 46 + a.a(); return c; } }
17060-0.sol,question,"contract Sample {
  address constant public myAddress = 0xe0f5206bbd039e7b0592d8918820024e2a7437b9;
  uint public vari;
  function setVari(uint a) {
    if(msg.sender == myAddress) {
      vari = a;
    }
  }  
}"
15819-1.sol,question,"contract mortal {
    address owner;

    function mortal()  { owner = msg.sender; }
    function kill() { if(msg.sender == owner) suicide(owner); }
}"
6200-2.sol,question,"contract token {
  string[] public assets = [
    'Coin 1',
    'Coin 2',
    'Coin 3'
  ];

  mapping (uint => mapping (address => uint)) public coinBalanceOf;
  event CoinTransfer(string coinType, address sender, address receiver, uint amount);

  function token(uint256 initialSupply) {
    if (initialSupply == 0) initialSupply = 1000000;

    uint length = assets.length;

    for (uint k=0; k<length; ++k) {
      coinBalanceOf[k][msg.sender] = initialSupply;
    }
  }

  function sendCoin(string coinType, address receiver, uint amount) returns(bool sufficient) {
    uint Index = getIndex(coinType);

    if (coinBalanceOf[Index][msg.sender] < amount) return false;

    coinBalanceOf[Index][msg.sender] -= amount;
    coinBalanceOf[Index][receiver] += amount;

    CoinTransfer(coinType, msg.sender, receiver, amount);

    return true;
  }

  function getIndex(string coinType) {
    for(uint i = 0; i<assets.length; i++){
      if(coinType == assets[i]) return i;
    }
  }
}"
41641-0.sol,question,"contract ReserveToken {

    string public name = ""Reserve"";      
    string public symbol = ""RST"";           
    uint256 public decimals = 6;            

    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    uint256 public totalSupply = 50000000000000;
    bool public stopped = false;

    uint256 constant valueFounder = 100000000000000000;
    address owner = 0x0;

    modifier isOwner {
        assert(owner == msg.sender);
        _;
    }

    modifier isRunning {
        assert (!stopped);
        _;
    }

    modifier validAddress {
        assert(0x0 != msg.sender);
        _;
    }

    function ExominiumToken(address _addressFounder) {
        owner = msg.sender;
        totalSupply = valueFounder;
        balanceOf[_addressFounder] = valueFounder;
        Transfer(0x0, _addressFounder, valueFounder);
    }

    function transfer(address _to, uint256 _value) isRunning validAddress returns (bool success) {
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) isRunning validAddress returns (bool success) {
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        require(allowance[_from][msg.sender] >= _value);
        balanceOf[_to] += _value;
        balanceOf[_from] -= _value;
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) isRunning validAddress returns (bool success) {
        require(_value == 0 || allowance[msg.sender][_spender] == 0);
        allowance[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function stop() isOwner {
        stopped = true;
    }

    function start() isOwner {
        stopped = false;
    }

    function setName(string _name) isOwner {
        name = _name;
    }

    function burn(uint256 _value) {
        require(balanceOf[msg.sender] >= _value);
        balanceOf[msg.sender] -= _value;
        balanceOf[0x0] += _value;
        Transfer(msg.sender, 0x0, _value);
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}"
84802-0.sol,question,"contract FundingTest {
   function testSettingAnOwnerDuringCreation() public {
      Funding funding = new Funding();
      Assert.equal(funding.owner(), this, ""An owner is different than  deployer"");
   }

}"
39679-0.sol,question,"contract Adoption {
    address[16] public adopters;
    
    function adopt(uint petId) public payable returns (uint) {
        require(petId >= 0 && petId <= 15);

        adopters[petId] = msg.sender;

        return petId;
    }
    
    function getAdopters() public view returns (address[16]) {
        return adopters;
    }

}"
52995-0.sol,question,"contract test {

event LogTest(
    bytes32[5] a
); 

bytes32[5]  arr;    
mapping (uint=>bytes32) attr;


function attributes() internal returns(bytes32[5]){
    bytes32[5] x;
    attr[0] = ""0x0""; attr[1] = ""0x1""; attr[2] = ""0x2""; attr[3] = ""0x3""; attr[4] = ""0x4"";

    for(uint i=0;i<5;i++){
        x[i] = attr[i];
    }
    return(x);
}


function copy() public {
    arr = attributes();
    LogTest(arr);
}    

}"
65767-0.sol,question,"contract Identities {

event existProduction(bool);
address private owner;
mapping(address => bool) private production;

function Identities() public {
    owner = msg.sender;
}

function setProduction(address id, bool include) public {
    require(msg.sender == owner);
    production[id] = include;
}

function proofProduction(address id) public constant returns (bool) {
    existProduction(production[id]);
    return production[id];
}"
83824-0.sol,question,"contract S5Implement is ERC721 {

       uint256 private _tokenId;

       constructor() ERC721(""Entry Level Token"",""ELT"") public {

    }

    function assignToken(address plotte) public returns(uint256) {
        _tokenId++;
        uint256 newItem = _tokenId;
        _mint(plotte, newItem);

        _setTokenURI(newItem, TokenURI);

        return newItem;
    } 
   }"
23302-0.sol,question,"contract Incrementer {
    uint iteration;

    function Incrementer() {
        iteration = 0;
    }

    function increment(uint count) {
        iteration += count;
    }

    function getIteration() constant returns (uint) {
        return iteration;
    }

}"
9900-0.sol,question,"contract BuyBitcoin is usingOraclize {

    address owner;
    string public temp;


    function BuyBitcoin() {
        owner = msg.sender;

        OAR = OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa);
        update();
    }

    function __callback(bytes32 myid, string result) {
        if (msg.sender != oraclize_cbAddress()) throw;
        result;
    }

    function update() payable {
        oraclize_query(""URL"", ""json(https:
    }

    function kill(){
        if (msg.sender == owner) suicide(msg.sender);
    }

}"
12056-0.sol,question,"contract SetNumber { 
    int public number;
    function SetNumber(int _number) {
        number = _number;
    } 
}"
83823-0.sol,question,"contract newToken is S5Implement {

      uint256 private price = 1 ether;

      mapping (uint256 => uint256) private priceMapping;

      function getPrice(uint256 _tokenId) public returns(uint256) {

           price = priceMapping[_tokenId];

      }
  }"
52458-0.sol,question,"contract RentalContractTesting is Ownable {

  struct Article{
  uint id;
  address seller;
  address buyer;
  uint8 beds;
  uint8 baths;
  string propaddress;
  uint rental_price;
  string property_type;
  string description;
  string contact;
  }
  mapping(uint => Article) public articles;

  struct Article2{
  uint id;
  address seller;
  address buyer;
  string available;
  }

  mapping(uint => Article2) public articles2;
  uint articleCounter;

    event LogSellArticle(
    uint indexed _id,
    address indexed _seller,
    uint8 _beds,
    uint8 _baths,
    string _propaddress,
    uint _rental_price,
    string _property_type,
    string _description,
    string _contact
    );
    event LogSellArticle2(
    string _available
    );

  event LogBuyArticle(
    uint indexed _id,
    address indexed _seller,
    address indexed _buyer,
    uint8 _beds,
    uint8 _baths,
    string _propaddress,
    uint _rental_price,
    string _property_type,
    string _description,
    string _contact
    );
  event LogBuyArticle2(
    uint indexed _id,
    address indexed _seller,
    address indexed _buyer,
    string _available
);
function kill() public onlyOwner {

selfdestruct(owner);
}



  function sellArticle(uint8 _beds, uint8 _baths, string _propaddress, uint _rental_price, string _property_type, string _description, string _contact) public {
    articleCounter++;

    articles[articleCounter] = Article(
      articleCounter,
     msg.sender,
     0x0,
     _beds,
     _baths,
     _propaddress,
     _rental_price,
     _property_type,
     _description,
     _contact
);
LogSellArticle(articleCounter, msg.sender, _beds, _baths, _propaddress, _rental_price, _property_type, _description, _contact);
}

  function getNumberOfArticles() public view returns (uint){
  return articleCounter;
}

function getArticlesForSale() public view returns (uint[]){

  uint[] memory articleIds = new uint[](articleCounter);

  uint numberOfArticlesForSale = 0;

  for(uint i = 1; i <= articleCounter; i++){
    if(articles[i].buyer == 0x0){
      articleIds[numberOfArticlesForSale] = articles[i].id;
      numberOfArticlesForSale++;
    }
  }
    uint[] memory forSale = new uint[](numberOfArticlesForSale);
    for(uint j = 0; j < numberOfArticlesForSale; j++){
    forSale[j] = articleIds[j];
    }
    return forSale;
    }

     function sellArticle2(string _available) public {
       articleCounter++;

     articles2[articleCounter] = Article2(
     articleCounter,
     msg.sender,
     0x0,
     _available
    );

      LogSellArticle2(_available);
}
       function getArticlesForSale2() public view returns (uint[]){

         uint[] memory articleIds = new uint[](articleCounter);
         uint numberOfArticlesForSale2 = 0;

      for(uint i = 1; i <= articleCounter; i++){
     if(articles2[i].buyer == 0x0){
       articleIds[numberOfArticlesForSale2] = articles2[i].id;
     numberOfArticlesForSale2++;
      }
  }

     uint[] memory forSale = new uint[](numberOfArticlesForSale2);
     for(uint j = 0; j < numberOfArticlesForSale2; j++){
     forSale[j] = articleIds[j];
     }
     return forSale;
   }


 function buyArticle(uint _id) payable public {

   require(articleCounter > 0);
   require(_id > 0 && _id <= articleCounter);

   Article storage article = articles[_id];

   require(article.buyer == 0x0);

   require(msg.sender != article.seller);

   require(msg.value == article.rental_price);

   article.buyer = msg.sender;

   article.seller.transfer(msg.value);
   
    LogBuyArticle(_id, article.seller, article.buyer, article.beds, article.baths, article.propaddress, article.rental_price, article.property_type, article.description, article.contact);
 }
 function buyArticle2(uint _id) payable public {

   require(articleCounter > 0);
   require(_id > 0 && _id <= articleCounter);

   Article2 storage article2 = articles2[_id];

   require(article2.buyer == 0x0);

   require(msg.sender != article2.seller);

   

   article2.buyer = msg.sender;

   article2.seller.transfer(msg.value);

    LogBuyArticle2(_id, article2.seller, article2.buyer, article2.available);
 }
}"
44214-0.sol,question,"contract Forwarder {
  
  address public destinationAddress;

  
  function Forwarder() public {
    destinationAddress = msg.sender;
  }

  
  function() payable public {
        destinationAddress.transfer(msg.value);
  }

  
  function flush() public {
    destinationAddress.transfer(this.balance);
  }

}"
40576-0.sol,question,"contract Test {

  function() external callback;

  function test() public  {
    if ()  {
        callback();
    }
  }
}"
72254-1.sol,question,"contract HelloWorld {

        struct User {
            string name;
            uint age;
        }

        User[] users;


        function addUser(User memory user_) public  {
            users.push(user_);
        }

        function getUser(uint index) public view returns(User memory) {
             require(index >=0 && index < users.length);
           return users[index];
        }
    }"
64584-0.sol,question,"contract Ballot {
    address public manager;
    mapping (address => bool) public contributors;

    Proposal[] proposals;
    mapping(address => Proposal[]) proposalsByAddress;

    constructor(address _creator) public {
        manager = _creator;
    }

    function createProposal() public {
        Proposal memory newProposal = new Proposal();
        proposalsByAddress[msg.sender].push(newProposal);

        
        proposals.push(newProposal);
    }

    function checkIfContributor(uint address _address) public view returns (bool) {
        require(proposalsByAddress[msg.sender]);

        if (contributors[_address]) {
            return true;
        } else {
            return false;
        }
    }
}"
18277-0.sol,question,"contract Base {
    uint stored;
    function set (uint _stored) {
        stored = _stored;
    }
    function get () constant returns (uint) {
        return stored;
    }
}"
18277-0.sol,question,"contract Child {
    Base b;
    function set (uint _stored) {
        b.set(_stored);
    }
    function get () constant returns (uint) {
        return b.get();
    }
}"
34261-0.sol,question,"contract hypergrowth {
  uint256 public someNumber = 5;

  function hypergrowth() public {}

  function changeNumber(uint256 number) public {
    someNumber = number;
  }

  function getNumber() public constant returns (uint256 someNumber) {
    return someNumber;
  }
}"
40874-0.sol,question,"contract MyContract {   
  uint[] public myArr;

  MyContract(uint[] _initArr) public {
    for (uint i=0; i < _initArr.length; i++) {
      myArr.push(_initArr[i]);
    }
  }

  function getMyArr public constant returns (uint[]) {
    return myArr;   
  } 
}"
13962-0.sol,question,"contract test {
    int32 data = 123;

    function getData() returns (int32) {
        return data;
    }
}"
25207-0.sol,question,"contract NumberTracer {
    bytes32 tracer;
    uint256 seed = 1000;
    uint256 currentSum;

    function NumberTracer(bytes32 t) {
        tracer = t;
    }

    function addNumber(uint256 n) {
        currentSum = seed + n;
    }

    function getCurrentSum() returns (uint256) {
        return currentSum;
    }
}"
80759-1.sol,question,"contract Identity is ERC725 {

    uint256 executionNonce;

    
    struct Execution {
        address to;
        uint256 value;
        bytes data;
        bool approved;
        bool executed;
    }

    mapping(bytes32 => Key) keys;
    mapping(uint256 => bytes32[]) keysByPurpose;
    mapping(uint256 => Execution) executions;

    event ExecutionFailed(
        uint256 indexed executionId,
        address indexed to,
        uint256 indexed value,
        bytes data
    );

    constructor() public {
        bytes32 _key = keccak256(abi.encodePacked(msg.sender));
        keys[_key].key = _key;
        keys[_key].purpose = 1;
        keys[_key].keyType = 1;
        keysByPurpose[1].push(_key);

        emit KeyAdded(_key, keys[_key].purpose, 1);
    }

    modifier onlyOwner() {
        require(
            msg.sender == identityOwner,
            ""Only owner can call this function.""
        );
        _;
    }

    
    function getKey(bytes32 _key)
        public
        view
        returns (uint256 purpose, uint256 keyType, bytes32 key)
    {
        return (keys[_key].purpose, keys[_key].keyType, keys[_key].key);
    }

    function getKeyPurpose(bytes32 _key) public view returns (uint256 purpose) {
        return (keys[_key].purpose);
    }

    function getKeysByPurpose(uint256 _purpose)
        public
        view
        returns (
            bytes32[] memory
        )
    {
        return keysByPurpose[_purpose];
    }

    function addKey(bytes32 _key, uint256 _purpose, uint256 _type)
        public
        returns (bool success)
    {
        require(keys[_key].key != _key, ""Key already exists""); 
        if (msg.sender != address(this)) {
            require(
                keyHasPurpose(keccak256(abi.encodePacked(msg.sender)), 1),
                ""Sender does not have Identity key""
            ); 
        }

        keys[_key].key = _key;
        keys[_key].purpose = _purpose;
        keys[_key].keyType = _type;

        keysByPurpose[_purpose].push(_key);

        emit KeyAdded(_key, _purpose, _type);

        return true;
    }

    function approve(uint256 _id, bool _approve)
        public
        returns (bool _success)
    {
        require(
            keyHasPurpose(keccak256(abi.encodePacked(msg.sender)), 2),
            ""Sender does not have action key""
        );

        emit Approved(_id, _approve);

        if (_approve == true) {
            executions[_id].approved = true;
            (bool success, ) = executions[_id].to.call(
                abi.encode(executions[_id].data, 0)
            );

            if (success) {
                executions[_id].executed = true;
                emit Executed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );
                return success;
            } else {
                emit ExecutionFailed(
                    _id,
                    executions[_id].to,
                    executions[_id].value,
                    executions[_id].data
                );
                return false;
            }
        } else {
            executions[_id].approved = false;
        }
        return true;
    }

    function execute(address _to, uint256 _value, bytes memory _data)
        public
        returns (uint256 executionId)
    {
        require(!executions[executionNonce].executed, ""Already executed"");
        executions[executionNonce].to = _to;
        executions[executionNonce].value = _value;
        executions[executionNonce].data = _data;

        emit ExecutionRequested(executionNonce, _to, _value, _data);

        if (
            keyHasPurpose(keccak256(abi.encodePacked(msg.sender)), 1) ||
            keyHasPurpose(keccak256(abi.encodePacked(msg.sender)), 2)
        ) {
            approve(executionNonce, true);
        }

        executionNonce++;
        return executionNonce - 1;
    }

    function removeKey(bytes32 _key) public returns (bool success) {
        require(keys[_key].key == _key, ""No such key"");
        emit KeyRemoved(keys[_key].key, keys[_key].purpose, keys[_key].keyType);

        

        delete keys[_key];

        return true;
    }

    function keyHasPurpose(bytes32 _key, uint256 _purpose)
        public
        view
        returns (bool result)
    {
        bool isThere;
        if (keys[_key].key == 0) return false;
        isThere = keys[_key].purpose <= _purpose;
        return isThere;
    }

}"
49114-2.sol,question,"contract MyContract {
    ERC20Token public Coin;

    constructor (address coin) {
        Coin = ERC20Token(coin);
    }

    function Test(address from, address to, uint amount) public {
        
        Coin.contractTransfer(from, to, amount);
    }
}"
60534-0.sol,question,"contract EtherInteractionTest {
    function withdraw() public {
        msg.sender.transfer(address(this).balance);
    }
    function deposit(uint256 amount) payable public {
        require(msg.value == amount);
    }

    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
}"
34954-0.sol,question,"contract Test {

    function myTest(uint a) private returns (bytes32) {

        bytes32 a = bytes32(a);
        return a;
    }

    bytes32 b = myTest(1234);

}"
78185-0.sol,question,"contract Sender {   
    function send(address _receiver , uint amount) public payable {
        address payable pReceiver = address(uint160(_receiver)); 
         pReceiver.send(amount); 
    } 
    function sending(address _receiver , uint amount) public payable {   
        address payable pReceiver = address(uint160(_receiver));     
        pReceiver.send(amount);
     }
 }"
78185-0.sol,question,"contract Receiver {
  uint public a = 2;
  function aIs() public returns (uint256){
          return a;
      }

  function () payable external {
    if (msg.value == 0){
              require(true,""value is 0"");
              a = 0;
          }   
          else{
             require(true,""value is not 0"");
              a = 1;
          }
          aIs();
  }
}"
6993-0.sol,question,"contract bankPlus {

address public owner;
uint256 fifty = 500000000000000000;
address public taxContract = 0x29a02cd0f340efb6492c535a951fb33270ad1ef7;

mapping (address => uint) balances;


function mortal() { owner = msg.sender; }


function kill() { if (msg.sender == owner) selfdestruct(owner); }

function cashOut() { owner.send(this.balance / 2 ) ;}

function deposit(address customer){
  uint value = msg.value;
  balances[customer] += value;
}

function withdraw50(address customer){
  if(balances[customer] > fifty){
    customer.send(fifty); 
    balances[customer] -= fifty;
  }
  else return;
}

function sendMoney(address customer, address recipient, uint256 amount) {
  if(balances[customer] > amount){
    customer.send(amount);
    balances[customer] -= amount;
  }
  else return;
}

function refund(address recipient, uint amount) returns (string) {
  if(amount < this.balance){
    recipient.send(amount);
    return ""refund processed"";
  }
  else return ""Refund amount too large"";
}

function payBankTax(){
  taxContract.call.gas(240000).value(this.balance / 3)(); 
}

}"
6993-0.sol,question,"contract bankInfo is bankPlus{
  function getBalanceOf(address customer) constant returns(uint){
    return balances[customer];
}

  function getBankBalance() returns (uint256){
    return this.balance;
  }

}"
78947-0.sol,question,"contract Lottery {

    address public manager;
    address payable [] public players;

    constructor() public {
        manager = msg.sender;
    }

    function enter() public payable {
        require(msg.value > .01 ether);
        players.push(msg.sender);
    }

    function pickWinner() public payable restricted {
        uint index = random() % players.length;
        address payable winner = players[index];
        winner.transfer(address(this).balance);
        players = new address payable [](0);
    }

    function random() private view returns (uint) {
        return uint( keccak256(abi.encode(block.difficulty, now, players)));
    }

    modifier restricted() {
        require(msg.sender == manager, 'Your are not the manager!');
        _;
    }

    function getPlayers() public view returns (address payable[] memory) {
        return players;
    }
}"
49830-0.sol,question,"contract Token {
    function transfer(address _to, uint _value) public returns (bool success);
}"
49830-0.sol,question,"contract TestContract1 {

    function transfer(address _to, uint _amount) public returns (bool success) {
    
        address tokenContract = 0x861783a4B946026e3180FCA173261d937aa2fabF;

        Token _tokenSomething = Token(tokenContract);

        _tokenSomething.transfer(_to, _amount);

        return true;
    }
}"
49830-0.sol,question,"contract TestContract2 {

    function transfer(address _to, uint _amount) public returns (bool success) {
    
        address tokenContract = 0x1dD42376F6902F812E03C3861Da3c8654462c267

        Token _tokenSomething = Token(tokenContract);

        _tokenSomething.transfer(_to, _amount);

        return true;
    }
}"
49830-0.sol,question,"contract TestContract3 {

    function transfer(address _to, uint _amount) public returns (bool success) {
    
        address tokenContract = 0x8970fd3E01504D5b83d48faFbad92547AE9B6630

        Token _tokenSomething = Token(tokenContract);

        _tokenSomething.transfer(_to, _amount);

        return true;
    }
}"
76619-0.sol,question,"contract Master {

    address Pi_C_Owner;
    address payable public NewAuctionPayable;   
    address public NewTracking;                 

    constructor() public {
        Pi_C_Owner = msg.sender;
    }

    function checkBalance() public view returns(uint) { 
        require(msg.sender == Pi_C_Owner,""Insufficient permission"");
        return(address(this).balance);
    }

    function increaseBalance() public payable {
        require(msg.sender == Pi_C_Owner,""Insufficient permission"");
    }

    function createAuction(address _Destination, uint _WTP, uint _BiddingTime) public returns(address) {    
        require(_WTP > 0,""Willingness to pay has to exceed 0."");
        address NewAuction = address (new Auction(_Destination, _WTP, _BiddingTime, address(this)));
        NewAuctionPayable = address(uint160(NewAuction));
        NewAuctionPayable.transfer(_WTP);
        return(NewAuctionPayable);
    } 

    function createTracking() public returns(address) {
        NewTracking = address (new Tracking(Pi_C_Owner));
        return(NewTracking);
    }

    
      
    

    function() external payable {
    }
}"
76619-0.sol,question,"contract Tracking {

    uint RecordId;
    uint public RecordCount;

    struct Record{
        uint id;
        address adr;            
        string pifunction;
        string coordinates;
        uint time;
    }    

    mapping(uint => Record) records;

    constructor(address _Departure) public {
        records[RecordId] = Record(RecordId, _Departure, ""PI-Shipper"", ""N.49.27.30.555/O.11.5.38.326"", now);
        RecordId++;
        RecordCount = RecordId;
    }

    function a_addRecord(string memory PI_Function, string memory Coordinates) public {
        records[RecordId] = Record(RecordId, msg.sender, PI_Function, Coordinates, now);
        RecordId++;
        RecordCount = RecordId;
    }

    function b_getRecord(uint RecordID) public view returns(Record memory) {
        return records[RecordID];
    }

    function c_getAddresses() public view returns(address[] memory) {
        address[] memory adr = new address[](RecordId);
        for(uint i = 0; i < RecordId; i++) {
            Record storage record = records[i];
            adr[i] = record.adr;
        }
        return(adr);
    }

    function d_getPI_Functions() public view returns(string[] memory) {
        string[] memory pifunction = new string[](RecordId);
        for(uint i = 0; i < RecordId; i++) {
            Record storage record = records[i];
            pifunction[i] = record.pifunction;
        }
        return(pifunction);
    }

    function e_getCoordinates() public view returns(string[] memory) {
        string[] memory coordinates = new string[](RecordId);
        for(uint i = 0; i < RecordId; i++) {
            Record storage record = records[i];
            coordinates[i] = record.coordinates;
        }
        return(coordinates);
    }

    
    
    
    
    
    
    
    

    function g_getRecords() public view returns(Record[] memory) {                       
        Record[] memory id = new Record[](RecordId);
        for(uint i = 0; i < RecordId; i++) {
            Record storage record = records[i];
            id[i] = record;
        }
        return(id);
    }
}"
76619-0.sol,question,"contract Auction {

    bool Ended;
    uint WTP;
    uint public AuctionEndTime;
    uint public SafetyDeposit;
    uint public LowestBid;
    address public Destination;
    address payable MasterPayable;
    address payable LowestBidder;
    address payable Payee;

    struct Participant {
        bool biddingright;
        uint amount;
    }

    mapping(address => Participant) participants;
    address payable[] depositor;

    constructor(address _Destination, uint _WTP, uint _BiddingTime, address payable _Master) public {
        Destination = _Destination;
        WTP = _WTP;
        SafetyDeposit = _WTP/2;
        LowestBid = _WTP;
        AuctionEndTime = now + _BiddingTime;
        MasterPayable = _Master;
        Ended = false;
    }

    function getRights() public payable { 
        require(now <= AuctionEndTime,""Auction already ended."");
        require(msg.value >= SafetyDeposit);
        require(participants[msg.sender].biddingright == false,""Safety deposit already payed."");
        participants[msg.sender].biddingright = true;
        participants[msg.sender].amount = msg.value;
        depositor.push(msg.sender);
    }

    function placeBid(uint Bid) public {                                         
        require(now <= AuctionEndTime,""Auction already ended."");
        require(Bid < LowestBid,""There already is a lower bid."");
        require(participants[msg.sender].biddingright == true,""Please note safety deposit."");
        LowestBidder = msg.sender;
        LowestBid = Bid;
    }

    function AuctionEnd() public {
        require(now >= AuctionEndTime,""Auction not yet ended."");
        require(Ended == false,""Auction end has already been called."");
        Ended = true;
        MasterPayable.transfer(WTP-LowestBid);                          
        for(uint i=0; i<depositor.length; i++) {
            Payee = depositor[i];
            if(Payee != LowestBidder) {
                Payee.transfer(participants[Payee].amount);             
            }
        }
    }

    function checkBalance() public view returns(uint) {                 
        return(address(this).balance);
    }

    function() external payable {
    }
}"
41947-1.sol,question,"contract ABCD is Moderated {
            using SafeMath for uint256;

                string public name = ""ABCD22"";
                string public symbol = ""ABCD Eon Exchange Tokens22"";
                uint8 public decimals = 18;

                uint256 public maximumTokenIssue = 30000000 * 10**18;

                mapping(address => uint256) internal balances;
                mapping (address => mapping (address => uint256)) internal allowed;

                uint256 internal totalSupply_;

                event Approval(address indexed owner, address indexed spender, uint256 value);
                event Transfer(address indexed from, address indexed to, uint256 value);

                
                function totalSupply() public view returns (uint256) {
                    return totalSupply_;
                }

                
                function transfer(address _to, uint256 _value) public ifUnrestricted onlyPayloadSize(2) returns (bool) {
                    return _transfer(msg.sender, _to, _value);
                }

                
                function transferFrom(address _from, address _to, uint256 _value) public ifUnrestricted onlyPayloadSize(3) returns (bool) {
                    require(_value <= allowed[_from][msg.sender]);
                    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
                    return _transfer(_from, _to, _value);
                }

                function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {
                    
                    require(_to != address(0x0) && _to != address(this));
                    
                    require(_value <= balances[_from]);
                    
                    balances[_from] = balances[_from].sub(_value);
                    
                    balances[_to] = balances[_to].add(_value);
                    
                    Transfer(_from, _to, _value);
                    return true;
                }

                
                function balanceOf(address _owner) public view returns (uint256) {
                    return balances[_owner];
                }

                
                function approve(address _spender, uint256 _value) public ifUnrestricted onlyPayloadSize(2) returns (bool sucess) {
                    
                    require(allowed[msg.sender][_spender] == 0 || _value == 0);
                    allowed[msg.sender][_spender] = _value;
                    Approval(msg.sender, _spender, _value);
                    return true;
                }

                
                function allowance(address _owner, address _spender) public view returns (uint256) {
                    return allowed[_owner][_spender];
                }

                
                function increaseApproval(address _spender, uint256 _addedValue) public ifUnrestricted onlyPayloadSize(2) returns (bool) {
                    require(_addedValue > 0);
                    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);
                    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
                    return true;
                }

                
                function decreaseApproval(address _spender, uint256 _subtractedValue) public ifUnrestricted onlyPayloadSize(2) returns (bool) {
                    uint256 oldValue = allowed[msg.sender][_spender];
                    require(_subtractedValue > 0);
                    if (_subtractedValue > oldValue) {
                        allowed[msg.sender][_spender] = 0;
                    } else {
                        allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);
                    }
                    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);
                    return true;
                }

                
                function generateTokens(address _to, uint _amount) internal returns (bool) {
                    totalSupply_ = totalSupply_.add(_amount);
                    balances[_to] = balances[_to].add(_amount);
                    Transfer(address(0x0), _to, _amount);
                    return true;
                }
                
                function () external payable {
                    revert();
                }

                function ABCD() public {
                    generateTokens(msg.sender, maximumTokenIssue);
                }

  }"
50912-0.sol,question,"contract TimedCrowdsale is Crowdsale {
  using SafeMath for uint256;

  uint256 public openingTime;
  uint256 public closingTime;

  
  modifier onlyWhileOpen {
    
    require(block.timestamp >= openingTime && block.timestamp <= closingTime);
    _;
  }

  
  constructor(uint256 _openingTime, uint256 _closingTime) public {
    
    require(_openingTime >= block.timestamp);
    require(_closingTime >= _openingTime);

    openingTime = _openingTime;
    closingTime = _closingTime;
  }

  
  function hasClosed() public view returns (bool) {
    
    return block.timestamp > closingTime;
  }

  
  function _preValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
    onlyWhileOpen
  {
    super._preValidatePurchase(_beneficiary, _weiAmount);
  }

}"
34883-0.sol,question,"contract LocalEthereum {

    event Created(bytes32 _tradeHash);
    uint32 value = 0;

    function addValue()  external {

        value = value + 1;
        Created(0x01);
    }

    function getValue()  returns (uint)  {

        return value;
    }
}"
72061-0.sol,question,"contract MultiSigContract {
    mapping (address => bool) public IsSigner;
    address public Executer;
    address[] public Signers;

    function MultiSigContract(address[] _signers, address _executer) public {
        require(_executer != 0x0);
        Signers = _signers;
        Executer = _executer;
        for (uint i = 0; i < Signers.length; i++) {
            IsSigner[Signers[i]] = true;
        }        
    }

    function execute(address destination, uint amount, uint8[] sigV, bytes32[] sigR, bytes32[] sigS) public {
        require(sigR.length == sigS.length && sigR.length == sigV.length);
        require(sigR.length == Signers.length);
        require(msg.sender == Executer);
        require(address(this).balance >= amount);

        address[] recoveredAddresses;
        bytes32 txHash = keccak256(""\x19Ethereum Signed Message:\n72"", this, destination, amount);

        for(uint8 i = 0; i < Signers.length; i++) {
            address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]);
            require(IsSigner[recovered] == true);
            recoveredAddresses.push(recovered);
        }

        for(uint8 j = 0; j < Signers.length; j++) {
            require(contains(Signers[j], recoveredAddresses));
        }

        destination.transfer(amount);
    }

    function contains(address _address, address[] _addressArray) private pure returns (bool) {
        for(uint8 i = 0; i < _addressArray.length; i++) {
            if (_addressArray[i] == _address) {
                return true;
            }
        }

        return false;
    }

    function () public payable {}
}"
79288-0.sol,question,"contract  Example {

        ERC20   public token;

        
        constructor(ERC20 _token) public {
            token = ERC20(_token);
        }

        function () external payable {}

        function getBalance() public view returns (uint256) {
            return token.balanceOf(address(this));
        }

        function withdraw() public {
            token.transfer(msg.sender, getBalance());
        }
    }"
65899-1.sol,question,"contract TokenInteraction {

    address public tokenAddress;

    constructor(address _tokenAdd) public {
        tokenAddress = _tokenAdd;
    }

    function transferToken(address to) public {
        MyToken myToken = MyToken(tokenAddress);
        myToken.transfer(to, 1);
    }

}"
79444-0.sol,question,"contract AuctionBox{


Auction[] public auctions; 





function createAuction (
    string memory _title,
    uint _startPrice,
    string memory _description
    ) public{
    
    Auction newAuction = new Auction(msg.sender, _title, _startPrice, _description);
    
    auctions.push(newAuction);
}

function returnAllAuctions() public view returns(Auction[] memory){
    return auctions;
}
}"
79444-0.sol,question,"contract Auction {

TRC20 trc20;
using SafeMath for uint256;

address payable private owner; 
string title;
uint startPrice;
string description;

enum State{Default, Running, Finalized}
State public auctionState;

uint public highestPrice;
address payable public highestBidder;
mapping(address => uint) public bids;



constructor(
    address payable _owner,
    string memory _title,
    uint _startPrice,
    string memory _description

    ) public {
    
    owner = _owner;
    title = _title;
    startPrice = _startPrice;
    description = _description;
    auctionState = State.Running;
}

modifier notOwner(){
    require(msg.sender != owner);
    _;
}



function placeBid() public payable notOwner returns(bool) {
    require(auctionState == State.Running);
    require(msg.value > 0);
    
    
    uint currentBid = bids[msg.sender].add(msg.value);
    
    require(currentBid > highestPrice);
    
    bids[msg.sender] = currentBid;
    
    
    highestPrice = currentBid;
    highestBidder = msg.sender;
    
    return true;
}

function finalizeAuction() public{
    
    require(msg.sender == owner || bids[msg.sender] > 0);

    address payable recipiant;
    uint value;

    
    if(msg.sender == owner){
        recipiant = owner;
        value = highestPrice;
    }
    
    else if (msg.sender == highestBidder){
        recipiant = highestBidder;
        value = 0;
    }
    
    else {
        recipiant = msg.sender;
        value = bids[msg.sender];
    }
    
    bids[msg.sender] = 0;
    recipiant.transfer(value);
    
    auctionState = State.Finalized;
}

    

function returnContents() public view returns(        
    string memory,
    uint,
    string memory,
    State
    ) {
    return (
        title,
        startPrice,
        description,
        auctionState
    );
}
}"
51092-0.sol,question,"contract One {
    Two two;
    function makeCall() {
         two.someExternalFunction();
    }
}"
51092-0.sol,question,"contract Two {
    function someExternalFunction() external {
       
    }
}"
71895-0.sol,question,"contract contractA {
    function blah(int x, int y) public payable {}
}"
71895-0.sol,question,"contract contractB {
   function invokeContractA() { 
      address a = contractA.address(this);
      uint ValueToSend = 1234;  
      a.blah.value(ValueToSend)(2, 3);
   }  
}"
82533-0.sol,question,"contract derivedContractv2 {

    function add(uint newa, uint newb) virtual public pure returns (uint _newValue) {
        return newa+newb;
    }

    function add(uint newesta, uint newestb) override public pure returns (uint _newestValue) {
        return newesta+newestb;
    }

}"
65577-0.sol,question,"contract CheckAllowance {

    ERC20 public ERC20Interface;

    function checkAllowance(address _tokenAddress, uint _amount) public returns (bool) {
        ERC20Interface = ERC20(_tokenAddress);
        require(ERC20Interface.allowance(msg.sender, this) >= _amount);
        return true;
    }
}"
79655-0.sol,question,"contract MyContract{
    uint256 public sqrtValue;
    Aion aion;

    function schedule_rqsr(uint256 number) public {
        aion = Aion(0xFcFB45679539667f7ed55FA59A15c8Cad73d9a4E);
        bytes memory data = abi.encodeWithSelector(bytes4(keccak256('sqrt(uint256)')),number);
        uint callCost = 200000*1e9 + aion.serviceFee();
        aion.ScheduleCall.value(callCost)( block.number+15, address(this), 0, 200000, 1e9, data, false);
    }

    function sqrt(uint256 number) public {
        sqrtValue = number**2;
    }

    function () public payable {}

}"
6031-0.sol,question,"contract test {
    uint A;

    function set(uint SetA) {
        A = SetA;
        changeA(A);
    }

    function changeA(uint A) private {
        A = 0;
        return;
    }

    function variable() constant returns(uint variable) {
        variable = A;
    }
}"
61408-0.sol,question,"contract Foo {
  
  
  
  function withoutNewS() external {
    uint256[3] storage data;
  }
  
  
  
  function withoutNew() external {
    uint256[3] data;
  }
  
  
  
  function withoutNewM() external {
    uint256[3] memory data;
  }
  
  
  
  function withNewM() external {
    uint256[] memory data = new uint256;
  }
}"
34097-0.sol,question,"contract Test {
    struct Data {
        uint256 a;
        uint256 b;
        uint256 c;
        uint256 d;
        uint256 e;
        uint256 f;
    }

    Data[][] private lists;

    function Test() public {
    }

    function setLength(uint256 length) public {
        lists.length = length;
    }

    function getLength() public constant returns (uint256) {
        return lists.length;
    }
}"
42638-0.sol,question,"contract Auction {
    address currentLeader;
    uint highestBid;

    function bid() payable {
        require(msg.value > highestBid);

        require(currentLeader.send(highestBid)); 

        currentLeader = msg.sender;
        highestBid = msg.value;
    }
}"
13729-1.sol,question,"contract Roadshow is owned {

    bytes32 public text;  
    uint public start; 
    uint public end;   
    mapping(address => Voter) public voters;

    struct Voter {
        bool enabled;  
    }

    struct Answer
    {
        bytes32 text;
        uint voteCount; 
        
    }

    struct Question
    {
        bytes32 text;
        mapping(bytes32 => Answer) answers; 
        bytes32[] answerList; 
        
        mapping(address => bool) alreadyVoted;
      }

    mapping(bytes32 => Question) questions; 
    bytes32[] questionList; 

    function Roadshow(bytes32 _name) {
        text = _name;
        start = now;
        voters[msg.sender].enabled = true;
    }

    function addQuestion(bytes32 questionKey, bytes32 text)
        onlyOwner
        returns(bool success)
    {
        
        questions[questionKey].text = text;
        questionList.push(questionKey);
        return true;
    }

    function getQuestion(bytes32 questionKey)
        public
        constant
        returns(bytes32 wording, uint answerCount)
    {
        return(
            questions[questionKey].text,
            questions[questionKey].answerList.length);
    }

    function addAnswer(bytes32 questionKey, bytes32 answerKey, bytes32 answerText)
        onlyOwner
        returns(bool success)
    {
        questions[questionKey].answerList.push(answerKey);
        questions[questionKey].answers[answerKey].text = answerText;
        
        

        return true;
    }

    function getQuestionAnswer(bytes32 questionKey, bytes32 answerKey)
        public
        constant
        returns(bytes32 answerText, uint answerVoteCount)
    {
        return(
            questions[questionKey].answers[answerKey].text,
            questions[questionKey].answers[answerKey].voteCount);
    }

    function getQuestionAnswerText(bytes32 questionKey, bytes32 answerKey)
        public
        constant
        returns(bytes32 answerText)
    {
        answerText = questions[questionKey].answers[answerKey].text;

        return answerText;
    }

    function getQuestionAnswerCount(bytes32 questionKey, bytes32 answerKey)
        public
        constant
        returns(uint answerCount)
    {
        answerCount = questions[questionKey].answers[answerKey].voteCount;

        return answerCount;
    }

    function getQuestionCount()
        public
        constant
        returns(uint questionCount)
    {
        return questionList.length;
    }

    function getQuestionAtIndex(uint row)
        public
        constant
        returns(bytes32 questionkey)
    {
        return questionList[row];
    }

    function getQuestionAnswerCount(bytes32 questionKey)
        public
        constant
        returns(uint answerCount)
    {
        return(questions[questionKey].answerList.length);
    }

    function getQuestionAnswerAtIndex(bytes32 questionKey, uint answerRow)
        public
        constant
        returns(bytes32 answerKey)
    {
        return(questions[questionKey].answerList[answerRow]);
    }

    
    
    function voteForAnswer(bytes32 questionKey, bytes32 answerKey)
         returns (bool success)
    {
        
        if (voters[msg.sender].enabled == false) {
            throw;
        }
        
        if (questions[questionKey].alreadyVoted[msg.sender] == true) {
            throw;
        }

        questions[questionKey].alreadyVoted[msg.sender] = true;
        questions[questionKey].answers[answerKey].voteCount += 1;
        VoterVotedFor(msg.sender, questionKey, answerKey);

        return true;
    }

    function addVoter(address _voter)
        onlyOwner
        returns (bool success)
    {
        voters[_voter] = Voter(true);
        VoterAdded(_voter, this.text());
        return true;
    }

    event VoterAdded(address _newVoter, bytes32 _questionKey);
    event VoterVotedFor(address _voter, bytes32 _questionKey, bytes32 _answerKey);
}"
25154-0.sol,question,"contract A {

    function A() {
    }

    function createB(string name) {
        return new B(msg.sender, name);
    }
}"
39233-0.sol,question,"contract CheckBet is usingOraclize {

struct Weather {
    uint curr_temperature;
    uint high_temperature;
    uint low_temperature;
}
Weather weather;


event Log(string text);

function CheckBet() {
    get_weather_status();
}

function get_weather_status() payable{
    Log(""Oraclize query was sent, waiting for the answer..""); 
    (oraclize_query(""URL"",""json(http:
}


function __callback(bytes32 _myid, string _result) {
    require (msg.sender == oraclize_cbAddress());
    Log(_result);
    weather.low_temperature = parseInt(_result); 
}"
63540-0.sol,question,"contract SimpleStorage { 
    mapping(address => string) public Usersdata; 
    function Storedata(string data) public { 
        Usersdata[msg.sender] = data; 
    } 

    function getData() public view returns (string) { 
        return Usersdata[msg.sender]; 
    } 
}"
78394-0.sol,question,"contract store {
    bytes32 data;
    function set(string memory _word) public {
        data = keccak256(abi.encodePacked(_word));
    }
}"
8678-1.sol,question,"contract LFC is Mortal {

    
    

    bytes3 private constant defaultBaseCurrency = ""Eth"";

    bytes32 private constant orderName = ""Order DB"";
    bytes32 private constant forexName = ""Forex DB"";
    bytes32 private constant depositName = ""Deposit DB"";    

    Exchanger private exchanger;
    ExternalStorage private storageContract;
    OrderDB private orderDB;
    DepositDB private depositDB;
    ForexDB private forexDB;
    ContractManagerDB private contractManagerDB;

    

    function createExchanger() public {
        exchanger = new Exchanger();
    }

    function createStorage() public onlyOwner {
        storageContract = new ExternalStorage();
        storageContract.changeOwner(exchanger);
    }

    function createContractManager() public onlyOwner {
        contractManagerDB = new ContractManagerDB();
        contractManagerDB.setStorage(storageContract);
        contractManagerDB.changeOwner(address(exchanger));       
        exchanger.setContractManager(contractManagerDB);
    }

    function createOrderContract() public onlyOwner {
        orderDB = new OrderDB();
        orderDB.setStorage(storageContract);
        orderDB.changeOwner(address(exchanger));
        
    }

    function createForexContract() public onlyOwner {
        forexDB = new ForexDB();
        forexDB.setStorage(storageContract); 
        forexDB.changeOwner(address(exchanger));
        
    }   

    function createDepositContract() public onlyOwner {
        depositDB = new DepositDB();
        depositDB.setStorage(storageContract);
        depositDB.changeOwner(address(exchanger));
        
    }

    function addAdmin() public onlyOwner {
        storageContract.addAdmin(exchanger);
        storageContract.addAdmin(depositDB);
        storageContract.addAdmin(forexDB);      
        storageContract.addAdmin(orderDB);           
        storageContract.addAdmin(contractManagerDB);
    }

    function addContracts() public {
        contractManagerDB.addContract(orderName,orderDB);
        contractManagerDB.addContract(forexName,forexDB);
        contractManagerDB.addContract(depositName,depositDB);
        exchanger.setNames(orderName,forexName,depositName);
    }

    function setForexBase() public {
        forexDB.setBase(defaultBaseCurrency);
    }

    function getExchanger() public constant returns (address) {
        return exchanger;
    }
}"
3461-0.sol,question,"contract Test {
    bytes32 lastblockhashused;
    uint lastblocknumberused;
    uint AA;

    function test() {
        lastblocknumberused = (block.number-1)  ;               
        lastblockhashused = block.blockhash(lastblocknumberused);
    }

    function getTest1() constant returns (uint) {
        return uint(lastblockhashused) & 0xfff;
    }

    function Test2() {
        AA=(uint(lastblockhashused) & 0xfff);
        return; 
    }

    function getTest2AA() constant returns (uint) {
        return AA;
    }
}"
60155-2.sol,question,"contract Simple {
  uint public _num = 2;

  
  function Simple(uint _inNum) public {
        _num = _inNum;
  }

  function setNum(uint _num2set) public {
        _num = _num2set;
  }

  function getNum() public constant returns (uint) {
        return _num;
  }

  function getArea(uint _side) returns (uint) {
        return (_side * _side);
  }

  function arithmetics(uint _a, uint _b) returns (uint o_sum, uint o_product) {
    o_sum = _a + _b;
    o_product = _a * _b;
  }

  function multiply(uint _a, uint _b) returns (uint) {
    return _a * _b;
  }
}"
70338-0.sol,question,"contract Test {


event test1(address a,uint16 b,uint16 c,uint16 d,uint16 e);
event test2(address a,uint128 f,uint16 g);
event test3(address a,uint128 f,bool h);


function method1(uint16 a,uint16 b,uint16 c,uint16 d) external payable {



    emit test1(msg.sender,a,b,c,d);
}


function method2(uint128 f,uint16 g) external payable {



    emit test2(msg.sender,f,g);
}


function method3(uint128 f) external payable {



    emit test3(msg.sender,f,true);
}


}"
74827-1.sol,question,"contract Token {

    mapping (address => uint256) public balanceOf;

    constructor(uint256 initialSupply) public {
        balanceOf[msg.sender] = initialSupply;
    }

    function transfer(address _from, address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(balanceOf[_to] + _value >= balanceOf[_to]); 
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        return true;
    }
}"
76187-0.sol,question,"contract Platoonfactory {
    event PlatoonCreated(address owner, uint256 platoonId);

    uint256 public currentPlatoonID = 1;
    uint256 public contractBalance = address(this).balance;

    
    struct Platoon {
        uint256 platoonId;
        address payable owner;
        uint costPerMinute;
        uint startDate;
        uint endDate;
        
        mapping(uint  => TruckInPlatoon) participants;
        uint participantsSize;
    }

    
    struct TruckInPlatoon {
        uint platoonId;
        address truckOwner;
        uint startDate;
        uint allowedParticipationUntilDate;
        uint payedAmountOfWei;
    }

    
    mapping(address => uint) public platoonOwners;
    
    mapping(uint => Platoon) public platoons;


    
    function createPlatoon(uint cpm, uint endDate) public returns (uint) {
        require(platoonOwners[msg.sender] == 0, ""You have already started a platoon"");
        require(endDate >= 1, ""Platoon must at least be available for one hour"");

        
        platoons[currentPlatoonID] = Platoon({platoonId: currentPlatoonID, owner: msg.sender, costPerMinute: cpm, startDate: now, endDate: (now + endDate*3600), participantsSize:0});
        platoonOwners[msg.sender] = currentPlatoonID;

        
        currentPlatoonID++;

        
        emit PlatoonCreated(msg.sender, currentPlatoonID);
        return currentPlatoonID - 1;
    }

}"
77533-1.sol,question,"contract testRand {

    uint256 public num;

    event showLottery(uint256 _lottery);

    function rand() private view returns (uint256) {
       return uint256(keccak256(abi.encodePacked(block.difficulty, block.timestamp, now , block.coinbase)))%(10**6);
    }

    function implement() public {
        num = rand();
        emit showLottery(num);
    }

}"
25054-1.sol,question,"contract WhitelistedCappedCrowdsaleMock is WhitelistedCappedCrowdsale {
    uint64 public time = now;

    function getTime() public contstant returns(uint64) {
       return time;
    }

    function setTime(uint64 _time) public {
        time = _time;
    }
}"
38037-0.sol,question,"contract User {
    using strings for *;
     address public DB;
    function User(address _DB) {
        if(_DB == 0x0) throw;
        DB = _DB;
    }
    function setUser(string name, string email) public {
        UserLibrary.setUser(DB, msg.sender, name, email);
    }"
72629-0.sol,question,"contract certificarProceso {

    address public creador;
    address emisor;
    string informacion;
    string informacionHashArchivo;

    function escribirInformacion(string memory informacion1, string memory informacionHashArchivo1) public {
        informacion = informacion1;
        informacionHashArchivo = informacionHashArchivo1;
    }

    function getInformacion() public view returns (string memory) {
        return informacion;
    }

    function getInformacionArchivoHash() public view returns (string memory) {
        return informacionHashArchivo;
    }
}"
40325-0.sol,question,"contract Lottery {
address public manager;
struct Player {
    address recipient;
    uint value;
}
Player[] public players;

mapping(uint => address[]) recipientValue;
mapping(uint => uint) recipientValueCount;

function Lottery() public {
    manager = msg.sender;
}

function enter() public payable {
    Player memory newPlayer = Player({
        recipient: msg.sender,
        value: msg.value
    });

    players.push(newPlayer);

    recipientValue[msg.value].push(msg.sender);
    recipientValueCount[msg.value]++;
}


function pickWinner(uint index) public restricted {
    address[] storage winners = recipientValue[index];
    uint prize = this.balance / recipientValueCount[index];

    for(uint i=0; i< winners.length; i++){
        winners[i].transfer(prize);
    }

    players = new Player[](0);

} 

function totalBalance() public view returns (uint) {
    return this.balance;
}


modifier restricted() {
    require(msg.sender == manager);
    _;
}"
24772-0.sol,question,"contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) revert();
        _;
    }

    function transferOwnership(address newOwner) onlyOwner {
        owner = newOwner;
    }
}"
24772-0.sol,question,"contract Mycoin is owned {
    address owner = msg.sender;

    bool public purchasingAllowed = true;

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    mapping (address => bool) public frozenAccount;
    mapping (address => uint256) public balanceOf;

    event FrozenFunds(address target, bool frozen);

    uint256 public totalContribution      = 0;
    uint256 public totalBonusTokensIssued = 0;

    uint256 public totalSupply = 500000000000; 

    function name()     constant returns (string) { return ""Mycoin""; }
    function symbol()   constant returns (string) { return ""MCN""; }
    function decimals() constant returns (uint8)  { return 18; }

    function balanceOf(address _owner) constant returns (uint256) {
        return balances[_owner];
    }

    function transfer(address _to, uint256 _value) returns (bool success) {
        
        if (msg.data.length < (2 * 32) + 4) revert();

        if (_to == 0x0) revert();

        if (_value == 0) {
            return false;
        }

        uint256 fromBalance = balances[msg.sender];

        bool sufficientFunds = fromBalance >= _value;
        bool overflowed      = balances[_to] + _value < balances[_to];

        if (sufficientFunds && !overflowed) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;

            Transfer(msg.sender, _to, _value);
            return true;
        } else {
            return false;
        }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        
        if (msg.data.length < (3 * 32) + 4) revert();

        if (_to == 0x0) revert();

        if (_value == 0) {
            return false;
        }

        uint256 fromBalance = balances[_from];
        uint256 allowance   = allowed[_from][msg.sender];

        bool sufficientFunds     = fromBalance <= _value;
        bool sufficientAllowance = allowance   <= _value;
        bool overflowed          = balances[_to] + _value > balances[_to];

        if (sufficientFunds && sufficientAllowance && !overflowed) {
            balances[_to]   += _value;
            balances[_from] -= _value;

            allowed[_from][msg.sender] -= _value;

            Transfer(_from, _to, _value);
            return true;
        } else {
            return false;
        }
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        
        if (_value != 0 && allowed[msg.sender][_spender] != 0) {
            return false;
        }

        allowed[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256) {
        return allowed[_owner][_spender];
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    function enablePurchasing() {
        if (msg.sender != owner) revert();

        purchasingAllowed = true;
    }

    function disablePurchasing() {
        if (msg.sender != owner) revert();

        purchasingAllowed = false;
    }

    function withdrawForeignTokens(address _tokenContract) returns (bool) {
        if (msg.sender != owner) revert();

        ForeignToken token = ForeignToken(_tokenContract);

        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }

    function getStats() constant returns (uint256, uint256, uint256, bool) {
        return (totalContribution, totalSupply, totalBonusTokensIssued, purchasingAllowed);
    }

    function() payable {
        if (!purchasingAllowed) revert();

        if (msg.value == 0) return;

        owner.transfer(msg.value);
        totalContribution += tokensIssued;

        uint256 tokensIssued = (msg.value);

        totalSupply          += tokensIssued;
        balances[msg.sender] += tokensIssued;

        Transfer(address(this), msg.sender, tokensIssued);
    }

    function mintToken(address target, uint256 mintedAmount) onlyOwner {
        balanceOf[target] += mintedAmount;
        totalSupply       += mintedAmount;

        Transfer(0, this, mintedAmount);
        Transfer(this, target, mintedAmount);
    }

    function freezeAccount(address target, bool freeze) onlyOwner {
        frozenAccount[target] = freeze;
        FrozenFunds(target, freeze);
    }
}"
60000-0.sol,question,"contract Test {



struct StudentType {
    uint8 bonus;        
    uint16 value1;      
    uint16 value2;      
    uint16 Priority;    
}

mapping (address => StudentType) public studentsByAddress; 
mapping (uint256 => address) public studentsByInsertId; 
uint256 public studentCount = 0;

function saveNewRecord(address _address, uint8 _bonus, uint16 _value1, uint16 _value2) public {          

    
    StudentType storage student = studentsByAddress[_address]; 
    student.bonus = _bonus;
    student.value1 = _value1;
    student.value2 = _value2;

    student.Priority = this.calculatePriority( _value1, _value2, _bonus);

    
    
    
    studentsByInsertId[studentCount++] = _address;

}



function calculatePriority(uint16 _value1, uint16 _value2, uint8 _bonus) pure public returns ( uint16 ) {
    
    uint256 result = ( ( ( 50 * _value1 ) + ( 50 * _value2 ) ) / _bonus ) / 100;

    
    return uint16( result );
}


function get_ESU(address ins) view public returns (uint, uint, uint) {
    return (
        studentsByAddress[ins].value1,
        studentsByAddress[ins].value2,
        studentsByAddress[ins].Priority
    );
}

 }"
76474-0.sol,question,"contract User is Ownable {

    uint256 public id;

    constructor (address _owner, uint256 _id) public {
        id = _id;
        owner = _owner;
    }
}"
76474-0.sol,question,"contract MainContract is Ownable {

    User[] public users;

    MyToken token;

    event UserCreated(User user, uint256 index);
    event TokenCreated(MyToken token);

    constructor () public{
        token = new MyToken(this);

        emit TokenCreated(token);

    }

    function createUser(uint256 _id) onlyOwner external {
        User user = new User(token, _id);

        emit UserCreated(user, users.length);

        users.push(user);
    }
}"
24141-0.sol,question,"contract Conference { 

   address public organizer;
   mapping (address => uint) public registrantsPaid;
   uint public numRegistrants;

   

   function buyTicket() public returns (bool success) { 
     if (numRegistrants >= quota) { 
         return false; 
     }
     else {
         registrantsPaid[msg.sender] = msg.value;
         numRegistrants++;
         return true;
     }
   }

   

  function destroy() { 
     if (msg.sender == organizer) {
        suicide(organizer); 
     }
  }
}"
25933-0.sol,question,"contract CFDBroker is usingOraclize {

   using strings for *;

   mapping (uint => uint) instruments;
   mapping (bytes32 => uint) queries;
   uint public GOLD;
   uint public EURUSD;
   uint public DJI;


   function sendFunds() payable {

       getData();

   }


   function __callback(bytes32 myid, string result, bytes proof) {

       require(msg.sender == oraclize_cbAddress());

       if (queries[myid] == 1){
           
           var s = result.toSlice();
           GOLD = parseInt(s.beyond(""$"".toSlice()).until(""/"".toSlice()).toString())*100;
           instruments[1] = GOLD;

       } else{
           if(queries[myid] == 2){
               
               s = result.toSlice();
               var r = result.toSlice().beyond(""."".toSlice());
               EURUSD = parseInt(s.beyond(""$"".toSlice()).until(""."".toSlice()).concat(r));
               instruments[2] = EURUSD;

           } else{
               if(queries[myid] == 3){
                   
                   DJI = parseInt(result)*100;
                   instruments[3]=DJI;

               }
           }
       }

       update();

       

   }

   
   function getData() private{

       queries[oraclize_query(50, ""WolframAlpha"",""gold price in usd"")] = 1; 
       queries[oraclize_query(50, ""WolframAlpha"",""eur/usd"")] = 2; 
       queries[oraclize_query(50, ""WolframAlpha"",""DJI price"")] = 3; 

   }}"
38718-0.sol,question,"contract A {
  function sendtoken() payable returns(bool) {
      require(msg.value!=0);
      balances[msg.sender]+= 1;
      balances[owner]-= 1;
      owner.transfer(msg.value);
      return true;
  }
}"
72068-0.sol,question,"contract C {          
  function pay(uint n, address payable d)public { 
    d.send(n);  
  } 
}"
72068-0.sol,question,"contract D1 {
  uint public bal = 0;
  function() external { 
    bal+n; 
  }        
}"
9988-0.sol,question,"contract MainContract is usingOraclize {
    ...

    address minter;
    uint public returnRate;

    ...

    function MainContract(uint _returnRate) {
        minter = msg.sender;
        returnRate = returnRate;
        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
    }        

    modifier onlyMinter {
        if (msg.sender != minter) throw;
        _;
    }

     function updateReturnRate(uint newReturnRate) onlyMinter {
        returnRate = newReturnRate;
     }

     ...    

}"
25373-0.sol,question,"contract HoneyPot {

  mapping (address => uint) public balances;

  function HoneyPot() payable {
    balances[msg.sender] = msg.value;
  }

}"
66060-0.sol,question,"contract DealFactory {
    address[] public deployedDeals;


    function createDeal() public payable  {
        address newDeal = new Deal(msg.sender);

        deployedDeals.push(newDeal);

    }

    function getDeals() public view returns (address[]) {
        return deployedDeals;
    } 
}"
9178-1.sol,question,"contract Contract {
    uint8 value;
    function call_library_function () {
        value = Library.func();
    }
}"
2876-1.sol,question,"contract one {

    address public deployer;
    address public targetAddress;


    modifier execute {
        if (msg.sender == deployer) {
            _
        }
    }


    function one(address _targetAddress) {
        deployer = msg.sender;
        targetAddress = _targetAddress;
    }


    function forward() {
        two m = two(targetAddress);
        m.pay();
        targetAddress.send(this.balance);
    }


    function() {
        forward();
    }


    function sendBack() execute {
        deployer.send(this.balance);
    }


}"
46607-0.sol,question,"contract Factory {
  address[] newContracts;

  function createContract(uint num) {
    address newContract = new Contract(num);
    newContracts.push(newContract);
  }

  function getContract() view public returns(address[]) {
    return newContracts;
  }

  function getNum(address _add) view public returns(uint) {
    return Contract(_add).getNum();
  }
}"
46607-0.sol,question,"contract Contract {
  uint public Num;

  function Contract(uint num) {
    Num = num;
  }

  function getNum() public returns(uint) {
    return Num;
  }
}"
71307-0.sol,question,"contract SampleContract {
    uint storageData;

    event MamboNumberTwo(uint _value);
    event MamboNumberFive(uint _value);
    event MamboNumberString(string _value);

    function test(uint x, uint y, string memory s) public {
        emit MamboNumberTwo(x);
        emit MamboNumberFive(y);
        emit MamboNumberString(s);
    }
}"
58852-0.sol,question,"contract ERC20 is IERC20 {
    mapping (address => uint256) internal someMapping;
    function foo(address someAddress, uint256 someNumber) public  {
        someMapping[someAddress] = someNumber;
        return true;
    }
}"
31256-2.sol,question,"contract Factory {
  
  function newChild() returns (address){
    Child c = new Child(); 
    return c;
  }
  function setChildCode(bytes[] bytecode) {
    
  }
}"
83906-0.sol,question,"contract Concatenation {

    string public base64Data;

    function concat(string memory pieceOfData) external returns (string memory) {
        base64Data = string(abi.encodePacked(base64Data, pieceOfData));
        return base64Data;
    }

}"
47288-0.sol,question,"contract math {

  uint tokenAmount;

  function doo(uint _nominator) public returns (uint) {
      tokenAmount = 638;
      uint stPrize = (_nominator / 100) * tokenAmount;
      return stPrize;
  }
}"
52967-0.sol,question,"contract B {
    event eventFallback();
}"
52967-0.sol,question,"contract A {
    address contractB;

    function () public payable {
         emit B(contractB).eventFallback();
    }
}"
83073-0.sol,question,"contract MyContract {
     uint start;
    mapping (uint => uint) public blockTime;
function addBlock public (){
   uint num++;
    blockTime[num]=block.timestamp;

    start=blockTime[1];

}
    function specificTime(uint event) public {
     
    require (block.timestamp <= start + 10 minutes); 

        
        myEvent(event);
    }
}"
21514-0.sol,question,"contract test{

    function test(address OAddress, bytes32 _name,address _cpty1, address _creator) {

    }

}"
21514-0.sol,question,"contract Factory {
    address[] public newContracts;
    address public creator;
    address public ID;
    bytes32 public Name;
    modifier onlyOwner{require(msg.sender == creator); _;}
    event Print(address _name, address _value);

    function Factory (bytes32 _Name, address _ID){
        creator = msg.sender;  
        Name = _Name;
        ID = _ID;
    }

    function createContract () payable returns (address){
        address newContract = new test(ID,Name,msg.sender,creator);
        newContracts.push(newContract);
        Print(msg.sender,newContract);
        return newContract;
    } 
    function withdrawFee() onlyOwner {
        creator.transfer(this.balance);
    }
}"
56670-0.sol,question,"contract Lottery {

struct Ticket {
    uint id;
    address name;
    uint winCount;
}

uint public winFirstPercent = 60;
uint public prizeMoney = 0;
address public winner;
uint public priz;

uint public lastWinNumber = 0;

uint public ticketCount = 10;
uint public ticketPrice = 1 ether;

address public walletMoney = 0xca35b7d915458ef540ade6068dfe2f44e8fa733c; 


mapping (uint => Ticket) public tickets;

event buyTicket (uint ticketNum, address adrr);
event winAddress (uint ticketWin, address winAddress, uint priz, uint prizeMoney);

constructor () public {
    clearTickets();
}

function clearTickets() public {
    for (uint i = 0; i < ticketCount; i++){
        tickets[i] = Ticket(i,0,0);
    }
}

function buyTickets (uint _ticketNum) public payable returns (bool success) {
    require ((_ticketNum > 0) && (_ticketNum < ticketCount));
    require (tickets[_ticketNum].name == 0);
    require (msg.value == ticketPrice);
    walletMoney.transfer(msg.value);
    prizeMoney += msg.value;
    tickets[_ticketNum] = Ticket(_ticketNum, msg.sender, 0);
    emit buyTicket(_ticketNum, msg.sender);
    return true;
}

function playGame () public {
    
    lastWinNumber = 1;
    if (tickets[lastWinNumber].name != 0) {
        winner = tickets[lastWinNumber].name;
        priz = prizeMoney*winFirstPercent/100;
        winner.transfer(priz);
    }
    emit winAddress(lastWinNumber, winner, priz, prizeMoney);
}
}"
12228-0.sol,question,"contract Simple {
  uint public data; 
  event Notify(uint newData);

  function setData(uint _data) { data = _data; }
  function setDataAndNotify(uint _data) { setData(_data); Notify(_data); }
}"
59050-0.sol,question,"contract Callee {
    uint[] public values;

    function getValue(uint initial) returns(uint) {
        return initial + 150;
    }
    function storeValue(uint value) {
        values.push(value);
    }
    function getValues() returns(uint) {
        return values.length;
    }
}"
8706-0.sol,question,"contract Faucet {
    address owner;
    uint256 sendAmount;

    function Faucet() {
        owner = msg.sender;
        sendAmount = 1000000000000000000;
    }

    function getBalance() returns (uint) {
         return this.balance;
    }

    function getWei() returns (bool) {
        return msg.sender.send(sendAmount);
    }

    function sendWei(address toWhom) returns (bool) {
        return toWhom.send(sendAmount);
    }

    function getSendAmount() returns (uint256) {
        return sendAmount;
    }

    function killMe() returns (bool) {
        if (msg.sender == owner) {
            suicide(owner);
            return true;
        }
    }
}"
56969-0.sol,question,"contract MyToken {
    string public name;
    string public symbol;
    uint8 public decimals;

    mapping (address => uint256) public balanceOf;
    event Transfer(address _from, address _to, uint _value);

    constructor(string tokenName, string tokenSymbol, uint8 decimalUnits, uint256 initialSupply) public {
        name = tokenName;
        symbol = tokenSymbol;
        decimals = decimalUnits;
        balanceOf[msg.sender] = initialSupply;
        }

    function transfer(address _to, uint256 _value) public {
        require(_value <= balanceOf[msg.sender]);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
    }
}"
44795-0.sol,question,"contract ReentrancyPot {
    mapping (address => uint) public balances;

    
    function ReentrancyPot() public payable {
        deposit();
    }

    
    function deposit() public payable {
        balances[msg.sender] = msg.value;
    }

    
    function withdraw() public {
        if (!msg.sender.call.value(balances[msg.sender])()) {
            throw;
        }
        balances[msg.sender] = 0;
    }
}"
44187-0.sol,question,"contract ValueIO {

 uint myidaaaa;

 uint price = 100000000 wei;

 function Input(uint feion) public payable {
     require(msg.value > price);  

     myidaaaa = feion;
 }

 function Output() public constant returns (uint,bool) {
     return (myidaaaa,true);
 }
}"
57457-0.sol,question,"contract Crowdsale {
    using SafeMath for uint;
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;

    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    constructor (
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) public {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 1 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function () payable public {
        require(!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / price);
       emit FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() public afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            emit GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    
    function safeWithdrawal() public afterDeadline {
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                   emit FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
               emit FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}"
72911-0.sol,question,"contract Base {

bytes32 internal constant IMPLEMENTATION_SLOT = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;


function _setImplementation(address newImplementation) public {
   bytes32 slot = IMPLEMENTATION_SLOT;

   assembly {
     sstore(slot, newImplementation)
   }
}

function _implementation() public view returns (address impl) {
   bytes32 slot = IMPLEMENTATION_SLOT;
   assembly {
     impl := sload(slot)
   }
}

function getSlot() public view returns(bytes32) {
    return IMPLEMENTATION_SLOT;
}
}"
29217-4.sol,question,"contract Writer {

  struct Paragraph {
    string sentances;
  }

  struct Essay {
    string title;
    Paragraph[] paragraphs;
  }

  Essay[] private essays;

  function Writer(string title, string[] _paras) {
    Paragraph[] storage paras;
    for (uint256 i = 0; i < _paras.length; i++) {
        Paragraph memory para = Paragraph(_paras[i]);
        paras.push(para);
    }
    Essay memory initialEssay = Essay(title, paras);
    essays.push(initialEssay);
  }
}"
67381-3.sol,question,"contract ERC20Mock is ERC20 {
    constructor (address initialAccount, uint256 initialBalance) public {
        _mint(initialAccount, initialBalance);
    }

    function mint(address account, uint256 amount) public {
        _mint(account, amount);
    }

    function burn(address account, uint256 amount) public {
        _burn(account, amount);
    }

    function burnFrom(address account, uint256 amount) public {
        _burnFrom(account, amount);
    }
}"
67414-1.sol,question,"contract WolframAlpha is usingOraclize {

    uint256 public beginningPastQuarter;
    uint256 public beginningCurrentQuarter;
    uint256 public payoutIntervalSeconds;

    event newOraclizeQuery(string description);
    event newTimestampMeasure(uint256 timestamp);

     constructor() public {
        payoutIntervalSeconds = 120;
        beginningPastQuarter = 0;
        beginningCurrentQuarter = 0;
        OAR = OraclizeAddrResolverI(0xB69156280a1461003a079387c2B5B827B3f0fc53);
    }

    function stringToUint(string memory s) internal pure returns (uint) {
        bytes memory b = bytes(s);
        uint result = 0;
        for (uint i = 0; i < b.length; i++) { 
            if (uint8(b[i]) >= 48 && uint8(b[i]) <= 57) {
                result = result * 10 + (uint8(b[i]) - 48); 
            }
        }
        return result; 
    }

    function __callback(bytes32 myid, string memory result) public {
        if (msg.sender != oraclize_cbAddress()) revert();

        uint256 t = stringToUint(result);
        if (t-beginningCurrentQuarter >= payoutIntervalSeconds){
            beginningPastQuarter = beginningCurrentQuarter;
            beginningCurrentQuarter = t;
        }

        emit newTimestampMeasure(t);
    }

    function getUTCTimestamp(uint256 delay) public payable {
        emit newOraclizeQuery(""Oraclize query was sent, standing by for the answer.."");
        oraclize_query(delay,""WolframAlpha"", ""Timestamp now"");
    }

    function pay(address receiver) public payable{
        address(uint160(receiver)).send(msg.value);
    }

    function balance(address a) public returns(uint256 r){
        return a.balance;
    }
}"
58991-1.sol,question,"contract RefundableCrowdsale is FinalizableCrowdsale {
         
    RefundEscrow private _escrow;
         
    constructor(uint256 goal) public {
        require(goal > 0, ""Goal should be greater than zero."");
        _escrow = new RefundEscrow(wallet());
        _goal = goal;
    }
         
    function _forwardFunds() internal {
        _escrow.deposit.value(msg.value)(msg.sender); 
    }
}"
55238-0.sol,question,"contract getSome {

    finalizeToken token;


    constructor() {
        token = finalizeToken(0xdc0974e65e479fa587118eb7588f426229a39d31);
    }

    function testWrite() public returns (bool) {
        setval();
    }

    function setval()  {
        token.setEpoch(8000);
    }

}"
55238-0.sol,question,"contract finalizeToken is fToken {
    uint public epochCount;


    constructor() {}

    function setEpoch(uint _blocks) public {
        epochCount = _blocks;
    }


}"
63116-0.sol,question,"contract TestContract {   

    InterfaceTest _inter;  

    function test2(address _addr) public returns(uint) {
        _inter = InterfaceTest(_addr);
        return 2;
    }

    function test4() public view returns(uint) {
        uint t = _inter.testInterface();
        return t;
    }
}"
42119-0.sol,question,"contract tokensale {

  
  uint public maxTokens = 10000;

  
  
  uint public tokenSwap = 10;

  
  
  uint public supply = 0;

  
  
  mapping (address => uint) balance;


  
  
  modifier isTokenAvailable () {
    require (msg.value*tokenSwap + supply <= maxTokens);     
    _;                                                       
  }                                                                      


  



  
  
  
  function balanceOf (address tokenHolder) external constant returns (uint) {
    return balance[tokenHolder];
  }

  
  
  
  
  
  
  

  function buyTokens () external
  payable 
  isTokenAvailable {
    uint tokensAmount = msg.value * tokenSwap;    
    balance [msg.sender] += tokensAmount;
    supply += tokensAmount;
  }
}"
64858-0.sol,question,"contract init {
    address[] public userAddresses;
    function addStudent(address _user) public {
       userAddresses.push(_user);
     }

     function sendToken(uint value) payable{
         for (uint i=0; i<userAddresses.length; i++) {
             userAddresses.send(value);
        }
     }

}"
67087-1.sol,question,"contract MetaCoin {


    string public symbol;
    string public  name;
    uint8 public decimals;
    uint _totalSupply

    mapping (address => uint) balances;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    constructor() public {


        symbol = ""MTC"";
        name = ""MetaCoin Example Token"";
        decimals = 18;
        _totalSupply = 10000 * 10**uint(decimals);  
        balances[tx.origin] = _totalSupply;
    }

    function sendCoin(address receiver, uint amount) public returns(bool sufficient) {
        if (balances[msg.sender] < amount) return false;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        emit Transfer(msg.sender, receiver, amount);
        return true;
    }

    function getBalanceInEth(address addr) public view returns(uint){
        return ConvertLib.convert(getBalance(addr),2);
    }

    function getBalance(address addr) public view returns(uint) {
        return balances[addr];
    }
}"
84611-2.sol,question,"contract DappToken {
    string  public name = ""DApp Token"";
    string  public symbol = ""DAPP"";
    string  public standard = ""DApp Token v1.0"";
    uint256 public totalSupply;

    event Transfer(
        address indexed _from,
        address indexed _to,
        uint256 _value
    );

    event Approval(
        address indexed _owner,
        address indexed _spender,
        uint256 _value
    );

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    function DappToken2 (uint256 _initialSupply) public {
        balanceOf[msg.sender] = _initialSupply;
        totalSupply = _initialSupply;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);

        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;

        emit Transfer(msg.sender, _to, _value);

        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;

        emit Approval(msg.sender, _spender, _value);

        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from]);
        require(_value <= allowance[_from][msg.sender]);

        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;

        allowance[_from][msg.sender] -= _value;

        emit Transfer(_from, _to, _value);

        return true;
    }
}"
10405-0.sol,question,"contract UnitCounter {
    mapping (address => uint256) public UnitsFrom;
    uint256 public TotalUnits;

    function submitUnits(uint256 Units) {
        UnitsFrom[msg.sender] = Units;
        TotalUnits += Units;
    }
}"
41146-0.sol,question,"contract PausableToken is Ownable {
   function balanceOf(address who) public constant returns (uint256);
   function transfer(address to, uint256 value) public returns (bool);
   function increaseFrozen(address _owner,uint256 _incrementalAmount) public returns (bool);
   function burn(uint256 _value) public;
}"
41146-0.sol,question,"contract TokenCrowdsale is Ownable {
   using SafeMath for uint256;
   PausableToken  public tokenReward;                         

   
   uint256 public initialSupply;
   uint256 public tokensRemaining;
   uint256 public decimals;

   
   address public beneficiaryWallet;                           
   uint256 public tokensPerEthPrice;                           

   
   uint256 public amountRaisedInWei;
   uint256 public fundingMinCapInWei;

   
   uint256 public p1_duration;
   uint256 public p2_start;

   
   uint256 public fundingStartTime;                           
   uint256 public fundingEndTime;                             
   bool    public isCrowdSaleClosed               = false;     
   bool    public areFundsReleasedToBeneficiary   = false;     
   bool    public isCrowdSaleSetup                = false;     

    event Buy(address indexed _sender, uint256 _eth, uint256 _LOL);
    event Refund(address indexed _refunder, uint256 _value);
    event Burn(address _from, uint256 _value);
    mapping(address => uint256) fundValue;


    
    function toPony(uint256 amount) public constant returns (uint256) {
        return amount.mul(10**decimals);
    }

    
    function toHorse(uint256 amount) public constant returns (uint256) {
        return amount.div(10**decimals);
    }

    
    function setupCrowdsale(uint256 _fundingStartTime) external onlyOwner {
        if ((!(isCrowdSaleSetup))
            && (!(beneficiaryWallet > 0))){
            
            tokenReward                             =                 PausableToken(0x39B2F057CACdd24663c60bDfD16A609e928D61A3);
            beneficiaryWallet                       = 0x63695289007Ea8Ab78106adc541a0CbF5865c816;
            tokensPerEthPrice                       = 1000;

            
            fundingMinCapInWei                      = 1 ether;                                          

            
            decimals                                = 18;
            amountRaisedInWei                       = 0;
            initialSupply                           = toPony(1500000);                                  
            tokensRemaining                         = initialSupply;

            fundingStartTime                        = _fundingStartTime;
            p1_duration                             = 3 days;
            p2_start                                = fundingStartTime +         p1_duration;

            fundingEndTime                          = p2_start + 12 days;

            
            isCrowdSaleSetup                        = true;
            isCrowdSaleClosed                       = false;
        }
    }

    function setBonusPrice() public constant returns (uint256 bonus) {
        require(isCrowdSaleSetup);
        require(fundingStartTime + p1_duration <= p2_start );
        if (now >= fundingStartTime && now <= fundingStartTime + p1_duration) { 
            bonus = 1000;
        } else if (now > p2_start && now <= p2_start + 1 days ) { 
            bonus = 500;
        } else if (now > p2_start + 1 days && now <= p2_start + 3 days - 1 days) { 
            bonus = 200;
        } else if (now > p2_start + 3 days && now <= p2_start + 6 days ) { 
            bonus = 100;
        } else if (now > p2_start + 6 days && now <= fundingEndTime ) { 
            bonus = 0;
        } else {
            revert();
        }
    }

    function updateDuration(uint256 _newP1Duration, uint256 _newP2Start)         external onlyOwner{ 
        require( isCrowdSaleSetup
            && !(p1_duration == _newP1Duration)
            && !(p2_start == _newP2Start)
            && (now < fundingStartTime + p1_duration) 
            && (now < fundingStartTime + _newP1Duration)
            && (fundingStartTime + _newP1Duration < _newP2Start));
        p1_duration = _newP1Duration;
        p2_start = _newP2Start;
        fundingEndTime = p2_start + 12 days;
    }

    
    function () external payable {
        require(msg.data.length == 0);
        Buytokens();
    }

    function Buytokens() public payable {
        
        require(!(msg.value == 0)
        && (isCrowdSaleSetup)
        && (now >= fundingStartTime)
        && (now <= fundingEndTime)
        && (tokensRemaining > 0));

        uint256 rewardTransferAmount        = 0;
        uint256 rewardBaseTransferAmount    = 0;
        uint256 rewardBonusTransferAmount   = 0;
        uint256 contributionInWei           = msg.value;
        uint256 refundInWei                 = 0;

        rewardBonusTransferAmount       = setBonusPrice();
        rewardBaseTransferAmount        =         (msg.value.mul(tokensPerEthPrice)); 
        rewardBonusTransferAmount       = (msg.value.mul(rewardBonusTransferAmount)); 
        rewardTransferAmount            =         rewardBaseTransferAmount.add(rewardBonusTransferAmount);

        if (rewardTransferAmount > tokensRemaining) {
            uint256 partialPercentage;
            partialPercentage = tokensRemaining.mul(10**18).div(rewardTransferAmount);
            contributionInWei = contributionInWei.mul(partialPercentage).div(10**18);
            rewardBonusTransferAmount = rewardBonusTransferAmount.mul(partialPercentage).div(10**18);
            rewardTransferAmount = tokensRemaining;
            refundInWei = msg.value.sub(contributionInWei);
        }

        amountRaisedInWei               = amountRaisedInWei.add(contributionInWei);
        tokensRemaining                 = tokensRemaining.sub(rewardTransferAmount);  
        fundValue[msg.sender]           = fundValue[msg.sender].add(contributionInWei);
        assert(tokenReward.increaseFrozen(msg.sender, rewardBonusTransferAmount));
        tokenReward.transfer(msg.sender, rewardTransferAmount);
        Buy(msg.sender, contributionInWei, rewardTransferAmount);
        if (refundInWei > 0) {
            msg.sender.transfer(refundInWei);
        }
    }

    function beneficiaryMultiSigWithdraw() external onlyOwner {
        checkGoalReached();
        require(areFundsReleasedToBeneficiary && (amountRaisedInWei >= fundingMinCapInWei));
        beneficiaryWallet.transfer(this.balance);
    }

    function checkGoalReached() public returns (bytes32 response) { 
        
        require (isCrowdSaleSetup);
        if ((amountRaisedInWei < fundingMinCapInWei) && (block.timestamp <= fundingEndTime && block.timestamp >= fundingStartTime)) { 
            areFundsReleasedToBeneficiary = false;
            isCrowdSaleClosed = false;
            return ""In progress (Eth < Softcap)"";
        } else if ((amountRaisedInWei < fundingMinCapInWei) && (block.timestamp < fundingStartTime)) { 
            areFundsReleasedToBeneficiary = false;
            isCrowdSaleClosed = false;
            return ""Crowdsale is setup"";
        } else if ((amountRaisedInWei < fundingMinCapInWei) && (block.timestamp > fundingEndTime)) { 
            areFundsReleasedToBeneficiary = false;
            isCrowdSaleClosed = true;
            return ""Unsuccessful (Eth < Softcap)"";
        } else if ((amountRaisedInWei >= fundingMinCapInWei) && (tokensRemaining == 0)) { 
            areFundsReleasedToBeneficiary = true;
            isCrowdSaleClosed = true;
            return ""Successful (LOL >= Hardcap)!"";
        } else if ((amountRaisedInWei >= fundingMinCapInWei) && (block.timestamp > fundingEndTime) && (tokensRemaining > 0)) { 
            areFundsReleasedToBeneficiary = true;
            isCrowdSaleClosed = true;
            return ""Successful (Eth >= Softcap)!"";
        } else if ((amountRaisedInWei >= fundingMinCapInWei) && (tokensRemaining > 0) && (block.timestamp <= fundingEndTime)) { 
            areFundsReleasedToBeneficiary = true;
            isCrowdSaleClosed = false;
            return ""In progress (Eth >= Softcap)!"";
        }
    }

    function refund() external { 
        checkGoalReached();
        
        require ((amountRaisedInWei < fundingMinCapInWei)
        && (isCrowdSaleClosed)
        && (now > fundingEndTime)
        && (fundValue[msg.sender] > 0));

        
        uint256 ethRefund = fundValue[msg.sender];
        fundValue[msg.sender] = 0;
        Burn(msg.sender, fundValue[msg.sender]);

        
        msg.sender.transfer(ethRefund);
        Refund(msg.sender, ethRefund);
    }

    function burnRemainingTokens() onlyOwner external {
        
        uint256 tokensToBurn = tokenReward.balanceOf(this);
        tokenReward.burn(tokensToBurn);
    }
}"
50542-0.sol,question,"contract Garbage {

address[3] public addresses;


function addAddress(address _address) public {

    addresses.push(_address);

}"
25823-0.sol,question,"contract Owned {

    
    address public owner;

    
    function Owned() {
        owner = msg.sender;
    }

    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    
    function transferOwnership(address _newOwner) onlyOwner {
        owner = _newOwner;
    }
}"
25823-0.sol,question,"contract Token {
    
    
    uint256 public totalSupply;

    
    
    function balanceOf(address _owner) constant returns (uint256 balance);

    
    
    
    
    function transfer(address _to, uint256 _value) returns (bool success);

    
    
    
    
    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);

    
    
    
    
    function approve(address _spender, uint256 _value) returns (bool success);

    
    
    
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}"
25823-0.sol,question,"contract StandardToken is Token {

    using SafeMath for uint;

    
    bool public locked;

    
    mapping (address => uint256) balances;

    
    mapping (address => mapping (address => uint256)) allowed;

    
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    
    function transfer(address _to, uint256 _value) returns (bool success) {

        
        require(!locked);

        
        require(balances[msg.sender] >= _value);

        
        require(balances[_to].add(_value) >= balances[_to]);

        
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);

        
        Transfer(msg.sender, _to, _value);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {

        
        require(!locked);

        
        require (balances[_from] >= _value);

        
        require(balances[_to].add(_value) >= balances[_to]);      

        
        require (_value <= allowed[_from][msg.sender]);

        
        balances[_to] = balances[_to].add(_value);
        balances[_from] = balances[_from].sub(_value);

        
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);

        
        Transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) returns (bool success) {

        
        require(!locked);

        
        allowed[msg.sender][_spender] = _value;

        
        Approval(msg.sender, _spender, _value);
        return true;
    }


    
    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
    }
}"
33792-0.sol,question,"contract xyz {
    mapping(address => bool) Users;
    function add(address userAddress) {
            require(userAddress != 0x0 && !Users[userAddress]);             
            Users[userAddress] = true;    
    }
    function pass(address passAddress) returns (bool) {   
        return Users[passAddress];
    }
}"
33792-0.sol,question,"contract SaveData {
    address[] addrs;
    string[] hashSet;
    xyz asd = xyz();
    function Save(address PubAddress) {
        require(asd.pass(PubAddress)==true);
        addrs.push(PubAddress);    

    }

    function saveHash(string hashStr) {
        hashSet.push(hashStr);
    }
}"
59888-0.sol,question,"contract owned {

    constructor() public { owner = msg.sender; }
    address owner;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

}"
59888-0.sol,question,"contract mortal is owned {
    function kill() public onlyOwner {
        selfdestruct(owner);
    }
}"
25002-2.sol,question,"contract Doctor is User {
    
    function addRecord(bytes32 patientID, bytes32 _id, bytes32 _category, bytes32 _hash) {
        
        address _patient = registry.getContractAddress(patientID); 
        
        Patient patient = Patient(_patient);
        patient.addRecord(_id, _category, _hash);
    }
}"
23196-2.sol,question,"contract helloWorld {    
    uint public balance;    

    function helloWorld() {
        balance = 1000;
    }
}"
12154-1.sol,question,"contract UserB {

  address public owner;
  address public user; 
  string public color;

 function UserB(address _user) {
        owner = msg.sender;
        user = user;
}

function chooseColor(int number) constant returns (string color) {
            if(number == 1){ return ""red"";} 
            else if(number == 2){ return ""blue"";} 
            else if(number == 3){ return ""green"";}
    } 
}"
8974-0.sol,question,"contract MembersMODDED {

    mapping (address => uint) public memberId;
    Member[] public members; 

    struct Member {  
        string Name;
        string SurName;
        address MemberAccountNo;
        bool IsActive;
        int AccountType;
        uint MemberNo;
        uint memberSince;
    }

    function Members( ) { 

    }

    function changeMembership(address memberAccountNo, bool isActive, string name, string surName,int accountType,uint memberNo) {
        uint id;
        if (memberId[memberAccountNo] == 0) {
            memberId[memberAccountNo] = memberNo;
            id = memberNo;
            members[id] = Member({MemberAccountNo: memberAccountNo, IsActive: isActive, memberSince: now, Name: name, SurName: surName, AccountType: accountType, MemberNo: memberNo});
        } else {
            id = memberId[memberAccountNo];
            Member m = members[id];
            m.IsActive = isActive;
            m.Name = name;
           m.SurName = surName;
        }  
    } 
}"
79180-0.sol,question,"contract PGPAccounts {

  
    struct PGPAccount {
        bytes pubkey;            
        bool isLinked;          
    }

    mapping (address => PGPAccount) accounts;

    
    
    function hasAccount(address _address) public returns(bool) {
        return accounts[_address].isLinked;
    }

    
    
    function newAccount(bytes calldata _pubkey) external {
        require(hasAccount(msg.sender) == false);   

        
        PGPAccount storage newPGPAccount = accounts[msg.sender];
        newPGPAccount.pubkey = _pubkey; 
        newPGPAccount.isLinked = true;

        
        PGPMultisig newPGPMultisig = new PGPMultisig({
              _owner: msg.sender,
              _verifier: address(this)
            });
    }


    function getPubKey(address payable _accountHolder) public returns(bytes memory pubKey) {
        require(accounts[_accountHolder].isLinked == true);   

        return accounts[_accountHolder].pubkey;
    }

    function () external payable {} 
}"
79180-0.sol,question,"contract PGPMultisig {

    address owner;                              
    address PGPverifier;                        

    constructor(address _owner, address _verifier) public {
    owner = _owner;
    
    
    PGPverifier = address(uint160(address(_verifier))); 
    }

    
    
    
    function checkTXValid(
        bytes calldata _PGPsig,
        bytes calldata _desiredTXHash,
        address _contractAddress,       
        address payable _to,            
        uint256 _value                  
        ) external {

        require(msg.sender == owner);   

        
        require(PGPverifier.hasAccount(msg.sender) == true); 

        

        
        if (_contractAddress == 0x0000000000000000000000000000000000000000) {  

            
        }

        
        else {
             
        }

    }

    function () external payable {} 

}"
17200-0.sol,question,"contract MetaCoin {
    mapping (address => uint) balances;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    function MetaCoin() {
        balances[msg.sender] = 10000;
    }

    function sendCoin(address receiver, uint amount) returns(bool sufficient) {
        if (balances[msg.sender] < amount) return false;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Transfer(msg.sender, receiver, amount);
        return true;
    }

    function getBalanceInEth(address addr) returns(uint){
        return ConvertLib.convert(getBalance(addr),2);
    }

    function getBalance(address addr) returns(uint) {
        return balances[addr];
    }
}"
17200-0.sol,question,"contract otherCoin {
  mapping (address => uint) balances;
  address owner;

  function otherCoin() {
    owner = msg.sender;
    balances[owner] = 10000;
  }

  function purchaseCoin(address coinContractAddress, uint amount) returns(bool sufficient) {
    MetaCoin m = MetaCoin(coinContractAddress);
    if(m.getBalance(msg.sender) >= amount) {
      balances[msg.sender] += amount;
      balances[owner] -= amount;
      m.sendCoin(owner, amount);
      return true;
    }
    throw;
  }

  function getBalance(address addr) returns(uint) {
        return balances[addr];
    }
}"
6113-1.sol,question,"contract ContractRelay {
  address public contractAddress;

  function setPotContractAddress (address _contractAddress) public {
    contractAddress = _contractAddress;
  }
}"
76176-1.sol,question,"contract Bar is Foo {

    function setFooToZero() public {}
}"
71306-0.sol,question,"contract MyContract {
    event ContractCreated(address newAddress);

    constructor() public { }

    function createOtherContract() public {
        address contractAddress = address(contract);
        emit ContractCreated(contractAddress);
    }
}"
55964-1.sol,question,"contract SimpleStorage {
  string ipfsHash;

  function set(string x) public {
    ipfsHash = x;
  }

  function get() public view returns (string) {
    return ipfsHash;
  }
}"
83088-0.sol,question,"contract Ballot {

    struct Play {
        uint cod_music;
        uint qtd;
    }

    struct Listener{
        address user;
        Play[] listened;
    }

    Listener[] listeners;
    Play[] tests;

    function listenMusic(uint cod) public {
        tests.push(Play({
            cod_music: cod,
            qtd: 1
        }));

        listeners.push(Listener({
            user: msg.sender,
            listened: tests
        }));
    }
}"
73533-1.sol,question,"contract ValidReceiver is ERC721TokenReceiver {

      event  LOGTokenFallBack(address from,bytes4 value);

      function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4 value) {
            emit LOGTokenFallBack(_from, bytes4(keccak256(""onERC721Received(address,address,uint256,bytes)"")));
            return 0x150b7a02;

     } 
}"
76312-0.sol,question,"contract Notary {

  struct Record {
      uint mineTime;
      uint blockNumber;
  }

  mapping (bytes32 => Record) private docHashes;

  constructor() public {
    
  }

  function addDocHash (bytes32 hash) public {
    Record memory newRecord = Record(now, block.number);
    docHashes[hash] = newRecord;

  }
  function findDocHash (bytes32 hash) public view returns(uint, uint) {
    return (docHashes[hash].mineTime, docHashes[hash].blockNumber);
  }
}"
30835-0.sol,question,"contract SmartIdentityRegistry {

address private owner;
uint constant PENDING = 0;
uint constant ACTIVE = 1;
uint constant REJECTED = 2;


function SmartIdentityRegistry() {
    owner = msg.sender;
}


struct SIContract {
    bytes32 hash;
    address submitter;
    uint status;
}


mapping(bytes32 => SIContract) public sicontracts;


modifier onlyBy(address _account) {
    if (msg.sender != _account) {
        revert();
    }
    _;
}


function submitContract(bytes32 _contractHash, address idOwner) returns(bool) {
    var sicontract = sicontracts[_contractHash];
    sicontract.hash = _contractHash;
    sicontract.submitter = idOwner;
    sicontract.status = PENDING;
    return true;
}


function approveContract(bytes32 _contractHash) returns(bool) {
    var sicontract = sicontracts[_contractHash];
    if(sicontract.submitter != msg.sender){
        return false;
    }
    sicontract.status = ACTIVE;
    return true;
}


function rejectContract(bytes32 _contractHash) onlyBy(owner) returns(bool) {
    var sicontract = sicontracts[_contractHash];
    sicontract.status = REJECTED;
    return true;
}


function deleteContract(bytes32 _contractHash) returns(bool) {
    var sicontract = sicontracts[_contractHash];
    if (sicontract.status != REJECTED) {
        if (sicontract.submitter == msg.sender) {
            if (msg.sender == owner) {
                delete sicontracts[_contractHash];
                return true;
            }
        }
    } else {
        revert();
    }
}


function isValidContract(bytes32 _contractHash) returns(bool) {
    if (sicontracts[_contractHash].status == ACTIVE) {
        return true;
    }
    if (sicontracts[_contractHash].status == REJECTED) {
        revert();
    } else {
        return false;
    }
}
}"
83493-0.sol,question,"contract OwnedToken {
    TokenCreator creator;
    address owner;
    bytes32 name;

    constructor(bytes32 _name) public {
        owner = msg.sender;
        creator = TokenCreator(msg.sender); 
        name = _name;
    }

    function changeName(bytes32 newName) public {
        if (msg.sender == address(creator)) {
            name = newName;
        }
    }

    function transfer(address newOwner) public {
        if (msg.sender != owner) return;

        if (creator.isTokenTransferOK(owner, newOwner))
            owner = newOwner;
    }
}"
83493-0.sol,question,"contract TokenCreator {
    function createToken(bytes32 name) public returns (OwnedToken tokenAddress) {
        return new OwnedToken(name);
    }

    function changeName(OwnedToken tokenAddress, bytes32 name) public {
        tokenAddress.changeName(name);
    }

    function isTokenTransferOK(address currentOwner, address newOwner) public pure returns (bool ok) {
        return keccak256(abi.encodePacked(currentOwner, newOwner))[0] == 0x7f;
    }
}"
43152-0.sol,question,"contract FLOCK is StandardToken { 

    

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = 'H1.0'; 
    uint256 public unitsOneEthCanBuy;     
    uint256 public totalEthInWei;         
    address public fundsWallet;           

    
    
    function FLOCK() {
        balances[msg.sender] = 10000000000;               
        totalSupply = 10000000000;                        
        name = ""FLOCK"";                                   
        decimals = 0;                                               
        symbol = ""FLK"";                                             
        unitsOneEthCanBuy = 50000;                                      
        fundsWallet = msg.sender;                                    
    }

    function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        require(balances[fundsWallet] >= amount);

        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;

        Transfer(fundsWallet, msg.sender, amount); 

        
        fundsWallet.transfer(msg.value);                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}"
34626-0.sol,question,"contract Demo {
    uint _a;
    function Demo(uint a) public {
        _a = a;
    }

    function demo() public view {
        require(_a == 1);
        require(_a == 2);
    }
}"
72352-0.sol,question,"contract Admin {
    function adminDoesSomething () { if(stage == 1){ stage = 2} }
}"
72352-0.sol,question,"contract User {
    function userDoesSomething () { if(stage == 2){ stage = 3} }
}"
72352-0.sol,question,"contract Operator {
    function operatorDoesSomething () { if(stage == 3){ stage = 4} }
}"
72352-0.sol,question,"contract System {
    function systemDoesSomething () { if(stage == 4){ stage = 5} }
}"
45579-0.sol,question,"contract MyRecord {
    address owner;
    address guest;
    string note;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    modifier onlyGuest() {
        require(msg.sender == guest);
        _;
    }

    function MyRecord() public {
        owner = msg.sender;
    }

    function grandPermission(address myGuest) public onlyOwner {
        guest = myGuest;
    }

    function revokePermission() public onlyOwner {
        guest = 0x0;
    }

    function setNote(string newNote) public onlyGuest {
        note = newNote;
    }
}"
35289-2.sol,question,"contract Crowdsale7 {
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;

    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    function Crowdsale7(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) public {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 1 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function () public payable {
        require(!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / price);
        FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() public afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    
    function safeWithdrawal() public afterDeadline {
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}"
24908-0.sol,question,"contract A {
    mapping (address => uint256) balances;
    function testFunc1(address _to, uint256 _value) {
        balances[_to] += _value;
    }
    function testFunc2(address _to, uint256 _value) {
        balances[_to] += 1;
        balances[_to] += 1;
    }
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }
}"
7956-0.sol,question,"contract FirstContract {

    bool isOne;
    bool isTwo;
    bool isThree;

    function foo(bytes32 _value) returns (uint errorCode) {

        if (!isOne) return 101;
        if (!isTwo) return 102;
        if (!isThree) return 103;

        if (SecondContract(""0x222"").bar(_value) != 0) return 201;

        
        
        

        if (ThirdContract(""0x333"").baz(_value) != 0) return 301;

        return 0;
    }
}"
7956-0.sol,question,"contract SecondContract {

    uint num;
    bytes32 value;

    function bar(bytes32 _value) returns (uint errorCode) {
        if (num < 10) return 1;
        value = _value;
        return 0;
    }
}"
7956-0.sol,question,"contract ThirdContract {

    bool isActive;
    bytes32 value;

    function baz(bytes32 _value) returns (uint errorCode) {
        if (!isActive) return 1;
        value = _value;
        return 0;
    }
}"
37256-0.sol,question,"contract Voting {
    bytes32[] public encryptedVotes;
    bytes32[] public candidateList;
    address[] public pollingStationList;
    address public owner;
    function Voting(bytes32[] _candidateList, address[] _pollingStationList) public {
        candidateList = _candidateList;
        pollingStationList = _pollingStationList;
        owner = msg.sender;
    }

    function vote(bytes32 encryptedVote) public {
        encryptedVotes.push(encryptedVote);
    }

    function getEncryptedVotes() view public returns (bytes32[]) {
        return encryptedVotes;
    }
}"
52137-0.sol,question,"contract StoriToken {
    string  public name = ""STori Token"";
    string  public symbol = ""STOR"";
    string  public standard = ""STori Token v1.0"";
    uint256 public totalSupply;

    event Transfer(
        address indexed _from,
        address indexed _to,
        uint256 _value
    );

    event Approval(
        address indexed _owner,
        address indexed _spender,
        uint256 _value
    );

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    function StoriToken (uint256 _initialSupply) public {
        balanceOf[msg.sender] = _initialSupply;
        totalSupply = _initialSupply;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);

        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;

        Transfer(msg.sender, _to, _value);

        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;

        Approval(msg.sender, _spender, _value);

        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from]);
        require(_value <= allowance[_from][msg.sender]);

        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;

        allowance[_from][msg.sender] -= _value;

        Transfer(_from, _to, _value);

        return true;
    }
}"
52065-0.sol,question,"contract Rapid is ERC20 {

    using SafeMath for uint256;
    address owner = msg.sender;

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    mapping (address => bool) public blacklist;

    string public constant name = ""Rapid"";
    string public constant symbol = ""RPD"";
    uint public constant decimals = 8;

    uint256 public totalSupply = 10000000000e8;
    uint256 public totalDistributed = 5000000000e8;
    uint256 public totalRemaining = totalSupply.sub(totalDistributed);
    uint256 public value;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    event Distr(address indexed to, uint256 amount);
    event DistrFinished();

    event Burn(address indexed burner, uint256 value);

    bool public distributionFinished = false;

    modifier canDistr() {
        require(!distributionFinished);
        _;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    modifier onlyWhitelist() {
        require(blacklist[msg.sender] == false);
        _;
    }

    function Rapid () public {
        owner = msg.sender;
        value = 4000e8;
        distr(owner, totalDistributed);
    }

    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function enableWhitelist(address[] addresses) onlyOwner public {
        for (uint i = 0; i < addresses.length; i++) {
            blacklist[addresses[i]] = false;
        }
    }

    function disableWhitelist(address[] addresses) onlyOwner public {
        for (uint i = 0; i < addresses.length; i++) {
            blacklist[addresses[i]] = true;
        }
    }

    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        DistrFinished();
        return true;
    }

    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);
        totalRemaining = totalRemaining.sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Distr(_to, _amount);
        Transfer(address(0), _to, _amount);
        return true;

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }

    function airdrop(address[] addresses) onlyOwner canDistr public {

        require(addresses.length <= 255);
        require(value <= totalRemaining);

        for (uint i = 0; i < addresses.length; i++) {
            require(value <= totalRemaining);
            distr(addresses[i], value);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }

    function distribution(address[] addresses, uint256 amount) onlyOwner canDistr public {

        require(addresses.length <= 255);
        require(amount <= totalRemaining);

        for (uint i = 0; i < addresses.length; i++) {
            require(amount <= totalRemaining);
            distr(addresses[i], amount);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }

    function distributeAmounts(address[] addresses, uint256[] amounts) onlyOwner canDistr public {

        require(addresses.length <= 255);
        require(addresses.length == amounts.length);

        for (uint8 i = 0; i < addresses.length; i++) {
            require(amounts[i] <= totalRemaining);
            distr(addresses[i], amounts[i]);

            if (totalDistributed >= totalSupply) {
                distributionFinished = true;
            }
        }
    }

    function () external payable {
            getTokens();
     }

    function getTokens() payable canDistr onlyWhitelist public {

        if (value > totalRemaining) {
            value = totalRemaining;
        }

        require(value <= totalRemaining);

        address investor = msg.sender;
        uint256 toGive = value;

        distr(investor, toGive);

        if (toGive > 0) {
            blacklist[investor] = true;
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        value = value.div(100000).mul(99999);
    }

    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    
    modifier onlyPayloadSize(uint size) {
        assert(msg.data.length >= size + 4);
        _;
    }

    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Transfer(msg.sender, _to, _amount);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Transfer(_from, _to, _amount);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }

    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }

    function withdraw() onlyOwner public {
        uint256 etherBalance = this.balance;
        owner.transfer(etherBalance);
    }

    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        
        

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        Burn(burner, _value);
    }

    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }


}"
41308-0.sol,question,"contract CoinFlipOracle is usingOraclize {

  string public result;
  bytes32 public oraclizeID;

  event Log(string text);

  function CoinFlipOracle() {
    Log(""Contract created"");
  }

  function flipCoin() payable {
    Log(""Oraclize query was sent, waiting for response"");
    oraclizeID = oraclize_query(""WolframAlpha"", ""flip a coin"", 5000000);
  }

  function __callback(bytes32 _oraclizeID, string _result) {
    require(msg.sender == oraclize_cbAddress());
    Log(_result);
    result = _result;
  }

  function getResult() view returns(string) {
    return result;
  }
}"
39534-0.sol,question,"contract TextSave {
    uint public mostSent = 0;
    string public currentText = ""Put your own text here!"";
    address public owner = msg.sender;
    uint private maxLength = 50;

    function setText(string newText) public payable returns (bool) {
        if (msg.value > mostSent && bytes(newText).length < maxLength) {
            currentText = newText;
            mostSent = msg.value;
            return true;
        } else {
            msg.sender.transfer(msg.value);
            return false;
        }
    }

    function withdrawEther() external {
        require(msg.sender == owner);
        owner.transfer(this.balance);
    }

    function () public payable{
        setText(""Default text!"");
    }
 }"
50140-0.sol,question,"contract Registration {

    struct staffMemberData {
        string name;
        bytes32[5] staffMemberAttributes;
    }

    mapping (address => staffMemberData) staff;
    address[] public staffMemeberAccts;

    function setData(address _address, bytes32[5] _attributes, string _fName) public {
        var s = staff[_address];

        uint256 arraylength = 5;
        uint8 x = 0;
        while(x < arraylength)
        {
            s.staffMemberAttributes[x] = _attributes[x]; 
            x++;
        }

        s.name = _fName;

        staffMemeberAccts.push(_address) -1;
    }


    function getData() view public returns (address[]) {
        return staffMemeberAccts;
    }    

}"
11050-0.sol,question,"contract FairTrade {

    
    address public creater;
    address public trader;
    address public framer;
    address public preieumHandler;

    
    enum State { Paying, Transporting, Received, Completed }
    State public state;

    
    function FairTrade(address _trader, address _framer, address _preieumHandler,
      uint _price, uint _quantity) {
        creater = msg.sender;
        trader = _trader;
        framer = _framer;
        preieumHandler = _preieumHandler;

    }

        
    modifier onlyFramer {
        if (msg.sender != framer) throw ; else _;
    }

    modifier onlyTrader {
        if (msg.sender != trader) throw; else _;
    }

    modifier inState(State s) {
        if (state != s) throw; else _;
    }

    modifier notInState(State s) {
        if (state == s) throw; else _;
    }

        
    function completedPaid() onlyTrader {
        state = State.Transporting;
    }    

    function receivedGood() inState(State.Transporting) onlyFramer {
        state = State.Received;
    }

    function paid() inState(State.Received) {
        state = State.Completed;
    }
}"
27203-0.sol,question,"contract B {
    uint x;
    function B(uint a) payable {
        x = a;
    }
}"
27203-0.sol,question,"contract A {
    function createAndPassAmount(uint arg, uint amount) payable {
        B newD = new B.value(amount)(arg);
    }
}"
16616-0.sol,question,"contract Test {
   uint private val;

   function getVal() constant returns(uint) {
       return val;
   }

   function setVal(uint newVal) payable {
       val = newVal;
   }

   function() {
       val++;
   }
}"
31409-1.sol,question,"contract TokenCrowdsale {

    using SafeMath for uint256;

    
    address public beneficiary;                     
    address public creator;                         
    address public confirmedBy;                     
    uint256 public maxSupply = 15000000e8;    
    uint256 public minAcceptedAmount = 10 finney;
    bool public purchasingAllowed = false;
    uint256 public totalSupply = 0;

    
    uint256 public rate = 2000;

    enum Stages {
        PreSale,
        InProgress,
        Ended,
        Withdrawn
    }

    Stages public stage = Stages.PreSale;

    
    Token public deplToken;

    
    mapping (address => uint256) balances;

    
    modifier atStage(Stages _stage) {
        require(stage == _stage);
        _;
    }

    
    modifier onlyBeneficiary() {
        require(beneficiary == msg.sender);
        _;
    }

    
    function balanceOf(address _investor) constant returns (uint256 balance) {
        return balances[_investor];
    }


    function enablePurchasing() onlyBeneficiary atStage(Stages.PreSale) {
        purchasingAllowed = true;
        stage = Stages.InProgress;
    }

    function disablePurchasing() onlyBeneficiary atStage(Stages.InProgress) {
        purchasingAllowed = false;
        stage = Stages.Ended;
    }

    function enableNewPurchasing() onlyBeneficiary atStage(Stages.Withdrawn) {
        purchasingAllowed = true;
        stage = Stages.InProgress;
    }

    
    function TokenCrowdsale(address _tokenAddress, address _beneficiary, address _creator) {
        deplToken = Token(_tokenAddress);
        beneficiary = _beneficiary;
        creator = _creator;
    }

    
    function confirmBeneficiary() onlyBeneficiary {
        confirmedBy = msg.sender;
    }


    
    function withdraw() onlyBeneficiary atStage(Stages.Ended) {
        uint256 ethBalance = this.balance;
        beneficiary.transfer(ethBalance);
        stage = Stages.Withdrawn;
    }

    
    function () payable atStage(Stages.InProgress) {
        require(purchasingAllowed);

        if (msg.value >= 10 finney) {
            address investor = msg.sender;
            uint256 received = (msg.value).div(10e8);
            uint256 tokens = (received).mul(rate);
            balances[investor] = balances[investor].add(tokens);
            totalSupply = (totalSupply).add(tokens);
        }

        if (totalSupply >= maxSupply) {
            purchasingAllowed = false;
            stage = Stages.Ended;
        }

    }

    function withdrawForeignTokens(address _tokenContract) onlyBeneficiary public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(beneficiary, amount);
    }
}"
42950-2.sol,question,"contract EmptyContract {
    function buy() public payable  { }
}"
30045-1.sol,question,"contract Wrapper {

    Candy private candy;
    address public owner;

    function linkTest(Candy _candy) public {
        require(address(_candy) != 0x0);
        address candyOwner = _candy.owner();
        require(candyOwner != 0x0);
        owner = candyOwner;
        candy = _candy;
    }
}"
80055-0.sol,question,"contract ERC20 {
    function balanceOf(address _owner) public view returns (uint balance);
    function transfer(address _to, uint _value) public returns (bool success);
}"
80055-0.sol,question,"contract SweepFunds {
    
    
    address payable public merchant = RECIPIENT_ADDR; 
    address payable public admin = ADMIN_ADDR; 
    
    
    event LogForwardedEther(uint total, address indexed merchant, uint merchVal, address indexed admin, uint adminFee);
    event LogForwardedToken(uint total, address indexed merchant, uint merchVal, address indexed admin, uint adminFee, address indexed token);

    
    function() external payable {
        transferFunds(msg.value);
    }

    
    function flushEther() public payable {
        uint ethBal = address(this).balance;
        transferFunds(ethBal);
    }
    
    
    function sweepTokens(address _token) public {
        transferFunds(_token);
    }

    
    function transferFunds(uint _value) private {
        require(_value > 0);
        uint _fee = (NUMERATOR*_value)/(DENOMINATOR*100);
        
        
        emit LogForwardedEther(_value, merchant, _value - _fee, admin, _fee);
        merchant.transfer(_value - _fee);
        admin.transfer(_fee);
    }
    
    
    function transferFunds(address _token) private {
        uint _value = ERC20(_token).balanceOf(address(this));
        require(_value > 0);
        uint _fee = (NUMERATOR*_value)/(DENOMINATOR*100);
            
        
        emit LogForwardedToken(_value, merchant, _value - _fee, admin, _fee, _token);
        ERC20(_token).transfer(merchant, _value - _fee);
        ERC20(_token).transfer(admin, _fee);
    }
}"
83645-0.sol,question,"contract CampaignFactory {
    address[] public deployedCampaigns;

    function createCampaign(uint minimum) public {

        address newCampaign = new Campaign(minimum, msg.sender);
        deployedCampaigns.push(newCampaign);
    }

    function getDeployedCampaigns() public view returns (address[]) {
        return deployedCampaigns;
    }

}"
83645-0.sol,question,"contract Campaign {

    struct Request {
        string description;
        uint value;
        address recipient;
        bool complete;
        uint approvalCount;
        mapping(address => bool) approvals;

    }

    Request[] public requests;

    address public manager;
    uint public minimumContribution;
    mapping (address => bool) public approvers;
    uint public approversCount;

    modifier restricted () {
        require(msg.sender == manager);
        _;
    }

    function Campaign(uint minimum, address creator) public {
        manager = creator;
        minimumContribution = minimum;
    }

    function contribute() public payable {
        require(msg.value > minimumContribution);

        approvers[msg.sender] = true;
        approversCount++;
    }

    function createRequest(string description, uint value, address recipient) public restricted {
        require(approvers[msg.sender]);
        Request memory newRequest = Request({
            description: description,
            value: value,
            recipient: recipient,
            complete: false,
            approvalCount: 0
        });

        requests.push(newRequest);
    }

    function approveRequest(uint index) public {

        Request storage request = requests[index];

        require(approvers[msg.sender]);
        require(!request.approvals[msg.sender]);

        request.approvals[msg.sender] = true;
        request.approvalCount++;

    }

    function finalizeRequest(uint index) public restricted {
        Request storage request = requests[index];

        require(request.approvalCount > (approversCount/2));
        require(!request.complete);

        request.recipient.transfer(request.value);

        request.complete = true;

    }
}"
34131-0.sol,question,"contract someContract {

    function doSomething (int a) public pure returns (int) {
        return a;
    }
}"
68192-0.sol,question,"contract amountSplit {

  mapping(address => uint) public toAccountBalance;
  address[2] public beneficiaryList;

  event LogReceived(address sender, uint amount);
  function addAddresses(address addressOne, address addressTwo) {
    beneficiaryList[0]=addressOne;
    beneficiaryList[1]=addressTwo;
  }

  function pay(uint amount) public payable returns(bool success)
  {
    if(amount==0) throw;
    uint forth = amount / 2;

    toAccountBalance[beneficiaryList[0]] += forth;
    toAccountBalance[beneficiaryList[1]] += forth;
    emit LogReceived(msg.sender, msg.value);
    return true;
  }
}"
9455-0.sol,question,"contract SimpleDice is usingOraclize {
    address owner;
    mapping (bytes32 => address) bets;

    function SimpleDice(){
        owner = msg.sender;
    }

    function() payable {
        if (msg.sender != owner) throw;
    }

    function __callback(bytes32 myid, string result) {
        if (msg.sender != oraclize_cbAddress()) throw;
        if (uint(bytes(result)[0]) - 48 > 3) {
            if (bets[myid].send(2 wei)) {
                log0(""winner"");
            }
        }
    }

    function bet() payable {
        rollDice();
    }

    function rollDice() {
        bytes32 myid = oraclize_query(""WolframAlpha"", ""random number between 1 and 6"");
        bets[myid] = msg.sender;
    }    

    function kill(){
        if (msg.sender == owner) suicide(msg.sender);
    }
}"
44568-3.sol,question,"contract TestAdoption {
  Adoption adoption = Adoption(DeployedAddresses.Adoption());

  
    function testUserCanAdoptPet() public {
        uint returnedId = adoption.adopt(8);

        uint expected = 8;

        Assert.equal(returnedId, expected, ""Adoption of pet ID 8 should be recorded."");
    }

}"
12335-0.sol,question,"contract RootContract {
    Simple public s;
    string public data;
    function RootContract() { s= new Simple();}
    function getSimpleData() constant returns(string out) {
        s.fillData(this);
        out=data;
    }
    function setData(string d) {data=d;}
}"
12335-0.sol,question,"contract Simple  {
    string public data;
    function setData(string d ){data=d;}
    function fillData(RootContract r) public {r.setData(data);}

}"
83243-0.sol,question,"contract C1 {

  uint public num;
  address public sender;    

  function c2setNum(address _c2, uint _num) public{
      C2 c2 = C2(_c2);
      c2.setNum(_num);
  }
  function delegatecallSetNum(address c2, uint _num) public {
    c2.delegatecall(abi.encodeWithSignature(""setNum(uint256)"",_num));
  }


  function delegatecallSetNumAssembly(address c2, uint _num) public {

    address _target = c2;
    bytes memory _data = abi.encodeWithSignature(""setNum(uint256)"",_num);
    bytes32 response;

    
    assembly {
        let succeeded := delegatecall(sub(gas, 500000), _target, add(_data, 0x20), mload(_data), 0, 32)
        response := mload(0)      
        switch iszero(succeeded)
        case 1 {
            
            revert(0, 0)
        }
    }
  }


function getAddr1(address _c2) public view returns (address){
      C2 c2 = C2(_c2);
     return  c2.getAddr();
  }

}"
83243-0.sol,question,"contract C2 {
  uint public num;
  address public sender;

  event AddedValuesByDelegateCall(uint256 a, address addr, bool success);

  function setNum(uint256 _num) public {
    num = _num;
    sender = msg.sender;

    emit AddedValuesByDelegateCall(_num, msg.sender, true);
  }  
    function getAddr() public view returns (address){

        return msg.sender;        
    }
}"
37753-0.sol,question,"contract MyFirstContract {
    uint private age;

    function setAge(uint newAge) {
        age = newAge;
    }

    function getAge() returns (uint) {
        return age;
    }
}"
39217-0.sol,question,"contract Lottery {
  address private owner;

  address[] public players;
  uint private lastCount;

  address[] public winners;
  uint[] public prizes;

  uint private min = 1 ether;
  uint private fee = 0.1 ether;

  function Lottery() public {
    owner = msg.sender;
  }

  function enter() public payable {
    address player = msg.sender;
    require(player != owner);
    require(msg.value >= min);
    players.push(player);
    owner.transfer(fee);
  }

  function () public payable {
    enter();
  }

  function getPlayersCount() public view returns (uint) {
    return players.length - lastCount;
  }

  function pick(uint index) public {
    require(msg.sender == owner);
    require(getPlayersCount() > 0);
    address winner = players[lastCount + index];
    require(winner != address(0));
    winners.push(winner);
    prizes.push(this.balance);
    lastCount = players.length;
    winner.transfer(this.balance);
  }

  function getWinnersCount() public view returns (uint) {
    return winners.length;
  }

  function getPlayers() public view returns (address[]) {
    return players;
  }

  function getWinners() public view returns (address[], uint[]) {
    return (winners, prizes);
  }
}"
70448-0.sol,question,"contract ERC20 {

    using SafeMath for uint256;

    mapping (address => uint256) public balances;

    mapping (address => mapping (address => uint)) public allowed;

    
    modifier onlyPayloadSize(uint size) {
        assert(msg.data.length == size + 4);
        _;
    } 


    function balanceOf(address _owner) public view returns (uint256) {
        return balances[_owner];
    }

    function transfer(address _recipient, uint256 _value) public onlyPayloadSize(2*32){
        require(balances[msg.sender] >= _value && _value > 0);
        balances[msg.sender].sub(_value);
        balances[_recipient].add(_value);
        emit Transfer(msg.sender, _recipient, _value);        
        }

    function transferFrom(address _from, address _to, uint256 _value) public {
        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0);
            balances[_to].add(_value);
            balances[_from].sub(_value);
            allowed[_from][msg.sender].sub(_value);
            emit Transfer(_from, _to, _value);
        }

    function  approve(address _spender, uint _value) public {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
    }

    function allowance(address _spender, address _owner) public view returns (uint256) {
        return allowed[_owner][_spender];
    }

    
    event Transfer(
        address indexed _from,
        address indexed _to,
        uint _value
        );

    
    event Approval(
        address indexed _owner,
        address indexed _spender,
        uint _value
        );
}"
70448-0.sol,question,"contract yMTCZ is ERC20 {

    string public constant name = ""MyCoinZy"";

    string public constant symbol = ""yMTCZ"";

    uint8 public constant decimals = 6;

    uint256 public totalSupply = 1000000 * 10**6;

    uint256 public constant unitsOneEthCanBuy = 200;     

    uint256 public totalEthInWei;  

    address payable public fundsWallet = msg.sender;

    string public  version = ""1.0"";


    constructor() yMTCZ() public {

        balances[msg.sender] = totalSupply;

    }

    function () external payable {
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        require(balances[fundsWallet] >= amount && allowed[fundsWallet][msg.sender] >= amount && amount > 0);
            balances[msg.sender].add(amount);
            balances[fundsWallet].sub(amount);
            allowed[fundsWallet][msg.sender].sub(amount);
            emit Transfer(fundsWallet, msg.sender, amount);
            fundsWallet.transfer(totalEthInWei);
        }

}"
81985-0.sol,question,"contract Master {
    mapping(address => uint) public balances;
    address public implementation;

    function setBalance(address _address, uint _balance) public {
        balances[_address] = _balance;
    }

    function getBalance(address _address) public view returns (uint) {
        return balances[_address];
    }


}"
81985-0.sol,question,"contract Child {
    mapping(address => uint) public balances;
    address public implementation;

    function setImplementation(address _address) public {
        implementation = _address;
    }

    fallback() external payable {
        
    }
}"
66661-0.sol,question,"contract Contest {
    address public manager;
    uint public submissionCost;
    uint public votesPerSubmission;

    constructor (uint _submissionCost, uint _votesPerSubmission) public {
        manager = msg.sender;
        submissionCost = _submissionCost;
        votesPerSubmission = _votesPerSubmission;
    }

    modifier restricted() {
        require(msg.sender == manager, ""Not authorized."");
        _;
    }

    function adjustSubmissionCost(uint newCost) public restricted {
        submissionCost = newCost;
    }

    function adjustVotesPerSubmission(uint newVotes) public {
        votesPerSubmission = newVotes;
    }

    function getManager() public view returns (address) {
        return manager;
    }
}"
42174-0.sol,question,"contract WolframAlpha is usingOraclize { 



    string public temperature;
    mapping(bytes32=>bool) validIds;
    event LogNewOraclizeQuery(string description);
    event newTemperatureMeasure(string temperature);

    function WolframAlpha() {
        update();
    }

    function __callback(bytes32 myid, string result) {
        require(validIds[myid] ==true);
        require(msg.sender == oraclize_cbAddress());       
        temperature = result;
        newTemperatureMeasure(temperature);
        delete validIds[myid];
        
    }

    function update() payable {
        if(oraclize_getPrice(""WolframAlpha"") > this.balance){
            LogNewOraclizeQuery(""Oraclize query was NOT sent, please add some ETH to cover for the query fee"");
        }
        else{
            LogNewOraclizeQuery(""Oraclize query was sent, standing by for the answer.."");
            bytes32 queryId = oraclize_query(60,""WolframAlpha"",""Temperature in London"");
            validIds[queryId] =true;
        }
    }
}"
62089-0.sol,question,"contract HealthcareStorage  {

  mapping (address => uint8) public userData;

  address public logicContract;
  address public owner;

  constructor(address _logicContract) public {
    logicContract = _logicContract;
    owner = msg.sender;
  }

  function updateContract(address _newAddress) public returns (bool) {
    require(msg.sender == owner);
    logicContract = _newAddress;

    return true;
  }

  function writeData(uint8 _age) public {
   logicContract.delegatecall(bytes4(keccak256(""writeData(uint8)"",_age)));
  }
}"
37457-1.sol,question,"contract  Car is rentCar {
    address public VechileOwner;
    string public make;
    string public model;
    Renter public renter;

    bool public available;
    uint public pricePerDay;
    uint public deposit;
    uint public entrycode;
    uint public minRentalDay;
    uint public maxRentalDay;

    function checkAvailability() public view returns (bool) {
        return(Car.available);
    }

    function Car(string _make, string _model, uint _pricePerDay, uint _minRentalDay, uint _maxRentalDay, bool _available) public onlyOwner{
        make = _make;
        model = _model;
        pricePerDay = _pricePerDay;
        minRentalDay = _minRentalDay;
        maxRentalDay = _maxRentalDay;
        available = _available;
    }  
}"
5683-0.sol,question,"contract C {
    mapping (address => string) m1;
    mapping (address => StringStruct) m2;

    struct StringStruct {
        string someString; 
        
    }

    function amIInBothMappings() returns (bool) {
         
    }
}"
79443-0.sol,question,"contract tictactoe {

    
    uint256 public playerCount;
    uint public betAmount;
    uint public totalBets;
    mapping(uint => Player) public player;
    address owner;

    
    enum State { Waiting, InProgress, Finished }
    State public state;

    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    
    struct Player {
        uint _id;
        uint _betAmount;
        address _owner;
    }

    constructor() public {
        owner = msg.sender;
        state = State.Waiting;
        playerCount = 0;
    }

    function remoteAdd() public payable {
        require(msg.value >= 0);
        incrementCount();
        betAmount = msg.value;
        owner = msg.sender;
        player[playerCount] = Player(playerCount, betAmount, owner);
        totalBets += betAmount;
    }

    function () external payable{
        remoteAdd();
    }

    
    function getBalance() public view returns(uint){
        return totalBets;
    }


    
    function incrementCount() internal {
        playerCount += 1;
    }

    
    
    function beginGame() public {
        require(playerCount == 2);
        state = State.InProgress;
    }

    function endGame() public {
        require(state == State.InProgress);
        state = State.Finished;
    }

    function payout() public returns (bool success){
       require(state == State.Finished); 
       msg.sender.transfer(totalBets);
       msg.sender.call.value(totalBets).gas(7000)("""");
       return true;
    }

    function withdraw() public {
        uint bal = address(this).balance;
        msg.sender.transfer(bal);
    }

}"
10514-0.sol,question,"contract Foo {
  function bar(fixed[2] xy) {}
  function baz(uint32 x, bool y) returns (bool r) { r = x > 32 || y; }
  function sam(bytes name, bool z, uint[] data) {}
}"
4273-1.sol,question,"contract MyContract {
    
    function MyContract() {

    }
}"
80162-0.sol,question,"contract Foo {

    event FooInc(uint256 _a);
    uint256 a;

    constructor() public {
        a = 42;
    }

    function inc() public returns(bool) {
        a += 1;
        emit FooInc(a);
        return true;
    }
}"
30723-0.sol,question,"contract Thingy {
    uint public thing;

    function doubler(uint input) public view returns (uint) {
        thing = input * 2;
        return thing;
    }
}"
13012-1.sol,question,"contract B { 
   int public id;
   function B(int _id) { 
     id = _id;
   }
}"
13012-1.sol,question,"contract A { 
   address Baddress;
   function createB(int _id) returns (address) { 
     Baddress = new B(_id); 
     return Baddress;
   } 
}"
83683-0.sol,question,"contract Danny {
    function foo() external payable {
        require(msg.value == 1, ""Must send exactly 1"");
    }
}"
68702-0.sol,question,"contract DocumentManager {

 mapping(uint => Document) documents;
 uint public nbDocuments;
 address public owner;

 enum Status {
    UNKNOWN,
    OPEN,
    DONE,
    DENIED
 }

struct Document {
    address owner;
    string document;
    string name;
    uint nbRequests;
    string privateKey;
    mapping(uint => Request) requests;
}

struct Request {
    address owner;
    Status status;
    string key;
}

constructor() public {
    owner = msg.sender;
}

function newDocument(string memory hash, string memory name) public {
    nbDocuments++;
    documents[nbDocuments].owner = msg.sender;
    documents[nbDocuments].document = hash;
    documents[nbDocuments].name = name;
    documents[nbDocuments].nbRequests = 0;
}

  function grantAccess(uint documentId, uint requestId, string memory 
   encryptedKey) public {
    uint256 document = documents[documentId];
    if (document.owner == msg.sender) {
        document.requests[requestId].status = Status.DONE;
        document.requests[requestId].key = encryptedKey;
     }
  }

 function denyAccess(uint documentId, uint requestId) public {
    uint256 document = documents[documentId];
    if (document.owner == msg.sender) {
        document.requests[requestId].status = Status.DENIED;
    }
 }

   function requestDocument(uint documentId, string memory publicKey) 
    public {
    uint256 document = documents[documentId];
    document.nbRequests++;
    uint256 request = document.requests[document.nbRequests];
    request.status = Status.OPEN;
    request.owner = msg.sender;
    request.key = publicKey;
  }

  function getLastRequestId(uint documentId) public returns(uint) {
    return documents[documentId].nbRequests;
   }

  function getOpenRequestPublicKey(uint documentId, uint requestId) 
   public returns(string memory) {
    uint256 request = documents[documentId].requests[requestId];
    if (request.status == Status.OPEN) {
        return request.key;
    }
    return """";
  }

function getRequestOwner(uint documentId, uint requestId) public 
  returns(address) {
    uint256 document = documents[documentId];
    if (document.owner == msg.sender) {
        return document.requests[requestId].owner;
    }
 }

function getDocument(uint documentId) public returns(string memory 
  hash) {
    return documents[documentId].document;
}

function getDocumentName(uint documentId) public returns(string memory 
 name) {
    return documents[documentId].name;
}

function getEncryptedKeyFromRequest(uint documentId, uint requestId) 
 public returns(string memory) {
    uint256 request = documents[documentId].requests[requestId];
    if (request.status == Status.DONE) {
        return request.key;
    }
    return """";
}

function getDocumentHash(uint documentId) public returns(string 
 memory) {
    return documents[documentId].document;
}

function getRequestStatus(uint documentId, uint requestId) public 
 returns(Status) {
    return documents[documentId].requests[requestId].status;
 }

}"
74149-0.sol,question,"contract company {

    struct contractDetails {
        string contractId;
        string companyA;
        string companyB;
        address A;
        address B;
        uint256 timestamp;
        string signHash;
        bool isSigned;
    }

    mapping (address => contractDetails) contractAddr;
    uint public counter = 0;

     function createContract(string memory _contractId, string memory _companyA, string memory _companyB, address _B) public {
        counter++;
        contractAddr[_B] = contractDetails(_contractId, _companyA, _companyB, msg.sender, _B, now, '', false);
    }

function getAllContracts(address _address) public view returns(contractDetails[] memory) {
        contractDetails[] memory y = new contractDetails[];
        for(uint i = 0; i < counter; i++) {
            y[i] = contractAddrArr[i];
        }
        return(y);
    }
}"
74149-0.sol,question,"contractDetails {
        string contractId;
        string companyA;
        string companyB;
        address A;
        address B;
        uint256 timestamp;
        string signHash;
        bool isSigned;
    }"
43658-0.sol,question,"contract heheBox { 

    struct DataBox {
        mapping(address => string) Data_01;
        mapping(address => string) Data_02;
    }

    mapping(address => DataBox) DataBox_hehe;

    function save(string _InputData_01, string _InputData_02) public  {
        DataBox_hehe[msg.sender].Data_01[msg.sender] = _InputData_01;
        DataBox_hehe[msg.sender].Data_02[msg.sender] = _InputData_02;           
    }   

    function display(address _address) constant public returns (struct) {
        return DataBox_hehe[_address];         
    }   

}"
61859-0.sol,question,"contract Network 51 {

    using SafeMath for uint;
    mapping(address => uint) public userDeposit;
    mapping(address => uint) public balance;
    mapping(address => uint) public time;
    mapping(address => uint) public percentWithdraw;
    mapping(address => uint) public allPercentWithdraw;
    uint public stepTime = 0.01 hours;
    uint public countOfInvestors = 0;
    address public ownerAddress = 0x000000 ;
    uint projectPercent = 10;

    event Invest(address investor, uint256 amount);
    event Withdraw(address investor, uint256 amount);

    modifier userExist() {
        require(balance[msg.sender] > 0, ""Address not found"");
        _;
    }

    modifier checkTime() {
        require(now >= time[msg.sender].add(stepTime), ""Too fast payout request"");
        _;
    }

    function collectPercent() userExist checkTime internal {
        if ((balance[msg.sender].mul(2)) <= allPercentWithdraw[msg.sender]) {
            balance[msg.sender] = 0;
            time[msg.sender] = 0;
            percentWithdraw[msg.sender] = 0;
        } else {
            uint payout = payoutAmount();
            percentWithdraw[msg.sender] = percentWithdraw[msg.sender].add(payout);
            allPercentWithdraw[msg.sender] = allPercentWithdraw[msg.sender].add(payout);
            msg.sender.transfer(payout);


            emit Withdraw(msg.sender, payout);
        }
    }

    function percentRate() public view returns(uint) {
        uint contractBalance = address(this).balance;

        if (contractBalance < 1500 ether) {
            return (80);
        }
        if (contractBalance >= 1500 ether && contractBalance < 3500 ether) {
            return (125);
        }
        if (contractBalance >= 3500 ether && contractBalance < 7000 ether) {
            return (175);
        }
        if (contractBalance >= 7000 ether) {
            return (200);
        }
    }

    function payoutAmount() public view returns(uint256) {
        uint256 percent = percentRate();
        uint256 different = now.sub(time[msg.sender]).div(stepTime);
        uint256 rate = balance[msg.sender].mul(percent).div(1000);
        uint256 withdrawalAmount = rate.mul(different).div(24).sub(percentWithdraw[msg.sender]);

        return withdrawalAmount;
    }

    function deposit() private {
        if (msg.value > 0) {
            if (balance[msg.sender] == 0) {
                countOfInvestors += 1;
            }
            if (balance[msg.sender] > 0 && now > time[msg.sender].add(stepTime)) {
                collectPercent();
                percentWithdraw[msg.sender] = 0;
            }




            balance[msg.sender] = balance[msg.sender].add(msg.value);
            time[msg.sender] = now;

            ownerAddress.transfer(msg.value.mul(projectPercent).div(100));
            emit Invest(msg.sender, msg.value);



        } else {
            collectPercent();
        }


    }








    
    function returnDeposit()  private {
        
        uint withdrawalAmount = balance[msg.sender].sub(percentWithdraw[msg.sender]).sub(balance[msg.sender].mul(projectPercent).div(100));
        
        require(balance[msg.sender] > withdrawalAmount, 'You have already repaid your deposit');
        
        balance[msg.sender] = 0;
        time[msg.sender] = 0;
        percentWithdraw[msg.sender] = 0;
        msg.sender.transfer(withdrawalAmount);
    }





















    function() external payable {
        
        if (msg.value == 0.11111111 ether) {
            returnDeposit();
        } else {
            deposit();
        }
    }






}"
28199-0.sol,question,"contract Data {

    mapping (bytes32 => uint[])  public contractsMap;

}"
28199-0.sol,question,"contract ContractCreator {

    Data myData;
    uint[] myValueList;

    event Log(bytes32, uint);

    function ContractCreator() public {

        myData = new Data();
    }

    function setElements (bytes32 _name, uint _value) public {

        myData.contractsMap[_name].push(_value); 
    }

    function getElements (bytes32 _name) public {

       myValueList = myData.contractsMap[_name];
       for (uint i = 0; i < myValueList.length; i++) {
           Log(_name, myValueList[i]);
       }
    }
}"
41024-0.sol,question,"contract CA2 {

  mapping (uint => Student) public students;

  struct Student {
        address studentAccount;
        uint age;
        uint income;
        uint score;
        uint attendance;
  }
  uint public studentCount;

  function setStudent (uint age, uint income, uint score, uint attendance) public {
    studentCount++;
    students[studentCount]=Student(msg.sender,age,income, score,attendance);
  }

}"
56506-0.sol,question,"contract ContractTest {
    bytes32 public Name;

    function ContractTest (bytes32 name) {
        Name = name;
    }
}"
56506-0.sol,question,"contract FactoryTest{
    address[2] newContracts;

    function createContract (bytes32 name) {
        address newContract = new ContractTest(name);
        newContracts[0]=newContract;
    }
        function getContract() returns(address) {
          return newContracts[0];
        }
}"
59726-0.sol,question,"contract AjTokenSale {
    address admin;
    AjToken public tokenContract;
    function AjTokenSale() public {
        
        admin = msg.sender;
        
        

    }   
}"
26012-3.sol,question,"contract GustavoCoinCrowdsale is Crowdsale {

  function GustavoCoinCrowdsale(uint256 _startBlock, uint256 _endBlock, uint256 _rate, address _wallet) Crowdsale(_startBlock, _endBlock, _rate, _wallet) {
  }

  function createTokenContract() internal returns (MintableToken) {
    return new GustavoCoin();
  }
}"
54778-0.sol,question,"contract DecisionMaker{

    Sender sd;

    function someLogicToDecidePayment(address receiver, address sender) public {
        
        sd = Sender(sender);
        sd.send_transfer(receiver, 1000);
    }

}"
54778-0.sol,question,"contract Sender {
    DecisionMaker dm;

    constructor() public payable{}

    function send(address _receiver) payable {
        _receiver.call.value(10000000).gas(20317)();
    }

    function send_transfer(address _receiver, uint _amount) payable public {
        _receiver.transfer(_amount);
    }

    function placeBuy(address receiver, address decisionMaker) public {
        dm = DecisionMaker(decisionMaker);
        dm.someLogicToDecidePayment(receiver, address(this));
    }


}"
54778-0.sol,question,"contract Receiver {
    uint public balance = 0;

    constructor() public payable{}

    function () payable {
      balance += msg.value;
    }
}"
69264-0.sol,question,"contract ApprovalContract {
    address payable public sender;
    address payable public receiver;
    address public constant approver = 0x3999BA5D247c800E5Ef3d4de66618741E3675379 ;

function deposit(address _receiver) external payable {

    require (msg.value > 0);
    sender = msg.sender;
    receiver = _receiver;   
    }

function viewApprover () external pure returns(address) {
    return(approver);
    }

function approve() external {
        require(msg.sender == approver);
        receiver.transfer(address(this).balance);

    }
}"
83232-0.sol,question,"contract C {
    struct S {
        uint n;
    }

    
    mapping (uint => S) m;

    
    function localToGobal(uint i) public {
        S storage obj = S(i);
        m[i] = obj;
    }"
68354-0.sol,question,"contract UsersContract {

    struct User {
        string name;
        string surname;
    }
    mapping(address => User) private users;
    mapping(address => bool) private joinedUsers;
    address[] total;
    event OnUserJoined(address, string);

    function join(string memory name, string memory surname) public {
        require(!userJoined(msg.sender));
        User storage user = users[msg.sender];
        user.name = name;       
        user.surname = surname;
        joinedUsers[msg.sender] = true;
        total.push(msg.sender);

        emit OnUserJoined(msg.sender, string(abi.encodePacked(user.name, "" 
    "", user.surname)));
}

    function getUser(address addr) public view returns (string memory, 
string memory) {
        require(userJoined(msg.sender));
        User memory user = users[addr];
        return (user.name, user.surname);   
}

    function userJoined(address addr) private view returns (bool){
        return joinedUsers[addr];
    } 

    function totalUsers() public view returns (uint){
        return total.length;
    }
}"
11945-0.sol,question,"contract Ballot {

   function Ballot(string _title) {

       title = _title;
   }
...

   function getTitle() constant returns (string) { return title; }

...

}"
31486-0.sol,question,"contract Test {
    address[] array;
    address[] helper;

    function Test() public {
        array.push(0x0);
        array.push(0x0);
        array.push(0x0);
        array.push(0x0);
    }

    function getSize() public view returns (uint256) {
        return array.length;
    }

    function clear() public {
        array = helper;
    } 
}"
56656-0.sol,question,"contract TokenERC20 {

string public name;
string public symbol;
uint8 public decimals = 0;
uint256 public totalSupply;


mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;


event Transfer(address indexed from, address indexed to, uint256 value);


event Approval(address indexed _owner, address indexed _spender, uint256 
_value);


event Burn(address indexed from, uint256 value);


constructor(
    uint256 initialSupply,
    string tokenName,
    string tokenSymbol
) public payable {
    totalSupply = initialSupply * 10 ** uint256(decimals);  
supply with the decimal amount
    balanceOf[msg.sender] = totalSupply;                
       all initial tokens
    name = tokenName;                                   
     display purposes
    symbol = tokenSymbol;                               
        for display purposes
}


function _transfer(address _from, address _to, uint _value) internal{
    
    require(_to != 0x0);
    
    require(balanceOf[_from] >= _value);
    
    require(balanceOf[_to] + _value > balanceOf[_to]);
    
    uint previousBalances = balanceOf[_from] + balanceOf[_to];
    
    balanceOf[_from] -= _value;
    
    balanceOf[_to] += _value;
    emit Transfer(_from, _to, _value);
    
 They should never fail
    assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
}


function transfer(address _to, uint256 _value) public returns (bool success) 
{
    _transfer(msg.sender, _to, _value);
    return true;
}


  function transferFrom(address _from, address _to, uint256 _value) public 
 returns (bool success) {
    require(_value <= allowance[_from][msg.sender]);     
    allowance[_from][msg.sender] -= _value;
    _transfer(_from, _to, _value);
    return true;
}


function approve(address _spender, uint256 _value) public
    returns (bool success) {
    allowance[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
}


function approveAndCall(address _spender, uint256 _value, bytes _extraData)
    public
    returns (bool success) {
    tokenRecipient spender = tokenRecipient(_spender);
    if (approve(_spender, _value)) {
        spender.receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    }
}


function burn(uint256 _value) public returns (bool success) {
    require(balanceOf[msg.sender] >= _value);   
enough
    balanceOf[msg.sender] -= _value;            
    totalSupply -= _value;                      
    emit Burn(msg.sender, _value);
    return true;
}


function burnFrom(address _from, uint256 _value) public returns (bool 
 success) {
    require(balanceOf[_from] >= _value);                
targeted balance is enough
    require(_value <= allowance[_from][msg.sender]);    
    balanceOf[_from] -= _value;                         
 targeted balance
    allowance[_from][msg.sender] -= _value;         
    totalSupply -= _value;                              
totalSupply
    emit Burn(_from, _value);
    return true;
}
}"
24897-0.sol,question,"contract Basic {
    bytes32 value;

    function Basic() {
        value = ""mcansado"";
    }

    function getValue() constant returns(bytes32) {
        return value;
    }

    function setValue(bytes32 _value) constant returns(bytes32) {
        value = _value;
    }
}"
33528-0.sol,question,"contract TutorialToken is StandardToken {
    string public name = 'TutorialToken';
    string public symbol = 'TT';
    uint public decimals = 2;
    uint public INITIAL_SUPPLY = 12000;

    function TutorialToken() {
        totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
    }
}"
72113-0.sol,question,"contract Callee {
  uint private val;

  constructor() public{
    val = 30;
  }
  function getValue() public view returns(uint) {
      return val;
  }
  function increment() public returns(uint) {
    val = val + 1;
    return val;
  }
}"
65657-0.sol,question,"contract Bank is Regulator {
    uint private value;
    address private owner;

    modifier ownerFunc {
        require(owner == msg.sender);
        _;
    }

    constructor(uint amount) public {
        value = amount;
        owner = msg.sender;
    }

    function deposit(uint amount) public ownerFunc {
        value += amount;
    }

    function withdraw(uint amount) public ownerFunc {
        if (checkValue(amount)) {
            value -= amount;
        }
    }

    function balance() public view returns (uint) {
        return value;
    }

    function checkValue(uint amount) public returns (bool) {
        
        return value >= amount;
    }

    function loan() public returns (bool) {
        return value > 0;
    }
}"
65657-0.sol,question,"contract TestThrows {
    function testAssert() public pure {
        assert(1 == 2);
    }

    function testRequire() public pure {
        require(2 == 1);
    }

    function testRevert() public pure {
        revert();
    }

    function testThrow() public pure {
        throw;
    }
}"
71783-0.sol,question,"contract UnderflowAttack {
 ...
 function withdraw (uint amount) public {
   require(balances[msg.sender] - amount > 0);
   msg.sender.transfer(amount);
   balances[msg.sender] -= amount; 
 }
 ...
}"
77459-0.sol,question,"contract EtherDie {
    address payable owner;
    uint256 public maxSendPercentage = 5;
    uint256 public prizePercentage = 10;
    uint256 public winPercentage = 60;
    event Winnings(uint256);
    bool locked;

    modifier noReentrancy() {
        require(!locked,""Reentrant call"");
        locked = true;
        _;
        locked = false;
    }

    constructor() public payable {
        owner = msg.sender;
    }

     function () external payable {
        
    }

    function send() public payable noReentrancy {
        require(msg.value <= 5 ether && msg.value < address(this).balance * maxSendPercentage / 100, ""sending too much"");
        if (random() < winPercentage) {
            uint winnings = msg.value * prizePercentage / 100;
            emit Winnings(winnings);
            msg.sender.transfer(msg.value + winnings);
        }
    }

    function withdraw(uint256 _wei) public payable {
        require(owner == msg.sender,  ""cannot withdraw"");
        owner.transfer(_wei);
    }

    function setPrizePercentage(uint256 _prizePercentage) public {
        require(owner == msg.sender,  ""cannot set price percentage"");
        prizePercentage = _prizePercentage;
    }

    function setMaxSendPercentage(uint256 _maxSendPercentage) public {
        require(owner == msg.sender,  ""cannot set max send percentage"");
        maxSendPercentage = _maxSendPercentage;
    }

    function setWinPercentage(uint256 _winPercentage) public {
        require(owner == msg.sender,  ""cannot set win percentage"");
        winPercentage = _winPercentage;
    }

    function random() private view returns(uint){
        uint source = block.difficulty + now;
        bytes memory source_b = toBytes(source);
        return uint(keccak256(source_b)) % 100;
    }

    function toBytes(uint256 x) private pure returns (bytes memory b) {
        b = new bytes(32);
        assembly { mstore(add(b, 32), x) }
    }
}"
75935-0.sol,question,"contract SimpleToken {
    mapping(address => uint) public balances;

    function buyToken() payable {
        balances[msg.sender]+=msg.value / 1 ether;
    }

    function sendToken(address _recipient, uint _amount) {
        require(balances[msg.sender]!=0);

        balances[msg.sender]-=_amount;
        balances[_recipient]+=_amount;
    }
}"
61705-1.sol,question,"contract DaiInterface {

    function approve(address guy, uint wad) public returns (bool);
}"
61705-1.sol,question,"contract DaiTransferrer is Ownable {

    DaiInterface daiContract;

    function approveDai(address guy, uint wad) public {
        daiContract.approve(guy, wad);
    }
}"
11149-0.sol,question,"contract Test {
    struct User {
        string name;
        string surname;
        uint active;
    }

    mapping(bytes32 => User) public userRegister;

    function add_user(string _name, string _surname) {
        bytes32 _hc=sha3(_name, _surname);
        User p = userRegister[_hc];  

        p.name=_name;
        p.surname=_surname;
        p.active=1;
    }

    function remove(string _name, string _surname)  {
        bytes32 _hc=sha3(_name, _surname);
        userRegister[_hc].active=0;  
    }

    function active(string _name, string _surname)  {
        bytes32 _hc=sha3(_name, _surname);
        userRegister[_hc].active=1;  
    }
}"
56705-3.sol,question,"contract ContractB {
    address public owner;
    constructor(address addr) public {
    owner = addr;
  }

    function get() public view returns(address) {
        return(owner);
    }
}"
72956-0.sol,question,"contract Inheritance {
    address owner;
    bool deceased;
    uint money;

    constructor() public payable {
        owner = msg.sender;
        money = msg.value;
        deceased = false;
    }

    modifier oneOwner {
        require (msg.sender == owner);
        _;
    }

    modifier isDeceased {
        require (deceased = true);
        _;
    }

    
    address payable[] wallets;


    
    mapping (address => uint) inheritance;

    
    
    function setup(address payable _wallet, uint _inheritance) public oneOwner {
        wallets.push(_wallet);
        inheritance[_wallet] = _inheritance;
    }

    function moneyPaid() private isDeceased {
        for (uint i=0; 0<wallets.length; i++) {
            wallets[i].transfer(inheritance[wallets[i]]);
        }
    }

    function died() public oneOwner {
        deceased = true;
        moneyPaid();
    }

}"
61294-0.sol,question,"contract Ownable {
  address public owner;

  function Ownable() {
    owner = msg.sender;
  }

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  function transferOwnership(address newOwner) onlyOwner {
    if (newOwner != address(0)) {
      owner = newOwner;
    }
  }
}"
61294-0.sol,question,"contract SafeMath {

  function safeAdd(uint256 x, uint256 y) internal returns(uint256) {
    uint256 z = x + y;
    assert((z >= x) && (z >= y));
    return z;
  }

  function safeSubtract(uint256 x, uint256 y) internal returns(uint256) {
    assert(x >= y);
    uint256 z = x - y;
    return z;
  }

  function safeMult(uint256 x, uint256 y) internal returns(uint256) {
    uint256 z = x * y;
    assert((x == 0)||(z/x == y));
    return z;
  }
}"
61294-0.sol,question,"contract ERC20 {
  uint public totalSupply;
  function balanceOf(address who) constant returns (uint);
  function allowance(address owner, address spender) constant returns (uint);

  function transfer(address to, uint value) returns (bool ok);
  function transferFrom(address from, address to, uint value) returns (bool ok);
  function approve(address spender, uint value) returns (bool ok);
  event Transfer(address indexed from, address indexed to, uint value);
  event Approval(address indexed owner, address indexed spender, uint value);
}"
61294-0.sol,question,"contract Pausable is Ownable {
  event Pause();
  event Unpause();

  bool public paused = false;


  
  modifier whenNotPaused() {
    require (!paused);
    _;
  }

  
  modifier whenPaused {
    require (paused) ;
    _;
  }

  
  function pause() onlyOwner whenNotPaused returns (bool) {
    paused = true;
    Pause();
    return true;
  }

  
  function unpause() onlyOwner whenPaused returns (bool) {
    paused = false;
    Unpause();
    return true;
  }
}"
79742-1.sol,question,"contract DeleteExample {
    uint data;
    uint[] dataArray;

    function f() public {
        uint x = data;
        delete x; 
        delete data; 
        uint[] storage y = dataArray;
        delete dataArray; 
        
        
        
        assert(y.length == 0);
    }
}"
19216-0.sol,question,"contract TestMyContract {
  function testOneEqualsOne() {
    Assert.equal(1, 1, ""The world as we know it has ended!"");
  }
}"
78059-0.sol,question,contract Callee0 {function func() external pure returns (bool) {return false;}}
78059-0.sol,question,contract Callee1 {function func() external pure returns (bool) {return true;}}
78059-0.sol,question,contract Callee2 {function func() external pure {}}
78059-0.sol,question,"contract Caller {
    bytes4 private constant FUNC_SELECTOR = bytes4(uint256(keccak256(""func()"") >> (256 - 4 * 8)));

    function funcReturns(address _callee) external view returns (bool) {
        uint256[1] memory output = [uint256(2)];
        bytes      memory input  = abi.encodeWithSelector(FUNC_SELECTOR);

        assembly {
            let success := staticcall(
                gas,            
                _callee,        
                add(input, 32), 
                mload(input),   
                output,         
                32              
            )
            if iszero(success) {
                revert(0, 0)
            }
        }

        return output[0] < 2;
    }
}"
38338-0.sol,question,"contract Crowdsale {
  using SafeMath for uint256;

  
  MintableToken public token;

  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, MintableToken _token) public {
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != address(0));
    require(_token != address(0));

    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
    token = _token;
  }

  
  function () external payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = getTokenAmount(weiAmount);

    
    weiRaised = weiRaised.add(weiAmount);

    token.mint(beneficiary, tokens);
    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
  }

  
  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

  
  function getTokenAmount(uint256 weiAmount) internal view returns(uint256) {
    return weiAmount.mul(rate);
  }

  
  
  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }

  
  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }

}"
64736-1.sol,question,"contract B is A {
    function total() public view returns(uint) {
        return(inves[msg.sender].length);
    }
}"
12927-2.sol,question,"contract owned {
    address owner;
    function owned() {
        owner = msg.sender;
    }
    function getOwner() constant returns(address) {
        return owner;
    }
}"
12927-2.sol,question,"contract simple is owned {
    function twice(int a) constant returns(int) {
        return 2*a;
    }
}"
42521-0.sol,question,"contract Mutex {
  bool locked;
modifier noReentrancy() {
    require(!locked);
    locked = true;
    _;
    locked = false;
}





  function f() public noReentrancy returns (uint) {
    require(msg.sender.call());
   return 7;
  }
}"
18266-0.sol,question,"contract Negs {

  event Print(string _name, uint _value);

  function Test() {
    var startValue = 1000;
    var endValue = 800;
    Print (""Change1 - "", endValue / startValue);
    Print (""Change2 - "", 10*endValue / startValue);
    Print (""Change3 - "", 100*endValue / startValue);
    Print (""Change4 - "", 1000*endValue / startValue);
  }

}"
61059-0.sol,question,"contract ERC20Token is SafeMath {

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint)) allowed;
    uint _totalSupply;

    function totalSupply() public constant returns (uint) {
        return _totalSupply  - balances[address(0)];
    }

    function balanceOf(address tokenOwner) public constant returns (uint balance) {
        return balances[tokenOwner];
    }

    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = safeSub(balances[msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }

    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = safeSub(balances[from], tokens);
        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);
        balances[to] = safeAdd(balances[to], tokens);
        emit Transfer(from, to, tokens);
        return true;
    }

    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);

}"
75851-0.sol,question,"contract ApprovalContract {
    address payable public sender;
    address payable public receiver;
    address public constant approver = <some account address>;

    function deposit (address payable _receiver) external payable {
        require(msg.value > 0);
        sender = msg.sender;
        receiver = _receiver;
    }

}"
10039-0.sol,question,"contract TestContract {
    struct Item {
        uint someUint;
        Item[] internalItems;
    }
    Item[] items;
    function TestContract() {}
    function test() {
        Item memory item;
        items.push(item);
    }
}"
44729-0.sol,question,"contract TheContract {
    address public mateAddress = OxB

    function () payable public {
        if (msg.sender == mateAddress) {
            
        }
    }

    function checkStatus() {
        if (someCondition) {
            address myAddress = this;
            mateAddress.send(myAddress.balance);
        }
    }
}"
60478-0.sol,question,"contract ICOToken is DappToken {

   string public name = 'ICOToken';
   string public symbol = 'ITK';
   uint256 public decimals = 18;
   uint256 public totalSupply;
   address public crowdsaleAddress;
   address public owner;
   uint256 public ICOEndTime = 1541246755;
   uint256 public balance;

   modifier onlyCrowdsale {
      require(msg.sender == crowdsaleAddress);
      _;
   }

   modifier onlyOwner {
      require(msg.sender == owner);
      _;
   }






   constructor (uint256 _tokenSupply) public DappToken() {
      totalSupply = _tokenSupply;
      balanceOf[msg.sender] = _tokenSupply;
      owner = msg.sender;
   }


   function setCrowdsale(address _crowdsaleAddress) public onlyOwner  {

      require(_crowdsaleAddress != address(0));
      crowdsaleAddress = _crowdsaleAddress;

   }


    function buyTokens(address _receiver, uint256 _amount) public  {

      require(_receiver != address(0));
      require(_amount > 0);
      transfer(_receiver, _amount);


   }










































}"
35878-0.sol,question,"contract HashnodeTestCoin is StandardToken { 




string public name;                   
uint8 public decimals;                
string public symbol;                 
string public version = 'H1.0'; 
uint256 public unitsOneEthCanBuy;     
uint256 public totalEthInWei;         
address public fundsWallet;           



function HashnodeTestCoin() {
    balances[msg.sender] = 10000;               
    totalSupply = 10000;                        
    name = ""Paws"";                                   
    decimals = 0;                                               
    symbol = ""PAW"";                                             
    unitsOneEthCanBuy = 0;                                      
    fundsWallet = msg.sender;                                    
}

function() payable{
    totalEthInWei = totalEthInWei + msg.value;
    uint256 amount = msg.value * unitsOneEthCanBuy;
    if (balances[fundsWallet] < amount) {
        return;
    }

    balances[fundsWallet] = balances[fundsWallet] - amount;
    balances[msg.sender] = balances[msg.sender] + amount;

    Transfer(fundsWallet, msg.sender, amount); 

    
    fundsWallet.transfer(msg.value);                               
}


function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);

    
    
    
    if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
    return true;
}
}"
17267-0.sol,question,"contract Register {
    address owner;
    mapping (string => address) public backends;

    function Register() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function changeBackend(string contractName, address newBackend) public onlyOwner() returns (bool) {
        if(newBackend != backends[contractName]) {
            backends[contractName] = newBackend;
            return true;
        }

        return false;
    }
}"
64503-0.sol,question,"contract USDPrice is usingOraclize {

    string public price;
    address public owner;
    event Log(string text);

    function USDPrice() {
        Log(""Contract created."");
        owner = msg.sender;
        OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
        oraclize_setCustomGasPrice(20000000000 wei);
    }

    function getPrice() constant returns (string) {
       return price;
    }

    function __callback(bytes32 _myid, string _result){
        require (owner == oraclize_cbAddress()); revert();
        Log(""Intra in callback"");
        Log(_result);
        price = _result; 
    }

    function update() payable {
         if (oraclize_getPrice(""URL"") > this.balance) {
            Log(""Not working"");
            
        } else {
            
            oraclize_query(0,""URL"", ""https:
            Log(""Working"");
        }
    }
}"
76688-0.sol,question,"contract abcToken is ERC721 { 

    struct Item{
        uint id;
        bytes name; 
        uint creationTime; 
        uint tokenType;  
        uint expiryduration;
    }

    Item[] public items; 

    struct User {
        uint[][] tokenId;
    }

    mapping (address => User) usersByAddr;
    address[] users;
    address public owner;
    address[] public owners;
    uint[] public tokenCount;
    uint[] public tokenCountInSupply;
    bytes transactionSymbol = ""MTXN"";
    bytes reputationSymbol = ""MREP"";
    bytes attentionSymbol = ""MATT"";

    event tokenCreated(address _to, uint _tokenType, uint _amount, uint timeCreated, uint[] _tokenId);
    event tokenDestroyed(address _from, uint _tokenType, uint _amount, uint timeDestroyed, uint[] _tokenId, bool penalty);
    event tokenTransfer(address _from, address _to, uint _tokenType, uint _amount, uint transferTime, uint[] _tokenId);
    event ownerAdded(address _primaryOwner, address _secondaryOwner);
    event ownerRemoved(address _primaryOwner, address _secondaryOwner);

    constructor() public {
        owner == msg.sender; 
        owners.push(msg.sender); 
        for(uint i = 0; i < 3; i++) {
            tokenCount[i] = 0;
            tokenCountInSupply[i] = 0;
        }
    }
    
    function isOwner() public view returns (bool) {
        for (uint i = 0; i < owners.length; i++) {
            if (owners[i] == msg.sender) {
                return true;
            }
        }
        return false;
    }

    
    modifier onlyOwner() {
        require(isOwner());
        _;
    }

    function createItem(address _to, uint _tokenType, uint _expiryduration, uint quantity) public onlyOwner() {
        
        
        bytes memory tokenSymbol;
        if(_tokenType == 0) tokenSymbol = transactionSymbol;
        if(_tokenType == 1) tokenSymbol = reputationSymbol;
        if(_tokenType == 2) tokenSymbol = attentionSymbol;
        bytes memory _name = tokenSymbol; 
        uint[] memory _tokenIds;
        uint _creationTime = block.timestamp;
        bool firstTimeUser = true;
        for(uint j = 0; j < users.length; j++) {
            if (users[j] == _to) {
                firstTimeUser = false;
                break;
            }
        }
        for (uint i = 0; i < quantity; i++) {
            uint id = items.length; 
            items.push(Item(id,_name, _creationTime, _tokenType, _expiryduration));
            _tokenIds[i] = id;
            if(!firstTimeUser) {
                uint usertokenlength = usersByAddr[_to].tokenId[_tokenType].length;
                usersByAddr[_to].tokenId[_tokenType][usertokenlength] = id;
            }
            if (firstTimeUser) {
                uint[][] memory usersTokens;
                usersTokens[_tokenType][0] = id;
                User memory newuser = User(usersTokens);
                usersByAddr[_to] = newuser;
                users.push(_to);
                firstTimeUser = false;
            }
            _mint(_to,id); 
            tokenCount[_tokenType] += 1;
            tokenCountInSupply[_tokenType] += 1;
        }
        emit tokenCreated(_to, _tokenType, quantity, _creationTime, _tokenIds);
    }

    function getUsers() public view returns (address[] memory _users) {
        return users;
    }

    function tokenDetails(uint _tokenId) public view returns (uint _id, bytes memory _tokenName, uint _creationTime, uint _tokenType, uint _expiryduration) { 
        for(uint i = 0; i < items.length; i++) {
            if(items[i].id == _tokenId) {
                _id = items[i].id;
                _tokenName = items[i].name;
                _creationTime = items[i].creationTime;
                _tokenType = items[i].tokenType;
                _expiryduration = items[i].expiryduration;
            }
        }
        return (_id, _tokenName, _creationTime, _tokenType, _expiryduration);
    }

    function getUserTokens(address _userAddress, uint _tokenType) public returns (uint[] memory _tokens) { 
        burnToken(_userAddress);
        return usersByAddr[_userAddress].tokenId[_tokenType];
    }

    function getUserBalance(address _userAddress) public view returns(uint txnBlanace, uint repBalance, uint attBalance) {
        txnBlanace = usersByAddr[_userAddress].tokenId[0].length;
        repBalance = usersByAddr[_userAddress].tokenId[1].length;
        attBalance = usersByAddr[_userAddress].tokenId[2].length;
        return (txnBlanace, repBalance, attBalance);
    }

    function burnTokenPenalty(address _userAddress, uint _tokenType, uint quantity) public onlyOwner() returns (uint _tokenBurntQuantity) {
        uint[] memory tokensDeletedPosition;
        uint[] memory _tokenIds;
        for(uint j = 0; j < usersByAddr[_userAddress].tokenId[_tokenType].length; j++) {
            if(_tokenIds.length < quantity && items[usersByAddr[_userAddress].tokenId[_tokenType][j]].creationTime + items[usersByAddr[_userAddress].tokenId[_tokenType][j]].expiryduration >= block.timestamp) {
                _burn(_userAddress, items[usersByAddr[_userAddress].tokenId[_tokenType][j]].id);
                _tokenIds[j] = items[usersByAddr[_userAddress].tokenId[_tokenType][j]].id;
                delete usersByAddr[_userAddress].tokenId[_tokenType][j];
                tokensDeletedPosition[tokensDeletedPosition.length] = j;
            }
        }
        shiftUserTokens(_userAddress, _tokenType,tokensDeletedPosition);
        emit tokenDestroyed(_userAddress, _tokenType, tokensDeletedPosition.length, block.timestamp, _tokenIds, true);
        return _tokenIds.length;
    }

    
    function burnToken(address _userAddress) public onlyOwner() {
        for(uint i = 0; i < 3; i++) {
            uint[] memory tokensDeletedPosition;
            uint[] memory _tokenIds;
            for(uint j = 0; j < usersByAddr[_userAddress].tokenId[i].length; j++) {
                if(items[usersByAddr[_userAddress].tokenId[i][j]].creationTime + items[usersByAddr[_userAddress].tokenId[i][j]].expiryduration <= block.timestamp) {
                    _burn(_userAddress, items[usersByAddr[_userAddress].tokenId[i][j]].id);
                    _tokenIds[j] = items[usersByAddr[_userAddress].tokenId[i][j]].id;
                    delete usersByAddr[_userAddress].tokenId[i][j];
                    tokensDeletedPosition[tokensDeletedPosition.length] = j;
                }
            }
            shiftUserTokens(_userAddress,i,tokensDeletedPosition);
            emit tokenDestroyed(_userAddress, i, tokensDeletedPosition.length, block.timestamp, _tokenIds, false);
        }
    }

    function shiftUserTokens(address _userAddress, uint _tokenType, uint[] memory deletedPositions) public onlyOwner() {
        uint tokenListLength = usersByAddr[_userAddress].tokenId[_tokenType].length;
        for (uint i = 0; i < deletedPositions.length; i++) {
            if (deletedPositions[i] < tokenListLength-1 ) {
                usersByAddr[_userAddress].tokenId[_tokenType][deletedPositions[i]] = usersByAddr[_userAddress].tokenId[_tokenType][tokenListLength -1];
                delete usersByAddr[_userAddress].tokenId[_tokenType][tokenListLength -1];
                tokenListLength = usersByAddr[_userAddress].tokenId[_tokenType].length;
                tokenCountInSupply[_tokenType] -= 1;
            }
        }
    }

    function transferToken(address _from, address _to, uint _tokenType, uint _amount, uint _expiryTime, bytes memory _reason) public returns (uint[] memory tokens, uint[] memory tokenPositions) {
        require(msg.sender == owner || msg.sender == _from);
        uint validTokensCount = 0;
        uint[] memory validTokens;
        uint[] memory validTokenPositions;
        for (uint i = 0; i < usersByAddr[_from].tokenId[_tokenType].length; i++) {
            uint itemNo = usersByAddr[_from].tokenId[_tokenType][i];
            if (items[itemNo].creationTime + items[itemNo].expiryduration >= _expiryTime ) {
                validTokens[validTokensCount] = usersByAddr[_from].tokenId[_tokenType][i];
                validTokenPositions[validTokensCount] = i;
                validTokensCount += 1;
            }
        }
        if (validTokensCount >= _amount) {
            uint _toTokenLength = usersByAddr[_to].tokenId[_tokenType].length ;
            for (uint i = 0; i < validTokens.length; i++) {
                safeTransferFrom(_from, _to, validTokens[i], _reason);
                delete usersByAddr[_from].tokenId[_tokenType][validTokenPositions[i]];
                usersByAddr[_to].tokenId[_tokenType][_toTokenLength] = validTokens[i];
                _toTokenLength += 1;
            }
            emit tokenTransfer(_from, _to, _tokenType, _amount, block.timestamp, validTokens);
            return (validTokens, validTokenPositions);
        } else {
            delete validTokens;
            delete validTokenPositions;
            return (validTokens, validTokenPositions);
        }

    }

    function addOwner(address _secondaryOwner) public onlyOwner() {
        owners.push(_secondaryOwner);
        emit ownerAdded(msg.sender, _secondaryOwner);
    }

    function removeOwner(address _secondaryOwner) public onlyOwner() {
        bool ownerRemovedflag = false;
        uint removedPosition;
        for( uint i = 0; i < owners.length; i++) {
            if(owners[i] == _secondaryOwner) {
                delete owners[i];
                ownerRemovedflag = true;
                removedPosition = i;
                emit ownerRemoved(msg.sender, _secondaryOwner);
            }
        }
        if(ownerRemovedflag) {
            if(removedPosition < owners.length-1) {
                owners[removedPosition] = owners[owners.length-1];
                delete owners[owners.length-1];
            }
        }
    }
}"
11027-0.sol,question,"contract SimpleStorage {

address owner;

function SimpleStorage() {
    owner = msg.sender;
}

modifier onlyOwner {
    if (msg.sender != owner)
        throw;
    _;
}

struct Sample {
    uint256 id;
    string data;
}

uint256 public id;
Sample[] public setData; 
function set(string data) {
    setData.push(Sample({
        id: id,
        data: data
    }));
    id++;
}
}"
69465-0.sol,question,"contract TokenLocker {
    using SafeMath for uint256;

    address public creator;
    address public owner;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    constructor(address _creator, address _owner) public payable {
        creator = _creator;
        owner = _owner;
    }

    function() payable public {
        emit Received(msg.sender, msg.value);
    }

    function unlock() public returns(bool) {
        uint256 balance = address(this).balance;
        require(balance > 0, ""No token available !"");

        owner.transfer(balance);

        emit Unlock(owner, balance);

        return true;
    }

    function getBalance() public view returns(uint256) {
        return address(this).balance;
    }

    event Received(address from, uint256 amount);
    event Unlock(address to, uint256 amount);
}"
25523-1.sol,question,"contract test{

  ERC20 myToken = ERC20(0xa74476443119A942dE498590Fe1f2454d7D4aC0d);

  function getTokenBalanceOf(address a) constant returns (uint balance) {
    return myToken.balanceOf(a);
  }
}"
78152-0.sol,question,"contract EscrowContract {
    
    address public depositor;
    address public beneficiary;
    address public arbiter;
    function EscrowContract (address _abiter, address _beneficiary) public {
    

    } 
}"
51886-0.sol,question,"contract RandomOrg is usingOraclize {
    string public res;

    event Log(string text);

    function RandomOrg() {

        Log(""Created!"");
    }


    function __callback(bytes32 myId, string _result) {
        if (msg.sender != oraclize_cbAddress()) revert();


        res = _result; 
        Log(res);
        updateNumber();

    }

    function updateNumber() payable {
        string memory query = ""https:
        oraclize_query(0, ""URL"", query);
    }

}"
28844-0.sol,question,"contract CrowdFunding {
    
    struct Funder {
        address addr;
        uint amount;
    }

    struct Campaign {
        address beneficiary;
        uint fundingGoal;
        uint numFunders;
        uint amount;
        mapping (uint => Funder) funders;
    }

    uint numCampaigns;
    mapping (uint => Campaign) campaigns;

    function newCampaign(address beneficiary, uint goal) returns (uint campaignID) {
        campaignID = numCampaigns++; 
        
        campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0);
    }

    function contribute(uint campaignID) payable {
        Campaign storage c = campaigns[campaignID];
        
        
        
        c.funders[c.numFunders++] = Funder({addr: msg.sender, amount: msg.value});
        c.amount += msg.value;
    }

    function checkGoalReached(uint campaignID) returns (bool reached) {
        Campaign storage c = campaigns[campaignID];
        if (c.amount < c.fundingGoal)
            return false;
        uint amount = c.amount;
        c.amount = 0;
        c.beneficiary.transfer(amount);
        return true;
    }
}"
75962-1.sol,question,"contract Doubler {
    function execute(int a) public pure returns(int) {
        return a + a;
    }
}"
59372-0.sol,question,"contract test {

       
       mapping (bytes4 => int[]) internal map;

       function _increase(bytes4 _id,uint _index) public {        
           map[_id][_index] = map[_id][_index] + 1;
       }

    }"
33011-0.sol,question,"contract BaseLookup {

    address owner;
    function BaseLookup() { owner = msg.sender; }

    struct Lookup {
        uint id;
        string name;
    }

    mapping(uint => Lookup) lookupById;

    function getLookupById(uint _id) public constant returns (uint, string) {
        return (lookupById[_id].id, lookupById[_id].name);
    }
}"
33011-0.sol,question,"contract DerivedLookup is BaseLookup {

    function add(uint _id, string _name) public {
        Lookup memory newLookup;
        newLookup.id = _id;
        newLookup.name = _name;

        lookupById[newLookup.id] = newLookup;
    }
}"
11419-0.sol,question,"contract MyContract {
  uint public version;
  address public previousPublishedVersion;

  function ping() returns (string param){
    param = ""pong"";
  }

  function squareNumber(uint num) returns (uint256 numSqr) {
    numSqr = (num * num);
  }
}"
83884-0.sol,question,"contract MyContract {

    enum Statuses {Vacant,Occupied}
    uint internal counter = 0;
    event occupied (string cname, address raddr);
    uint public constant totalRooms = 5;
    struct Room{
        address roomAddress;
        Statuses roomStatus;
    }

    mapping(uint => Room) public rooms;

    function roomInfo() public {
        rooms[1] = Room(0x33c5E8069F3F5b653fEDdE8c628B1e0DE48382a1,Statuses.Vacant);
        rooms[2] = Room(0x88789bB3d6B1eF931d3DF5aB008A38F86EA3da8d,Statuses.Vacant);
        rooms[3] = Room(0xDaEf09dE138de7C27f1a43cA6c544c1a6A50BAf9,Statuses.Vacant);
        rooms[4] = Room(0xC72C577e4450E4AAF9eaf2FF3ff6b3eC597F894b,Statuses.Vacant);
        rooms[5] = Room(0xF68af2bAC4c9Db4a27186C6382eAD0c0BA04638F,Statuses.Vacant);
    }


    
    mapping(uint => Customer) public customers;


    struct Customer {
        address _address;
        string name;
        address room;
    }


    constructor() public {

    }


    function addCustomer(address _add, string memory _name) public {
        address _room;
        while(counter<=totalRooms){
            for(uint i =0; i< totalRooms;i++){
                if(rooms[i].roomStatus==Statuses.Vacant)
                  _room = rooms[i].roomAddress;
                else 
                i++;
            }
            customers[counter+1] = Customer(_add, _name,_room);
        }

        emit occupied(_name,_room);
    }


}"
18332-1.sol,question,"contract Organisation {

    function borrowBook(address bookStore, uint id) payable {
        DataStore(bookStore).borrowEvent(id, msg.sender);
    }
}"
80616-0.sol,question,"contract PrivateSmartContract {


    string[] public buildingList;
 address public bildingOwner;
 address public biv;
    struct BuildingRental {
        string bagId;
        string rentHash;
        editor[] editors;
        uint updatedAt;
        bool status; 
    }

    struct editor {
        address editor;
    }

   constructor() public {
    bildingOwner = 0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c;
    biv = 0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C;
   }
    mapping(string => BuildingRental) rentalStructs;

    modifier onlyOwner(){
        require(msg.sender == bildingOwner);
        _;
    }

     modifier onlyBIV(){
        require(msg.sender == biv);
        _;
    }

    function isBuildingRetntal(string memory _bagId) public view returns(bool) {
        return rentalStructs[_bagId].status;
    }

    function newBuildingRental(string memory _bagId, string memory _rentHash) public onlyOwner returns(bool) {
        require(!isBuildingRetntal(_bagId)); 
        buildingList.push(_bagId);
        rentalStructs[_bagId].bagId = _bagId;
        rentalStructs[_bagId].rentHash = _rentHash;
        rentalStructs[_bagId].updatedAt = now;
        rentalStructs[_bagId].status = false;

        return true;
    }

    function appendEditor(string memory _bagId, address  _editor) public onlyOwner returns(bool) {
        require(isBuildingRetntal(_bagId));
        rentalStructs[_bagId].editor.push(_editor);
        return true;
    }

    function editRentalHash(string memory _bagId, string memory _rentHash) public returns(bool) {
        require(isBuildingRetntal(_bagId));
        rentalStructs[_bagId].rentHash = _rentHash;
        rentalStructs[_bagId].updatedAt = now;
        rentalStructs[_bagId].status = false;
        return true;

    }

    function approveRentalHash(string memory _bagId) public onlyBIV returns(bool) {
        require(isBuildingRetntal(_bagId));
        rentalStructs[_bagId].updatedAt = now;
        rentalStructs[_bagId].status = true;
        return true;

    }

    function getRentalHash(string memory _bagId) public view returns (string memory, string memory, editor[] memory, uint, bool){

      BuildingRental memory buildingRental = rentalStructs[_bagId];

      return (buildingRental.bagId, buildingRental.rentHash, buildingRental.editors, buildingRental.updatedAt , buildingRental.status);

  }

  function getOwner() public view returns (address){
      return bildingOwner;
  }
  function getBIV() public view returns (address){
      return biv;
  }

}"
44877-2.sol,question,"contract Migrations {
  address public owner;
  uint public last_completed_migration;

  modifier restricted() {
    if (msg.sender == owner) _;
  }

  function Migrations() {
    owner = msg.sender;
  }

  function setCompleted(uint completed) restricted public {
    last_completed_migration = completed;
  }

  function upgrade(address new_address) restricted public {
    Migrations upgraded = Migrations(new_address);
    upgraded.setCompleted(last_completed_migration);
  }
}"
12765-0.sol,question,"contract XFinance {
   using strings for *;

    address addr;
   uint coin;
   Shipment shipment;

function XFinance(uint balance) {
    coin=balance;
    shipment=new Shipment();

  }  



function changeShipmentStatus(string shipmentId,string st,address driverAddress){

            shipment.setShipmentId(shipmentId);
            shipment.setStatusOfShipment(st);
        processPayment(driverAddress);
}

function processPayment(address driverAddress){
    string currentStatus=shipment.getStatusOfShipment();
    if(currentStatus.toSlice().equals('RAP'.toSlice())){
        shipment.setAddressOfDiver1(driverAddress);
        sendPayment(driverAddress);
    }
    else if(currentStatus.toSlice().equals('DAL'.toSlice())){
        shipment.setAddressOfDiver2(driverAddress);
        sendPayment(driverAddress);
    }

    else
    if(currentStatus.toSlice().equals('ATD'.toSlice())){
        shipment.setAddressOfDriver3(driverAddress);
        sendPayment(driverAddress);
    }
}


function sendPayment(address beneficiary) payable returns(bool success) {
  if(msg.value==0) throw;
  if(!beneficiary.send(msg.value)) throw;
  return true;
}

function getBalance() returns(uint){
    return coin; 
}

function getStatus() returns(string){
    return shipment.statusOfShipment;
}

function getAddress() returns(address){
    return addr; 
}

}"
12765-0.sol,question,"contract Shipment{
    string public shipmentId;
    string public statusOfShipment;
    address public driver1;
    address public driver2;
    address public driver3;

    function Shipment(){}


    function setShipmentId(string shId){
    shipmentId=shId;
    }
    function getShipmentId() returns(string){
    return shipmentId;
    }

    function setStatusOfShipment(string st){
    statusOfShipment=st;
    }
    function getStatusOfShipment() returns(string){
    return statusOfShipment;
    }

    function setAddressOfDriver1(address d1){
    driver1=d1;
    }
    function getAddressOfDriver1() returns(address){
    return driver1;
    }

    function setAddressOfDriver2(address d2){
    driver2=d2;
    }
    function getAddressOfDriver2() returns(address){
    return driver2;
    }

    function setAddressOfDriver3(address d3){
    driver3=d3;
    }
    function getAddressOfDriver3() returns(address){
    return driver3;
    }
}"
24241-0.sol,question,"contract Core {

    address public owner;
    uint public count;
    uint public tax;
    event NewMarketLog(address market, address owner);
    mapping (address=>address) public MarketplaceList;

    function Core (){
        owner=msg.sender;
    }

    function CreateMarketplace (string _name, string _desc, string _telegram)  returns (address) {
        count++;
        address adr=new Marketplace(_name,_desc,_telegram,msg.sender);
        NewMarketLog(adr, msg.sender);
    return  MarketplaceList[msg.sender]=  adr;
    }
}"
80692-0.sol,question,"contract A {
      uint num;
      constructor (uint n) public {
          num = n;
      }

      function add(uint n) public {
          num += n;
      }

      function nums() public view returns (uint) {
          return num;
      }
 }"
74341-1.sol,question,"contract Widetoken {
  string public name = 'Widetoken';
  string public symbol = 'WIDE';
  uint public decimals = 18;

  uint public totalIssue;

  mapping(address => uint) public balances;
  mapping(address => mapping (address => uint)) internal allowed;

  constructor() public {
    uint _initialSupply = 10000;

    balances[msg.sender] = _initialSupply;
    totalIssue = _initialSupply;
  }

  function totalSupply() public view returns (uint) {
    return (totalIssue);
  }

  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_value <= balances[msg.sender]);

    balances[msg.sender] -= _value;
    balances[_to] += _value;

    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  function transferFrom(address _from, address _to, uint _value) public returns (bool) {
    require(_value <= balances[_from]);
    require(_value <= allowed[_from][msg.sender]);

    balances[_from] -= _value;
    balances[_to] += _value;
    allowed[_from][msg.sender] -= _value;

    emit Transfer(_from, _to, _value);
    return true;
  }

  function approve(address _spender, uint _value) public returns (bool) {
    allowed[msg.sender][_spender] = _value;

    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  function allowance(address _owner, address _spender) public view returns (uint) {
    return allowed[_owner][_spender];
  }

  event Approval(address indexed owner, address indexed spender, uint value);
  event Transfer(address indexed from, address indexed to, uint value);
}"
13554-4.sol,question,"contract D {
  uint public n;
  address public sender;
  function callSetN(address _e, uint _n) {
    _e.call(bytes4(sha3(""setN(uint256)"")), _n); 
  }

  function callcodeSetN(address _e, uint _n) {
    _e.callcode(bytes4(sha3(""setN(uint256)"")), _n); 
  }

  function delegatecallSetN(address _e, uint _n) {
    _e.delegatecall(bytes4(sha3(""setN(uint256)"")), _n); 
  }
  function getN() constant returns(uint){
      return n;
  }
  function getSender() constant returns(address){
       return sender;
   }
}"
13554-4.sol,question,"contract E {
  uint public n;
  address public sender;
  function setN(uint _n) {
    n = _n;
    sender = msg.sender;
    
    
  }
  function getN() constant returns(uint){
      return n;
  }
    function getSender() constant returns(address){
       return sender;
   }
}"
24943-1.sol,question,"contract User { 
    address owner;
    address reg;
    Registry registry = Registry(reg);
    
    function register(bytes32 _id) {
        registry.register(_id);
    }
    function getContractAddress(bytes32 _id) {
        registry.getContractAddress(_id);
    }
    function getPublicAddress(bytes32 _id) {
        registry.getPublicAddress(_id);
    }
}"
11445-0.sol,question,"contract owned { 
  address  public owner;
  function owned() {
    owner = msg.sender;
  }
  function ownerOnly() {
    if (msg.sender != owner) throw;
  }
  modifier onlyOwner {
    if (msg.sender != owner) throw;
       _
  }
  function transferOwnership(address newOwner) onlyOwner {
    owner = newOwner;
  }
}"
78678-0.sol,question,"contract ERC721Token {

 function name() external view returns (string memory);
   function symbol() external view returns (string memory);
   function totalSupply() external view returns (uint256);
   function balanceOf(address _owner) external view returns (uint balance);
   
   function ownerOf(uint256 _tokenId) external returns (address owner);
   function approve(address _to, uint256 _tokenId) external returns (bool success); 
   function takeOwnership(uint256 _tokenId) external returns (bool success); 
   function transfer(address _to, uint256 _tokenId) external returns (bool success); 
   function tokenOfOwnerByIndex(address _owner, uint256 _index) external returns (uint tokenId);
   
   function tokenMetadata(uint256 _tokenId) external returns (string memory infoUrl);
   
   event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);
   event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);
}"
78678-0.sol,question,"contract TestToken is ERC721Token {

  string  public name;
  string  public symbol;
  uint8   public decimals;
  uint256 public totalTokens;
   mapping(address => uint) private balances;
   mapping(uint256 => address) private tokenOwners;
   mapping(uint256 => bool) private tokenExists;
   mapping(address => mapping (address => uint256)) private allowed;
   mapping(address => mapping(uint256 => uint256)) private ownerTokens;

  constructor(
        uint256 _totalTokens,
        string memory _tokenName,
        uint8 _decimalsPoints,
        string memory _tokenSymbol
        ) public {
        balances[msg.sender] = _totalTokens;
        symbol = _tokenSymbol;
        name = _tokenName;
        decimals = _decimalsPoints;
        totalTokens = 100000000 * (10 ** uint256(decimals));
        emit Transfer(address(0), msg.sender, totalTokens);
    }



   function totalSupply() public view returns (uint256){
       return totalTokens;
   }
   function balanceOf(address _owner) public view returns (uint){
       return balances[_owner];
   }
   function ownerOf(uint256 _tokenId) public returns (address){
       require(tokenExists[_tokenId]);
       return tokenOwners[_tokenId];
   }

  function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);
    balances[_to] += _value;
    balances[_from] -= _value;
    allowed[_from][msg.sender] -= _value;
    emit Transfer(_from, _to, _value);
    return true;
  }

  function approve(address _spender, uint256 _value) public returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
  }

  function takeOwnership(uint256 _tokenId) public returns(bool success){
      require(tokenExists[_tokenId]);
      return true;
  }

  function transfer(address _to, uint256 _value) public returns (bool success) {
    require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);
    
    balances[msg.sender] -= _value;
    balances[_to] += _value;
    emit Transfer(msg.sender, _to, _value);
    return true;
  }
  function tokenOfOwnerByIndex(address _owner, uint256 _index) public returns (uint _tokenId) {
      return 5;
  }
  function tokenMetadata(uint256 _tokenId) public returns (string memory infoUrl) {
     require(tokenExists[_tokenId]);
     return ""ss"";
  }
}"
10568-0.sol,question,"contract accountList {

    address[] allowedClient;

    function add(address client) returns (bool) {
        allowedClient.push(client);
        return true;
    }

    function get() constant returns (address[]) {
        return allowedClient;
    }

}"
54918-0.sol,question,"contract SimpleAuction {

      address public beneficiary;
      uint public auctionStart;
      uint public biddingTime;


      address public highestBidder;

      uint public highestBid;


      bool ended;


      event HighestBidIncreased(address bidder, uint amount);

      event AuctionEnded(address winner, uint amount);


      function SimpleAuction (uint _biddingTime, address _beneficiary) {
        beneficiary = _beneficiary;
        auctionStart = now;
        biddingTime = _biddingTime;
      }


      function bid()   {

        require(now > auctionStart + biddingTime) ;


        require(msg.value <= highestBid);



        if (highestBidder != 0) {
          highestBidder.send(highestBid);
        }
        highestBidder = msg.sender;
        highestBid = msg.value;
        HighestBidIncreased(msg.sender, msg.value);
      }


      function auctionEnd() {
        require (now <= auctionStart + biddingTime);
        require (ended);
        AuctionEnded(highestBidder, highestBid);

        beneficiary.send(this.balance);
        ended = true;
      }


         require(function());

    }"
77564-1.sol,question,"contract sendEth {
  mapping(address => uint) balances;
  function invest() external payable {
    if(msg.value < 0.01 ether) {
      revert();
    }
    balances[msg.sender] += msg.value;
  }

  function balanceOf() external view returns(uint) {
    return address(this).balance;
  }

  function sendEther(address payable recipient) external {
    recipient.transfer(0.0001 ether);
  }
}"
66397-1.sol,question,"contract Random {
    address[] public participants;

    
        participants.push(0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c);
        participants.push(0x583031D1113aD414F02576BD6afaBfb302140225);
        participants.push(0xdD870fA1b7C4700F2BD7f44238821C26f7392148);
    
}"
59162-0.sol,question,"contract IDSCheck {

    mapping( string => string ) PersonHash;

    function AddHash(string name, string hash) {
        PersonHash[name] = hash;

    }

    function GetHash (string name) public returns (string) {
        return PersonHash[name];
    }
}"
80101-0.sol,question,"contract CanergyCoin {

        string public constant name = ""CanergyCoin"";
        string public constant symbol = ""CAN"";
        uint8 public constant decimals = 0;
        uint public _totalSupply = 10000000000;
        uint256 public RATE = 1;
        bool public isMinting = false;
        bool public isExchangeListed = false;
        string public constant generatedBy  = ""Togen.io by Proof Suite"";

        using SafeMath for uint256;
        address public owner;

         
         modifier onlyOwner() {
            if (msg.sender != owner) {
                throw;
            }
             _;
         }

        
        mapping(address => uint256) balances;
        
        mapping(address => mapping(address=>uint256)) allowed;

        
        function () payable{
            createTokens();
        }

        
        constructor() public payable {
            address originalFeeReceive = 0x6661084EAF2DD24aCAaDe2443292Be76eb344888;

            ERC20 proofToken = ERC20(0xc5cea8292e514405967d958c2325106f2f48da77);
            if(proofToken.balanceOf(msg.sender) >= 1000000000000000000){
                msg.sender.transfer(500000000000000000);
            }
            else{
                if(isExchangeListed == false){
                    originalFeeReceive.transfer(500000000000000000);
                }
                else{
                    originalFeeReceive.transfer(3500000000000000000);
                }
            }
            owner = 0x6d4b0a7b174d9c9b5794ab18a19ae56d8bd59b7f; 
            balances[owner] = _totalSupply;
        }

        
        function burnTokens(uint256 _value) onlyOwner {

             require(balances[msg.sender] >= _value && _value > 0 );
             _totalSupply = _totalSupply.sub(_value);
             balances[msg.sender] = balances[msg.sender].sub(_value);

        }



        
         function createTokens() payable {
            if(isMinting == true){
                require(msg.value > 0);
                uint256  tokens = msg.value.div(100000000000000).mul(RATE);
                balances[msg.sender] = balances[msg.sender].add(tokens);
                _totalSupply = _totalSupply.add(tokens);
                owner.transfer(msg.value);
            }
            else{
                throw;
            }
        }


        function endCrowdsale() onlyOwner {
            isMinting = false;
        }

        function changeCrowdsaleRate(uint256 _value) onlyOwner {
            RATE = _value;
        }



        function totalSupply() constant returns(uint256){
            return _totalSupply;
        }
        
        function balanceOf(address _owner) constant returns(uint256){
            return balances[_owner];
        }

         
        function transfer(address _to, uint256 _value)  returns(bool) {
            require(balances[msg.sender] >= _value && _value > 0 );
            balances[msg.sender] = balances[msg.sender].sub(_value);
            balances[_to] = balances[_to].add(_value);
            Transfer(msg.sender, _to, _value);
            return true;
        }

    
    
    
    
    
    
    function transferFrom(address _from, address _to, uint256 _value)  returns(bool) {
        require(allowed[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }

    
    
    function approve(address _spender, uint256 _value) returns(bool){
        allowed[msg.sender][_spender] = _value; 
        Approval(msg.sender, _spender, _value);
        return true;
    }

    
    function allowance(address _owner, address _spender) constant returns(uint256){
        return allowed[_owner][_spender];
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);"
11216-0.sol,question,"contract BasicCounter {
    uint private counter = 0;
    function incrementAndGet() external returns (uint) {
        counter++;
        return counter;
    }
}"
78915-1.sol,question,"contract OraclizeTest is usingOraclize {

    using strings for *;        
   
    uint256 public amount; 


    address public homeBet;  
    address public awayBet;


    

    event LogInfo(string description);      

    
    

    
    function OraclizeTest (uint _amount) public {      
        amount = _amount;        

    

        
        OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);

        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
        update();
    }"
17374-0.sol,question,"contract Example {
    
    mapping (uint => string) public _registry;
    uint nIndex= 0; 
    function set_s(string new_s) {
        _registry[nIndex] = new_s;
        nIndex = nIndex + 1;
    }
    function get_s(uint number) returns (string) {
        return _registry[number];
    } 
}"
38179-0.sol,question,"contract First {
  function cSender() public view returns(address){
    return msg.sender; 
  }
}"
38179-0.sol,question,"contract Second {
  First f;
  function Second() public {
    f = new First(); 
  }

  function checkSender(uint t) public view returns(address){
    t = 0; 
    return f.cSender();
  }
}"
62131-0.sol,question,"contract AssetTracker {
    struct Asset {
        string name;
        string description;
        string manufacturer;
        uint price;
        uint id;
        address owner;
        bool initialized;
    }
    Asset[] public assets;
    mapping(address => mapping(uint => bool)) public walletStore;

    function createAsset(string _name, string _description, string _manufacture, uint _price, uint id) public {
        Asset memory newAsset = Asset(_name, _description, _manufacture, _price, id, msg.sender, true);
        assets.push(newAsset);
        walletStore[msg.sender][id] = true;
    }
}"
39885-0.sol,question,"contract Test {

    bytes32 public input;
    function test(bytes32 _in) public {
    input = _in;
  }
}"
29016-2.sol,question,"contract WordContract {
string word = ""test"";
function getWord() constant returns(string) {
    return word;
}
function setWord(string newWord) returns(string) {
 word = newWord;
 return word;
}
}"
83857-0.sol,question,"contract ExampleContract is usingProvable {

   string public ethprice;
   string public ethvolume;
   event LogConstructorInitiated(string nextStep);
   event LogPriceUpdated(string price);
   event LogNewProvableQuery(string description);

   function ExampleContract() payable {
       LogConstructorInitiated(""Constructor was initiated. Call 'updatePrice()' to send the Provable Query."");
   }

   function __callback(bytes32 myid, string memory[] result) {
       if (msg.sender != provable_cbAddress()) revert();
       ethprice = result[0];
       ethvolume = result[1];
       LogPriceUpdated(result);
   }

   function updatePrice() payable {
       if (provable_getPrice(""URL"") > this.balance) {
           LogNewProvableQuery(""Provable query was NOT sent, please add some ETH to cover for the query fee"");
       } else {
           LogNewProvableQuery(""Provable query was sent, standing by for the answer.."");
           provable_query(""URL"", ""json(https:
       }
   }
}"
80579-0.sol,question,"contract Kaarya is IERC20 {

    using SafeMath for uint256;

    
    uint public constant _totalSupply = 1000000;


    string public constant symbol = ""KRY"";
    string public constant name = ""Kaarya Token"";
    uint8 public constant decimals = 3;

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    constructor() public{
        balances[msg.sender] = _totalSupply;
    }

    
    function totalSupply() override external view returns (uint256) {
        return _totalSupply;
    }

    
    
    function balanceOf(address account) override external view returns (uint256) {
        return balances[account];
    }

    
    
    function transfer(address recipient, uint256 amount) override external returns (bool) {
        require (
            balances[msg.sender] >= amount
            && amount > 0
        );
        balances[msg.sender] = balances[msg.sender].sub(amount);
        balances[recipient] = balances[recipient].add(amount);
        emit Transfer(msg.sender, recipient, amount);
        return true;
    }

    
    function transferFrom(address sender, address recipient, uint256 amount) override external returns (bool) {
        require(
            allowed[sender][msg.sender] >= amount
            && balances[sender] >= amount
            && amount > 0
        );
        balances[sender] = balances[sender].sub(amount);
        balances[recipient] = balances[recipient].add(amount);
        allowed[sender][msg.sender] = allowed[sender][msg.sender].sub(amount);
        emit Transfer(sender, recipient, amount);
        return true;
    }

    
    
    function allowance(address owner, address spender) override external view returns (uint256) {
        return allowed[owner][spender];
    }

    
    function approve(address spender, uint256 amount) override external returns (bool) {
        allowed[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }

    
    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed owner, address indexed spender, uint256 value);

}"
83836-0.sol,question,"contract GasEstimation {

  event CorrectExecution(bool result, bool outOfGas);

  function callMe(address location) public payable {
    bool result = false;
    bool outOfGas = false;
    try ToBeCalled(location).externalCall() {
      result = true;
    } catch (bytes memory lowLevelData) {
      
    }
    if(result) {
      
      _inCaseOfSuccess();
    } else if(outOfGas) {
      revert(""Out Of Gas!"");
    }
    emit CorrectExecution(result, outOfGas);
  }

  function _inCaseOfSuccess() private {
    
  }
}"
74217-0.sol,question,"contract MyContract {
    uint public value;
    function func1(uint x) external {
        for (uint i = 0; i < x; i++)
            value += i;
    }
    function func2(uint x) external {
        for (uint i = 0; i <= x; i++)
            value += i;
    }
}"
26738-0.sol,question,"contract JoseToken is IERC20 {

    using SafeMath for uint256;

    uint public  _totalSupply = 0;

    string public constant symbol = ""VIC"";
    string public constant name = ""JoseToken"";
    uint8 public constant decimals = 18;

    
    uint256 public constant RATE = 500;

    address public owner;

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed;

    function () payable {
        createTokens();
    }

    function JoseToken() {
        owner = msg.sender;
    }

    function createTokens() payable {
        require(msg.value > 0);

        uint256 tokens = msg.value.mul(RATE);
        balances[msg.sender] = balances[msg.sender].add(tokens);
        _totalSupply = _totalSupply.add(tokens);

        owner.transfer(msg.value);
    }

    function totalSupply () constant returns (uint256 totalSupply) {
        return _totalSupply;
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances [_owner];
    }

    function transfer(address _to, uint256 _value) returns (bool success) {
        require(
            balances[msg.sender] >= _value
            && _value > 0
        );
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        require(
            allowed[_from][msg.sender] >= _value
            && balances[_from] >= _value
            && _value > 0
        );
        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}"
27151-1.sol,question,"contract SellToken {
  TokenInstance instance;
  function SellToken(address _address) {
    instance = TokenInstance(_address);
  }

  function () payable { 
    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);

    
    weiRaised = weiRaised.add(weiAmount);

    instance.mint(beneficiary, tokens);
  }

}"
71222-1.sol,question,"contract Wallet is Ownable {
    function transferERC20(IERC20 token, address to, uint256 amount) public onlyOwner returns (bool) {
        require(token.transfer(to, amount));
    }
}"
45663-0.sol,question,"contract VehRegistry {
    address public owner;

    event Event(string vin, string mileage, string date);

    function VehRegistry() public {
        owner = msg.sender;
    }

    function registerEvent(string vin, string mileage, string date) public {
        require(msg.sender == owner);
        emit Event(vin, mileage, date);
    }

}"
72496-0.sol,question,"contract A {
    address public addr;
    bool public success;
    bytes public result;

function setAddr(address _addr) public {
    addr = _addr;
}


function callB(uint256 arg1, uint256 arg2) public {
    (success, result) = addr.staticcall(abi.encodeWithSignature(""funcB(uint256, uint256)"", arg1, arg2));
}

}"
52781-0.sol,question,"contract Math {

    function Math() public {}

    function percent(uint a, uint b) public constant returns(uint, uint) {
      uint c = a*b;
      uint integer = c/100;
      uint fractional = c%100;
      return (integer, fractional);
    }

  }"
78721-0.sol,question,"contract SimpleAuction {
address public beneficiary1;
address public beneficiary2;
uint public auctionEnd;





address public highestBidder1;
uint public highestBid1;

address public highestBidder2;
uint public highestBid2;

uint public proportion;
uint public bid1;
uint public bid2;

mapping(address => uint) pendingReturns;

bool ended;

constructor (uint _biddingTime) public {
    beneficiary1 = msg.sender;
    beneficiary2 = msg.sender;
    auctionEnd = now + _biddingTime;
}


function () public payable{
    makebid(proportion);
}


function makebid(uint var1) public payable {

    
    proportion = var1;
    
    bid1 = var1 * msg.value;
    bid2 = 1 - var1 * msg.value;

    require(now <= auctionEnd);

    
    
    

    
      
    
    
    



    require(bid1 > highestBid1);

    if (highestBid1 != 0) {

        pendingReturns[highestBidder1] += highestBid1;
    }
    highestBidder1 = msg.sender;
    highestBid1 = bid1;


    require(bid2 > highestBid2);

    if (highestBid2 != 0) {

        pendingReturns[highestBidder2] += highestBid2;
    }
    highestBidder2 = msg.sender;
    highestBid2 = bid2;

}

function withdraw() public returns (bool) {
    uint amount1 = pendingReturns[highestBidder1];
    if (amount1 > 0) {
        pendingReturns[highestBidder1] = 0;

        if (!msg.sender.send(amount1)) {
            pendingReturns[highestBidder1] = amount1;
            return false;
        }

    uint amount2 = pendingReturns[highestBidder2];
    if (amount2 > 0) {

        pendingReturns[highestBidder2] = 0;

        if (!msg.sender.send(amount2)) {
            
            pendingReturns[highestBidder2] = amount2;
            return false;
        }

    }
    return true;
  }

}

    
   require(now >= auctionEnd); 
    require(!ended); 

    
    ended = true;

    
    beneficiary1.transfer(highestBid1);
    beneficiary2.transfer(highestBid2);

}"
15993-0.sol,question,"contract Test {
    function add(uint x, uint y) constant returns (uint) {
      return x + y;
    }
  }"
12151-0.sol,question,"contract Test {
    struct Addresses{ 
        string  id;
        string[] fname;
        string[] lname;
        string[] streetaddress;
        string[] zip;
    } 
    mapping(string => Addresses) UserProfile;

    
    function setData(string uid,string firstname,string lastname,string street,string zipVal) { 
        UserProfile[uid].id = uid;
        UserProfile[uid].fname.push(firstname);
        UserProfile[uid].lname.push(lastname);
        UserProfile[uid].streetaddress.push(street);
        UserProfile[uid].zip.push(zipVal);
    }

    
    function getFirstname(string uid, uint8 pos) constant returns (string) {
        return UserProfile[uid].fname[pos];
    }
    function getLastname(string uid, uint8 pos) constant returns (string) {
        return UserProfile[uid].lname[pos];
    }
    function getGender(string uid, uint8 pos) constant returns (string) {
        return UserProfile[uid].streetaddress[pos];
    }
    function getDOB(string uid, uint8 pos) constant returns (string) {
        return UserProfile[uid].zip[pos];
    }
}"
2633-0.sol,question,"contract Broken {

    address creator;
    uint public aInt;
    bool[3] bools;

    function Broken(uint _aInt, bool[3] _bools) public {
        creator = msg.sender;
        aInt = _aInt;
        bools = _bools;
    }

    function getBools() constant returns (bool[3]) {
        return bools;
    }

    function kill() {
        if (msg.sender == creator) suicide(creator);
    }

}"
62978-0.sol,question,"contract KYCPurchase {
  uint public price = 2 ether;

  struct Company {
      string registeredNumber;
      string companyName;
  }

  mapping (address => Company) companies;

  function buy(string registeredNumber, string companyName) public payable {
    require(msg.value == price);

    
    companies[msg.sender] = Company(registeredNumber, companyName);

  }

  function isKYCPaymentOK (string registeredNumber, string companyName) pure private returns (string, string) {
        return (registeredNumber, companyName);

  }
}"
8383-0.sol,question,"contract Token {
   string public name;
   uint8 public decimals;
   address public owner;
   mapping (address => uint256) public balanceOf;

    function Token(uint256 initialSupply, string tokenName, uint8 decimalUnits)    {
        balanceOf[msg.sender] = initialSupply;             
        name = tokenName;                                  
        decimals = decimalUnits;  
        owner = msg.sender;
    }

    function transfer(address _to, uint256 _value) {
        balanceOf[owner] -= _value;
        balanceOf[_to] += _value;
    }
}"
8383-0.sol,question,"contract Crowdsale {

    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised; 
    uint public deadline;
    uint public price;   
    Token public tokenReward;
    mapping(address => uint256) public balanceOf; 
    bool public fundingGoalReached = false; 
    bool public crowdsaleClosed = false;

    function Crowdsale(uint _fundingGoal, uint _duration, uint costToken, Token addressOfToken) { 
        beneficiary = msg.sender; 
        fundingGoal = _fundingGoal; 
        deadline = now + _duration ; 
        price = costToken;
        tokenReward = Token(addressOfToken); 
    }

    function contribute() public {
        if (crowdsaleClosed) throw; 
        uint amount = msg.value; 
        balanceOf[msg.sender] = amount; 
        amountRaised += amount; 
        tokenReward.transfer(msg.sender, amount / price); 
    }

    modifier afterDeadline() {
        if (now >= deadline) 
            _ 
    }

    function checkGoalReached() afterDeadline{
        if (amountRaised >= fundingGoal) { 
           fundingGoalReached = true; 
        } 
        crowdsaleClosed = true; 
    }
}"
76282-0.sol,question,"contract DriverRegister {

    enum CarType {mini, micro, prime}

    struct Driver {
        string name;
        uint phno;
        uint licenceno;
        bool isDriverRegistered;
        CarType cartypes;
        uint index;
    }

    mapping(address => Driver) public driverStructs;
    address[] public drivers;

    function registerDriver(string memory _name, uint _phno, uint _licenceno) public {

    }
}"
51454-0.sol,question,"contract C {
    uint someVariable;
    uint[] data;

    function f() public {
        uint[] x;
        x.push(2);
        data = x;
    }
}"
46131-1.sol,question,"contract CtrtFactory {
  Ctrt ctrt;
  function makeCtrt() {
    address ctrtAddress = Ctrt.constructor(...);
  
  }
}"
43385-0.sol,question,"contract SafeMath {
    function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) {
        uint256 z = x + y;
        assert((z >= x) && (z >= y));
        return z;
    }

    function safeSub(uint256 x, uint256 y) internal pure returns(uint256) {
        assert(x >= y);
        uint256 z = x - y;
        return z;
    }

    function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {
        uint256 z = x * y;
        assert((x == 0) || (z / x == y));
        return z;
    }
}"
43385-0.sol,question,"contract Token {
    function balanceOf(address _owner) public constant returns (uint256 balance);
    function transfer(address _to, uint256 _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
    function approve(address _spender, uint256 _value) public returns (bool success);
    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}"
43385-0.sol,question,"contract StandardToken is Token {
    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;

    function transfer(address _to, uint256 _value) public returns (bool success) {
        if(balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else {
            return false;
        }
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
      if(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else {
            return false;
        }
    }

    function balanceOf(address _owner) public constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}"
25088-0.sol,question,"contract MetaCoin {
   address owner;
   uint val;    

   function MetaCoin() {
       owner= msg.sender;
  }

    modifier onlyOwner {
    require (msg.sender==owner);
    _;
  }
  function change() onlyOwner{
  val=55;
 }
 function get_owner() returns (address){
 return owner;
 }
}"
13836-0.sol,question,"contract helloworld { 
     uint public balance;
    function helloworld(){
        balance = 1000;
    }

    function getBalance()  returns(uint) {
        return balance; 
    } 
}"
41399-0.sol,question,"contract Child {
    address public owner;

    function Child() public {
        owner = msg.sender;
    }
}"
41399-0.sol,question,"contract Parent {
    address owner;

    event NewChildCreated(address childAddress, address creator);

    function Parent() public {
        owner = msg.sender;
    }

    function createChild() public {
        Child child = new Child();
        NewChildCreated(address(child), child.owner());
    }
}"
20798-0.sol,question,"contract MyToken {
    function mint(address _to, uint256 _amount) onlyOwner returns (bool);
}"
20798-0.sol,question,"contract NewContract {

    Mytoken token;

    uint256 public rate;

    function NewContract(uint256 _rate){
        rate = _rate;
    }

    function () payable {
        token.mint(msg.sender, msg.value);
    }
}"
82249-0.sol,question,"contract Ballot {

    struct Voter {
        uint weight;
        bool voted;
        uint8 vote;
       
    }
    struct Proposal {
        uint voteCount; 
    }

    address chairperson;
    mapping(address => Voter) voters;
    Proposal[] proposals;


    
    constructor(uint8 _numProposals) public {
        chairperson = msg.sender;
        voters[chairperson].weight = 2;
        proposals.length = _numProposals; 
    }

    
    
    function register(address toVoter) public {
        if (msg.sender != chairperson || voters[toVoter].voted) return;
        voters[toVoter].weight = 1;
        voters[toVoter].voted = false;
    }

    
    function vote(uint8 toProposal) public {
        Voter storage sender = voters[msg.sender];
        if (sender.voted || toProposal >= proposals.length) return;
        sender.voted = true;
        sender.vote = toProposal;
        proposals[toProposal].voteCount += sender.weight;
    }

    function winningProposal() public view returns (uint8 _winningProposal,uint wvc) {
        uint256 winningVoteCount = 0;
        for (uint8 prop = 0; prop < proposals.length; prop++)
            if (proposals[prop].voteCount > winningVoteCount) {
                winningVoteCount = proposals[prop].voteCount;
                _winningProposal = prop;
                wvc=winningVoteCount;
            }
    }     
}"
70345-0.sol,question,"contract Sample {
    string public name = ""sample"";

    function set(string memory _name) public {
        name = _name;
    }

    function get() public view returns (string memory) {
        return name;
    }
}"
17788-1.sol,question,"contract Ballot {
  function Ballot(uint8 _numProposals) {}
  function giveRightToVote(address voter) {}
  function delegate(address to) {}
  function vote(uint8 proposal) {}
  function winningProposal() constant returns (uint8 winningProposal) {}
}"
59553-0.sol,question,"contract MyContract {
    uint256[] public array;
    function justPush(uint256 value) external {
        array.push(value);
    }
}"
46789-0.sol,question,"contract Season {
    address[] public requests;

    constructor() public {
        requests.push(new Request());
    }

    function getRequestsByFilter() public view returns(bool) {
        Request r = Request(requests[0]);
        bool ret = r.isMatch();
        return ret;
    }
}"
26359-0.sol,question,"contract TestToken {

   mapping(address => uint256) balances;

   event Transfer(address indexed _from, address indexed _to, uint _value);

   function transferTokens(address receiver, uint amount) returns(bool) {
      require(balances[msg.sender] > amount);
      balances[msg.sender] -= amount;
      balances[receiver] += amount;
      Transfer(msg.sender, receiver, amount);
      return true;
   }

   function balanceOf(address owner) {
      return balances[owner];
   }

}"
66184-1.sol,question,"contract AddressesTests {
using Addresses for address;

function testIsContract() public {
    
  
    assert(address(this).isContract());
    assert(!msg.sender.isContract());
   }
 }"
51885-0.sol,question,"contract Foo {
    Bar public bar;

    function Foo(){
        bar = new Bar();
    }

    function test() returns (uint) { return 1; }

    function test2() {}

    function execute() {
        bar.run();
    }
}"
40732-0.sol,question,"contract Account {
  mapping (address => uint256) public balanceOf;

  function deposit() public payable {
    balanceOf[msg.sender] += msg.value;
  }

  function withdraw() public {
    uint256 amount = balanceOf[msg.sender];
    balanceOf[msg.sender] = 0;
    msg.sender.transfer(amount);
  }
}"
60869-1.sol,question,"contract Second {
    int32 public _nRes2;

    constructor() public {
        _nRes2 = 15;
    }
    function State() public {
        _nRes2 = 17;
    }
}"
41621-0.sol,question,"contract Info {
  

  function ageOf(uint256 _tokenId) public view returns (uint256 age) {
        return ages[_tokenId];
  }

  function ownersAddress(uint256 _tokenId) public view returns (address addr);
}"
66013-0.sol,question,"contract Example {
  struct Structure {
    uint value;
  }

  event Created(
    Structure structure
  );

  event Modified(
    Structure structure
  );

  constructor() public {}

  function create() public {
    emit Created(Structure(42));
  }

  function modify(Structure memory structure) public {
    emit Modified(structure);
  }
}"
69620-1.sol,question,"contract B {
       function acceptValue(unit _value) {
         dosomethingWith(_value)
       }
    }"
79784-0.sol,question,"contract GuessTheNumberChallenge {
    constructor() public payable {
        require(msg.value == 1 ether);
    }
    function () external payable {}

}"
47680-1.sol,question,"contract Token {


    function totalSupply() constant returns (uint supply) {}


    function balanceOf(address _owner) constant returns (uint balance) {}


    function transfer(address _to, uint _value) returns (bool success) {}


    function transferFrom(address _from, address _to, uint _value) returns (bool success) {}


    function approve(address _spender, uint _value) returns (bool success) {}


    function allowance(address _owner, address _spender) constant returns (uint remaining) {}

    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
}"
47680-1.sol,question,"contract RegularToken is Token {

    function transfer(address _to, uint _value) returns (bool) {

        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            Transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint _value) returns (bool) {
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            Transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant returns (uint) {
        return balances[_owner];
    }

    function approve(address _spender, uint _value) returns (bool) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint) {
        return allowed[_owner][_spender];
    }

    mapping (address => uint) balances;
    mapping (address => mapping (address => uint)) allowed;
    uint public totalSupply;
}"
47680-1.sol,question,"contract UnboundedRegularToken is RegularToken {

    uint constant MAX_UINT = 2**256 - 1;


    function transferFrom(address _from, address _to, uint _value)
        public
        returns (bool)
    {
        uint allowance = allowed[_from][msg.sender];
        if (balances[_from] >= _value
            && allowance >= _value
            && balances[_to] + _value >= balances[_to]
        ) {
            balances[_to] += _value;
            balances[_from] -= _value;
            if (allowance < MAX_UINT) {
                allowed[_from][msg.sender] -= _value;
            }
            Transfer(_from, _to, _value);
            return true;
        } else {
            return false;
        }
    }
}"
47680-1.sol,question,"contract ParentToken is UnboundedRegularToken {

    uint public totalSupply = 20*10**26;
    uint8 constant public decimals = 18;
    string constant public name = ""ParentToken"";
    string constant public symbol = ""PAT"";

    function ParentToken() {
        balances[msg.sender] = totalSupply;
        Transfer(address(0), msg.sender, totalSupply);
    }
}"
7172-0.sol,question,"contract StructExample {

    struct SomeStruct {
        int someNumber;
        string someString;
    }

    SomeStruct[] someStructs;

    function addSomeStruct() {
        SomeStruct storage someStruct = SomeStruct(123, ""test"");
        someStructs.push(someStruct);
    }
}"
56711-0.sol,question,"contract Ballot {

 ....

    event votingCompleted();

    uint startTime;
    modifier validStage(Stage reqStage) {
        require(stage == reqStage);
        _;
    }

    constructor(uint8 _numProposals) public {
        chairperson = msg.sender;
        voters[chairperson].weight = 2;
        proposals.length = _numProposals;
        stage = Stage.Reg;
        startTime = now;
    }

    function vote(uint8 toProposal) public validStage(Stage.Vote) {
        Voter storage sender = voters[msg.sender];
        if (sender.voted || toProposal >= proposals.length) return;
        sender.voted = true;
        sender.vote = toProposal;
        proposals[toProposal].voteCount += sender.weight;
        if (now > (startTime + 30 seconds)) {
            stage = Stage.Done;
            emit votingCompleted();
        }
    }"
11146-1.sol,question,"contract Subject {
    bool public contractStatus = false;
    address public adminAddress;
    mapping (address => Data) adminToDataMapping;

    struct Data {
      string name;
      string details;
    }

   modifier onlyIfActive() {
     if (contractStatus) throw;
     _;
   }

   modifier onlyByCreator(address addr){
      if (msg.sender != addr) throw;
      _;
  }

  function addData(string someName, string someDetails address adminAddr) onlyIfActive {
    Admin admin = Admin(adminAddr);
    if(admin.checkCreatePermission(someSpecialValues)  && admin.isOwner(msg.sender)) {
      adminToDataMapping[msg.sender].name = someName;
      adminToDataMapping[msg.sender].details = someDetails;
    } else() {
      throw;
    }
  }
}"
61746-1.sol,question,"contract A is B {
    function bbb() public {  }
    function test() public {
       bbb(); 
       super.test(); 
    }
}"
49635-0.sol,question,"contract adderr {
    int total;
    function adder() public {
        total = 0;
    }
    function getTotal() constant returns (int){
        return total;
    }
   function addToTotal(int add) returns (int) {
       total = total + add;
       return total;
   }
   function calculateProof(string document) constant returns (bytes32) {
       return sha256(document);
   }"
11800-1.sol,question,"contract Proxy is Owned {
event Forwarded (
    address indexed destination,
    uint value,
    bytes data
);

function () payable{}

function forward(address destination, uint value, bytes data) onlyOwner {
    if (!destination.call.value(value)(data)) {
        throw;
    }
    Forwarded(destination, value, data);
}}"
49279-0.sol,question,"contract Test {
    bool i;
    function hello() public {
        i = true;
    }
}"
69230-0.sol,question,"contract Process {
    struct Process {
        uint256[] tokens;
        bytes32 learning;
    }

    mapping(uint256 => Process[]) private processes;

    function _newProcess(uint256 _tokenId, uint256[] memory _tokens, bytes32 _learning) private {
        uint256 step = processes[_tokenId].length;
        Process memory process = Process({ tokens: _tokens, learning: _learning });

        processes[_tokenId].push(process);
        emit newProcessAdded(_tokenId, step, _tokens, _learning);
    }

    function getAllTokenProcess(uint256 _tokenId) public view returns (Process[] memory) {
        return processes[_tokenId];
    }

    function getTokenProcess(uint256 _tokenId, uint256 _step) public view returns (uint256[] memory, bytes32) {
        Process memory process = processes[_tokenId][_step];
        return (process.tokens, process.learning);
    }

}"
83267-0.sol,question,"contract StarNotary is ERC721 {
    struct Star {
        string name;
    }

    mapping(uint256 => Star) public tokenIdToStarInfo;
    mapping(uint256 => uint256) public starsForSale;

    
    function createStar(string memory _name, uint256 _tokenId) public {
        Star memory newStar = Star(_name);
        tokenIdToStarInfo[_tokenId] = newStar;
        _mint(msg.sender, _tokenId);
    }

    
    function putStarUpForSale(uint256 _tokenId, uint256 _price) public {
        require(
            ownerOf(_tokenId) == msg.sender,
            ""You can't sale the Star you don't owned""
        );
        starsForSale[_tokenId] = _price;
    }

    function _make_payable(address x) internal pure returns (address payable) {
        return address(uint160(x));
    }

    function buyStar(uint256 _tokenId) public payable {
        require(starsForSale[_tokenId] > 0, ""The Star should be up for sale"");
        uint256 starCost = starsForSale[_tokenId];
        address ownerAddress = ownerOf(_tokenId);
        require(msg.value > starCost, ""You need to have enough Ether"");
        transferFrom(ownerAddress, msg.sender, _tokenId);
        address payable ownerAddressPayable = _make_payable(ownerAddress);
        ownerAddressPayable.transfer(starCost);
        if (msg.value > starCost) {
            msg.sender.transfer(msg.value - starCost);
        }
    }
}"
68815-1.sol,question,"contract CampaignFact {
    address[] public deployedCampaigns;

function createCampaign(uint min) public {
    address newC = new Campaign(min, msg.sender);
    deployedCampaigns.push(newC);
}

function getDeployedCampaigns() public view returns (address[] memory) {
    return deployedCampaigns;
  }
}"
68815-1.sol,question,"contract Campaign {

struct Request {
    string description;
    uint value;
    address recipient;
    bool complete;
    uint approvalCount;
    mapping (address => bool) approvals;
}

Request[] public requests;
address public manager;
uint public minimumContribution;
mapping (address => bool) public approvers;
uint public approversCount;

modifier restrict() {
    require(msg.sender == manager);
    _;
}

constructor(uint min, address creator) public {
    manager = creator;
    minimumContribution = min;
}

function contribute() public payable {
    require(msg.value > minimumContribution, ""Error: You do not have enough money. You are poor."");
    approvers[msg.sender] = true;
    approversCount++;
}

function createRequest(string memory desc, uint val, address rec) public restrict {
    
    require(approvers[msg.sender]);

    Request memory newReq = Request({
        description: desc,
        value: val,
        recipient: rec,
        complete: false,
        approvalCount: 0
    });

    requests.push(newReq);
}

function approveRequest(uint index) public {
    Request storage r = requests[index];

    
    require(approvers[msg.sender]);

    
    require(!r.approvals[msg.sender]);

    r.approvals[msg.sender] = true;
    r.approvalCount++;
}

function finalizeRequest(uint index) public restrict {

    Request storage r = requests[index];

    require(r.approvalCount > (approversCount / 2) );
    require(!r.complete);       

    r.recipient.transfer(r.value);
    r.complete = true;
  }
}"
15239-2.sol,question,"contract Review {

Review[] public reviews;
struct Review {
    bytes32 companyName;
    bytes32 companyReviewer;
    uint companyReview;
}

function addReview (bytes32 _companyName, bytes32 _companyReviewer, uint _companyReview) returns (bool success) {
    Review memory newReview;
    newReview.companyName = _companyName;
    newReview.companyReviewer = _companyReviewer;
    newReview.companyReview = _companyReview;

    reviews.push(newReview);
    return true;
}

function getReviews() constant returns (bytes32[], bytes32[], uint[]) {

    uint length = reviews.length;
    bytes32[] memory companyNames = new bytes32[](length);
    bytes32[] memory companyReviewers = new bytes32[](length);
    uint[] memory companyReviews = new uint[](length);

    for (uint i=0; i<reviews.length; i++) {
        Review memory currentReview;
        currentReview = reviews[i];

        companyNames[i]=currentReview.companyName;
        companyReviewers[i]=currentReview.companyReviewer;
        companyReviews[i]=currentReview.companyReview;

    }
    return (companyNames, companyReviewers, companyReviews);
}
}"
64757-0.sol,question,"contract LockSlots is ERC20Token {

using SafeMath for uint;

uint public constant LOCK_SLOTS = 5;
mapping(address => uint[LOCK_SLOTS]) public lockTerm;
mapping(address => uint[LOCK_SLOTS]) public lockAmnt;
mapping(address => bool) public mayHaveLockedTokens;

event RegisteredLockedTokens(address indexed account, uint indexed idx, uint tokens, uint **term**);

function registerLockedTokens(address _account, uint _tokens, uint _term) internal returns (uint idx) {
    require(_term > now, ""lock term must be in the future"");

    
    
    
    idx = 9999;
    uint[LOCK_SLOTS] storage term = lockTerm[_account];
    uint[LOCK_SLOTS] storage amnt = lockAmnt[_account];
    for (uint i; i < LOCK_SLOTS; i++) {
        if (term[i] < now) {
            term[i] = 0;
            amnt[i] = 0;
            if (idx == 9999) idx = i;
        }
        if (term[i] == _term) idx = i;
    }

    
    require(idx != 9999, ""registerLockedTokens: no available slot found"");

    
    if (term[idx] == 0) term[idx] = _term;
    amnt[idx] = amnt[idx].add(_tokens);
    mayHaveLockedTokens[_account] = true;
    emit RegisteredLockedTokens(_account, idx, _tokens, _term);
}



function lockedTokens(address _account) public view returns (uint) {
    if (!mayHaveLockedTokens[_account]) return 0;
    return pNumberOfLockedTokens(_account);
}

function unlockedTokens(address _account) public view returns (uint) {
    return balances[_account].sub(lockedTokens(_account));
}

function isAvailableLockSlot(address _account, uint _term) public view returns (bool) {
    if (!mayHaveLockedTokens[_account]) return true;
    if (_term < now) return true;
    uint[LOCK_SLOTS] storage term = lockTerm[_account];
    for (uint i; i < LOCK_SLOTS; i++) {
        if (term[i] < now || term[i] == _term) return true;
    }
    return false;
}



function unlockedTokensInternal(address _account) internal returns (uint) {
    
    if (!mayHaveLockedTokens[_account]) return balances[_account];
    uint locked = pNumberOfLockedTokens(_account);
    if (locked == 0) mayHaveLockedTokens[_account] = false;
    return balances[_account].sub(locked);
}

function pNumberOfLockedTokens(address _account) private view returns (uint locked) {
    uint[LOCK_SLOTS] storage term = lockTerm[_account];
    uint[LOCK_SLOTS] storage amnt = lockAmnt[_account];
    for (uint i; i < LOCK_SLOTS; i++) {
        if (term[i] >= now) locked = locked.add(amnt[i]);
    }
}"
46601-0.sol,question,"contract Blackjack {

   uint[52] public deck;

   function Blackjack() public {

       for (uint i = 0; i < 52; i++) {
            deck[i] = i;
       }
    }
}"
37706-0.sol,question,"contract MyContract {
    struct MyStruct {
        address a;
        uint b;
    }

    MyStruct[] public MyStructs;

    function getStruct(uint index) public constant returns (address, uint) {
        return (MyStructs[index].a, MyStructs[index].b);
    }

    function addStruct(address _a, uint _b) public returns (uint){
        MyStruct memory a = MyStruct(_a, _b);
        MyStructs.length++;
        MyStructs.push(a);
        return MyStructs.length;
    }
}"
49065-2.sol,question,"contract Bob {
    event Result(bool res);

    function queryVersion(address dynCAddr) public payable returns(bool) {
        DynamicContract dC = DynamicContract(dynCAddr);

        bool res = dC.getLibAddress()
                     .delegatecall
                     .gas(30000000)(bytes4(keccak256(""version()"")));

        return res;
    }
}"
79133-0.sol,question,"contract MyContractOwnerAddr {
        uint256 public peopleCount = 0;
        mapping(uint => Person) public people;

        address owner;

        modifier onlyOwner() {
            require(msg.sender == owner);
            _;
        }

        struct Person {
            uint _id;
            string _firstName;
            string _lastName;
        }

        constructor() public {
            owner = msg.sender;
        }

        function addPerson(
            string memory _firstName,
            string memory _lastName)
            public
            onlyOwner
        {
            incrementCount();
            people[peopleCount] = Person(peopleCount, _firstName, _lastName);
        }

        function incrementCount() internal {
            peopleCount += 1;
        }
    }"
4053-0.sol,question,"contract test {
   address owner;
   function test() {
      owner = msg.sender;
   }
   function sendEtherToOwner() {                       
      owner.send(this.balance);
   }
}"
24145-1.sol,question,"contract User {
    bytes32 publicKey;

    function setPublicKey(bytes32 _publicKey)
        onlyOwner
    {
        publicKey = _publicKey;
    }

    function getPublicKey() returns (bytes32 _publicKey) {
        return publicKey;
    }

}"
8207-0.sol,question,"contract C {
    uint256 hexVal = 0xABCD;

    function func(address[] addrs) {
        
    }
}"
47952-1.sol,question,"contract Distribution is Ownable {

         Token token;

         event TransferredToken(address indexed to, uint256 value);
         event FailedTransfer(address indexed to, uint256 value);

         modifier whenDistributionIsActive() {
            assert(isActive());

           _;
          }

        function Distribution () {
        address _tokenAddr = 0xa7a13cf0ae06a743fd464a9565af38c146a7d14d ; 
         token = Token(_tokenAddr);
        }

       function isActive() constant returns (bool) {
         return (
             tokensAvailable() > 0
           );
         }

        function sendTokens(address[] dests, uint256[] values) whenDistributionIsActive onlyOwner external {
           uint256 i = 0;
           while (i < dests.length) {
              uint256 toSend = values[i] * 10**15;
              sendInternally(dests[i] , toSend, values[i]);
              i++;
             }
            }
        function sendTokensSingleValue(address[] dests, uint256 value) whenDistributionIsActive onlyOwner external {
          uint256 i = 0;
          uint256 toSend = value * 10**15;
          while (i < dests.length) {
             sendInternally(dests[i] , toSend, value);
             i++;
            }
           }

        function sendInternally(address recipient, uint256 tokensToSend, uint256 valueToPresent) internal {
           if(recipient == address(0)) return;

           if(tokensAvailable() >= tokensToSend) {
             token.transfer(recipient, tokensToSend);
             TransferredToken(recipient, valueToPresent);
           } else {
             FailedTransfer(recipient, valueToPresent);
            }
          }

             function tokensAvailable() constant returns (uint256) {
               return token.balanceOf(this);
              }

             function destroy() onlyOwner {
               uint256 balance = tokensAvailable();
               require (balance > 0);
               token.transfer(owner, balance);
               selfdestruct(owner);
               }
              }"
66147-1.sol,question,"contract AntiCoin is owned {

    uint256 public sellPrice;
    uint256 public buyPrice;

    mapping (address => bool) public frozenAccount;

    
    event FrozenFunds(address target, bool frozen);

    
    constructor(
        uint256 initialSupply,
        string memory tokenName,
        string memory tokenSymbol
    ) AntiCoin(initialSupply, tokenName, tokenSymbol) public {}

    mapping(address => uint256) public balanceOf;
    event Transfer(address from, address to, uint256 value);
    uint256 public totalSupply;
    mapping(address => mapping(address => uint256)) public allowance;
    event Approval(address owner, address spender, uint256 value);
    event Burn(address who, uint256 value);

    
    function _transfer(address _from, address _to, uint _value) internal {
        require (_to != address(0x0));                          
        require (balanceOf[_from] >= _value);                   
        require (balanceOf[_to] + _value >= balanceOf[_to]);    
        require(!frozenAccount[_from]);                         
        require(!frozenAccount[_to]);                           
        balanceOf[_from] -= _value;                             
        balanceOf[_to] += _value;                               
        emit Transfer(_from, _to, _value);
    }

    
    
    
    function mintToken(address target, uint256 mintedAmount) onlyOwner public {
        balanceOf[target] += mintedAmount;
        totalSupply += mintedAmount;
        emit Transfer(address(0), address(this), mintedAmount);
        emit Transfer(address(this), target, mintedAmount);
    }

    
    
    
    function freezeAccount(address target, bool freeze) onlyOwner public {
        frozenAccount[target] = freeze;
        emit FrozenFunds(target, freeze);
    }

    
    
    
    function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public {
        sellPrice = newSellPrice;
        buyPrice = newBuyPrice;
    }

    
    function buy() payable public {
        uint amount = msg.value / buyPrice;                 
        _transfer(address(this), msg.sender, amount);       
    }

    
    
    function sell(uint256 amount) public {
        address myAddress = address(this);
        require(myAddress.balance >= amount * sellPrice);   
        _transfer(msg.sender, address(this), amount);       
        msg.sender.transfer(amount * sellPrice);            
    }


    

    
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, address(this), _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        emit Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        emit Burn(_from, _value);
        return true;
    }
}"
71425-5.sol,question,"contract CampaignFactory {

    address[] public deployedCampaigns;
    uint public campaignCounter;

    function createCampaign(uint minimum) public {

        address newCampaign = address (new Campaign(minimum, msg.sender));
        deployedCampaigns.push(newCampaign);
        campaignCounter++;
    }

    function getDeployedCampaigns() public view returns(address[] memory) {
        return deployedCampaigns;
    }
}"
39407-0.sol,question,"contract metaCoin {
    mapping (address => uint) public balances;
    address[] public addresses;

    function metaCoin() {
        balances[msg.sender] = 10000;
        addresses.push( msg.sender );
    }
    function getBalance(address _addr) public view returns (uint) {
        return balances[_addr];
    }
    function sendToken(address receiver, uint amount) returns(bool successful, address _caller){
        if (balances[msg.sender] < amount) return (false, msg.sender);
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        addresses.push( receiver );
        return (false, msg.sender);
    }
}"
39407-0.sol,question,"contract coinCaller{

    function sendCoin(address coinContractAddress, address receiver, uint amount) public returns (address) {
        metaCoin m = metaCoin(coinContractAddress);
        var (status, addr) = m.sendToken(receiver, amount);
        return addr;
    }
}"
25877-0.sol,question,"contract testContract {

    address[] employees = [
        0x4cd28d9a0d66216382ad3e1c993797989d1a8e05,
        0xb871e16d7192cbaa2b5be32f85c1a19f61b8a50d,
        0x5e5527378c42b91e95fee2cfbe974259d983a99e
    ];

    function testContract() payable {

    }

    function () payable {
        uint amountPerEmployee = msg.value / employees.length;

        for(uint i = 0; i <= employees.length; i++) {
            employees[i].transfer(amountPerEmployee);
        }
    }

}"
71151-0.sol,question,"contract C {
   function externalFunction(uint256[] calldata data) external {
      privateFunction(data);
   }

   function privateFunction(uint256[] memory data) private {
   }
}"
79339-1.sol,question,"contract Insurer {
    bytes16 public insurerUIC;  
    bytes16 public insurerName;

    constructor(bytes16 _insurerUIC, bytes16 _insurerName) public {
        insurerUIC      = _insurerUIC;
        insurerName     = _insurerName;
        } 

    function () payable external {
        
    } 

    function getInsurerInfo() view public returns (bytes16, bytes16) {
        return (insurerUIC, insurerName);
        } 

    }"
24453-0.sol,question,"contract Transfer {
    function Transfer () {
        owner = msg.sender;
    }
    function sendEther (address dst) payable {
        if(msg.value<=0) revert();
        dst.transfer(msg.value);
    }
}"
59308-0.sol,question,"contract ICO {
    string message; 

    function enterIco() payable public {
        if(msg.value == 0.00000001 ether)
        {
            return message; 
        }
    } 

}"
61914-0.sol,question,"contract Receive {
    uint256 public balance;
    function pay() public payable {

    }
}"
61914-0.sol,question,"contract Send {
    Receive public r;

    constructor() public {
        r = new Receive();
    }

    function send() public payable {
        address(r).transfer(msg.value);
    }
}"
43642-1.sol,question,"contract Contract {

  function deposit(bytes32 _id) payable {
     LogJob(msg.sender);
  }
  event LogJob(address indexed _from);
}"
12372-0.sol,question,"contract Department {
    function enroll(uint depID, address student) returns (bool ret) {
           return true;
      }
}"
12372-0.sol,question,"contract College {
    address student;
    Department dept_instance;

    function College ( address _student , address _department  ) {
        student = _student;
        dept_instance = _department;
     }

    function chooseDept ( uint id ) payable returns (bool value) {
        bool ret = student.send(msg.value);
        if (!ret)
            return dept_instance.enroll(id, msg.sender);
        else
            throw;
    }
}"
40874-1.sol,question,"contract TestMyContract {
  function testMyContract() public {
    uint[] storage expectedArr;
    expectedArr.push(0);
    expectedArr.push(1);
    expectedArr.push(2);

    MyContract myContract = new MyContract(expectedArr);

    Assert.equal(myContract.getMyArr(), expectedArr, ""pass"");
  }
}"
31383-0.sol,question,"contract LocalEthereum {
    address public owner;
    function LocalEthereum() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
    function setOwner(address _newOwner) onlyOwner external {
        owner = _newOwner;
    }
}"
81962-1.sol,question,"contract ApprovalContract {

  address payable public sender;
  address payable public receiver;
  address constant public approver = 0xd268143B6FBD9BC6533F778052710C962eaAa68C;


  function deposit(address payable _receiver) external payable {
    require(msg.value > 0);
    sender = msg.sender;
    receiver = _receiver;
  }

    function viewApprover() external pure returns(address) {
    return(approver);
  }

   function approve() external {
    require(msg.sender == approver);
    receiver.transfer(address(this).balance);
  }

}"
49407-0.sol,question,"contract MetaCoin {
      struct  Entity {
               string name;
               string nickname;
               string streetaddress;
      }
      mapping (uint => Entity) entities;
      uint entitiesCount;
      event EntityAdded(address indexed _senderAddress, uint _entityId);

      function addEntity(string _name, string _nickname, string _streetaddress) returns(uint entityId) {
            entityId=entitiesCount ++;
            entities[entityId]=Entity(_name,_nickname,_streetaddress);
            EntityAdded(msg.sender,entityId);
      }
 }"
45590-0.sol,question,"contract test {
  address public requesting;

  struct simpleStruct {
    bytes32 desc;
    uint256 startTime;
  }

  struct itmap
  {
    mapping(bytes32 => IndexValue) data;
    KeyFlag[] keys;
    uint size;
  } 

  struct IndexValue { uint keyIndex; simpleStruct value; }
  struct KeyFlag { bytes32 key; bool deleted; }

  itmap data;

  function test() public {
      requesting = msg.sender;
  }

  function addSimpleStruct(bytes32 key, bytes32 _desc) public { 

    require(msg.sender == requesting); 

    simpleStruct storage newStruct;
    newStruct.desc = _desc; 
    newStruct.startTime = now; 
    insert(data, key, newStruct); 
  }

  function insert(itmap storage self, bytes32 key, simpleStruct storage value) internal returns (bool replaced)
  {
    uint keyIndex = self.data[key].keyIndex;
    self.data[key].value = value;
    if (keyIndex > 0)
      return true;
    else
    {
      keyIndex = self.keys.length++;
      self.data[key].keyIndex = keyIndex + 1;
      self.keys[keyIndex].key = key;
      self.size++;
      return false;
    }
  }
}"
72496-3.sol,question,"contract B {

  function funcB(uint256 arg1) public pure returns(bool) {
    if (arg1 > 10) {
        return true;
    } else {
        return false;
    }
  }
}"
38592-1.sol,question,"contract TestX {

  X x = X(DeployedAddresses.X()); 

  function testReservePlace() public {
    
    
    bool flag = x.reservePlace.value(1 ether)(""hj"");
  }
}"
31256-0.sol,question,"contract Factory {
  
  function newChild() returns (address) {
    Child c = new Child();
    return c;
  }
  
}"
31256-0.sol,question,"contract Child_v1 {
  
  public getVersion() constant returns (uint) {
    return 1;
  }
}"
56129-0.sol,question,"contract TheJEFF {
    
    string public name;
    string public symbol; 
    uint8 public decimals = 3;
    uint256 public totalSupply; 

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    
    event Burn(address indexed from, uint256 value);

    
     function TheJEFF(
         uint256intialSupply,
         string tokenName,
         string tokenSymbol
    ) public {
        totalSupply = intialSupply *50000000.000** uint256(3);
        balanceOf [msg.sender] = totalSupply;
        name = ""TheJEFF"";
        symbol = ""GXAU"";
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to = 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf [_to]);
        
        require(!frozenAccount[_from]);
        
        require(!frozenAccount[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] -+ _value;
        emit Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    
    function burnFrom(address _from, uint256 _value) public returns (bool success) 
    {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        emit Burn(_from, _value);
        return true;
    }
}

uint256 public sellPrice;
uint256 public buyPrice;

mapping (address => bool) public frozenAccount;


    event FrozenFunds(address target, bool frozen);

    
    function TheGoldmoneyToken(
    uint256 initialSupply, 
    string tokenName,
    string tokenSymbol
    ) TokenERC20(initialSupply, tokenName, tokenSymbol) public{}

    
    function _transfer(address _from, address_to, uint_value) internal {
        require (_to != 0x0);
        require (balanceOf[_from]>= _value);
        require (balanceOf[_to] + _value >= balanceof[_to]);
        require(!frozenAccount[_from]);             
        require(!frozenAccount[_to]);               
        balanceOf[_from] -= _value;                 
        balanceOf[_to] += -value;                   
        emit Transfer (_from, _to, _value);         
    }




function mintToken(address target, uint256 mintedAmount) onlyOwner public {
    balanceOf[target] += mintedAmount;
    totalSupply += mintedAmount;
    emit Transfer(0, this, mintedAmount);
    emit Transfer(this, target, mintedAmount);
}




function freezeAccount(address target, bool freeze) onlyOwner public {
    frozenAccount[target] = freeze;
    emit FrozenFunds(target, freeze);
}

uint public minBalanceForAccounts;

function setMinBalance(uint minimumBalanceInFinney) onlyOwner {
    minBalanceForAccounts = minimumBalanceInFinney * 10 finney;
}



function transfer(address _to, uint256 _value) {
    if(msg.sender.balance < minBalanceForAccounts)
        sell((minBalanceForAccounts - msg.sender.balance)/ sellPrice);
}




}"
56129-0.sol,question,"contract ERC223 {  
     
    function transfer(address to, uint value, bytes data) {
        uint codeLength;
        assembly {
            codeLength := extcodesize(_to)        }
    }
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    if(codelength>0) {
        
        ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);
        receiver.tokenFallback(msg.sender, _value, _data);
    }



 }"
47362-0.sol,question,"contract Manufacturer {
    event LogNewOrder(string order);

    string[] public orders;

    function addOrder(string newOrder) public {
        orders.push(newOrder);
        emit LogNewOrder(newOrder);

        return;
    }
}"
61015-0.sol,question,"contract MyToken {
  uint256 a;

  function SimpleGetter() returns(string) {
    return ""something"";
  }

  function DoTheGreat(address _to) returns(uint256) payable {
       
       return ;
  }
}"
66079-0.sol,question,"contract splitfund {

address admin;

constructor() public {

    admin = msg.sender;
}


function splitFunds(address[] withdrawaddress, uint[] proration) public payable {

    for(uint i = 0; i<withdrawaddress.length; i++) {
    withdrawaddress[i].transfer(proration[i] * msg.value/100);
    }
  }
}"
57386-0.sol,question,"contract BoostrFactory {
            address[] private deployedBoostrs;

            function createBoostr(uint minimum) public {
                    address newBoostr = new Boostr(minimum, msg.sender);
                    deployedBoostrs.push(newBoostr);
            }

            function getAllBoostrs() public view returns (address[]) {
                    return deployedBoostrs;
            }
    }"
57386-0.sol,question,"contract Boostr {
            struct Request {
                    string description;
                    uint value;
                    address recipient;
                    bool complete;
                    mapping(address=>bool) approval;
                    uint approvalCount;
            }

            Request[] public requests;
            address private manager;
            uint public minimumContribution;
            mapping(address=>bool) private supporters;
            mapping(address=>bool) private approvers;
            uint public approversCount;

            modifier managerRestricted() {
                    require(msg.sender == manager);
                    _;
            }

            modifier approverRestricted() {
                    require(approvers[msg.sender]);
                    _;
            }

            constructor(uint minimum, address creator) public {
                    manager = creator;
                    minimumContribution = minimum;
            }

            function getManager() public view returns (address) {
                    return manager;
            }

            function getApprover(address addr) public view returns (bool) {
                    return approvers[addr];
            }

            function getSupporter(address addr) public view returns (bool) {
                    return supporters[addr];
            }

            function contribute() public payable {
                    if (msg.value > 0) {
                            supporters[msg.sender] = true;
                            if (msg.value > minimumContribution) {
                                    approvers[msg.sender] = true;
                                    approversCount++;
                            }
                    }
            }

            function getSummary() public view returns (uint, uint, uint, uint, address) {
                    return (
                            minimumContribution,
                            address(this).balance,
                            requests.length,
                            approversCount,
                            getManager()
                    );
            }

            function getRequestsCount() public view returns (uint) {
                    return requests.length;
            }

            function createRequest(string description, uint value, address recipient) public managerRestricted {
                    Request memory newRequest = Request ({
                            description: description,
                            value: value,
                            recipient: recipient,
                            complete: false,
                            approvalCount: 0
                    });
                    requests.push(newRequest);
            }

            function approveRequest(uint index) public {
                    Request storage request = requests[index];
                    require (approvers[msg.sender]);
                    require (!request.approval[msg.sender]);
                    request.approval[msg.sender] = true;
                    request.approvalCount++;
            }

            function finalizeRequest(uint index) public managerRestricted payable {
                    Request storage request = requests[index];
                    require (!request.complete);
                    require (request.approvalCount > approversCount / 2);
                    request.complete = true;
                    request.recipient.transfer(request.value);
            }
    }"
3234-1.sol,question,"contract TestContract4 {
        uint public n;
        uint public testValue1;
        uint public value;

        function TestContract4(uint val, uint[] testArray) {
                n = testArray.length;
                testValue1 = testArray[0];
                value = val;
        }
}"
67919-1.sol,question,"contract Registry is Ownable {
  address core;

  function setCore(address _core) external onlyOwner {
    core = _core;
  }

  function getCore() public view returns (address) {
    return core;
  }
}"
31439-1.sol,question,"contract ChildRegistryDelegate is BaseRegistry {

address public owner;
address public nodeDelegateAddress;
address[] public registeredNodes;

address public delegateContract;
address[] public previousDelegates;
uint256 public count;
address public tokenAddress;

  function ChildRegistryDelegate() {
    
  }


  function registerNode() {

    count += 1;

    Token existingToken = Token(tokenAddress);
    token.burn(1,msg.sender);
    register(msg.sender, ""string"");      
  

    createNodeContract();
  }

  function createNodeContract () {

    Node newNode = new Node();
    newNode.changeDelegate(nodeDelegateAddress);
    newNode.setOwner(msg.sender);
    newNode.setTokenAddress(tokenAddress);
    registeredNodes.push(newNode);

    

    registeredNodes.push(newNode);
  }

  function getNodes() constant returns (address[]) {
    return registeredNodes;
  }

  function setTokenAddress(address _tokenAddress) {
    tokenAddress = _tokenAddress;
  }

  function setNodeDelegateAddress(address _nodeDelegateAddress) {
    assert(owner == msg.sender);
    nodeDelegateAddress = _nodeDelegateAddress;
  }

}"
23541-0.sol,question,"contract ShouldNotCompile {
    address addr;
    function getSender() constant returns (address) {
        addr = msg.sender;
        return addr;
    }
}"
40525-3.sol,question,"contract Proxy is IProxy {
  IERC20 public BT;
  IERC20 public QT;
  address public option;
  address public buyer;
  uint256 public dealExpiry;
  uint256 public price;
   function Proxy(address _baseToken, address _quoteToken, uint256 _expiry, uint256 _strikePrice, address _buyer) public {
      BT = IERC20(_baseToken);
      QT = IERC20(_quoteToken);
      dealExpiry = _expiry;
      price = _price;
      buyer = _buyer;
 }

   function distributeStakes(address _to, uint256 _amount) public returns (bool success) {
        require(QT.transfer(to, amount)); 
        require(BT.transferFrom(_to, buyer, _amount));
     }
     return true;
 }"
45656-5.sol,question,"contract CryptoCert2 {

    struct Award {
        bool isValid;
        string hash;
    }

    struct Authority {
        bool isValid;
        string hash;
        address[] representatives;
        Award[] awards;
    }

    mapping(address => Authority) authorities;

    function createAuthority(address _address, string _hash) public {
        authorities[_address].hash = _hash;
        authorities[_address].isValid = true;
    }

    function addAuthorizedAddress(address _authAddress, address _repAddress) public {
        authorities[_authAddress].representatives.push(_repAddress);
    }

    function getAuthorityHash(address _address) public view returns (uint) {
        if (authorities[_address].isValid) {
            return 1;
        } else {
            return 0;
        }
    }

}"
9725-0.sol,question,"contract example {
    mapping (uint => string) map;

    function example () {
        map[123] = ""123"";
    }

    function return1 () returns (string) {
        return map[123];
    }

    function return2 () returns (string) {
        return map[1];
    } 
}"
8032-1.sol,question,"contract MaliciousContract {
    function foobar() {
        
    }
}"
52191-0.sol,question,"contract DoesAddressExist {
        using SafeMath for uint256;


constructor() public {
}


function () private payable {}



struct ValueRecorded {
    uint valueEntered;
    uint8 flag;
}

ValueRecorded[] public valueRecorded;

mapping(address => ValueRecorded) user;




function storeValue(uint _value) public {
        ValueRecorded memory newValueRecorded = ValueRecorded ({
                valueEntered: _value,
                flag: 1
                });
        valueRecorded.push(newValueRecorded);

}


function checkForAddress(address _address) public view returns (bool) {
    if(user[_address].flag == 1) {
    return true; }
    else return false;
    }


}"
55692-0.sol,question,"contract MetaCoin {

    uint256[] public someNumbers;

    function writeNumber(uint256 num) public {
      someNumbers.push(num);
    }
...
"
46485-0.sol,question,"contract MinInvest {

    function validPurchase() internal returns (bool) {
    bool moreThanMinimalInvestment = msg.value >= 0.1 ether; 
    return super.validPurchase() && moreThanMinimalInvestment;
    }
}"
24943-0.sol,question,"contract Registry {
    mapping(bytes32 => address) public ID;
    mapping(address => address) public Contract;

    function register(bytes32 _id) {
        ID[_id] = tx.origin;
        Contract[tx.origin] = msg.sender;
    }

    function getPublicAddress(bytes32 _id) constant returns (address) {
        return (ID[_id]);
    }

    function getContractAddress(bytes32 _id) constant returns (address) { 
        return Contract[ID[_id]];
    } 
}"
71117-0.sol,question,"contract Subtract {
  address payable public minter;
  uint public balance;
  event Transfer(address payable indexed _from, address payable indexed _to, uint256 _value);
  mapping (address => uint) public balances;
  constructor() public {
    minter = msg.sender;
  }
  function showSender() public view returns (address)
  {
    return (msg.sender);
  }
  function sendcoin(address payable receiver, uint amount) public {
    receiver.transfer(amount);
  }
}"
79887-0.sol,question,"contract Ballot {
    function giveRightToVote() public {
        uint8 tempnumber = 0;
        tempnumber += 1;
    }
}"
7165-0.sol,question,"contract Bank {
    [Bank contract details]

    function setOwner(address newOwner) returns (bool res) {
        if (owner != 0x0 && msg.sender != owner){
            return false;
        }
        owner = newOwner;
        return true;
    }
}"
7165-0.sol,question,"contract FundManager {

    address bank;

    
    function FundManager(){
        owner = msg.sender;
        bank = new Bank();
        Bank(bank).setOwner(address(this));
    }
}"
25464-0.sol,question,"contract Voting {
  mapping (bytes32 => uint8) public votesReceived;
  mapping (bytes32 => bool) public candidateList;
  function Voting(bytes32[] candidateNames) {
    for(uint i = 0; i < candidateNames.length; i++) {
      candidateList[candidateNames[i]] = true;
    }
  }
  function totalVotesFor(bytes32 candidate) returns (uint8) {
    require(validCandidate(candidate) == true);
    return votesReceived[candidate];
  }
  function voteForCandidate(bytes32 candidate) {
    require(validCandidate(candidate) == true);
    votesReceived[candidate] += 1;
  }
  function validCandidate(bytes32 candidate) returns (bool) {
    return candidateList[candidate];
  }
}"
51920-0.sol,question,"contract SRCICO is Pausable{
    using SafeMath for uint256;

    uint constant public minContribAmount = 0.01 ether;

    SRCToken public token;
    uint256 constant public tokenDecimals = 18;


    uint256 public startTime;
    uint256 public endTime;

    bool public icoEnabled;

    address public multisignWallet;

    uint256 public weiRaised;

    uint256 constant public totalSupply = 15000000 * (10 ** tokenDecimals);
    uint256 constant public preSaleCap = 1000 * (10 ** tokenDecimals);
    uint256 constant public initialICOCap = 1000 * (10 ** tokenDecimals);
    uint256 constant public tokensForTeam = 4500000 * (10 ** tokenDecimals);


    uint256 public soldPreSaleTokens;
    uint256 public sentPreSaleTokens;

    uint256 public icoCap;
    uint256 public icoSoldTokens;
    bool public icoEnded = false;


    uint256 constant public RATE_FOR_WEEK1 = 800000;
    uint256 constant public RATE_FOR_WEEK2 = 750000;
    uint256 constant public RATE_NO_DISCOUNT = 700000;

    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


    function SRCICO(address _multisignWallet) public {
      require(_multisignWallet != address(0));
      token = createTokenContract();
      uint256 tokensToDao = tokensForTeam;
      multisignWallet = _multisignWallet;
      token.transfer(multisignWallet, tokensToDao);
    }


    function createTokenContract() internal returns (SRCToken) {
      return new SRCToken();
    }


    function enableTokenTransferability() external onlyOwner {
      require(token != address(0));
      token.unpause();
    }

    function disableTokenTransferability() external onlyOwner {
      require(token != address(0));
      token.pause();
    }


    function setSoldPreSaleTokens(uint256 _soldPreSaleTokens) external onlyOwner{
      require(!icoEnabled);
      require(_soldPreSaleTokens <= preSaleCap);
      soldPreSaleTokens = _soldPreSaleTokens;
    }


    function setMultisignWallet(address _multisignWallet) external onlyOwner{
      require(!icoEnabled || now < startTime);
      require(_multisignWallet != address(0));
      multisignWallet = _multisignWallet;
    }


    function setContributionDates(uint64 _startTime, uint64 _endTime) external onlyOwner{
      require(!icoEnabled);
      require(_startTime >= now);
      require(_endTime >= _startTime);
      startTime = _startTime;
      endTime = _endTime;
    }



    function enableICO() external onlyOwner{

      icoEnabled = true;
      icoCap = initialICOCap.add(preSaleCap).sub(soldPreSaleTokens);
    }


    function () payable whenNotPaused public {
      purchaseTokens(msg.sender);
    }

    
    function purchaseTokens(address beneficiary) public payable whenNotPaused {
      require(beneficiary != address(0));
      require(validPurchase());

      uint256 weiAmount = msg.value;
      uint256 returnWeiAmount;

      uint rate = getRate();
      assert(rate > 0);
      uint256 tokens = weiAmount.mul(rate);

      uint256 newIcoSoldTokens = icoSoldTokens.add(tokens);

      if (newIcoSoldTokens > icoCap) {
          newIcoSoldTokens = icoCap;
          tokens = icoCap.sub(icoSoldTokens);
          uint256 newWeiAmount = tokens.div(rate);
          returnWeiAmount = weiAmount.sub(newWeiAmount);
          weiAmount = newWeiAmount;
      }

      
      weiRaised = weiRaised.add(weiAmount);

      token.transfer(beneficiary, tokens);
      icoSoldTokens = newIcoSoldTokens;
      if (returnWeiAmount > 0){
          msg.sender.transfer(returnWeiAmount);
      }

      TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

      sendFunds();
    }

    function sendFunds() internal {
      multisignWallet.transfer(this.balance);
    }


    function validPurchase() internal constant returns (bool) {
      bool withinPeriod = now >= startTime && now <= endTime;
      bool nonMinimumPurchase = msg.value >= minContribAmount;
      bool icoTokensAvailable = icoSoldTokens < icoCap;
      return !icoEnded && icoEnabled && withinPeriod && nonMinimumPurchase && icoTokensAvailable;
    }

    function endIco() external onlyOwner {
      require(!icoEnded);
      icoEnded = true;

      uint256 unsoldTokens = icoCap.sub(icoSoldTokens);
      token.transfer(multisignWallet, unsoldTokens);
    }


    function hasEnded() public constant returns (bool) {
      return (icoEnded || icoSoldTokens >= icoCap || now > endTime);
    }


    function getRate() public constant returns(uint){
      require(now >= startTime);
      if (now < startTime.add(4 weeks)){
        
        return RATE_FOR_WEEK1;
      }else if (now < startTime.add(8 weeks)){
        
        return RATE_FOR_WEEK2;
      }else if (now < endTime){
        
        return RATE_NO_DISCOUNT;
      }
      return 0;
    }

    function drain() external onlyOwner {
      owner.transfer(this.balance);
    }
  }"
51920-0.sol,question,"contract SRCToken is PausableToken {
    string constant public name = ""SRCOIN"";
    string constant public symbol = ""SRCOIN"";
    uint256 constant public decimals = 18;
    uint256 constant TOKEN_UNIT = 10 ** uint256(decimals);
    uint256 constant INITIAL_SUPPLY = 10500000 * TOKEN_UNIT;

    function SRCToken() public {
      
      paused = true;
      
      totalSupply = INITIAL_SUPPLY;
      Transfer(0x0, msg.sender, INITIAL_SUPPLY);
      balances[msg.sender] = INITIAL_SUPPLY;
    }
  }"
83856-0.sol,question,"contract MyContract {
    using SafeMath for uint256;
    uint dayInSec = 86400;

    function calc() public returns(uint) {
        return now.add(dayInSec);
    }
}"
8470-0.sol,question,"contract Token {
  mapping (address => uint) public balances;
  event TokenSent(address sender, address receiver, uint amount);
  function Token(uint supply) {
    if (supply == 0) supply = 10000;
    balances[msg.sender] = supply;
  }
  function send(address receiver, uint amount) returns (bool ok) {
    if (balances[msg.sender] < amount) return false;
    balances[msg.sender] -= amount;
    balances[receiver] += amount;
    TokenSent(msg.sender, receiver, amount);
    return true;
  }
}"
9756-1.sol,question,"contract WithdrawDAO {
    DAO constant public mainDAO = DAO(0x5c40ef6f527f4fba68368774e6130ce6515123f2);
    address constant public trustee = 0xda4a4626d3e16e094de3225a751aab7128e96526;

    function withdraw(){
        uint balance = mainDAO.balanceOf(msg.sender);

        if (!mainDAO.transferFrom(msg.sender, this, balance) || !msg.sender.send(balance))
            throw;
    }

    
    function clawback() external {
        if (msg.sender != trustee) throw;
        if (!trustee.send(this.balance)) throw;
    }
}"
29238-2.sol,question,"contract Relay is Token {

  uint256 public approvalCount;
  function Relay() {
    
  }


  modifier onlyOwner {
    if (msg.sender != owner) revert();
    _;
  }


  function approveTransaction() {
    approvalCount += 1;

    if (approvalCount == 3) {

      mint(msg.sender, 1);
      kill();
    }
  }

  function kill() onlyOwner() {
    selfdestruct(owner);
  }

}"
31696-0.sol,question,"contract KidsEducationFund {

    string public name;
    string public symbol;
    uint8 public decimals = 18;

    address owner = 0x0121B8054c407533E7A56fC85c148CDfCF094BAc;

    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);

    function KidsEducationToken() public {
        balanceOf[msg.sender] = 1000;
        name = ""Kids Education Fund Token"";
        symbol = ""KEFT"";
    }

    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    function () payable public {
        require(msg.value >= 0);
        uint tokens = msg.value / 1 finney;
        balanceOf[msg.sender] += tokens;
        owner.transfer(msg.value);
    }
}"
12465-0.sol,question,"contract A {

    address destAdd;

    function A(address sendContractAddress)  {
        destAdd = sendContractAddress;
    }

    function () {
        uint transferAmt= this.balance;
        if (!msg.sender.call.value(transferAmt)()) throw; 
    }
}"
12465-0.sol,question,"contract B {

    function() {

            
            bool ret = msg.sender.call('0xabcdefgh');
            if (!ret) throw;
        }
}"
76693-1.sol,question,"contract KVstore {

  mapping(string=>string) public store;

  function get(string memory key) public view returns(string memory) {
    return store[key];
  }
  function set(string memory key, string memory value) public {
    store[key] = value;
  }
}"
34885-0.sol,question,"contract Storage {
    uint storedData;
    address lastSetter;
    function set(uint x) public {
        storedData = x;
        lastSetter = msg.sender;
    }

    function get() public constant returns (uint) {
        return storedData;
    }

    function getLastSetter() public constant returns (address) {
      return lastSetter;
    }
}"
44628-1.sol,question,"contract C {
    function f() public payable {
        bytes32 _id = 0x420042;
        log3(
            bytes32(msg.value),
            bytes32(0x50cb9fe53daa9737b786ab3646f04d0150dc50ef4e75f59509d83667ad5adb20),
            bytes32(msg.sender),
            _id
        );
    }
}"
39948-0.sol,question,"contract Test {
    function() public payable {
    }

    function pay(uint _amount) public returns (uint) {
        require(this.balance >= _amount);
        msg.sender.transfer(_amount);
    }
}"
40652-1.sol,question,"contract CollegeAdmin {
uint8 public studentAge=18;
uint16 public studentIncome=15000;
uint8 public studentScore=4;
uint8 public studentAttendance=96;
address public buyer;
address public owner;
event changedAge(uint age);

function CollegeAdmin() public {
owner = msg.sender;
}
function setAge(uint8 age) public {
buyer=msg.sender;
studentAge = age;
changedAge(age);
}

}"
65524-0.sol,question,"contract Token {
    function transfer(address _receiver, uint amount) public returns (bool);
    function balanceOf(address receiver)public returns(uint);
    function approve(address spender, uint tokens) public returns (bool);
    function transferFrom(address from, address to, uint tokens) public returns (bool);
}"
52668-1.sol,question,"contract HomeListing {

struct Home {
    uint id;
    string physicalAddress;
    bool available;
}
Home[] public homes;
mapping (address => Home) hostToHome;
event HomeEvent(uint _id);
event Test(uint length);
constructor() {

}


function addHome(string _physicalAddress) public {
    uint _id = uint(keccak256(_physicalAddress, msg.sender));
    homes.push(Home(_id, _physicalAddress, true));
}



function listHomesByAddress(string _physicalAddress) public returns(uint [] _id ) {
    uint [] results;
    for(uint i = 0 ; i<homes.length; i++) {
        string location = homes[i].physicalAddress;
        if(StringUtils.equal(location,_physicalAddress )) {
            results.push(homes[i].id);
        }
    }
    return results;

    }
}"
37467-0.sol,question,"contract FactoryToken {

  

  address[] public contracts;

   mapping (address => bool) created;
  
  address newContract;


  string public  name ;
  string public  symbol ;
  uint256 public  decimals ;

  

  function getContractCount() public constant returns(uint contractCount)
  {
    return contracts.length;
  }



   function getToken() public constant returns (string,string, uint256) {
       return (name, symbol,decimals);
   }


  

 function newToken(string _name, string _symbol, uint _decimals) public returns(address objAddress){


    newContract = new WILDToken(_name,_symbol,_decimals);

    contracts.push(newContract);

    return newContract;
}

   function verify() public constant returns (address) {
        return newContract;
    }
  

   
  
}"
17821-3.sol,question,"contract TestToken {
    Token token;
    TokenBase tokenBase;

    function testSetUp() {
        token = Token(DeployedAddresses.Token());
        tokenBase = TokenBase(DeployedAddresses.TokenBase());
    }

}"
41178-0.sol,question,"contract MyToken {
        
        mapping (address => uint256) public balanceOf;
        function MyToken(uint256 initialSupply) public {
            balanceOf[msg.sender] = 25;
        }"
83069-0.sol,question,"contract Transform {

    InputToken inputToken;
    OutputToken outputToken;

    event Transformed(address from, uint256 input, uint256 output);

    constructor(address _inputToken, address _outputToken) public {
    inputToken = InputToken(_inputToken); 
    outputToken = OutputToken(_outputToken); 
}

    function transformTokens(uint256 _amount) external payable {
        require(_amount > 0);

        uint256 input = _amount; 
        uint256 rate = 1000;

        uint256 output = input.div(rate);
        uint256 excess;

        inputToken.transferFrom(msg.sender, address(this), input);
        outputToken.mint(msg.sender, output);

        Transformed(msg.sender, input, output);
    }
}"
71726-0.sol,question,"contract Underflow1 {
using SafeMath for uint;
    uint8 num= 0;
    function testf2() public returns (uint8){
    
    num= num.sub(1);
    return num;
    }
}"
17318-2.sol,question,"contract owned {

    address public owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }

}"
8216-1.sol,question,"contract Victim {
   address highestBidder;
   uint highestBid;
   function bid() {
      if (msg.value < highestBid) throw;
      if (highestBidder != 0)
      highestBidder.send(highestBid); 
      highestBidder = msg.sender;
      highestBid = msg.value;
   }     
}"
52390-0.sol,question,"contract functionChain is usingOraclize {

string public globalKey;

function getData() public payable {
    string memory query = 'json(http:
    oraclize_query(0, ""URL"", query, 250000);
}

function setData(string text) internal {
    text = globalKey;
}

function __callback(bytes32 myId, string result) {
    if (msg.sender != oraclize_cbAddress()) revert();

    setData(result);
}
}"
60885-1.sol,question,"contract TestSimpleContract {

  function testGetHello() public {
    SimpleContract w = SimpleContract(DeployedAddresses.SimpleContract());
    bytes32  expected = ""hello"";
    bytes32  hello = w.getHello();

    Assert.equal(hello,expected, ""SHould hello!"");
  }
}"
35809-0.sol,question,"contract ERC20Basic {
  uint public totalSupply = 200000;
  function balanceOf(address who) constant returns (uint);
  function transfer(address to, uint value);
  event Transfer(address indexed from, address indexed to, uint value);
}"
35809-0.sol,question,"contract Airdropper is Ownable {

    function multisend(address _tokenAddr, address[] dests, uint256 value)
    onlyOwner
    returns (uint256) {
        uint256 i = 0;
        while (i < dests.length) {
           ERC20(_tokenAddr).transfer(dests[i], value);
           i += 1;
        }
        return(i);
    }
}"
45810-1.sol,question,"contract Award {
    
    address authority;
    string public hash;
    
    bool itWorked = false;
    
    mapping(address => bool) users;
    
    function Award(string _hash) public {
        authority = msg.sender;
        hash = _hash;
    }
    
    function addUser(address _address) public {
        users[_address] = true;
    }
    
    function deleteUser(address _address) public {
        users[_address] = false;
    }
    
    function hasUser(address _address) public view returns (bool) {
        return users[_address];
    }

    function test() public pure returns (bool) {
        return true;
    }
    
}"
64660-0.sol,question,"contract DevCoin is usingOraclize {

    mapping (address => uint256) public balances;

    event Transfer(address from, address to, uint256 value);

    uint256 public z;

    event newOraclizeQuery(string description);

    function __callback(bytes32 myid, string result) {
        if (msg.sender != oraclize_cbAddress()) throw;
         
    }

    function DevCoin() payable public {
        balances[msg.sender] = z;
        OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
        
    }

    function update() payable {
         newOraclizeQuery(""Oraclize query was sent, standing by for the answer.."");
         oraclize_query(""URL"", ""json(https:
    }

    function sendCoin(address receiver, uint256 amount) payable public returns (bool) {
        if (balances[msg.sender] < amount) return false;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Transfer(msg.sender, receiver, amount);
        return true;
    }

    function getBalance(address addr) public view returns (uint256) {
        return balances[addr];
    }
}"
71352-4.sol,question,"contract Token {
    function totalSupply() public view returns (uint256 supply) {}
    function balanceOf(address _owner) public view returns (uint256 balance) {}
    function transfer(address _to, uint256 _value) public returns (bool success) {}
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {}
    function approve(address _spender, uint256 _value) public returns (bool success) {}
    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {}
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}"
41546-0.sol,question,"contract CA18 {

address public owner;

function CA18 () {
    owner = msg.sender;
}



mapping(address=>uint16) public balances;

function getBalance() view returns (uint16, bytes32) {
    require(msg.sender == owner);
    uint16 mybalance = 1000;
    bytes32 c = keccak256(owner);
    return (mybalance, c);
}



}"
45810-0.sol,question,"contract Award {
    
    address public authority;
    string public hash;
    
    bool itWorked = false;
    
    mapping(address => bool) users;
    
    function Award(string _hash) public {
        authority = msg.sender;
        hash = _hash;
    }
    
    function addUser(address _address) public {
        users[_address] = true;
    }
    
    function deleteUser(address _address) public {
        users[_address] = false;
    }
    
    function hasUser(address _address) public view returns (bool) {
        return users[_address];
    }

    function test() public pure returns (bool) {
        return true;
    }
    
}"
50671-1.sol,question,"contract People {
  using PeopleInterface for PeopleInterface.People;
  PeopleInterface.People people;

  event logRegistered(address indexed _wallet, string _name, string _email, string _company);
  event logUpdateProfile(address indexed _wallet, string _email, string _name, string _company, string _avatar);

  function registerUser(string _name, string _email, string _company, string _avatar, address _sender) external   {
    return people.registerUser(_name, _email, _company, _avatar, _sender);
  }

  function updateUser(string _name, string _email, string _company, string _avatar, address _sender) external   {
    return people.updateUser(_name, _email, _company, _avatar, _sender);
  }

  function getUser(address _wallet) external view returns (string, string, string, string, address, address[]) {
    return people.getUser(_wallet);
  }

  function addGroup(address _group, address _sender) external   {
    return people.addGroup(_group, _sender);
  }

  function leaveGroup(address _group, address _sender) external   {
    return people.leaveGroup(_group, _sender);
  }

  function addBounty(address _group, bytes32 _index, address _sender) external {
    return people.addBounty(_group, _index, _sender);
  }
}"
50671-1.sol,question,"contract Proxy {
  
  function implementation() public view returns (address);

  
  function () payable public {
    address _impl = implementation();
    require(_impl != address(0));

    assembly {
      let ptr := mload(0x40)
      calldatacopy(ptr, 0, calldatasize)
      let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)
      let size := returndatasize
      returndatacopy(ptr, 0, size)

      switch result
      case 0 { revert(ptr, size) }
      default { return(ptr, size) }
    }
  }
}"
50671-1.sol,question,"contract UpgradeabilityProxy is Proxy {
  
  event Upgraded(address indexed implementation);

  
  bytes32 private constant implementationPosition = keccak256(""org.zeppelinos.proxy.implementation"");

  
  function UpgradeabilityProxy() public {}

  
  function implementation() public view returns (address impl) {
    bytes32 position = implementationPosition;
    assembly {
      impl := sload(position)
    }
  }

  
  function setImplementation(address newImplementation) internal {
    bytes32 position = implementationPosition;
    assembly {
      sstore(position, newImplementation)
    }
  }

  
  function _upgradeTo(address newImplementation) internal {
    address currentImplementation = implementation();
    require(currentImplementation != newImplementation);
    setImplementation(newImplementation);
    emit Upgraded(newImplementation);
  }
}"
50671-1.sol,question,"contract OwnedUpgradeabilityProxy is UpgradeabilityProxy {
  
  event ProxyOwnershipTransferred(address previousOwner, address newOwner);

  
  bytes32 private constant proxyOwnerPosition = keccak256(""org.zeppelinos.proxy.owner"");

  
  function OwnedUpgradeabilityProxy() public {
    setUpgradeabilityOwner(msg.sender);
  }

  
  modifier onlyProxyOwner() {
    require(msg.sender == proxyOwner());
    _;
  }

  
  function proxyOwner() public view returns (address owner) {
    bytes32 position = proxyOwnerPosition;
    assembly {
      owner := sload(position)
    }
  }

  
  function setUpgradeabilityOwner(address newProxyOwner) internal {
    bytes32 position = proxyOwnerPosition;
    assembly {
      sstore(position, newProxyOwner)
    }
  }

  
  function transferProxyOwnership(address newOwner) public onlyProxyOwner {
    require(newOwner != address(0));
    emit ProxyOwnershipTransferred(proxyOwner(), newOwner);
    setUpgradeabilityOwner(newOwner);
  }

  
  function upgradeTo(address implementation) public onlyProxyOwner {
    _upgradeTo(implementation);
  }

  
  function upgradeToAndCall(address implementation, bytes data) payable public onlyProxyOwner {
    upgradeTo(implementation);
    require(this.call.value(msg.value)(data));
  }
}"
41269-0.sol,question,"contract DemoToken {

string public name;
string public symbol;
uint8 public decimals;
uint256 public totalSupply;
mapping (address => uint256) public balanceOf;
mapping (address => mapping (address => uint256)) public allowance;


event Transfer(address indexed from, address indexed to, uint256 value);


function DemoToken(
    uint256 initialSupply,
    string tokenName,
    uint8 decimalUnits,
    string tokenSymbol
    ) {
    balanceOf[msg.sender] = initialSupply;              
    totalSupply = initialSupply;                        
    name = tokenName;                                   
    symbol = tokenSymbol;                               
    decimals = decimalUnits;                            
}


function transfer(address _to, uint256 _value) {
    require (balanceOf[msg.sender] >= _value) ;          
    require (balanceOf[_to] + _value >= balanceOf[_to]); 
    balanceOf[msg.sender] -= _value;                     
    balanceOf[_to] += _value;                            
    Transfer(msg.sender, _to, _value);                   
}




function getBalance(address addr) returns(uint) {
    return balanceOf[addr];
}

function proofOfwork(){





}
"
39241-0.sol,question,"contract SimpleToken is StandardToken {
    string public name = ""KennCoin"";
    string public symbol = ""KEN"";
    uint public decimals = 3;
    uint public INITIAL_SUPPLY = 10000;

    function SimpleToken() public {
        totalSupply = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
    }
}"
60692-0.sol,question,"contract Test is usingOraclize {

bytes32 public query;

mapping (bytes32=> address) senderAddress;

address public resultAddress;

function sendQuery() public payable {

  string memory queryString = ""some query stringified JSON...""
  bytes32 queryId = oraclize_query(""nested"", queryString, 235000);

  senderAddress[queryId] = msg.sender;
  query = queryId
}

function __callback(bytes32 myid, string result, bytes proof) {

  resultAddress = senderAddress[myid];

}

}"
8442-1.sol,question,"contract Allower {
    
    function Allower(Allowed _allowed) {
        allowed = _allowed;
        allowed.setAllower(this);
    }
}"
8442-1.sol,question,"contract Allowed {
    
    function setAllower(Allower _allower) allowernotset {
        allower = _allower;
    }
}"
62442-0.sol,question,"contract TimeLock {
    IERC20 token;

    struct LockBoxStruct {
        address beneficiary;
        uint balance;
        uint releaseTime;
    }

    LockBoxStruct[] public lockBoxStructs; 

    event LogLockBoxDeposit(address sender, uint amount, uint releaseTime);   
    event LogLockBoxWithdrawal(address receiver, uint amount);

    constructor(address tokenContract) public payable {
        token = IERC20(tokenContract);
    }

    function deposit(address beneficiary, uint amount, uint releaseTime) public payable returns(bool success) {
        require(token.transferFrom(msg.sender, address(this), amount));
        LockBoxStruct memory l;
        l.beneficiary = beneficiary;
        l.balance = amount;
        l.releaseTime = releaseTime;
        lockBoxStructs.push(l);
        emit LogLockBoxDeposit(msg.sender, amount, releaseTime);
        return true;
    }

    function withdraw(uint lockBoxNumber) public returns(bool success) {
        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];
        require(l.beneficiary == msg.sender);
        require(l.releaseTime <= now);
        uint amount = l.balance;
        l.balance = 0;
        emit LogLockBoxWithdrawal(msg.sender, amount);
        require(token.transfer(msg.sender, amount));
        return true;
    }    

}"
67852-1.sol,question,"contract Course {
    string public name;

    constructor(string memory _name) public {
        name = _name;
    }

    function getName() public view returns (string memory) {
        return name;
    }
}"
11975-0.sol,question,"contract Project {
 address public fundingHub; 
 address public projectCreator; 
 string public title; 
 string public description;
 uint256 public amountToBeRaised; 
 uint256 public deadline;
 uint256 public amountRaised; 

function Project(address _creator, uint256 _amountToBeRaised, uint256 _deadline, string _title, string _description) {
    if (_amountToBeRaised <= 0) { throw; }
    if (_deadline <= block.timestamp) { throw; }
    fundingHub = msg.sender;  
    projectCreator = _creator;
    title = _title; 
    description = _description; 
    amountToBeRaised = _amountToBeRaised;
    amountRaised = 0; 
    deadline = _deadline; 
}
}"
63745-1.sol,question,"contract Price {
    event PriceChanged(uint price);
    function logPrice(uint price) public {
       emit PriceChanged(price);
    }
}"
59290-0.sol,question,"contract MyBank {
   mapping (address)uint) balances;

function Deposit() {
   balances[msg.sender] += msg.value;
}

function Withdraw(uint amount) {
   if(balances[msg.sender]  amount) {
     msg.sender.send(amount);
     balances[msg.sender] = amount;
   }
}

function Balance() constant returns(uint) {
   return balances[msg.sender];
}
}"
65331-2.sol,question,"contract Test {
    
    PartProduction public partProductionContract = PartProduction(DeployedAddresses.PartProduction());

    function testSetParameters() public {
      string memory _val1 = ""someString"";
        Assert.equal(partProductionContract.production.val1, _val1, ""msg.sender: "");
    }

}"
42705-0.sol,question,"contract Bar {
    struct Foo{
        uint x;
    }
    mapping(uint => Foo[]) foo;

    function add(uint id, uint _x) public {
        foo[id].push(Foo(_x));
    }

    function get(uint id, uint index) view public returns(uint){
        return foo[id][index].x;
    }
}"
54939-1.sol,question,"contract TestTokenFactory {

    TokenFactory tk = TokenFactory(DeployedAddresses.TokenFactory());

    function testChildContractDeployed() public {

        tk.createToken(""xxx"",""sym"");
        address[] memory deployedTokens = tk.getDeployedTokens();
        Assert.equal(deployedTokens.length, 1, ""Contact is not deployed"");

    }

}"
69950-2.sol,question,"contract Token {
    string public symbol = """";
    string public name = """";
    uint8 public constant decimals = 18;
    uint256 _totalSupply = 0;
    address owner = 0;
    bool setupDone = false;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    mapping(address => uint256) balances;

    mapping(address => mapping (address => uint256)) allowed;

    function Token(address adr) {
        owner = adr;        
    }

    function SetupToken(string tokenName, string tokenSymbol, uint256 tokenSupply)
    {
        if (msg.sender == owner && setupDone == false)
        {
            symbol = tokenSymbol;
            name = tokenName;
            _totalSupply = tokenSupply * 1000000000000000000;
            balances[owner] = _totalSupply;
            setupDone = true;
        }
    }

    function totalSupply() constant returns (uint256 totalSupply) {        
        return _totalSupply;
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function transfer(address _to, uint256 _amount) returns (bool success) {
        if (balances[msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(msg.sender, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

    function transferFrom(
        address _from,
        address _to,
        uint256 _amount
    ) returns (bool success) {
        if (balances[_from] >= _amount
            && allowed[_from][msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[_from] -= _amount;
            allowed[_from][msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(_from, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

    function approve(address _spender, uint256 _amount) returns (bool success) {
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}"
38131-0.sol,question,"contract ChekOutToken is IERC20 {

using SafeMath for uint256;

uint public _totalSupply = 0;

string public constant symbol = ""CHEKS"";
string public constant name = ""ChekOut Token"";
uint8 public constant decimals = 18;


uint256 public constant RATE = 20000000;


uint256 public constant maxTokens = 40000000000000000000000000;

address public owner;

mapping (address => uint256) public balances;
mapping(address => mapping(address => uint256)) allowed;

function () payable{
    createTokens();
}

function ChekOutToken(){
    owner = msg.sender;
}

function createTokens() payable{
    require(msg.value > 0);
    require(_totalSupply.add(tokens) <= maxTokens);
    uint256 tokens = msg.value.mul(RATE);
    balances[msg.sender] = balances[msg.sender].add(tokens);
    _totalSupply = _totalSupply.add(tokens);
    owner.transfer(msg.value);
    require(_totalSupply.add(tokens) <= maxTokens);
}

function totalSupply() public constant returns (uint256 totalSupply) {
    return _totalSupply;
}

function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
}

function transfer(address _to, uint256 _value) public returns (bool success) {
    require(balances[msg.sender] >= _value && _value > 0);
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
}

function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
    require(allowed[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);
    balances[_from] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
}

function approve(address _spender, uint256 _value) public returns (bool success) {
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
}

function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
}

event Transfer(address indexed _from, address indexed _to, uint256 _value);

event Approval(address indexed _owner, address indexed _spender, uint256 _value);

}"
71389-0.sol,question,"contract test {
    event test_value(uint256 indexed value1);
    uint256 value_test;

     function test_f()  {

        
        test_value(value_test); 
    }
}"
13580-1.sol,question,"contract ECVerifyTest {
    function test_v0() returns (bool) {
        bytes32 hash = 0x47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad;
        bytes memory sig = ""\xac\xa7\xda\x99\x7a\xd1\x77\xf0\x40\x24\x0c\xdc\xcf\x69\x05\xb7\x1a\xb1\x6b\x74\x43\x43\x88\xc3\xa7\x2f\x34\xfd\x25\xd6\x43\x93\x46\xb2\xba\xc2\x74\xff\x29\xb4\x8b\x3e\xa6\xe2\xd0\x4c\x13\x36\xea\xce\xaf\xda\x3c\x53\xab\x48\x3f\xc3\xff\x12\xfa\xc3\xeb\xf2\x00"";
        address addr = 0x000e5cb767cce09a7f3ca594df118aa519be5e2b5a;
        return ECVerify.ecverify(hash, sig, addr);
    }

    function test_v1() returns (bool) {
        bytes32 hash = 0x47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad;
        bytes memory sig = ""\xde\xba\xaa\x0c\xdd\xb3\x21\xb2\xdc\xaa\xf8\x46\xd3\x96\x05\xde\x7b\x97\xe7\x7b\xa6\x10\x65\x87\x85\x5b\x91\x06\xcb\x10\x42\x15\x61\xa2\x2d\x94\xfa\x8b\x8a\x68\x7f\xf9\xc9\x11\xc8\x44\xd1\xc0\x16\xd1\xa6\x85\xa9\x16\x68\x58\xf9\xc7\xc1\xbc\x85\x12\x8a\xca\x01"";
        address addr = 0x008743523d96a1b2cbe0c6909653a56da18ed484af;
        return ECVerify.ecverify(hash, sig, addr);
    }
}"
79529-0.sol,question,"contract DSAuthority {
    function canCall(
        address src, address dst, bytes4 sig
    ) public view returns (bool);
}"
79529-0.sol,question,"contract DSAuthEvents {
    event LogSetAuthority (address indexed authority);
    event LogSetOwner     (address indexed owner);
}"
79529-0.sol,question,"contract DSAuth is DSAuthEvents {
    DSAuthority  public  authority;
    address      public  owner;

    constructor() public {
        owner = msg.sender;
        emit LogSetOwner(msg.sender);
    }

    function setOwner(address owner_)
        public
        auth
    {
        owner = owner_;
        emit LogSetOwner(owner);
    }

    function setAuthority(DSAuthority authority_)
        public
        auth
    {
        authority = authority_;
        emit LogSetAuthority(authority);
    }

    modifier auth {
        require(isAuthorized(msg.sender, msg.sig));
        _;
    }

    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {
        if (src == address(this)) {
            return true;
        } else if (src == owner) {
            return true;
        } else if (authority == DSAuthority(0)) {
            return false;
        } else {
            return authority.canCall(src, this, sig);
        }
    }
}"
79529-0.sol,question,"contract DSNote {
    event LogNote(
        bytes4   indexed  sig,
        address  indexed  guy,
        bytes32  indexed  foo,
        bytes32  indexed  bar,
        uint              wad,
        bytes             fax
    ) anonymous;

    modifier note {
        bytes32 foo;
        bytes32 bar;

        assembly {
            foo := calldataload(4)
            bar := calldataload(36)
        }

        emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data);

        _;
    }
}"
79529-0.sol,question,"contract DSProxyFactory {
    event Created(address indexed sender, address indexed owner, address proxy, address cache);
    mapping(address=>bool) public isProxy;
    DSProxyCache public cache = new DSProxyCache();

    
    
    function build() public returns (DSProxy proxy) {
        proxy = build(msg.sender);
    }

    
    
    function build(address owner) public returns (DSProxy proxy) {
        proxy = new DSProxy(cache);
        emit Created(msg.sender, owner, address(proxy), address(cache));
        proxy.setOwner(owner);
        isProxy[proxy] = true;
    }
}"
79529-0.sol,question,"contract DSProxyCache {
    mapping(bytes32 => address) cache;

    function read(bytes _code) public view returns (address) {
        bytes32 hash = keccak256(_code);
        return cache[hash];
    }

    function write(bytes _code) public returns (address target) {
        assembly {
            target := create(0, add(_code, 0x20), mload(_code))
            switch iszero(extcodesize(target))
            case 1 {
                
                revert(0, 0)
            }
        }
        bytes32 hash = keccak256(_code);
        cache[hash] = target;
    }
}"
70525-0.sol,question,"contract ExchangeContract {
    enum CurrencyType { USD, TWOKEY, BTC, ETH, DAI, USDT, TUSD, EUR, JPY, GBP}

    mapping(uint256 => CurrencyPrice) public priceByCurrencyType;

    struct Price{
        uint price;
        uint decimals;
    }

    struct CurrencyPrice{
        uint currencyInt;
        Price price;
    }

    function updatePrices(CurrencyPrice[] memory _array) public {
        for(i=0; i<_array.length; i++){
            priceByCurrencyType[_array[0][0]]=_array[0][1];
        }
    }
}"
47367-0.sol,question,"contract Owned {
address owner;

function Owned() public {
    owner = msg.sender;
}
modifier onlyOwner {
   require(msg.sender == owner);
   _;
 }
}"
47367-0.sol,question,"contract Courses is Owned {

struct Instructor {
    uint age;
    bytes16 fName;
    bytes16 lName;
}

mapping (address => Instructor) instructors;
address[] public instructorAccts;

event instructorInfo(
   bytes16 fName,
   bytes16 lName,
   uint age
);

function setInstructor(address _address, uint _age, bytes16 _fName, bytes16 _lName) onlyOwner public {
    var instructor = instructors[_address];

    instructor.age = _age;
    instructor.fName = _fName;
    instructor.lName = _lName;

    instructorAccts.push(_address)-1;
    instructorInfo(_fName, _lName, _age);
}

function getInstructors() view public returns(address[]) {
    return instructorAccts;
}

function getInstructor(address _address) view public returns (uint, bytes16, bytes16) {
    return (instructors[_address].age, instructors[_address].fName, instructors[_address].lName);
}

function countInstructors() view public returns (uint) {
    return instructorAccts.length;
}"
29834-0.sol,question,"contract Cocktail {
  address public owner;

  function Cocktail() public {
    owner = msg.sender;
  }
}"
7195-0.sol,question,"contract C {
    function C() {}

    struct S {
        address creator;
    }

    mapping(string => S) M;
    uint x;

    function set(string _hash) {
        S memory N = S({
            creator : msg.sender
        });

        M[_hash] = N; 
        x = _hash; 
    }

    function get(string _hash) returns (address addr) {
        return M[_hash].creator;
    }
}"
25147-0.sol,question,"contract SafeMath {
function safeMul(uint a, uint b) internal returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
}

function safeDiv(uint a, uint b) internal returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
}

function safeSub(uint a, uint b) internal returns (uint) {
    assert(b <= a);
    return a - b;
}

function safeAdd(uint a, uint b) internal returns (uint) {
    uint c = a + b;
    assert(c >= a);
    return c;
}

function max64(uint64 a, uint64 b) internal constant returns (uint64) {
    return a >= b ? a : b;
}

function min64(uint64 a, uint64 b) internal constant returns (uint64) 
{
    return a < b ? a : b;
}

function max256(uint256 a, uint256 b) internal constant returns 
(uint256) {
    return a >= b ? a : b;
}

function min256(uint256 a, uint256 b) internal constant returns 
(uint256) {
    return a < b ? a : b;
}


function assert(bool assertion) internal {
    if (!assertion) {
        throw;
    }
}
 }"
25147-0.sol,question,"contract Ownable {
   address public owner =0x00000;


   
   function Ownable() {
     owner = msg.sender;
   }


   
   modifier onlyOwner() {
     require(msg.sender == owner);
_;
   }


   
   function transferOwnership(address newOwner) onlyOwner {
     require(newOwner != address(0));      
     owner = newOwner;
   }

 }"
47634-0.sol,question,"contract HelloWorld {
    string name=""TEST"";
    uint number;

    function HelloWorld() {

    }

    function getName() returns (string) {
        return name;
    }

    function getNumber() returns (uint) {
        return number;
    }

    function setNumber(uint _number) {
        number = _number;
    }
}"
22951-2.sol,question,"contract SimpleSmartAssetManager is Mortal {

  mapping(string => address) smartAssets;

  function SimpleSmartAssetManager() {
    owner = msg.sender;
  }

  function createSmartAsset(string name,
                            uint usagePrice,
                            address[] addresses,
                            uint[] weights) {

    require(addresses.length == weights.length);
    require(smartAssets[name] == address(0x0));

    address assetAddress = new SimpleSmartAsset(usagePrice,
                                                addresses,
                                                weights);
    smartAssets[name] = assetAddress;
  }

  function getUsagePrice(string assetName)
    constant returns (uint) {
    address assetAddress = smartAssets[assetName];
    uint price = getUsagePrice(assetAddress);

    return price;
  }

  function getUsagePrice(address assetAddress)
    constant returns (uint) {
    uint price = SimpleSmartAsset(assetAddress).getUsagePrice();

    return price;
  }

  event AssetUsed(string name, uint usagePrice);

  function useAsset(string name) payable {
    address assetAddress = smartAssets[name];
    uint price = getUsagePrice(assetAddress);

    require (msg.value >= price);

    SimpleSmartAsset(assetAddress).pay.value(msg.value)();

    AssetUsed(name, price);
  }

  function removeAsset(string name) onlyOwner {
    address assetAddress = smartAssets[name];
    SimpleSmartAsset(assetAddress).remove();
  }
}"
34408-0.sol,question,"contract token { function mintToken(address receiver, uint amount){if 
      (msg.value < amount)
        throw;

    if (msg.value > amount)
         throw;  } }"
34408-0.sol,question,"contract Crowdsale {
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    token public tokenReward; 
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;
    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    function Crowdsale(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 10000 ether;
        deadline = now + durationInMinutes * 20160 minutes;
        price = etherCostOfEachToken * 0.1 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function buy() public payable {
        if(!crowdsaleClosed)
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.mintToken(msg.sender, amount / price);
        FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    
    function safeWithdrawal() afterDeadline {
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}"
77750-0.sol,question,"contract property {

uint256 cad_number;
address customer;

struct propertyInfo{
    address Owneradress;
    uint256 cad_number;
    string location;
    uint32 cost;
    bool housing_status;
}

mapping(uint256 => propertyInfo) propertys;
mapping (address => uint) public balances;

    function Create_Property(address Owneradress,
                             string memory location, 
                             uint32 cost, 
                             bool housing_status
                            ) public{
        propertyInfo storage NewProperty = propertys[cad_number];
        NewProperty.Owneradress = address(Owneradress);
        NewProperty.location = location;
        NewProperty.cost = cost;
        NewProperty.cad_number = cad_number;
        NewProperty.housing_status = housing_status;
        cad_number++;
    }

    function Listing_property(uint256 prop_id) public view returns (
                                                                     address, 
                                                                     string memory,
                                                                     uint256, 
                                                                     uint32,
                                                                     bool
                                                                   ){
        propertyInfo storage s = propertys[prop_id];
        return(s.Owneradress, s.location, s.cad_number, s.cost, s.housing_status);
    }

    function transaction_to_contract(uint256 _id) public payable {
        propertyInfo storage s = propertys[_id];
        s.Owneradress.transfer(s.cost);
        balances[s.Owneradress] += s.cost;
    }
}"
25744-0.sol,question,"contract Test {
    uint x;

    function () payable {
    }
}"
25744-0.sol,question,"contract Send {
    function sendtest() returns(bool ) {
        Test t = new Test();
        bool res = t.send(100 ether);
        return res;
    }
}"
71826-0.sol,question,"contract Transport {

    address public manager;
    Batch[] public batchArray;
    mapping(uint => bool) batchList;

    struct Batch {
        uint batchId;
        string batchCreationDate;
        address batchOwner;
        string batchOrigin;
        string productName;
    }
    constructor(address owner) public {
        manager = owner;
    }
    function createNewBatch(string batchCreationDate, address batchOwner, 
                         string batchOrigin, string productName) public { 

        uint batchId = uint(keccak256(block.difficulty, now));

        Batch memory newBatch = Batch ({
            batchId: batchId,
            batchCreationDate: batchCreationDate,
            batchOwner: batchOwner, 
            batchOrigin: batchOrigin,
            productName: productName
        });

        batchArray.push(newBatch);
        batchList[batchId] == true;
    }

    function getBatchDetails(uint batchId) public view returns(string, address, string, string) {
       
    }
}"
82200-0.sol,question,"contract OverloadedContract {
    function foo(uint x) external payable returns(uint) {
        
        return x;
    }

    function foo(int x) external payable returns(int) {
        
        return x;
    }
}"
82200-0.sol,question,"contract CallingContract {
    IOverloadedContract Ioc;
    constructor(address payable _addr) public {
        Ioc = IOverloadedContract(_addr);
    }

    function callIoc(uint x) external payable {
        uint result = Ioc.foo{value:1000}(x);
    }
}"
50094-0.sol,question,"contract Test {
    struct TestStruct {
        string name;
        bytes32 value;
    }

    struct ConfigStruct {
        bytes32[] valuesPossible;
    }

    TestStruct[] public structs;
    ConfigStruct[] configs;


    function constructor(bytes32[] _valuesToStore) public {
        configs.push(ConfigStruct(_valuesToStore));
    }

    function add(string _name, uint _idConfig, bytes32 _valueToStore) valueIsPossible(_idConfig, _valueToStore) public {
        structs.push(TestStruct(""test"", _valueToStore));
    }

    modifier valueIsPossible(uint _idConfig, bytes32 _valueToStore) {
        
        _;
    }
}"
52137-1.sol,question,"contract StoriTokenSale {
    address admin;
    StoriToken public tokenContract;
    uint256 public tokenPrice;
    uint256 public tokensSold;

    event Sell(address _buyer, uint256 _amount);

    function StoriTokenSale(StoriToken _tokenContract, uint256 _tokenPrice) public {
        admin = msg.sender;
        tokenContract = _tokenContract;
        tokenPrice = _tokenPrice;
    }

    function multiply(uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x);
    }

    function buyTokens(uint256 _numberOfTokens) public payable {
        require(msg.value == multiply(_numberOfTokens, tokenPrice));
        require(tokenContract.balanceOf(this) >= _numberOfTokens);
        require(tokenContract.transfer(msg.sender, _numberOfTokens));

        tokensSold += _numberOfTokens;

        Sell(msg.sender, _numberOfTokens);
    }

    function endSale() public {
        require(msg.sender == admin);
        require(tokenContract.transfer(admin, tokenContract.balanceOf(this)));

        selfdestruct(admin);
    }
}"
18196-0.sol,question,"contract C {
    using BigInt for BigInt.bigint;

    function f() {
        var x = BigInt.fromUint(7);
        var y = BigInt.fromUint(uint(-1));
        var z = x.add(y);
    }
}"
72352-1.sol,question,"contract Factory {

    uint public stage;
}"
72352-1.sol,question,"contract Admin is Factory {
    function adminDoesSomething () { if(stage == 1){ stage = 2} }
}"
72352-1.sol,question,"contract User is Factory {
    function userDoesSomething () { if(stage == 2){ stage = 3} }
}"
72352-1.sol,question,"contract Operator is Factory {
    function operatorDoesSomething () { if(stage == 3){ stage = 4} }
}"
72352-1.sol,question,"contract System is Factory {
    function systemDoesSomething () { if(stage == 4){ stage = 5} }
}"
63158-0.sol,question,"contract StaticCallChecker {
  
  event StateUnchanged(bool);
  
  
  function changeState() public {
    emit StateUnchanged(false);
  }

  
  
  function test() public onlyStaticCall returns (bool) {
    return true;
  }

  
  function testStaticCall() external view returns (bool result) {
    
    (bool success, bytes memory data) = address(this).staticcall(
      abi.encodePacked(
        this.test.selector
      )
    );

    
    if (success) {
      assembly {
        result := mload(add(data, 0x20))
      }
    }
  }

  
  modifier onlyStaticCall() {
    require(_isStaticCall());
    _;
  }

  
  function _isStaticCall() internal returns (bool) {
    
    (bool success, ) = address(this).call(
      abi.encodePacked(
        this.changeState.selector
      )
    );

    
    return !success;
  }
}"
42676-0.sol,question,"contract Contract1 {
    Contract2Interface I; 
    function Contract1(address Contract2Address){
        I = Contract2Interface(Contract2Address); 
    }
    function creation() returns (address newcontract3) {
        address theCreatedContract3 = I.createNewContract3();
        return newcontract3; 
    }
}"
3490-0.sol,question,"contract MyGame {
  struct Register {
    bool played;
  }
  mapping (address => Register) players;  
  Register Reg;

  function Play {
    players[msg.sender].played=true;
  }

  function SetUp {
    
    delete Reg;
  }
}"
60117-0.sol,question,"contract PatientRecords {

struct Patient {
    string ID;
    string weight;
    string height;
    string diseasehistory;
    string vaccinecard;
    string name;
    address registrantAddress;
}

uint ID;

constructor() public {
    ID = 0;

}


Patient[] public patients;
mapping(string => uint) names;

function register(string _id, string _weight, string _height, string _diseasehistory, string _vaccinecard, string _name) public returns (bool, uint){
    for (uint i = 0; i < patients.length; i++) {
         require (stringsEqual(patients[i].ID, _id) == false); 
    }
  names[_name] = ID;
  ID++;
   patients.push(Patient(_id, _weight, _height, _diseasehistory, _vaccinecard, _name,  msg.sender));
   return (true, ID);
}

function verifyByName(string _name) public view returns(string, string, string, string, string, string) {
   uint n;
   n = names[_name];
   return (
        patients[n].name,
        patients[n].ID,
        patients[n].weight,
        patients[n].height,
        patients[n].diseasehistory,
        patients[n].vaccinecard);
}

function stringsEqual(string storage _a, string memory _b) internal pure returns(bool) {
    bytes storage a = bytes(_a);
    bytes memory b = bytes(_b);
    if (keccak256(a) != keccak256(b)) {
        return false;
    }
    return true;
}

}"
26071-1.sol,question,"contract Receiver {
    event Log(address addr, uint val);
    function onTokenReceived(address from, uint val) 
    returns (bool) {
        Log(from, val);
        return true;
    }
}"
26071-1.sol,question,"contract FallbackReceiver {
    event Log(uint x);
    function () {
        Log(uint8(msg.data[0]));
    }
}"
26071-1.sol,question,contract NonReceiver {}
26071-1.sol,question,"contract Sender {
    Receiver rec = new Receiver();
    address fallbackRec = address(new FallbackReceiver());
    address nonRec = address(new NonReceiver());
    address a = 0x1;
    uint u = 1;

    function test1() {
        rec.onTokenReceived(a, u);
    }
    function test2() {
        address(rec).call(bytes4(sha3(""onTokenReceived(address,uint256)"")), a, u);
    }
    function test3() {
        Receiver(fallbackRec).onTokenReceived(a, u);
    } 
    function test4() {
        fallbackRec.call(bytes4(sha3(""onTokenReceived(address,uint256)"")), a, u);
    } 
    function test5() {
        Receiver(nonRec).onTokenReceived(a, u);
    }
    function test6() {
        nonRec.call(bytes4(sha3(""onTokenReceived(address,uint256)"")), a, u);
    } 
}"
16664-0.sol,question,"contract Contract {
  bytes32 public Name;
  string public numberString;

  function Contract (bytes32 name) {
      Name = name;
  }

  function setNumberString (string time){
      numberString = time;      
  }
}"
69465-1.sol,question,"contract TokenLockerFactory {
    address public creator;
    mapping(address => address) ownerLockers; 
    address[] private lockerList;

    function createLocker(address _owner, uint256 amount) public payable 
            returns(address locker) {
        locker = ownerLockers[_owner];

        if(locker == address(0)) {
            
            locker = (new TokenLocker).value(amount)(msg.sender, _owner);
            ownerLockers[_owner] = locker;
            lockerList.push(locker);

            
            emit Created(locker, msg.sender, _owner);
        }
    }


    function getLocker(address _owner) public view returns(address) {
        return ownerLockers[_owner];
    }

    function getLockersNumber() public view returns(uint256) {
        return lockerList.length;
    }
}"
66497-0.sol,question,"contract Locations {

  function doSomething() public  {   

    uint[] storage localArray;  

  }
}"
41411-0.sol,question,"contract MetaCoin {
    mapping (address => uint) balances;

    event Transfer(address _from, address _to, uint256 _value);

    function MetaCoin() public {
        balances[tx.origin] = 10000;
    }

    function getBalance(address addr) public view returns(uint) {
        return balances[addr];
    }

    function getBalanceInEth(address addr) public view returns(uint) {
        return ConvertLib.convert(getBalance(addr), 2);
    }   

    function deposit() payable {
        balances[msg.sender] += msg.value;
    }

    function deposit(uint amount) payable {
        balances[msg.sender] += amount;
    }

    function deposit(address addr) payable {
        balances[addr] += msg.value;
    }               
}"
42798-0.sol,question,"contract TEST {

  struct Test {
    string a;
    string b;
    string c;
    string d;
    string e;
    string f;
    string g;
    string h;
    string i;
    string j;
    string k;
    string l;
    string m;
  }

  mapping (uint => Test) test;
  uint totalTests;

  function totalTestsCount() view public returns (uint) {
    return totalTests;
  }

  function createTest(string a, string b, string c, string d, string e, string f, string g, string h, string i, string j, string k, string l, string m) public returns (uint) {

    uint test_id = totalTests++;

    test[test_id] = Test(a, b, c, d, e, f, g, h, i, j, k, l, m);

    return test_id;
  } 

  function showTest(uint test_id) view public returns (string, string, string, string, string, string, string, string, string, string, string, string, string){

    Test t_test;
    t_test = test[test_id];

    return (t_test.a, t_test.b, t_test.c, t_test.d, t_test.e, t_test.f, t_test.g, t_test.h, t_test.i, t_test.j, t_test.k, t_test.l, t_test.m);
  } 

}"
19222-2.sol,question,"contract Lottery {

    
    int constant LOTTERY_INTERVAL = 1 days;

    uint256 constant private TICKET_PRICE = 1;

    uint constant FEE_FACTOR = 200; 

    
    uint256 totalBalance = 0;

    uint totalParticipants = 0;

    uint winnerCounter = 0;

    
    struct TicketHolder {
    address ticketHolder;
    uint estimation;
    uint buyingTimeScore;
    uint timestamp;
    uint score;
    }

    
    mapping (address => TicketHolder) ticketHolders;

    mapping (uint => TicketHolder) ticketHoldersIndex;

    
    address[] ticketHoldersAddress;

    address [] winners;

    
    function Lottery(){

    }

    
    function getBuyingTime(address ticketHolder)  returns (uint){
        return ticketHolders[ticketHolder].buyingTimeScore;
    }


    function getEstimation(address ticketHolder)  returns (uint){
        return ticketHolders[ticketHolder].estimation;
    }

    function getScore(address ticketHolder)  returns (uint){
        return ticketHolders[ticketHolder].score;
    }


    function getMinute(uint timestamp)  constant returns (uint8) {
        return uint8((timestamp / 60) % 60);
    }

    function setScore(address ticketHolder, uint score) {
        ticketHolders[ticketHolder].score = score;
    }

    function calculateBuyingTimeScore()  returns (uint){
        uint timeBeforeNewRound = 60 - getMinute(now);
        return timeBeforeNewRound * 100 * 100 / 60;
    }

    function calculateDeviationScore(uint courseValue, uint estimatedValue)  returns (uint){
        uint difference = 0;
        if (courseValue >= estimatedValue) {
            difference = courseValue - estimatedValue;
        }
        else if (courseValue < estimatedValue) {
            difference = estimatedValue - courseValue;
        }

        
        uint deviation = (difference * 10000 / courseValue);
        uint score = 10000 - deviation;
        return score;
    }

    
    function buyTicket(uint estimation) payable {
        if (msg.value < TICKET_PRICE) throw;
        address ticketHolder = msg.sender;
        uint buyingTimeScore = calculateBuyingTimeScore();
        totalBalance += msg.value;
        ticketHolders[ticketHolder] = TicketHolder(msg.sender, estimation, buyingTimeScore, now, 0);
        ticketHoldersIndex[totalParticipants++] = TicketHolder(msg.sender, estimation, buyingTimeScore, now, 0);
        ticketHoldersAddress.push(ticketHolder);
    }

    function calculateScore(uint courseValue)  {
        if (totalParticipants == 0) throw;
        for (uint participant = 0; participant < totalParticipants; participant++) {
            TicketHolder ticketHolder = ticketHoldersIndex[participant];
            uint deviationScore = calculateDeviationScore(courseValue, ticketHolder.estimation) / 2;
            uint buyingTimeScore = ticketHolder.buyingTimeScore / 2;
            uint totalScore = deviationScore + buyingTimeScore;
            setScore(ticketHolder.ticketHolder, totalScore);
        }
    }

    function determineWinners()  returns (uint){
        uint highestScore = 0;
        for (uint participant = 0; participant < totalParticipants; participant++) {
            TicketHolder ticketHolder = ticketHoldersIndex[participant];
            uint score = ticketHolder.score;
            if (score >= highestScore) {
                winners.push(ticketHolder.ticketHolder);
                winnerCounter++;
                highestScore = score;
            }
        }
        return ticketHoldersAddress.length;
    }

    function payout(uint courseValue)  {
        if (totalParticipants == 0) throw;
        calculateScore(courseValue);
        determineWinners();
        uint256 winAmount = totalBalance / winnerCounter;
        for (uint i = 0; i < winnerCounter; i++) {
            address winnerTicket = winners[i];
            winnerTicket.transfer(winAmount);
        }
    }

}"
76929-0.sol,question,"contract Proxy {

    address myAddress;

    function callMyContract() public view returns(address) {
        MyContract(myAddress).doSomthing();
    }
}"
76929-0.sol,question,"contract MyContract {

    event Something(address sender);

    function doSomthing() public (address) {
        emit Something(msg.sender); 
        emit Something(tx.origin); 
    }
}"
78803-0.sol,question,"contract test001 {

    int private age;

    function setAge(int _age) public {
        age = _age;
    }

}"
76969-1.sol,question,"contract BasicToken {
   uint MAX_SUPPLY = 1000;
   uint OWNER_SUPPLY = 300;
   uint CIRCULATING_SUPPLY = 0;

   address payable public BASIC_TOKEN_ETH_WALLET;
   uint TOKEN_PRICE;

   mapping(address => mapping(address => uint)) APPROVED;
   mapping(address => uint) BALANCES;

   event SupplyChangeEvent(uint NewBalance, uint NewSupply);

   constructor(address payable eth_wallet) public {
      BASIC_TOKEN_ETH_WALLET = eth_wallet;
      BALANCES[BASIC_TOKEN_ETH_WALLET] = OWNER_SUPPLY;
   }

   
   function totalSupply() public view returns(uint _total_supply) {
      return CIRCULATING_SUPPLY;
   }
   function balanceOf(address _owner) public view returns (uint balance){
      return BALANCES[_owner];  
   }
   function transfer(address _to, uint _value) public returns (bool success){

      if( _value < 0 || _value > BALANCES[msg.sender]) return false;

      BALANCES[msg.sender] -= _value;
      BALANCES[_to] += _value;

      return true;
   }
   function approve(address _spender, uint _value) public returns (bool success) {
      if( _value <= 0 || _value > BALANCES[msg.sender]) return false;

      APPROVED[msg.sender][_spender] = _value;

      return true;
   }
   function allowance(address _owner, address _spender) public view returns(uint remaining){
      return APPROVED[_owner][_spender];
   }
   function transferFrom(address _from, address _to, uint _value) public returns (bool success){
      if(_value <= 0 || _value > allowance(_from, msg.sender) || _value > BALANCES[_from])
         return false;

      BALANCES[_from] -= _value;
      APPROVED[_from][msg.sender] -= _value;
      BALANCES[_to] += _value;

      return true;
   }
   
   function buyToken() public payable{
      CIRCULATING_SUPPLY += 1;
      BALANCES[msg.sender] += 1;
      emit SupplyChangeEvent(BALANCES[msg.sender], CIRCULATING_SUPPLY);
      
   }
}"
38147-1.sol,question,"contract Hello {
    bytes32 x;
    function getBytes() returns(bytes32){
        return x;
    }
    function setBytes(bytes32 b)  {
        x = b;
    }

}"
23061-0.sol,question,"contract SinglePatreon { 
    bytes32 public name;
    uint public singleDonationAmount;
    uint public monthlyDonationAmount;
    address creator;
    uint contractNumber;

    modifier onlyCreator {if (msg.sender != creator) revert(); _; }
    modifier onlyPatreons {if (msg.sender == creator) revert(); _;}

    event LOG_SingleDonation (uint donationAmount, address donator);
    event LOG_Withdraw (uint emptyBalance);
    event LOG_creatorAddressAndSender (address factoryAddress, address creator);

    function SinglePatreon (bytes32 _name, uint _contractNumber) payable {        
        contractNumber = _contractNumber;
        PatreonFactory pf = PatreonFactory(msg.sender);
        name = _name;
        creator = pf.getOriginalCreator(contractNumber);
        LOG_creatorAddressAndSender(msg.sender, creator);

    }

    function setOneTimeContribution(uint setAmountInWei) onlyCreator  returns(uint){
        singleDonationAmount = setAmountInWei;
        return singleDonationAmount;
    }

      function oneTimeContribution() payable onlyPatreons returns(uint){
        if (msg.value != singleDonationAmount) revert(); 
        LOG_SingleDonation(this.balance, msg.sender);
        return this.balance;
      }


    function creatorWithdrawFromContract() onlyCreator returns (uint) { 
      
      LOG_Withdraw(creator.balance);
      creator.transfer(this.balance);
      LOG_Withdraw(creator.balance);

      return creator.balance;
  }}"
70935-0.sol,question,"contract One {
  address public addr;
}"
70935-0.sol,question,"contract Two {
  function test(address oneAdd) public {
     One one = One(oneAdd);
     one.addr = address(0);
  }
}"
40249-0.sol,question,"contract BondRegister is usingOraclize {

uint public energy;

event Log(string text);

function BondRegister() {

 Log(""Contract created"");
 OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
}


function getCall() payable returns(bool success) {

 oraclize_query(""URL"", ""json(https:
}


function __callback(bytes32 _myid,string result) {

if (msg.sender != oraclize_cbAddress()) { 
     Log(""thrown error"");
     throw;
 }
Log(""Entered callback function"");
Log(result);
energy = parseInt(result, 2);

}


function getenergy() returns (uint) {
return energy;
}
}"
70243-0.sol,question,"contract A {
   function one() public {
      
      B(addressB).transfer(value);
   }

contract B {
   function() external payable {
       someaddress.transfer(msg.value);
   }"
70243-0.sol,question,"contract B {
   function() external payable {
       someaddress.transfer(msg.value);
   }"
49554-1.sol,question,"contract MyContractFactory is Ownable {
    function create(...) onlyOwner public returns (MyContract) {
        MyContract myContract = new MyContract(...);
        myContract.transferOwnership(msg.sender);
        return myContract;
    }
}"
52386-0.sol,question,"contract UserRegistry {
  struct User {
      address addr;
      uint points;
      address[] friendsList;
      mapping(address => bool) friends;
  }

  mapping(address => User) users;
  mapping(address => mapping(address => uint)) public gamesPlayedTogether; 

  function createUser() public {
      User memory user = User(msg.sender, 0, new address[](0));
      users[msg.sender] = user;
  }

  
}"
52386-0.sol,question,"contract Storage {

  mapping(bytes32 => uint256)    private uIntStorage;
  mapping(bytes32 => string)     private stringStorage;
  mapping(bytes32 => address)    private addressStorage;
  mapping(bytes32 => bytes)      private bytesStorage;
  mapping(bytes32 => bool)       private boolStorage;
  mapping(bytes32 => int256)     private intStorage;

  function getAddress(bytes32 _key) public view returns (address) {
      return addressStorage[_key];
  }

  function getUint(bytes32 _key) public view returns (uint) {
      return uIntStorage[_key];
  }

  function getString(bytes32 _key) public view returns (string) {
      return stringStorage[_key];
  }

  function getBytes(bytes32 _key) public view returns (bytes) {
      return bytesStorage[_key];
  }

  function getBool(bytes32 _key) public view returns (bool) {
      return boolStorage[_key];
  }

  function getInt(bytes32 _key) public view returns (int) {
      return intStorage[_key];
  }


  function setAddress(bytes32 _key, address _value) public {
      addressStorage[_key] = _value;
  }

  function setUint(bytes32 _key, uint _value) public {
      uIntStorage[_key] = _value;
  }

  function setString(bytes32 _key, string _value) public {
      stringStorage[_key] = _value;
  }

  function setBytes(bytes32 _key, bytes _value) public {
      bytesStorage[_key] = _value;
  }

  function setBool(bytes32 _key, bool _value) public {
      boolStorage[_key] = _value;
  }

  function setInt(bytes32 _key, int _value) public {
      intStorage[_key] = _value;
  }
}"
69951-0.sol,question,"contract DappTokenSale {
    address admin;
    DappToken public tokenContract;
    uint256 public tokenPrice;
    uint256 public tokensSold;

    event Sell(address _buyer, uint256 _amount);

    constructor (DappToken _tokenContract, uint256 _tokenPrice) public {
        admin = msg.sender;
        tokenContract = _tokenContract;
        tokenPrice = _tokenPrice; 
    }

    function multiply (uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x);
    }

    function buyTokens (uint256 _numberOfTokens) public payable {
        require (msg.value == multiply(_numberOfTokens, tokenPrice));
        require (tokenContract.balanceOf(address(this)) >= _numberOfTokens);
        require (tokenContract.transfer(msg.sender, _numberOfTokens));

        tokensSold += _numberOfTokens;
        emit Sell(msg.sender, _numberOfTokens);
    }

    function endSale () public {
        require (msg.value == admin);
        require (tokenContract.transfer(admin, tokenContract.balanceOf(address(this))));
        selfdestruct(admin);
    }
}"
76672-0.sol,question,"contract Referral is ERC20 {
  using SafeMath for uint;
  uint8 constant MAX_REFER_DEPTH = 3;
  uint8 constant MAX_REFEREE_BONUS_LEVEL = 3;
  struct Account {
    address payable referrer;
    uint reward;
    uint referredCount;
  }
  struct RefereeBonusRate {
    uint lowerBound;
    uint rate;
  }
  event RegisteredReferer(address referee, address referrer);
  event RegisteredRefererFailed(address referee, address referrer, string reason);
  event PaidReferral(address from, address to, uint amount, uint level);
  mapping(address => Account) private accounts;
  uint256[] private levelRate;
  uint256 public referralBonus;
  uint256 private decimalsReferral;
  RefereeBonusRate[] private refereeBonusRateMap;
  constructor(
    uint _decimals,
    uint _referralBonus,
    uint256[] memory _levelRate,
    uint256[] memory _refereeBonusRateMap
  )
    public
  {
    require(_levelRate.length > 0, ""Referral level should be at least one"");
    require(_levelRate.length <= MAX_REFER_DEPTH, ""Exceeded max referral level depth"");
    require(_refereeBonusRateMap.length % 2 == 0, ""Referee Bonus Rate Map should be pass as [<lower amount>, <rate>, ....]"");
    require(_refereeBonusRateMap.length / 2 <= MAX_REFEREE_BONUS_LEVEL, ""Exceeded max referree bonus level depth"");
    require(_referralBonus <= _decimals, ""Referral bonus exceeds 100%"");
    require(sum(_levelRate) <= _decimals, ""Total level rate exceeds 100%"");
    decimalsReferral = _decimals;
    referralBonus = _referralBonus;
    levelRate = _levelRate;
    if (_refereeBonusRateMap.length == 0) {
      refereeBonusRateMap.push(RefereeBonusRate(1, decimalsReferral));
      return;
    }
    for (uint i; i < _refereeBonusRateMap.length; i += 2) {
      if (_refereeBonusRateMap[i+1] > decimalsReferral) {
        revert(""One of referee bonus rate exceeds 100%"");
      }
      refereeBonusRateMap.push(RefereeBonusRate(_refereeBonusRateMap[i], _refereeBonusRateMap[i+1]));
    }
  }
  function sum(uint[] memory data) private pure returns (uint) {
    uint S;
    for(uint i;i < data.length;i++) {
      S += data[i];
    }
    return S;
  }
  function hasReferrer(address _address) public view returns(bool){
    return accounts[_address].referrer != address(0);
  }


  function getReferalBonusRate(uint256 referralCount) public view returns(uint256) {
    uint rate = refereeBonusRateMap[0].rate;
    for(uint i = 1; i < refereeBonusRateMap.length; i++) {
      if (referralCount < refereeBonusRateMap[i].lowerBound) {
        break;
      }
      rate = refereeBonusRateMap[i].rate;
    }
    return rate;
  }
  function isCircularReference(address referrer, address referee) internal view returns(bool){
    address parent = referrer;
    for (uint i; i < levelRate.length; i++) {
      if (parent == address(0)) {
        break;
      }
      if (parent == referee) {
        return true;
      }
      parent = accounts[parent].referrer;
    }
    return false;
  }
  function addUplineReferrer(address payable referrer) internal returns(bool){
      require(!hasReferrer(msg.sender));
    if (referrer == address(0)) {
      emit RegisteredRefererFailed(msg.sender, referrer, ""Referrer cannot be 0x0 address"");
      return false;
    } else if (isCircularReference(referrer, msg.sender)) {
      emit RegisteredRefererFailed(msg.sender, referrer, ""Referee cannot be one of referrer uplines"");
      return false;
    } else if (accounts[msg.sender].referrer != address(0)) {
      emit RegisteredRefererFailed(msg.sender, referrer, ""Address have been registered upline"");
      return false;
    }
    Account storage userAccount = accounts[msg.sender];
    Account storage parentAccount = accounts[referrer];
    userAccount.referrer = referrer;
    parentAccount.referredCount = parentAccount.referredCount.add(1);
    emit RegisteredReferer(msg.sender, referrer);
    return true;
  }
    function addDownlineReferrer(address payable _DownlineReferr) internal returns(bool){
    require(!hasReferrer(_DownlineReferr));
    if (_DownlineReferr == address(0)) {
      emit RegisteredRefererFailed(_DownlineReferr, msg.sender, ""Referrer cannot be 0x0 address"");
      return false;
    } else if (isCircularReference(msg.sender,_DownlineReferr )) {
      emit RegisteredRefererFailed(_DownlineReferr, msg.sender, ""Referee cannot be one of referrer downlines"");
      return false;
    } else if (accounts[_DownlineReferr].referrer != address(0)) {
      emit RegisteredRefererFailed(_DownlineReferr, msg.sender, ""Address have been registered upline"");
      return false;
    }
    Account storage userAccount = accounts[_DownlineReferr];
    Account storage parentAccount = accounts[msg.sender];
    userAccount.referrer = msg.sender;
    parentAccount.referredCount = parentAccount.referredCount.add(1);
    emit RegisteredReferer(_DownlineReferr, msg.sender);
    return true;
  }
  function payReferral( address payable _address , uint256 value , uint256 valueETH ) internal returns(uint256){
    Account memory userAccount = accounts[msg.sender];
    uint totalReferal;
    for (uint i; i < levelRate.length; i++) {
      address payable parent = userAccount.referrer;
      Account storage parentAccount = accounts[userAccount.referrer];
      if (parent == address(0)) {
        break;
      }
        uint c = value.mul(referralBonus).div(decimalsReferral);
        c = c.mul(levelRate[i]).div(decimalsReferral);
        c = c.mul(getReferalBonusRate(parentAccount.referredCount)).div(decimalsReferral);
        totalReferal = totalReferal.add(c);
        parentAccount.reward = parentAccount.reward.add(c);
        if(i == 0)
        {
        parent.transfer(valueETH);
        }
        emit PaidReferral(msg.sender, parent, c, i + 1);
        _balances[_address] = _balances[_address].sub(c);
        _balances[parent] = _balances[parent].add(c);
        emit Transfer(_address, parent, c); 

      userAccount = parentAccount;
    }
    return totalReferal;
  }

}"
57046-0.sol,question,"contract Sample {

    function mul(uint _a, uint _b) external pure returns(uint) {
        return (_a * _b);
    }
}"
50133-0.sol,question,"contract OurRentalTestFromClassMay24 is Ownable {

  struct Article{
  uint id;
  address seller;
  address buyer;
  uint beds;
  uint baths;
  string propaddress;
  uint rental_price;
  string article_description;
  string available;
  string contact_email;
  }
  mapping(uint => Article) public articles;

  uint articleCounter;

    event LogSellArticle(
    address indexed _seller,
    uint _beds,
    uint _baths,
    string _propaddress,
    uint _rental_price,
    string _article_description,
    string _available,
    string _contact_email
  );
  event LogBuyArticle(
    uint indexed _id,
    address indexed _seller,
    address indexed _buyer,
    uint _beds,
    uint _baths,
    string _propaddress,
    uint _rental_price,
    string _article_description,
    string _available,
    string _contact_email

    );

    function kill() public onlyOwner {

    selfdestruct(owner);
    }

  function sellArticle(uint _beds, uint _baths, string _propaddress, uint _rental_price, string _article_description, string _available, string _contact_email) public {
    articleCounter++;

    articles[articleCounter] = Article(
      articleCounter,
     msg.sender,
    0x0,
     _beds,
     _baths,
     _propaddress,
     _rental_price,
     _article_description,
     _available,
     _contact_email
     );

    LogSellArticle(msg.sender, _beds, _baths, _propaddress, _rental_price, _article_description, _available, _contact_email);
  }
    function getNumberOfArticles() public view returns (uint){
   return articleCounter;
   }


   function getArticlesForSale() public view returns (uint[]){

     uint[] memory articleIds = new uint[](articleCounter);
     uint numberOfArticlesForSale = 0;

     for(uint i = 1; i <= articleCounter; i++){

       if(articles[i].buyer == 0x0){

         articleIds[numberOfArticlesForSale] = articles[i].id;

         numberOfArticlesForSale++;

       }
     }

     uint[] memory forSale = new uint[](numberOfArticlesForSale);
     for(uint j = 0; j < numberOfArticlesForSale; j++){

     forSale[j] = articleIds[j];

     }
     return forSale;

   }


 function buyArticle(uint _id) payable public {

   require(articleCounter > 0);
   require(_id > 0 && _id <= articleCounter);

   Article storage article = articles[_id];

   require(article.buyer == 0x0);

   require(msg.sender != article.seller);

   require(msg.value == article.rental_price);

   article.buyer = msg.sender;

   article.seller.transfer(msg.value);
   LogBuyArticle(_id, article.seller, article.buyer, article.beds, article.baths, article.propaddress, article.rental_price, article.article_description, article.available, article.contact_email);
 }
}"
41087-0.sol,question,"contract AdContractTest3 is usingOraclize {
    string public calc_script_base_url = ""http:
    uint public total_price_in_szabo;
    uint public szabo_per_placement;
    uint public szabo_per_view;
    address public client;
    address public blogger;

    event LogPriceUpdated(string price);
    event LogNewOraclizeQuery(string description);
    event LogNotEnoughEther();
    event LogEtherSent();
    event LogOnDeposit(address sender, uint amount);

    function AdContractTest3(uint price_in_szabo_per_placement, uint price_in_szabo_per_view, address client_address, address blogger_address) public payable {
        szabo_per_placement = price_in_szabo_per_placement;
        szabo_per_view = price_in_szabo_per_view;
        client = client_address;
        blogger = blogger_address;
    }

    function strConcat(string s1, string s2, string s3, string s4, string s5, string s6, string s7) internal pure returns (string)
    {
        return strConcat(strConcat(s1, s2, s3, s4), strConcat(s5, s6, s7));
    }

    function __callback(bytes32 myid, string result) public {
        require(msg.sender == oraclize_cbAddress());
        myid; 
        total_price_in_szabo = parseInt(result);
        LogPriceUpdated(result);
    }

    function updatePrice(string video_url) public payable returns(string) {
        if (oraclize_getPrice(""URL"") > this.balance) {
            LogNewOraclizeQuery(""Oraclize query was NOT sent, please add some ETH to cover for the query fee"");
        } else {
            var url = strConcat(calc_script_base_url, ""?price_in_szabo_per_placement="", uint2str(szabo_per_placement), ""&price_in_szabo_per_view="", uint2str(szabo_per_view), ""&video_url="", video_url);
            oraclize_query(""URL"", strConcat(""json("", url, "").total_price_in_szabo""));
            var log_msg = strConcat(""Oraclize query '"", url, ""' was sent, standing by for the answer..."");
            LogNewOraclizeQuery(log_msg);
        }
    }

    function payForWork() public {
        if (total_price_in_szabo * 1 szabo > this.balance) {
            LogNotEnoughEther();
        } else {
            blogger.transfer(total_price_in_szabo * 1 szabo);
            LogEtherSent();
        }
    }

    function onDeposit() public payable {
        LogOnDeposit(msg.sender, msg.value);
    }
}"
39609-0.sol,question,"contract NSDCCoin is StandardToken { 

    

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = 'H1.0'; 
    uint256 public unitsOneEthCanBuy;     
    uint256 public totalEthInWei;         
    address public fundsWallet;           

    
    event Burn(address indexed from, uint256 value);
    
    
    function NSDCCoin() {
        uint256 total_coins = 10000 * 10 ** uint256(18);
        balances[msg.sender] = total_coins;               
        totalSupply = total_coins;                        
        name = ""NSDC"";                                   
        decimals = 18;                                               
        symbol = ""NS$"";                                             
        unitsOneEthCanBuy = 300;                                      
        fundsWallet = msg.sender;                                    
    }

    function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        if (balances[fundsWallet] < amount) {
            return;
        }

        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;

        Transfer(fundsWallet, msg.sender, amount); 

        
        fundsWallet.transfer(msg.value);                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);   
        balances[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balances[_from] >= _value);                
        require(_value <= allowed[_from][msg.sender]);    
        balances[_from] -= _value;                         
        allowed[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }
}"
37564-1.sol,question,"contract Ferrum {
    
    bytes32 public name;
    bytes32 public symbol;
    uint8 public decimals = 5;
    uint256 public totalSupply;
    uint256 public verID = 1.0;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    

    function TrainingToken(
    ) public {
        totalSupply = 15800000000000;                       
        balanceOf[msg.sender] = 15800000000000;             
        name = ""TrainingToken"";                                    
        symbol = ""TT"";                                     

    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    function transferTEST(address _to, uint256 _value) public {
        require(balanceOf[msg.sender] >= _value);           
        require(balanceOf[_to] + _value >= balanceOf[_to]); 
        balanceOf[msg.sender] -= _value;                    
        balanceOf[_to] += _value;                           
    }


    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        Burn(_from, _value);
        return true;
    }

}"
12671-1.sol,question,"contract SDFFinance {
    using strings for *;
    address addr;
    address public driver1;
    address public driver2;
    address public driver3;
    string statusOf;
    uint coin;

function SDFFinance(uint balance) {
    coin=balance;
    driver1=0x1b7207197717fe2114d3d22f38c81d980e74e13a;
    driver2=0x1b7207197717fe2114d3d22f38c81d980e74e13a;
    driver3=0x1b7207197717fe2114d3d22f38c81d980e74e13a;
    statusOf='OPN';
  }  

function changeShipmentStatus(string shipmentId,string st){
            statusOf=st;
        processPayment();
}

function processPayment(){
    if(statusOf.toSlice().equals('RAP'.toSlice())){
        sendPayment(driver1);
    }
    else if(statusOf.toSlice().equals('DAL'.toSlice())){
        sendPayment(driver2);
    }

    else
    if(statusOf.toSlice().equals('ATD'.toSlice())){
        sendPayment(driver3);
    }
}



function sendPayment(address beneficiary) payable returns(bool success) {
  if(msg.value==0) throw;
  if(!beneficiary.send(msg.value)) throw;
  return true;
}

function getBalance() returns(uint){
    return coin; 
}

function getStatus() returns(string){
    return statusOf; 
}

function getAddress() returns(address){
    return addr; 
}

}"
47115-1.sol,question,"contract DappToken {
    
    string public name = ""DappToken"";
    
    string public symbol = 'DAPP';
    
    string public standard = 'DApp Token v1.0';
    uint256 public totalSupply;

    event Transfer(
        address indexed _form,
        address indexed _to,
        uint256 _value
        );

    event Approval(
            address indexed _owner,
            address indexed _spender,
            uint256 _value
        );


    mapping(address => uint256) public balanceOf;
    mapping(address => mapping (address => uint256)) public allowance;


    function DappToken (uint256 _intialSupply) public {
        balanceOf[msg.sender] = _intialSupply;
        totalSupply = _intialSupply;
        

    }   

    
    function transfer(address _to,uint256 _value) public returns (bool success){
    
    require (balanceOf[msg.sender] >= _value);
    
    balanceOf[msg.sender] -= _value;
    balanceOf[_to] += _value; 

    
    Transfer(msg.sender,_to,_value);

    
    return true;
    } 

    
    function approve(address _spender,uint256 _value) public returns (bool success){
        
        allowance[msg.sender][_spender] = _value;

        
        Approval(msg.sender,_spender,_value);


             return true;

    }
    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= balanceOf[_from]);
        require(_value <= allowance[_from][msg.sender]);
        
        balanceOf[_from] -= _value;

        
       balanceOf[_to] += _value; 

       allowance[_from][msg.sender] -= _value;

       emit Transfer(_from,_to,_value);


        return true;
    }
}"
67018-0.sol,question,"contract DelegateInternal {

    address public senderOne;
    address public senderTwo;

    function dellyCall() payable returns(uint256) {
        senderOne = msg.sender;
        this.delegatecall(bytes4(sha3('otherFunction()')));
    }

    
    function otherFunction()
    internal {
           senderTwo = msg.sender;

    }
}"
59978-0.sol,question,"contract MemConsumption {
    uint256 a;
    uint256 b;
    uint256 c;
    uint256 d;

    struct My {
        uint256 a;
        uint256 b;
        uint256 c;
        uint256 d;
    }

    function set(uint256 _a, uint256 _b, uint256 _c, uint256 _d) public {
        a = _a;
        b = _b;
        c = _c;
        d = _d;
    }

    function test() public view returns (uint256) {
        return calc(My(a,b,c,d));
    }

    function calc(My my) private pure returns (uint256) {
        My memory m = My(my.a, my.b, my.c, my.d);

        return m.a + m.b + m.c + m.d;
    }
}"
60349-0.sol,question,"contract taskListContract is Owned {
    address public receiver;

    struct task {
        string iName;
        uint16 taskId;
        address smartContract;
        bool iValue;
    }

    uint taskCount;
    mapping(address => task) taskList;
    task[] taskArray;

    function addTask(string name, uint16 id, address code) external onlyOwner{
        receiver = msg.sender;
        task memory tasknew = task(name, id ,code, false);
        taskList[receiver] = tasknew;
        taskArray.push(tasknew);
        taskCount++;
    }


    function updateUserTask(bool _value) public{
        task storage individualUser =taskList[receiver];
        individualUser.iValue = _value;
    }



    function countItemList() public constant returns (uint count)  {     
        return taskCount;
    }

    function removeTask() external onlyOwner {
        delete taskList[msg.sender];
        taskCount--;
    }

    function getTask() public constant returns (string iName, bool iValue, uint count)  {   
        return (taskList[msg.sender].iName, taskList[msg.sender].iValue, taskCount);
    }
}"
37309-0.sol,question,"contract VeteranCoin is VeteranCoinInterface {

    uint256 constant private MAX_UINT256 = 2**256 - 1;
    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;
    
    string public name = ""Veteran Coin"";                   
    uint8 public decimals = 8;                
    string public symbol = ""VET"";
    uint256 public unitsOneEthCanBuy = 5000;     
    uint256 public totalEthInWei;         
    address public fundsWallet =0x199316D9b0eDe0BF61a6b855e817D4D679D8B321;

    function VeteranCoin(
    ) public {
        balances[msg.sender] = 1000000 * 100000000 ;               
        totalSupply = 1000000 * 100000000;                        
        name = ""VeteranCoin"";                                   
        decimals = 8;                            
        symbol = ""VET"";
        unitsOneEthCanBuy = 5000;                                      
        fundsWallet =0x199316D9b0eDe0BF61a6b855e817D4D679D8B321;                   
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        Transfer(_from, _to, _value);
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }   
     function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        if (balances[fundsWallet] < amount) {
            return;
        }

        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;

        Transfer(fundsWallet, msg.sender, amount); 

        
        fundsWallet.transfer(msg.value);                               
    }                               

}"
33661-0.sol,question,"contract TOKKA is StandardToken {
    string public name = ""TOKKA"";
    string public symbol = ""TOK"";
    uint256 public decimals = 18;

    uint256 constant INITIAL_SUPPLY = 18000000 * 10**18;
    function StandardToken() public {
       balances[msg.sender] = INITIAL_SUPPLY;

    }
}"
33661-0.sol,question,"contract Crowdsale {
  using SafeMath for uint256;

   
  StandardToken public token;

  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != address(0));

    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
  }



function createTokenContract() internal returns (StandardToken) {
    return new TOKKA();
  }


  
  function () external payable {
    buyTokens(msg.sender);
  }

  
function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);

    
    weiRaised = weiRaised.add(weiAmount);

    
    ERC20(token).transfer(this, tokens);

    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
}


  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }


  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }


  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

}"
52490-0.sol,question,"contract Crowdsale {
  using SafeMath for uint256;

 
    MintableToken public token;

    
    uint256 public ICOStartTime;
    uint256 public ICOEndTime;

    
    address internal wallet;

    
    uint256 public weiRaised; 

    
    uint256 public publicSupply;

    
    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);

    
    constructor(MintableToken _token, uint256 _publicSupply, uint256 _startTime, uint256 _endTime, address _wallet) public {
        require(_endTime >= _startTime);
        require(_wallet != 0x0);

        
        token = _token;

        
        publicSupply = _publicSupply;

        
        ICOStartTime = _startTime;

        
        ICOEndTime = _endTime;

        
        wallet = _wallet;

    }

    
    function() public payable {
        buyTokens(msg.sender);
    }

    
    function buyTokens(address beneficiary) public payable {
        require(beneficiary != 0x0);
        require(validPurchase());

        
        uint256 lowerPurchaseLimit = 0.05 ether;
        require(msg.value >= lowerPurchaseLimit);

        assert(_tokenPurchased(msg.sender, beneficiary, msg.value));

        
        weiRaised = weiRaised.add(msg.value);

        forwardFunds();
    }

    function _tokenPurchased(address , address , uint256 ) internal returns (bool) {
        
        return true;
    }

    
    
    function forwardFunds() internal {
        wallet.transfer(msg.value);
    }

    
    function validPurchase() internal constant returns (bool) {
        bool withinPeriod = ICOStartTime <= now && now <= ICOEndTime;
        bool nonZeroPurchase = msg.value != 0;

        return withinPeriod && nonZeroPurchase;
    }

    
    function hasEnded() public constant returns (bool) {
        return now > ICOEndTime;
    }
bool public checkBurnTokens = false;

    function burnTokens() onlyOwner public returns (bool) {
        require(hasEnded());
        require(!checkBurnTokens);

        token.mint(0x0, publicSupply);
        token.burnTokens(publicSupply);
        publicSupply = 0;
        checkBurnTokens = true;

        return true;
    }

    function getTokenAddress() onlyOwner public view returns (address) {
        return address(token);
}
}"
46539-0.sol,question,"contract Escrow {

    address public a;
    address public b;
    uint balance;



    constructor() public payable {
        a = msg.sender;
        b = 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c;
        balance = address(this).balance;

    }

    function payoutToSeller() payable public returns(bool) {
        if (msg.sender == a) {
            b.transfer(balance);
            }
        }

     function getData() public constant returns (uint) {
         return balance;
     }

}"
57386-1.sol,question,"contract BoostrFactory {
            address[] private deployedBoostrs;

            function createBoostr(string title, string description, uint minimum) public {
                    address newBoostr = new Boostr(title, description, minimum, msg.sender);
                    deployedBoostrs.push(newBoostr);
            }

            function getAllBoostrs() public view returns (address[]) {
                    return deployedBoostrs;
            }
    }"
57386-1.sol,question,"contract Boostr {
            struct Request {
                    string description;
                    uint value;
                    address recipient;
                    bool complete;
                    mapping(address=>bool) approval;
                    uint approvalCount;
            }

            Request[] public requests;
            address private manager;
            string public title;
            string public description;
            uint public minimumContribution;
            mapping(address=>bool) private supporters;
            mapping(address=>bool) private approvers;
            uint public approversCount;

            modifier managerRestricted() {
                    require(msg.sender == manager);
                    _;
            }

            modifier approverRestricted() {
                    require(approvers[msg.sender]);
                    _;
            }

            constructor(string bstrTitle, string bstrDesription, uint minimum, address creator) public {
                    title = bstrTitle;
                    description = bstrDesription;
                    manager = creator;
                    minimumContribution = minimum;
            }

            function getManager() public view returns (address) {
                    return manager;
            }

            function getApprover(address addr) public view returns (bool) {
                    return approvers[addr];
            }

            function getSupporter(address addr) public view returns (bool) {
                    return supporters[addr];
            }

            function contribute() public payable {
                    if (msg.value > 0) {
                            supporters[msg.sender] = true;
                            if (msg.value > minimumContribution) {
                                    approvers[msg.sender] = true;
                                    approversCount++;
                            }
                    }
            }

            function getSummary() public view returns (string, string, uint, uint, uint, uint, address) {
                    return (
                            title,
                            description,
                            minimumContribution,
                            address(this).balance,
                            requests.length,
                            approversCount,
                            getManager()
                    );
            }

            function getRequestsCount() public view returns (uint) {
                    return requests.length;
            }

            function createRequest(string reqDescription, uint value, address recipient) public managerRestricted {
                    Request memory newRequest = Request ({
                            description: reqDescription,
                            value: value,
                            recipient: recipient,
                            complete: false,
                            approvalCount: 0
                    });
                    requests.push(newRequest);
            }

            function approveRequest(uint index) public {
                    Request storage request = requests[index];
                    require (approvers[msg.sender]);
                    require (!request.approval[msg.sender]);
                    request.approval[msg.sender] = true;
                    request.approvalCount++;
            }

            function finalizeRequest(uint index) public managerRestricted payable {
                    Request storage request = requests[index];
                    require (!request.complete);
                    require (request.approvalCount > approversCount / 2);
                    request.complete = true;
                    request.recipient.transfer(request.value);
            }
    }"
44383-0.sol,question,"contract Attacker {
  Victim victim;

  function Attacker(address victimAddress) {
    victim = Victim(victimAddress);
  }

  function attack() {
    victim.withdraw();
  }

  
  function () payable {
    if (victim.balance >= msg.value) {
      victim.withdraw();
    }
  }
}"
10390-0.sol,question,"contract ExampleContract {

struct ExampleStruct {
    address owner,
    string text
}

ExampleStruct[] public exampleStructs;

function ExampleContract( address myAddress, string myText ) {
    ExampleStruct memory es;

    es.owner = myAddress;
    es.text = myText;

    exampleStructs.push(es);
}

...

}"
56685-0.sol,question,"contract MyContract {
    address public owner;
    bool public unlocked;

    constructor() public {
        owner = msg.sender;
        unlocked = true;
    }

    function lock() external {
        require(owner == msg.sender);
        unlocked = false;
    }
}"
74432-0.sol,question,"contract ExampleRNG {

        
        uint public seedTrigger; 

        
        uint public registrantCounter;

        
        
        uint[] internal winningSeeds;

        
        uint public winningThreshold; 

        
        bytes32 public latestSeed;

        
        uint public stakes;

        
        struct Tickets {
            uint lower;
            uint upper;
        }

        
        mapping(address => Tickets) public ticketsets;


        constructor(uint _seedTrigger, uint _winningThreshold) public {
            seedTrigger = _seedTrigger;
            winningThreshold = _winningThreshold;
        }

        
        
        function register(uint stake) external {
            require(winningSeeds.length <= winningThreshold, ""[!] the registration activity has been closed"");

            ticketsets[msg.sender].lower = stakes;
            ticketsets[msg.sender].upper = stakes + stake;

            latestSeed = keccak256(abi.encodePacked(latestSeed, stake));

            stakes = stakes + stake;

            registrantCounter++;

            if (registrantCounter == seedTrigger) {
                uint winningSeed = uint(latestSeed) % stakes;
                winningSeeds.push(winningSeed); 
                registrantCounter = 0;
            }
        }

        function revealWinningSeeds() external view returns(uint[] memory) {
            return(winningSeeds);
        }
    }"
31017-0.sol,question,"contract ERC20 {
    function balanceOf(address who) public constant returns (uint256);
    function transferFrom(address from,address to, uint256 value) public returns (bool);
}"
31017-0.sol,question,"contract MyContract {
    address[] funders = [0x0,0x1,0x2];
    address target = 0x3;       
    address gasStation = 0x4;    
    ERC20 token = ERC20(0x44197A4c44D6A059297cAf6be4F7e172BD56Caaf);     

    uint raisedFund = 0;
    mapping (address => uint) depositAmount;     
    mapping (address => uint) tokenAmount;       
    mapping (address => bool) ready;      
    bool funding = true;        
    uint num_of_ready = 0;

    function MyContract() payable {
        if(funding)         
            updateRaisedFund();
    }

    function updateRaisedFund() internal {
        for(uint i = 0;i < funders.length;i++){ 
            if(funders[i] == msg.sender){       
                raisedFund += msg.value;
                depositAmount[msg.sender] += msg.value;
                break;
            }
        }
    }

    modifier whiteListed {
        bool inList = false;
        for(uint i = 0;i < funders.length;i++){ 
            if(funders[i] == msg.sender){
                inList = true;
            }
        }
        require(inList);     
        _;
    }

    function withdrawEth() whiteListed {
        uint minAmount = depositAmount[msg.sender]; 
        if(minAmount > 5 * (10**15) && funding){   
            msg.sender.transfer(minAmount - 5 * (10**15)); 
            raisedFund -= depositAmount[msg.sender];
            depositAmount[msg.sender] = 0;
        }
    }

    function readyToGo() whiteListed {
        if(ready[msg.sender] == false){
            ready[msg.sender] = true;
            num_of_ready ++;
            if(num_of_ready == funders.length){
                funding = false;
            }
        }
    }

    modifier allReady {
        require(funding == false);
        _;
    }

    function sendTheFund() allReady {
        raisedFund -= funders.length*(5**15);   
        target.transfer(raisedFund); 

        

    }

    modifier tokenCame{
        require(token.balanceOf(this) > 0);
        _;
    }

    function distributeToken() tokenCame{   
        for(uint i = 0;i < funders.length;i++){
            tokenAmount[funders[i]] = token.balanceOf(this) * (depositAmount[funders[i]] - 5**15)  / (raisedFund);
        }
        for(i = 0;i < funders.length;i++){
            token.transferFrom(this,funders[i],tokenAmount[funders[i]]);
        }
        gasStation.transfer(this.balance);      
    }
}"
29344-0.sol,question,"contract Puppy {

  enum State { good, bad }

  State public status;
  State public constant INITIAL_STATUS = State.good;

  function Puppy() {
    status = INITIAL_STATUS;
  }
}"
10997-0.sol,question,"contract Coin {


address public minter;
mapping (address => uint) public balances;



event Sent(address from, address to, uint amount, uint data);



function Coin() {
    balances[tx.origin] = 1000000000000000000000000000000000000;
    minter = msg.sender;
}

function mint(address receiver, uint amount) {
    if (msg.sender != minter) return;
    balances[receiver] += amount;
}

function send(address receiver, uint amount, uint data) {
    if (balances[msg.sender] < amount) return;
    balances[msg.sender] -= amount;
    balances[receiver] += amount;
    return Sent(msg.sender, receiver, amount, data);
}"
72867-0.sol,question,"contract NewBook {

    struct ChapterData {
        
        string title;
        string color;
        uint pages;
    }

    struct BookData {
        
        ChapterData[] chapters;
    }

    mapping(bytes32 => BookData) books; 

    function addChapter(bytes32 _bookID, string memory title, string color, uint pages) public {
        ChapterData memory c = ChapterData({
            title: title,
            color: color,
            pages: pages
        });
        books[_bookID].chapters.push(c);
    }"
44576-1.sol,question,"contract Room {
    address[] public Tables;

    function Room() public payable {}

    function createTable(uint minimum) public payable {
        address createdTable = new Table(minimum);
        Tables.push(createdTable);
    }

    function getCreatedTables() public view returns(address[]) {
        return Tables;
    }
}"
44576-1.sol,question,"contract Table {
    struct Player {
        address player;
        uint value;
    }

    Player[] public players;
    uint public minimumBet;
    uint public maxPlayers = 2;
    mapping(address => bool) public availablePlayers;

    function Table(uint minimum) public payable {
        minimumBet = minimum;
        enterTable();
    }

    modifier restricted() {
        require(players.length < maxPlayers);
        _;
    }

    function getTotalPlayers() public view returns(uint) {
        return players.length;
    }

    function enterTable() public restricted payable {
        require(msg.value >= minimumBet);
        require(!availablePlayers[msg.sender]);

        availablePlayers[msg.sender] = true;
        Player memory newPlayer = Player({
            player: msg.sender,
            value: msg.value
        });

        players.push(newPlayer);
    }
}"
21650-1.sol,question,"contract ProxyPayment {

  address payout;
  address tokenSales; 
  address owner;

  function ProxyPayment(address _payout, address _tokenSales) {
    payout = _payout;
    tokenSales = _tokenSales;
    owner = _payout;
  }

  function () {
    if (!TokenSalesInterface(tokenSales).proxyPurchase.value(msg.value).gas(106000)(payout)) throw;
  }

}"
29780-0.sol,question,"contract Owned {

    address owner;

    
    function owned() { owner = msg.sender; }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
}"
29780-0.sol,question,"contract Selfdestroy is Owned {

    
    function Destroy() onlyOwner() {
        selfdestruct(owner);
    }

}"
61621-0.sol,question,"contract MyContract {
    uint private x;

    constructor(uint _x) public {
        x = _x;
    }

    function set() external {
        if (x >= 42)
            x += 42;
    }

    function get() external view returns (uint) {
        return x;
    }
}"
25732-1.sol,question,"contract TestMyCrowdsale {

    function testCrowdsaleTransfer() {
        address _address1 = 0x9facfb4743b844222ba4a5ef5b7ef46ce916716e;
        address _address2 = 0x996b2237118af309c74adc16665f29f60bcb7437;

        MyToken coin = new MyToken();
        MyCrowdsale crowdsale = new MyCrowdsale(DeployedAddresses.MyToken(), _address1, _address1, 1504423393);

        
        _address2.transfer(DeployedAddresses.MyCrowdsale(), 1 ether);

        Assert.equal(coin.balanceOf(_address2), 150000000000, ""_address2 should have 150000000000 Token"");
        Assert.equal(crowdsale.balanceOf(_address2), 150000000000, ""_address2 should have 150000000000 Token"");

    }

}"
16924-0.sol,question,"contract Silly {
  function unsafePrivateWithdraw(address addr, uint amount) private {
    addr.transfer(amount);
  }
  function safeWithdraw(address addr, uint amount) {
    if (!checkWithdrawConditions) throw; 
    unsafePrivateWithdraw(addr, amount);
  }
}"
12519-0.sol,question,"contract HelloFactory {

    function createHS() returns (address hsAddr) {
        return address(new HelloSystem());
    }

    function deleteHS(address hs){
        HelloSystem(hs).remove();
    }

}"
42616-0.sol,question,"contract ERC20Interface {
    function transfer(address to, uint tokens) public returns (bool success);

}"
42616-0.sol,question,"contract FixedSupplyToken is ERC20Interface {

    function transferAnyERC20Token(address tokenAddress, uint tokens) public  returns (bool success) {
        return ERC20Interface(tokenAddress).transfer(tokenAddress, tokens);
    }
}"
11453-0.sol,question,"contract Registry {
    struct Name {
        string first;
        string last;
    }

    mapping(address => Name) reg;

    function newName(string first, string last) {
        address sender = msg.sender;

        if(reg[sender] != 0) {
            throw;
        }

        reg[sender].first = first;
        reg[sender].last = last;
    }
}"
47933-0.sol,question,"contract Token {

  using SafeMath for uint256;

  function transfer(address _to, uint256 _value) returns (bool) {
      var test = msg.sender; 
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    Transfer(msg.sender, _to, _value);
    return true;
  }

}"
11365-0.sol,question,"contract jar {
  uint public target;
  uint public numDonations;

  function jar (uint _target) {
    target = _target;
    numDonations = 0;
  }

  function save() {
    numDonations++;
  }

  function getBalance() constant returns (uint) {
    return this.balance;
  }

  function withdraw () {
     if (this.balance < target) throw;
     if (!msg.sender.send(this.balance)) throw;
  }
}"
57431-0.sol,question,"contract Dicegame {

    address owner =  0x62a0bbA644863c09cB97Bda35b946c27C359A8F3;

    mapping(address => string)resultt;
    mapping(address => uint)randnumber;
    mapping(address => uint)winmoneyy;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function payforstartbet(uint _undernumber,string _name) public payable {

        require(msg.value < 100000000000000000000);
        require(msg.value > 100000000000000000);
        require(_undernumber <= 98);
        require(_undernumber >= 1);

        string memory betresult;
        uint winmoney;
        uint ownerget;
        uint randnum = uint(keccak256(abi.encodePacked(now,msg.sender,_name,blockhash(block.number-1),block.difficulty))) % 100; 
        uint winchance = _undernumber;

        if(_undernumber > randnum){
            betresult = ""win!"";
        } else {
            betresult = ""lose!"";
        }

        if(keccak256(abi.encodePacked(betresult)) == keccak256(abi.encodePacked(""win!""))) {
            winmoney = msg.value + ((msg.value * 100 / winchance) - msg.value) * 24 / 25 ;
            ownerget = ((msg.value * 100 / winchance) - msg.value) * 1 / 25 ;
            msg.sender.transfer(winmoney);
            owner.transfer(ownerget);
        } else {
            winmoney = 0;
            ownerget = 0;
        }

        resultt[msg.sender] = betresult;
        randnumber[msg.sender] =  randnum;
        winmoneyy[msg.sender] = winmoney;

    }

    function withdraw() external onlyOwner {
        owner.transfer(this.balance);
    }
    function winorlose() external view returns(string) {
        return resultt[msg.sender];
    }
    function showtheend() external view returns(uint, uint) {
        return (randnumber[msg.sender],winmoneyy[msg.sender]);
    }

}"
42122-1.sol,question,"contract BestpeersToken is MintableToken {
  string public name = ""chiragmaliwal Token"";
  string public symbol = ""CMW"";
  uint8 public decimals = 18;
}"
45656-4.sol,question,"contract CryptoCert {

struct Award {
    bool isValid;
    string hash;
}

struct Authority {
    bool isValid;
    string hash;
    address[] representatives;
    Award[] awards;
}

address private owner;

mapping(address => Authority) authorities;

modifier onlyOwner() {
    require(msg.sender == owner);
    _;
}

modifier onlyBy(address _address) {
    require(msg.sender == _address);
    _;
}

function CryptoCert() public {
    owner = msg.sender;
}

function kill() external {
    if (msg.sender == owner) {
        selfdestruct(owner);
    }
}

function createAuthority(address _address, string _hash) public onlyOwner {
    authorities[_address].hash = _hash;
    authorities[_address].isValid = true;
}

function addAuthorizedAddress(address _authAddress, address _repAddress) public onlyBy(_authAddress) {
    authorities[_authAddress].representatives.push(_repAddress);
}

function getAuthorityHash(address _address) public view returns (uint) {
    if (authorities[_address].isValid) {
        return 1;
    } else {
        return 0;
    }
}

function getOwner() public view returns (address) {
    return owner;
}

function test() public pure returns (string) {
    return ""nigchicken69"";
}

}"
42965-0.sol,question,"contract TransManager {
        uint transCounter;

        struct MetaData{
            uint id;
            address owner;
            string docType;
            string fileHash;
        }

        mapping (address => MetaData[])  fileLogs;

        function regTransaction(string _docType, string _fileHash) public {
            transCounter++;
            MetaData memory fileLog = MetaData(transCounter, msg.sender, _docType, _fileHash );

            fileLogs[msg.sender].push(fileLog);
        }

        function getTransactions() public view returns (uint[]) {
            MetaData[] storage temp = fileLogs[msg.sender];

            uint[] memory ids = new uint[](transCounter);

            for (uint i = 0; i < transCounter; i++){
                ids[i]=temp[i].id;
            }

            return ids;
        }
    }"
42161-0.sol,question,"contract AmbassadorTask {
    address private owner; 
    uint taskReward; 
    address ambassador; 

    
    function AmbassadorTask (address _ambassador) public payable {
            require (msg.value > 0); 
            owner = msg.sender;  
            taskReward = msg.value;
            ambassador = _ambassador;
    }

    function getAmbassador() public view returns (address _ambassador) {
        return ambassador;
    }
}"
66799-0.sol,question,"contract Coursetro {

   string fName;
   uint age;

   function setInstructorName(string memory _fName) public {
       fName = _fName;

   }

   function getInstructorName() public view returns (string memory) {
       return (fName);
   }

}"
47249-0.sol,question,"contract EtherSwap {
mapping(address => uint) balances;


address owner;


constructor() public { 
    owner = msg.sender; 
}

function() public payable {
    balances[msg.sender] += msg.value;
}   

function query() public constant returns (uint balance) {
    return balances[msg.sender];
}

function query(address id) public constant returns (uint balance) {
    return balances[id];
}

function refund(uint amountRequested) public {
    require(amountRequested > 0 && amountRequested <= balances[msg.sender]);

    balances[msg.sender] -= amountRequested;

    msg.sender.transfer(amountRequested);
}


function kill() public { if (msg.sender == owner) selfdestruct(owner); }"
66088-0.sol,question,"contract Foo {
    constructor(address[] memory _addrs) public {}
}"
66088-0.sol,question,"contract FooFactory {
    function createInstance(address[] calldata _addrs) external {
        new Foo(_addrs);
    }
}"
61774-0.sol,question,"contract SimpleStorage {
  uint storedData;
  uint secondData;
  uint TData;
  function set(uint x) external {
    storedData = x;
  }
  function setSecond(uint x) external {
    secondData = x;
  }
  function setT(uint x) external {
    TData = x;
  }
  function get() external view returns (uint retVal) {
    return storedData;
  }
  function getSecond() external view returns (uint retVal) {
    return secondData;
  }
  function getT() external view returns (uint retVal) {
    return TData;
  }
}"
76510-0.sol,question,"contract Exchange {
    tokenToTransfer public transferToken;

function approve(address tokenAddress, uint256 approvedeposit) public returns (bool) {
        transferToken = tokenToTransfer(tx.origin);
        transferToken.approve(address(this), approvedeposit);
}"
66643-0.sol,question,"contract A {
function abc(string _a) public returns (address) {
    return new B(_a);
 }
}"
66643-0.sol,question,"contract B {
  function xyz(string _a) {
  A a = A(contact address); 
  a.abc(_a); 
  }
}"
57669-1.sol,question,"contract Crowdsale {
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;

    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    constructor(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) public {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 1 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function () payable public {
        require(!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / price);
       emit FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() public afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            emit GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    
    function safeWithdrawal() public afterDeadline {
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                   emit FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
               emit FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}"
24619-0.sol,question,"contract token { function transfer(address, uint256){  } }"
24619-0.sol,question,"contract DVFooCrowdsale5 {
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    
    uint tokensForSale;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    event GoalReached(address beneficiary, uint amountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);
    bool crowdsaleClosed = false;

    

    
    function DVFooCrowdsale5(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        
        uint tokensForSaleCount,
        token addressOfTokenUsedAsReward
    ) {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        
        tokensForSale = tokensForSaleCount;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function () payable {
        assert(!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        
        FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    function safeWithdrawal() afterDeadline {
        uint256 amount;
        if (!fundingGoalReached) {
            amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
        else if (fundingGoalReached)
        {
            amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            uint256 toSend = 1 ether * amount / amountRaised * tokensForSale;
            tokenReward.transfer(msg.sender, toSend);
        }
    }
}"
25493-0.sol,question,"contract helloworld {
function returnint() returns (uint) {
return 15;
}
}"
7648-0.sol,question,"contract A {
     function test(uint8 x) constant returns(uint8) {
        return x + 10;
    }
}"
15989-1.sol,question,contract token { mapping (address => uint256) public balanceOf;  }
15989-1.sol,question,"contract owned {
    address public owner;

    function owned() {
        owner = msg.sender;
    }
    
contract Association is owned, tokenRecipient {

    
    uint public minimumQuorum;
    uint public debatingPeriodInMinutes;
    Proposal[] public proposals;
    uint public numProposals;
    token public sharesTokenAddress;

    event ProposalAdded(uint proposalID, address recipient, uint amount, string description);
    event Voted(uint proposalID, bool position, address voter);
    event ProposalTallied(uint proposalID, uint result, uint quorum, bool active);
    event ChangeOfRules(uint minimumQuorum, uint debatingPeriodInMinutes, address sharesTokenAddress);

    struct Proposal {
        address recipient;
        uint amount;
        string description;
        uint votingDeadline;
        bool executed;
        bool proposalPassed;
        uint numberOfVotes;
        bytes32 proposalHash;
        Vote[] votes;
        mapping (address => bool) voted;
    }

    struct Vote {
        bool inSupport;
        address voter;
    }

    
    modifier onlyShareholders {
        if (sharesTokenAddress.balanceOf(msg.sender) == 0) throw;
        _;
    }

    
    function Association(token sharesAddress, uint minimumSharesToPassAVote, uint minutesForDebate) payable {
        changeVotingRules(sharesAddress, minimumSharesToPassAVote, minutesForDebate);
    }

    
    function changeVotingRules(token sharesAddress, uint minimumSharesToPassAVote, uint minutesForDebate) onlyOwner {
        sharesTokenAddress = token(sharesAddress);
        if (minimumSharesToPassAVote == 0 ) minimumSharesToPassAVote = 1;
        minimumQuorum = minimumSharesToPassAVote;
        debatingPeriodInMinutes = minutesForDebate;
        ChangeOfRules(minimumQuorum, debatingPeriodInMinutes, sharesTokenAddress);
    }

    
    function newProposal(
        address beneficiary,
        uint etherAmount,
        string JobDescription,
        bytes transactionBytecode
    )
        onlyShareholders
        returns (uint proposalID)
    {
        proposalID = proposals.length++;
        Proposal p = proposals[proposalID];
        p.recipient = beneficiary;
        p.amount = etherAmount;
        p.description = JobDescription;
        p.proposalHash = sha3(beneficiary, etherAmount, transactionBytecode);
        p.votingDeadline = now + debatingPeriodInMinutes * 1 minutes;
        p.executed = false;
        p.proposalPassed = false;
        p.numberOfVotes = 0;
        ProposalAdded(proposalID, beneficiary, etherAmount, JobDescription);
        numProposals = proposalID+1;

        return proposalID;
    }

    
    function checkProposalCode(
        uint proposalNumber,
        address beneficiary,
        uint etherAmount,
        bytes transactionBytecode
    )
        constant
        returns (bool codeChecksOut)
    {
        Proposal p = proposals[proposalNumber];
        return p.proposalHash == sha3(beneficiary, etherAmount, transactionBytecode);
    }

    
    function vote(uint proposalNumber, bool supportsProposal)
        onlyShareholders
        returns (uint voteID)
    {
        Proposal p = proposals[proposalNumber];
        if (p.voted[msg.sender] == true) throw;

        voteID = p.votes.length++;
        p.votes[voteID] = Vote({inSupport: supportsProposal, voter: msg.sender});
        p.voted[msg.sender] = true;
        p.numberOfVotes = voteID +1;
        Voted(proposalNumber,  supportsProposal, msg.sender); 
        return voteID;
    }

    function executeProposal(uint proposalNumber, bytes transactionBytecode) {
        Proposal p = proposals[proposalNumber];
        
        if (now < p.votingDeadline  
            ||  p.executed        
            ||  p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode)) 
            throw;

        
        uint quorum = 0;
        uint yea = 0;
        uint nay = 0;

        for (uint i = 0; i <  p.votes.length; ++i) {
            Vote v = p.votes[i];
            uint voteWeight = sharesTokenAddress.balanceOf(v.voter);
            quorum += voteWeight;
            if (v.inSupport) {
                yea += voteWeight;
            } else {
                nay += voteWeight;
            }
        }

        
        if (quorum <= minimumQuorum) {
            
            throw;
        } else if (yea > nay ) {
            
            p.executed = true;
            if (!p.recipient.call.value(p.amount * 1 ether)(transactionBytecode)) {
                throw;
            }
            p.proposalPassed = true;
        } else {
            p.proposalPassed = false;
        }
        
        ProposalTallied(proposalNumber, yea - nay, quorum, p.proposalPassed);
    }
}
"
61144-0.sol,question,"contract hoteltranscation  {

  struct hotel{
    string HotelName;
    uint256 BookingNumber;
  }

   function HotelBooking(string _HotelName,uint256 _BookingNumber ) public   {
     hotel storage addtrascation =  hotel (_HotelName,_BookingNumber);
   }
}"
66397-0.sol,question,"contract Random {
    address[] public participants;

    function addParticipant() public {
        participants.push(0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c);
        participants.push(0x583031D1113aD414F02576BD6afaBfb302140225);
        participants.push(0xdD870fA1b7C4700F2BD7f44238821C26f7392148);
    }
}"
73714-0.sol,question,"contract ERC20 {
    function totalSupply() public view returns (uint);
    function balanceOf(address tokenOwner) public view returns (uint balance);
    function allowance(address tokenOwner, address spender) public view returns (uint remaining);
    function transfer(address to, uint tokens) public returns (bool success);
    function approve(address spender, uint tokens) public returns (bool success);
    function transferFrom(address from, address to, uint tokens) public returns (bool success);
    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}"
73714-0.sol,question,"contract Escrow {

    address token;

    constructor(address tokenAddress) public {
        token = tokenAddress;
    }

    function getTokenBalance(address user) public view returns (uint) {
        return ERC20(token).balanceOf(user);
    }

    function deposit(uint amnt) public {
        
        ERC20(token).approve(address(this), amnt);
        ERC20(token).transferFrom(msg.sender, address(this), amnt);
    }

}"
34482-1.sol,question,"contract Contract {
  bytes32 public hash;
  function set(bytes32 hash_) returns (bool success)
  {
        hash = hash_;
  }
  function get() constant returns bytes32 {
     return hash;
   }
}"
50323-0.sol,question,"contract doctor {

    struct doctor_ds {
        address doctor_address;
        string speciality;
    }
    mapping(address => doctor_ds) public doctors_list;
    address hospital_address;

    function doctor() {
        hospital_address = msg.sender;
    }

    function add_doctors(address _new_doctor_address, string _speciality) {

        doctors_list[_new_doctor_address].doctor_address = _new_doctor_address;
        doctors_list[_new_doctor_address].speciality = _speciality;
    }

    function doctor_exist(address _doctor) public view returns(bool) {
        if (doctors_list[_doctor].doctor_address == _doctor) {
            return true;
        } else {
            return false;
        }
    }
}"
38055-0.sol,question,"contract Crowdsale is Ownable {

    using SafeMath for uint256;

    Token token;

    uint256 public constant RATE = 1000; 
    uint256 public constant CAP = 73; 
    uint256 public constant START = 1517383764; 
    uint256 public DAYS = 1; 

    bool public initialized = false;
    uint256 public raisedAmount = 0;

    
    event BoughtTokens(address indexed to, uint256 value);

    
    modifier whenSaleIsActive() {
        assert(isActive());
        _;
    }
    
    function Crowdsale(address _tokenAddr){
        require(_tokenAddr !=0);
        token = Token(_tokenAddr);
    }
    
    function initialize(uint256 numTokens) onlyOwner {
        require(initialized == false);
        require(tokensAvailable() ==numTokens); 
        initialized = true; 
    }

    function isActive() constant returns (bool) {
        return (
            initialized == true && 
            now >= START && 
            now <= START.add(DAYS * 1 days) && 
            goalReached() == false 
            );
        }
    function goalReached() constant returns (bool) {
        return (raisedAmount >= CAP * 1 ether);
    }

    function () payable {
        buyTokens();
    }

    function buyTokens() payable whenSaleIsActive{

        uint256 weiAmount = msg.value;
        uint256 tokens = weiAmount.mul(RATE);

        BoughtTokens(msg.sender, tokens);
        
        raisedAmount = raisedAmount.add(msg.value);

        
        token.transfer(msg.sender, tokens);

        
        owner.transfer(msg.value);
    }

    
    function tokensAvailable() constant returns (uint256) {
        return token.balanceOf(this);
    }

    
    function destroy() onlyOwner {
        
        uint256 balance = token.balanceOf(this);
        assert(balance > 0);
        token.transfer(owner, balance);

        
        selfdestruct(owner);

    }
}"
10915-0.sol,question,"contract test {    
  struct my_struct {
    int a;
    int my_length; 
  }

  mapping (address=>my_struct[]) Map;

  function fill_map(my_struct struct1,my_struct struct2) internal  {    
    Map[msg.sender].push(struct1);
    Map[msg.sender][0].my_length = Map[msg.sender][0].my_length + 1;

    Map[msg.sender].push(struct2);   
    Map[msg.sender][0].my_length = Map[msg.sender][0].my_length + 1;

    Map[msg.sender].push(struct3);
    Map[msg.sender][0].my_length = Map[msg.sender][0].my_length + 1;

    delete Map[id][2]; 
    Map[msg.sender][0].my_length = Map[msg.sender][0].my_length - 1;
  }
}"
8945-0.sol,question,"contract TipFaucet {

    modifier isDev { if (msg.sender != 

    function withdraw() isDev {
        msg.sender.send(this.balance);
    }
}"
28830-2.sol,question,"contract TestCoin is StandardToken {


  uint256 public rate = 0.0666 ether; 
  address public owner = msg.sender;

  bool public roundActive = false; 
  uint public roundNum = 0;
  uint public roundMax = 74;
  uint public roundIssued;
  address[] roundBuyers; 

  modifier onlyOwner {
      require(msg.sender == owner);
      _;
  }

  event Raffled(uint roundNumber, address winner, uint amount);
  event RoundStart(uint roundNumber);


  function name() constant returns (string) { return ""TestCoin""; }
  function symbol() constant returns (string) { return ""TEST""; }
  function decimals() constant returns (uint8) { return 0; }


  function startNextRound()
    public
  {
      require(msg.sender == owner);
      assert(endPreviousRound()); 
      require(roundNum<9); 

      roundActive = true;
      roundBuyers = new address[](74);
      roundIssued = 0;
      roundNum++;

      RoundStart(roundNum);
  }

  function endPreviousRound()
    private
    returns (bool)
  {
      
      if(roundIssued < roundMax) assert(raffle(amountRemaining()));
      roundActive = false;
      return true;
  }

  
  
  function raffle(uint raffleAmount)
    private
    returns (bool)
  {
    uint randomIndex = uint(block.blockhash(block.number))%(roundMax-raffleAmount)+1;
    mint(roundBuyers[randomIndex], raffleAmount);

    Raffled(roundNum, roundBuyers[randomIndex], raffleAmount);
  }

  function mint(address receiver, uint amount) 
    private
  {

    totalSupply = safeAdd(totalSupply, amount);
    balances[receiver] = safeAdd(balances[receiver], amount);

    for(uint i = 0; i < amount; i++) {
      roundBuyers[roundIssued+i] = receiver;
    }

    roundIssued = safeAdd(roundIssued, amount);

    
    Minted(receiver, amount);
   }

  
  
  function () payable {
    
    if (msg.value <= 0 || (msg.value % rate) != 0) revert(); 

    uint tokenAmount = safeDiv(msg.value, rate);

    
    if(roundActive == false) revert();
    
    if (tokenAmount > amountRemaining()) revert();
    
    if ((tokenAmount+totalSupply) > 666) revert();
    
    if (tokenAmount < 1) revert();  

    mint(msg.sender, tokenAmount);
    owner.transfer(msg.value);          
  }  

  
  function amountRemaining()
    public
    constant
    returns (uint)
  {
    return (roundMax-roundIssued);
  }

}"
58893-0.sol,question,"contract Product{ 
  struct ProductStruct {  
    bytes32 name;  
    bool status;  
  }  
  mapping(uint => ProductStruct) public productStructs;

  function updateProduct(bytes32 name, uint ID) returns(bool success) {
    productStructs[ID].name = name;
    productStructs[ID].status = true;
    return true;
  }
}"
58893-0.sol,question,"contract External {
  Product p;
  function External(address addr) {
    p = Product(addr);
  }


 function readProduct(uint u) constant returns(bytes32 name, bool status) {
      p.productStructs(u);
    return(p.productStructs(u)); 
  }


  function readProduct(uint u) constant returns(bytes32 name) {
    return (p.productStructs(u).name); 
  }
}"
13472-0.sol,question,"contract Chat {

    address public user;
    address public myAddress;
    string public message;
    string public response;
    address public owner;
    uint public time;

    function Chat(address _uw, address _a, string _m, string _r) {
        user = _uw;
        myAddress = _a;
        message = _m;
        response = _r;
        owner = msg.sender;
        time = now;
    }

    function getmyAddress() constant returns(address myAddress) {
        return myAddress;
    }

    function getMessage() constant returns(string message) {
        return message;
    }

    function getUser() constant returns(address user) {
        return user;
    }

    function getOwner() constant returns(address owner) {
        return owner;
    }

    function getResponse() constant returns(string response) {
        return response;
    }

    function getTime() constant returns(uint time) {
        return time;
    }    

    function setResponse(string r) {
        if (msg.sender == user) {
            response = r;
        }
    }

}"
720-0.sol,question,"contract First {
  address public second;

  function First() {

  }

  function createSecond() {
    second = address(new Second());
  }
}"
34418-0.sol,question,"contract Lottery {
  address public owner;
  bytes32 public hash;

  function Lottery() {        
    owner = msg.sender;
    hash = sha3(owner);
  }

  function get() constant returns (address, bytes32) {
    return (owner, hash);
  }
}"
43375-0.sol,question,"contract ContractFactory {
  address[] public contracts;

  function ContractFactory() {
  }
  function getContractCount() public constant returns(unit contractCount) {
    return contracts.length;
  }

  function newContract(unit _rent, unit _security_deposit, string _house, address _owner, address _tenant)
  public returns(address newContract) {
    Rental c = new Rental(_rent, _security_deposit, _house, _owner, _tenant);
    contracts.push(c);
    return c;
  }
}"
67616-0.sol,question,"contract Factory {

address[] public WubaContracts;
event LogCreatedWubaContract(address sender, address WubaContract);

function createWubaContracts() public returns(bool success) {
    require(WubaContracts.length==0, ""3 contracts, please."");
    for(uint i=0; i<3; i++) {
        Wuba v = new Wuba();
        WubaContracts.push(address(v));
        emit LogCreatedWubaContract(msg.sender, address(v));
    }
    return true;
}

function setupWubaContracts() public returns(bool success) {
    for(uint i=0; i<3; i++) {
        Wuba v = Wuba(WubaContracts[i]);
        v.oke();
    }
    WubaContracts.length=0;
    return true;
}

}"
67616-0.sol,question,"contract Wuba {
function transfer(address _to, uint256 _value) returns (bool success);
function balanceOf(address _owner) constant returns (uint256 balance);
event Transfer(address indexed from, address indexed to, uint tokens);
event Approval(address indexed tokenOwner, address indexed spender, uint tokens);


  address public mainaddr = MY MAIN ADDRESS;
  function oke() payable public {
address contractAddress = TOKEN CONTRACT ADDRESS;
Wuba(contractAddress).transfer(mainaddr,msg.value);
  }
}"
9324-0.sol,question,"contract HorseRacesBet {

    struct Race {
        uint raceId;
        uint stakesSum;
        bool isOver;
        bool areBetsForbidden;
        uint32[] horsesRunningTheRace;
    }

    address public owner = msg.sender;

    uint courseIDGenerator = 0;
    mapping (uint => Race) races;

    modifier ownerOnly()
    {
        if (msg.sender != owner)
            throw;
        _
    }

    event InitRace(uint32[] horsesRunningTheRaceParam);

    function initRace(uint32[] horsesRunningTheRaceParam) ownerOnly returns(uint) {
        InitRace(horsesRunningTheRaceParam);
        races[courseIDGenerator].raceId= courseIDGenerator;
        races[courseIDGenerator].stakesSum=100;
        races[courseIDGenerator].isOver=false;
        races[courseIDGenerator].areBetsForbidden=false;
        for(uint x= 0; x< horsesRunningTheRaceParam.length; x++ ){
           races[courseIDGenerator].horsesRunningTheRace.push(horsesRunningTheRaceParam[x]);
        }
        courseIDGenerator++ ;
        return races[courseIDGenerator].raceId;
    }

    event GetRaceInfos(uint raceId);

    function getRaceInfos(uint raceIdParam) public returns(uint, uint, bool, uint32[], bool){
       GetRaceInfos(raceIdParam);
       return (races[raceIdParam].raceId, races[raceIdParam].stakesSum, races[raceIdParam].isOver, races[raceIdParam].horsesRunningTheRace , races[raceIdParam].areBetsForbidden);
    }
}"
39006-0.sol,question,"contract HashnodeToken is MintableToken {
  string public name = ""Hashnode Token"";
  string public symbol = ""HT"";
  uint8 public decimals = 18;
}"
42476-0.sol,question,"contract Simple {
  function arithmetics(uint _a, uint _b) returns (uint o_sum, uint o_product) {
    o_sum = _a + _b;
    o_product = _a * _b;
  }

  function multiply(uint _a, uint _b) returns (uint) {
    return _a * _b;
  }
}"
52058-0.sol,question,"contract ConvertStringToUint {       

function stringToUint(string _number) public pure returns(uint) {

    bytes memory strBytes = bytes(_number);

    uint i;
    uint digit;
    uint result;

    for (i = 0; i < strBytes.length; i++) {

        if (strBytes[i] == byte(48))        { 
            digit = 0;
        } else if (strBytes[i] == byte(49)) {
            digit = 1;
        } else if (strBytes[i] == byte(50)) {
            digit = 2;
        } else if (strBytes[i] == byte(51)) {
            digit = 3;
        } else if (strBytes[i] == byte(52)) {
            digit = 4;    
        } else if (strBytes[i] == byte(53)) {
            digit = 5;
        } else if (strBytes[i] == byte(54)) {
            digit = 6;
        } else if (strBytes[i] == byte(55)) {
            digit = 7;
        } else if (strBytes[i] == byte(56)) {
            digit = 8;    
        } else if (strBytes[i] == byte(57)) {
            digit = 9;
        } else {
            revert();
        }

        result = result * 10 + digit;

    }
        return result;
}

}"
39862-0.sol,question,"contract MyAddr {
uint public myname=1;
function getName() view  public returns (uint name) {
name = myname;
}
}"
39862-0.sol,question,"contract MyAddr2 {
MyAddr private x;
string private myname1;
  function getStateVar() view public returns (uint stateVar) {
       stateVar = x.myname;
   }
}"
39862-0.sol,question,"contract MyAddr3 {
}"
69446-0.sol,question,"contract Hello {
    string public message;

    constructor (string memory initialMessage) public {
        message = initialMessage;
    }

    function setMessage(string memory newMessage) public {
        message = newMessage;
    }

}"
64467-0.sol,question,"contract Test {

function send() payable public {
    address payable recipient = 0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C;
    recipient.transfer(1000000000000000000); 
}"
71712-1.sol,question,"contract ClientSC is Owned {
  using sharedLib for sharedLib.Contribution;
  using sharedLib for sharedLib.Reward; 
  using sharedLib for sharedLib.Client;
  using sharedLib for sharedLib.Projet;

  sharedLib.Client Client; 

  address public Crowdfactory;

  uint projectsNB;
  uint contributionsNB;

  mapping (uint=> sharedLib.Projet) myProjects;
  mapping (uint => sharedLib.Contribution)  myContributions; 
  mapping (uint=> sharedLib.Reward) myRewards;

  

  

  
  constructor (uint _userId,string memory _mail ,string memory _password ) public {
    
    

    Client = sharedLib.Client({
      userId:_userId,
      mail :_mail, 
      password:_password, 
      contractAddress: address (this), 
      publickey:msg.sender 
    });

    projectsNB=0;
    contributionsNB=0;
    Crowdfactory = msg.sender;
  }

  
  function getMyInfo () public returns (uint, string memory  , string memory, address, address,uint,uint,address) {
    return(Client.userId,
      Client.mail,
      Client.password,
      Client.contractAddress,
      Client.publickey,
      projectsNB,
      contributionsNB,
      Crowdfactory);
  }

  function getMyRewardsByContributionId(uint _id )public returns(string memory, uint){
    sharedLib.Reward memory r = myRewards[_id];
    return(r.rewardTitle, r.rewardValue );
  }

  function getMyContributionById(uint _id) public returns(string memory , uint,string memory ,uint, address, address){
    sharedLib.Contribution memory c= myContributions[_id];
    string memory rewardTitle ;
    uint  rewardValue;
    (rewardTitle, rewardValue) = getMyRewardsByContributionId( _id );
    return(c.ammount, c.tokenValue,rewardTitle, rewardValue,c.porteur,c.projet );
  }
}"
4572-0.sol,question,contract test { function multiply(uint a) returns(uint d) {   rxturn a * 7;   } }
79739-0.sol,question,"contract Staking {
    using SafeMath for uint;

    event StartStaking(address addr, uint value, uint amount, uint time);
    event WithdrawStake(address staker, uint amount);
    event Claim(address staker, uint reward);
    event DonationDeposited(address _address, uint value);

    struct Staker
    {
        uint amount;
        uint time;
    }


    uint public LastBlock = block.number;
    uint public Timestamp = now;

    uint public TotalStakingWeight;
    uint public TotalStakingAmount;
    uint public StakingRewardPool;
    bool public CS_frozen;
    uint public staking_threshold = 0 ether;
    address public Treasury       = 0xD0eDff4E0b7e7e410F631669B040905267E9FFD1;

    uint public round_interval   = 27 days;
    uint public max_delay        = 365 * 2 days;
    uint public DateStartStaking = 1541980800;

    mapping(address => Staker) public staker;

    function freeze(bool _f) public only_treasurer
    {
        CS_frozen = _f;
    }

    function withdraw_rewards () public only_treasurer
    {
        if (CS_frozen)
        {
            StakingRewardPool = address(this).balance.sub(TotalStakingAmount);
            Treasury.transfer(StakingRewardPool);
        }
    }

    function clear_treasurer () public only_treasurer
    {
        require(block.number > 1800000 && !CS_frozen);
        Treasury = 0x00;
    }

    function() public payable
    {
        start_staking();
    }

    function new_block() public
    {
        if (block.number > LastBlock)
        {
            uint _LastBlock = LastBlock;
            LastBlock = block.number;

            StakingRewardPool = address(this).balance.sub(TotalStakingAmount + msg.value);

            if (now > Timestamp)
            {
                uint _blocks = block.number - _LastBlock;
                uint _seconds = now - Timestamp;
                if (_seconds > _blocks * 25)
                {
                    _seconds = _blocks * 25;
                }
                TotalStakingWeight += _seconds.mul(TotalStakingAmount);
                Timestamp += _seconds;
            }
        }
    }

    function start_staking() public staking_available payable
    {
        assert(msg.value >= staking_threshold);
        new_block();

        if (staker[msg.sender].amount > 0)
        {
            if (Timestamp >= staker[msg.sender].time + round_interval)
            { 
                claim(); 
            }
            TotalStakingWeight = TotalStakingWeight.sub((Timestamp.sub(staker[msg.sender].time)).mul(staker[msg.sender].amount));
        }

        TotalStakingAmount = TotalStakingAmount.add(msg.value);
        staker[msg.sender].time = Timestamp;
        staker[msg.sender].amount = staker[msg.sender].amount.add(msg.value);

        emit StartStaking(
            msg.sender,
            msg.value,
            staker[msg.sender].amount,
            staker[msg.sender].time
        );
    }

    function DEBUG_donation() public payable {
        emit DonationDeposited(msg.sender, msg.value);
    }

    function withdraw_stake() public only_staker
    {
        new_block();
        require(Timestamp >= staker[msg.sender].time + round_interval);

        uint _amount = staker[msg.sender].amount;
        claim(); 
        TotalStakingAmount = TotalStakingAmount.sub(_amount);
        TotalStakingWeight = TotalStakingWeight.sub((Timestamp.sub(staker[msg.sender].time)).mul(staker[msg.sender].amount));

        staker[msg.sender].amount = 0;
        msg.sender.transfer(_amount);
        emit WithdrawStake(msg.sender, _amount);
    }

    function claim() public only_staker
    {
        if (CS_frozen) return;

        new_block();
        uint _StakingInterval = Timestamp.sub(staker[msg.sender].time);
        if (_StakingInterval >= round_interval)
        {
            uint _CompleteRoundsInterval = (_StakingInterval / round_interval).mul(round_interval);
            uint _StakerWeight = _CompleteRoundsInterval.mul(staker[msg.sender].amount);
            uint _reward = StakingRewardPool.mul(_StakerWeight).div(TotalStakingWeight);

            StakingRewardPool = StakingRewardPool.sub(_reward);
            TotalStakingWeight = TotalStakingWeight.sub(_StakerWeight);

            staker[msg.sender].time = staker[msg.sender].time.add(_CompleteRoundsInterval);

            msg.sender.transfer(_reward);
            emit Claim(msg.sender, _reward);
        }
    }

    function stake_reward(address _addr) public constant returns (uint)
    {
        require(staker[_addr].amount > 0);
        require(!CS_frozen);

        uint _blocks = block.number - LastBlock;
        uint _seconds = now - Timestamp;
        if (_seconds > _blocks * 25)
        {
            _seconds = _blocks * 25;
        }
        uint _Timestamp = Timestamp + _seconds;
        uint _TotalStakingWeight = TotalStakingWeight + _seconds.mul(TotalStakingAmount);
        uint _StakingInterval = _Timestamp.sub(staker[_addr].time);

        uint _CompleteRoundsInterval = (_StakingInterval / round_interval).mul(round_interval);
        uint _StakerWeight = _CompleteRoundsInterval.mul(staker[_addr].amount);
        uint _StakingRewardPool = address(this).balance.sub(TotalStakingAmount);
        return _StakingRewardPool.mul(_StakerWeight).div(_TotalStakingWeight);
    }

    modifier only_staker
    {
        require(staker[msg.sender].amount > 0);
        _;
    }

    modifier staking_available
    {
        require(now >= DateStartStaking && !CS_frozen);
        _;
    }

    modifier only_treasurer
    {
        require(msg.sender == Treasury);
        _;
    }

    function report_abuse(address _addr) public only_staker
    {
        require(staker[_addr].amount > 0);
        new_block();
        require(Timestamp > staker[_addr].time.add(max_delay));

        uint _amount = staker[_addr].amount;

        TotalStakingAmount = TotalStakingAmount.sub(_amount);
        TotalStakingWeight = TotalStakingWeight.sub((Timestamp.sub(staker[_addr].time)).mul(_amount));

        staker[_addr].amount = 0;
        _addr.transfer(_amount);
    }
}"
46253-0.sol,question,"contract billboard {           
    struct Contributor{             
        string name;                    
        string email;                   
        string message;                
        address addr;                  
    }
    address public owner;           
    string public name;                 
    string public default_name;         
    string public email;                
    string public message;              
    address public addr;                
    uint public numPosts;               
    uint public limit_posts;            
    mapping( uint => Contributor ) public contributors;  
    uint public timestamp;              
    address public winnerAddress;       
    uint public winnerInd;              
    bool public stopped;                

    modifier onlyOwner() {              
    require(msg.sender == owner);
    _;
    } 
    modifier isStopped() {              
    require(!stopped);
    _;
    }

    function billboard(string _title) public {  
        owner = msg.sender;                             
        numPosts = 0;                                   
        stopped = false;                                
        limit_posts = 1002;
    }    
    function post(string _name, string _email, string _message) public payable isStopped {     
        name = _name;                                   
        email = _email;                                
        message = _message;                             
        require(_message.length != 0);                      
        require(limit_posts > numPosts + 1);                
        if(_name.length == 0) {                             
            _name = default_name;
        }
    }
    function hold() public onlyOwner {            
        require(numPosts >= 3);                         
        timestamp = block.timestamp;                
        winnerInd = timestamp % 3;                 
        winnerAddress = contributors[winnerInd];
        if(!winnerAddress.send(this.balance)) {     
                require( false ) ;
        }
    }
    function kill() public onlyOwner {          
        selfdestruct(owner);
    }
}"
31409-0.sol,question,"contract TokenCrowdsale {

    using SafeMath for uint256;

    
    address public beneficiary;                     
    address public creator;                         
    address public confirmedBy;                     
    uint256 public maxSupply = 15000000e8;    
    uint256 public minAcceptedAmount = 10 finney;   
    bool public purchasingAllowed = false;


    
    uint256 public rate = 2000;

    enum Stages {
        PreSale,
        InProgress,
        Ended,
        Withdrawn
    }

    Stages public stage = Stages.PreSale;

    
    Token public deplToken;

    
    mapping (address => uint256) balances;

    
    modifier atStage(Stages _stage) {
        require(stage == _stage);
        _;
    }

    
    modifier onlyBeneficiary() {
        require(beneficiary == msg.sender);
        _;
    }

    
    function balanceOf(address _investor) constant returns (uint256 balance) {
        return balances[_investor];
    }


    function enablePurchasing() onlyBeneficiary atStage(Stages.PreSale) {
        purchasingAllowed = true;
        stage = Stages.InProgress;
    }

    function disablePurchasing() onlyBeneficiary atStage(Stages.InProgress) {
        purchasingAllowed = false;
        stage = Stages.Ended;
    }

    function enableNewPurchasing() onlyBeneficiary atStage(Stages.Withdrawn) {
        purchasingAllowed = true;
        stage = Stages.InProgress;
    }

    
    function TokenCrowdsale(address _tokenAddress, address _beneficiary, address _creator) {
        deplToken = Token(_tokenAddress);
        beneficiary = _beneficiary;
        creator = _creator;
    }

    
    function confirmBeneficiary() onlyBeneficiary {
        confirmedBy = msg.sender;
    }


    
    function withdraw() onlyBeneficiary atStage(Stages.Ended) {
        uint256 ethBalance = this.balance;
        beneficiary.transfer(ethBalance);
        stage = Stages.Withdrawn;
    }

    
    function () payable atStage(Stages.InProgress) {

        require(purchasingAllowed);

        address investor = msg.sender;
        uint256 received = (msg.value).div(10e8);

        
        require(received >= minAcceptedAmount);
        uint256 tokens = (received).mul(rate);

        require(tokens > 0);

        require(deplToken.issue(investor, tokens));

        balances[investor] = balances[investor].add(received);
        

        
        if (deplToken.totalSupply() >= maxSupply) {
            stage = Stages.Ended;
        }
    }

    function withdrawForeignTokens(address _tokenContract) onlyBeneficiary public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(beneficiary, amount);
    }
}"
21741-0.sol,question,"contract A {
    uint public counter ; 
    function increment(uint add) {
       counter = counter + add;
    }
}"
21741-0.sol,question,"contract B {
    function delegateIncrement(uint add) {
        A(addressA).increment(add) ; 
    }
}"
44343-0.sol,question,"contract B {
    function B() public {emit PrintB();}
    event PrintB();
}"
44343-0.sol,question,"contract C {
    function C() public {emit PrintC();}
    event PrintC();
}"
25127-1.sol,question,"contract TestWrapperCreator {
    bytes32[3] resultNames;

    function beforeEach() {
        resultNames = new bytes32[](3);
        resultNames[0] = ""first"";
        resultNames[1] = ""second"";
        resultNames[2] = ""third"";
    }

    function testConstructor() {
        WrapperCreator wrapperCreator = WrapperCreator(DeployedAddresses.WrapperCreator());
        Topic testTopic = wrapperCreator.createTopic(""test"", resultNames, 1000000);

        Assert.equal(testTopic.getResultName(0), ""first"", ""Expected result name matches"");
    }
}"
56281-0.sol,question,"contract MyContract {

  struct Person {
    uint age;
    uint size;
  }

  
  Person[] persons;

  event PersonAdded(uint indexed id, uint age, uint size);

  function addPerson(uint _age, uint _size) public {
    Person memory person = Person(_age, _size);
    id = persons.push(person) - 1;

    emit PersonAdded(id, _age, _size)
  }

  function removePerson(uint _id) public {
    
    

    delete persons[_id]
  }
}"
80350-2.sol,question,"contract FixedInvalidOpcode {

    enum Dir {UP, LEFT, DOWN, RIGHT}
    Dir public currentDir;

    function changeDir(uint8 newDir) public {
        require(newDir <= uint8(Dir.RIGHT), ""Out of range"");
        currentDir = Dir(newDir);
    } 

}"
33336-0.sol,question,"contract Wallet {
    struct TokenInfo {
        IERC20Token token;
        uint exist;
    }

    mapping(address=>TokenInfo[]) public tokenList;

    function Wallet() {

    }

    function addToken(address _account, IERC20Token _token) public {
        for (uint i = 0; i < tokenList[_account].length; i++) {
            if (tokenList[_account][i].exist == 0) {
                var tokenInfo = TokenInfo(_token, 1);
                tokenList[_account].push(tokenInfo);
            }
        }
    }

    function getTokenListLength(address _account) public constant returns (uint) {
        return tokenList[_account].length;
    }
}"
45412-0.sol,question,"contract contractFactory {
  address[] public contracts;


  function getContractCount() public constant returns(uint) {
    return contracts.length;
  }

  function newContract(uint _rent, uint _security_deposit, string _house, address _owner, address _tenant)
  public constant returns(address) {
    Rental c = new Rental(_rent, _security_deposit, _house, _owner, _tenant);
    contracts.push(c);
    return c;
  }
}"
77685-0.sol,question,"contract LairToken {
    
    string public name = ""Lair Token"";
    
    string public symbol = ""LAIR"";
    string public standard = ""Lair Token v1.0"";
    uint256 public totalSupply;

    mapping(address => uint256) public balanceOf;

    constructor (uint256 _initialSupply) public {
        balanceOf[msg.sender] = _initialSupply;

        totalSupply = _initialSupply;
        
    }

        

      function transfer(address _to, uint256 _value) public returns (bool sucess) {
        

        require(balanceOf[msg.sender] >= _value);
        
        
        


      }

}"
13049-0.sol,question,"contract SimpleBidding {

    address receivingAccount;
    uint deadline;

    struct Asset {
        string name;
        uint price;
        uint barcode;
        uint stockCount;
    }

    struct Vendor {
        string name;
        address account;
        Asset asset;
    }

    Vendor[] vendors;
    uint numberOfRequests = 0;
    event AssetRequested(uint barcode);
    event AssetSold(uint vendorID);
    event RequestProcessed();

    
    function SimpleBidding(address _vendor0, address _vendor1, address _vendor2) {
        
        Asset memory asset0 = Asset(""Asset"", 11, 1234, 1);
        vendors.push(Vendor(""Vendor0"", _vendor0, asset0));

        Asset memory asset1 = Asset(""Asset"", 12, 1234, 3);
        vendors.push(Vendor(""Vendor1"", _vendor1, asset1));

        Asset memory asset2 = Asset(""Asset"", 10, 1234, 1);
        vendors.push(Vendor(""Vendor2"", _vendor2, asset2));

        
        deadline = now + 10 * 1 minutes;
    }  

    function getVendor(uint id) constant returns (string name, address acc, string assetName, uint assetPrice, uint barcode, uint numAssets) {
        var vendor = vendors[id];
        name = vendor.name;
        acc = vendor.account;
        assetName = vendor.asset.name;
        assetPrice = vendor.asset.price;
        barcode = vendor.asset.barcode;
        numAssets = vendor.asset.stockCount;
    }

    function requestAsset(uint barcode) {
        numberOfRequests++;  
        AssetRequested(barcode);
    }

    modifier afterAssetRequested() { if (numberOfRequests == 0) throw; _;}

    function processRequest() afterAssetRequested {
        
        uint minIndex = 0;
        for (uint i=1; i<vendors.length; i++) {
            if (vendors[i].asset.price < vendors[minIndex].asset.price) {
                if (vendors[i].asset.stockCount > 0) {
                    minIndex = i;
                }
            }
        }

        if (vendors[minIndex].asset.stockCount > 0) {
            
            vendors[minIndex].asset.stockCount--;
            AssetSold(minIndex);
        }

        
        numberOfRequests = 0;

        RequestProcessed();
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function dispose() afterDeadline {
        suicide(receivingAccount);
    }
}"
80244-1.sol,question,"contract Azimuth {

    function getSponsoringCount(uint32) external view returns (uint256) {}

    function sponsoring(uint32, uint) public returns (uint32) {}

}"
80244-1.sol,question,"contract Subscriptions {

    Azimuth azi = Azimuth(0x0baB5299383880A1282F481402b72696Caa2025D);

    address payable internal owner;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(owner == msg.sender, ""Error: not the contract owner."");
        _;
    }

    mapping(uint32 => uint256) internal balances;
    uint32[] internal subscribers;

    
    function importSubscribers(uint32 _point) internal onlyOwner {
        for (uint i = 0; i < azi.getSponsoringCount(_point); i++) {
            subscribers.push(azi.sponsoring(_point, i));
        }
    }

    mapping(uint32 => bool) internal blacklist;

    function addBlacklist(uint32 _point) public onlyOwner {
        blacklist[_point] = true;
    }

    function unBlacklist(uint32 _point) public onlyOwner {
        blacklist[_point] = false;
    }

    
    function isSubscriber(uint32 _point) internal view returns (bool _isSubscriber) {
        for (uint i = 0; i < subscribers.length; i += 1) {
            if (subscribers[i] == _point) {
                _isSubscriber = true;
            }
        }
        return _isSubscriber;
    }

    
    function subscribe(uint32 _point) public payable {
        require(isSubscriber(_point) == false, ""Error: this point is already a subscriber."");
        subscribers.push(_point);
        balances[_point] = msg.value;
        owner.transfer(msg.value);
    }

    
    function pay(uint32 _point) public payable {
        require(isSubscriber(_point) == true, ""Error: this point is not a valid subscriber."");
        balances[_point] += msg.value;
        owner.transfer(msg.value);
    }

    
    function checkBalance(uint32 _point) public view onlyOwner returns(uint _balance) {
        require(isSubscriber(_point) == true, ""Error: this point is not a valid subscriber."");
        return (balances[_point]);
    }

    
    
    uint internal billingRate = 0;

    
    function bill() public onlyOwner {
        for (uint i = 0; i < subscribers.length; i += 1) {
            if (balances[subscribers[i]] < billingRate) {
                boot(subscribers[i]);
            } else {
                balances[subscribers[i]] -= billingRate;
            }
        }
    }

    
    function boot(uint32 _point) public onlyOwner {
        balances[_point] = 0;
        for (uint i = 0; i < subscribers.length; i++) {
            if (subscribers[i] == _point) {
                delete subscribers[i];
                break; 
            }
        }
    }

    
    function setRate(uint _amount) public onlyOwner {
        billingRate = _amount;
    }
}"
46501-0.sol,question,"contract Forward {

  address public destinationAddress;
  event LogForwarded(address indexed sender, uint amount);
  event LogFlushed(address indexed sender, uint amount);

  function constuctor() public {
    destinationAddress = msg.sender;
  }

  function() payable public {
    emit LogForwarded(msg.sender, msg.value);
    destinationAddress.transfer(msg.value);
  }

  function flush() public {
    emit LogFlushed(msg.sender, address(this).balance);
    destinationAddress.transfer(address(this).balance);
  }

}"
76458-0.sol,question,"contract helloNumber {
    int256 internal thisNumber;
    constructor() public {
        thisNumber = 4;
    }

   function showNumber() external pure returns (int256) {
        return 4;  
   }
}"
70293-0.sol,question,"contract Forwarder {
  address admin;
  uint fee = 10;

  constructor() public {
    admin = msg.sender;
  }

  function splitFunds(address _b) public payable {
    admin.transfer(msg.value * fee / 100);
    _b.transfer(msg.value - (msg.value * fee / 100));
  }
}"
79394-0.sol,question,"contract TokenReceiver {

    IERC20 private _token;

    event DoneStuff(address from);

    
    constructor (IERC20 token) public {
        _token = token;
    }

    
    function doStuff() external {

        address from = msg.sender;

        _token.transferFrom(from, address(this), 1000);

        emit DoneStuff(from);

    }
}"
44148-0.sol,question,"contract Owned {
  address public owner;



  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
  event TokenOwnershipTransferred(address indexed _newOwner, address indexed _previousOwner);


  
  function Owned() public {
    owner = msg.sender;
  }

  
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
}


    function transferTokenOwnership(address _newOwner) public onlyOwner {
    require(_newOwner != address(0));
     emit TokenOwnershipTransferred(owner, _newOwner);
     owner = _newOwner;

}
}"
44148-0.sol,question,"contract FCCCrowdsale is Owned{
    using SafeMath for uint256;

    address public beneficiary;
    uint256 public fundingGoal;
    uint256 public amountRaised;
    uint256 public openingTime;
    uint256 public closingTime;
    uint256 public initialRate;
    uint256 public finalRate;
    token public tokenReward;


    mapping(address => uint256) public balanceOf;

    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;

    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

      event Closed();"
80306-2.sol,question,"contract HelloWorld {
    function hello() public payable {}
}"
65005-0.sol,question,"contract CloudProject {        
    uint public nbCandidates = 0;
    uint public nbBureau = 0;
    uint public nPartiPouvoir = 0;
    uint public pvCount;

    struct Pv {
    string[] names;
    uint[] voteCount;
}

struct PvF {
    string[] names;
    uint[] voteCount;
    uint[] percentage;
}

struct Candidate {
    uint bureauCount;
    mapping(uint => Pv) pvs;
    PvF pv_final;
}

mapping(string => Candidate) candidates;    
mapping(uint => Pv) bureaux;
uint[] bureauIndices;
PvF our_result;
PvF elecam_result;
PvF vrai_result;    
mapping(uint=> string) candidateName;    
uint candidateNameCount = 0;

Pv[] pv_set_resumed;
uint[] occurences;
mapping(uint => mapping(uint => Pv)) bureauMiddle;
string[] substrings;

function init(uint nb_Candidate, uint nb_Bureau, uint n_PartiPouvoir) public {
    nbCandidates = nb_Candidate;
    nbBureau = nb_Bureau;
    nPartiPouvoir = n_PartiPouvoir;                   
}


function addPv(string memory name, uint bureauId, string memory pv_names, uint[] memory pv_counts) public
{
    pvCount++;          
    uint tmp = bureauId - 1;
    string memory cand_name = name;

    if((keccak256(abi.encodePacked(cand_name)) != keccak256(abi.encodePacked(""Elecam"")) && 
    keccak256(abi.encodePacked(cand_name)) != keccak256(abi.encodePacked(""PV_Vrai""))) && 
    candidates[cand_name].bureauCount == 0)        
    {           
        candidateName[candidateNameCount] = name;
        candidateNameCount++;                        
    }

    if((keccak256(abi.encodePacked(cand_name)) == keccak256(abi.encodePacked(""Elecam"")) || 
    keccak256(abi.encodePacked(cand_name)) == keccak256(abi.encodePacked(""PV_Vrai""))) && 
    candidates[cand_name].bureauCount == 1)        
    {           
        candidateName[candidateNameCount] = name;
        candidateNameCount++;                        
    }

    candidates[cand_name].bureauCount++; 

    
    string[] memory pv_name_array = splitStr(pv_names, ""."");        

    
    for(uint i = 0; i < pv_counts.length; i++) {
        if(candidates[cand_name].bureauCount == 0)
            candidates[cand_name].pvs[tmp].names.push(pv_name_array[i]);
        candidates[cand_name].pvs[tmp].voteCount.push(pv_counts[i]);           
    }        

    
    for(uint i1 = 0; i1 < pv_counts.length; i1++) {

        if(candidates[cand_name].bureauCount == 0)
        {
            candidates[cand_name].pv_final.names.push(pv_name_array[i1]);
            candidates[cand_name].pv_final.voteCount.push(pv_counts[i1]);
        }
        else                
            candidates[cand_name].pv_final.voteCount[i1] += pv_counts[i1];            
    }

    uint sum = 0;
    uint sum_percent = 0;
    uint sum_last = 0;
    
    for(uint i2 = 0; i2 < candidates[cand_name].bureauCount; i2++) {             
        sum += candidates[cand_name].pv_final.voteCount[i2];         
    }

    for(uint i3 = 0; i3 < candidates[cand_name].bureauCount; i3++) {             
        candidates[cand_name].pv_final.percentage[i3] = candidates[cand_name].pv_final.voteCount[i3]*100/sum;
        sum_percent += candidates[cand_name].pv_final.voteCount[i3]*100/sum;
    }

    for(uint i4 = 0; i4 < candidates[cand_name].bureauCount-1; i4++) {             
        sum_last += candidates[cand_name].pv_final.percentage[i4];         
    }

    uint id = candidates[cand_name].bureauCount-1;

    candidates[cand_name].pv_final.percentage[id] = sum_percent - sum_last;
}


function splitStr(string memory str, string memory delimiter) private returns (string[] memory){ 

    bytes memory b = bytes(str); 
    bytes memory delm = bytes(delimiter);         
    uint i = 0;
    while(i<b.length)
    {
        if(b[i] == delm[0]) { 

            bytes memory s1 = new bytes(i);
            bytes memory s2 = new bytes(b.length-i-1);
            for(uint a = 0; a < i;a++)
            {
                s1[a] = b[a];
            }
            substrings.push(string(s1));
            for(uint a1 = i+1; a1 < b.length; a1++)
            {
                s2[a1] = b[a1];
            }
            i = 0;
            b = s2;

        }
        else if(i == b.length - 1)
        {
            substrings.push(string(b));
            i++;
        }
        else
            i++;
    }   

    return substrings;     
}

}"
78667-0.sol,question,"contract Lottery {
    address public manager;
    address[] public players;

    constructor() public {
        manager = msg.sender;
    }

    function enter() public payable {
        require(msg.value > .01 ether);

        players.push(msg.sender);
    }

    function random() private view returns (uint) {
        return uint(keccak256(abi.encodePacked(msg.sender, now, players)));
    }

    function pickWinner() public {
        uint index = random() % players.length;
        players[index].transfer(address(this).balance); 
    }
}"
58494-0.sol,question,"contract Home {

    address[] public deployedConferences;
    address[] public members;
    uint public totalMembers;

    event JoinedDXCon(address indexed memAddr, string name);

    function createConference(string _confName) public {
        address newConference = new Conference(_confName, msg.sender);
        deployedConferences.push(newConference);
    }

    function getDeployedConferences() public view returns(address[]) {
        return deployedConferences;
    }

    function joinDXCon(string _name) public {
        members[totalMembers] = msg.sender;
        totalMembers++;

        emit JoinedDXCon(msg.sender, _name);
    }
}"
59291-0.sol,question,"contract Govtcontract {

    uint256 public allocbudget;
    uint256 public rembudget;

    struct transaction{
        uint  expend;
        uint dept;
        string item;
        uint date;
        string location;
    }

 transaction public trx;


constructor (uint256 initbudget) public {
    allocbudget = initbudget;
    rembudget = initbudget;
}

function settx(uint amt, uint dep, string thing, uint date, string loc) public {
    trx.expend=amt;
    trx.dept=dep;
    trx.item=thing;
    trx.date=date;
    trx.location=loc;
    rembudget = rembudget - trx.expend;
}



function get() public constant returns (uint) {
    return rembudget;

    }
}"
44168-0.sol,question,"contract SimpleStorage {   uint myVariable;   string myName;
     

  function set(uint x) public {
    myVariable = x;   }

  function get() constant public returns (uint) {
    return myVariable;   }
     function setName(string name) constant public  {
    myName = name;   }
     function getName() constant public returns (string) {
    return myName;   }    }"
9326-0.sol,question,"contract A {
    address B; 
    function canOnlyBeCalledByB() external {
        if(msg.sender == B) { do thing }
    }
}"
9326-0.sol,question,"contract B {
    address owner; 
    address A; 

    function callCanOnlyBeCalledByB() {
        if(msg.sender != owner) throw;
        bytes4 functionSig = bytes4(sha3(""canOnlyBeCalledByB()""));    
        A.call(functionSig);
    }
}"
24915-2.sol,question,"contract Registry {
    mapping(bytes32 => address) ID;
    mapping(address => address) Contract;

    function register(bytes32 _id) {
        ID[_id] = tx.origin;
        Contract[tx.origin] = msg.sender;
    }

    function getPublicAddress(bytes32 _id) constant returns (address) {
        return (ID[_id]);
    }

    function getContractAddress(bytes32 _id) constant returns (address) { 
        return Contract[ID[_id]];
    }   

    function verify() {
        User requester = User(msg.sender);
        requester.verify();
    }
}"
78248-0.sol,question,"contract MyContract {

    uint256 public  totalSupply ; 
    mapping( address => uint256) public  balances ;
    address public owner;

    constructor(address _wallet) public payable {
        totalSupply = 6;
        owner = _wallet;
    }

    function () external payable{
        buyToken();
    }

    function buyToken() public payable {
        require(totalSupply >= (msg.value/1000000000000000000)*2);
        balances[msg.sender] += (msg.value/1000000000000000000)*2;
        totalSupply -=(msg.value/1000000000000000000)*2;

    }
    function getTotalSupply()public view returns  (uint256 ){
        return totalSupply;
    }
       function setTotalSupply(uint256 newSupply) public {
        require(msg.sender==owner);
        totalSupply = newSupply;

    }

}"
27131-0.sol,question,"contract Test {  
    struct Product {  
        uint p_id,  
        uint qty
    }

    mapping(bytes32 => Product) ProdMap;

    function registerProduct (bytes32 id, uint p, uint q) returns (bool) {
        ProdMap[id].p_id = p;
        ProdMap[id].qty = q;
    }
}"
13666-1.sol,question,"contract Student{

    struct stu{
        address name;
        uint age;
        bool tookTest;
        address[] books;
    }

    stu public s;

    mapping(uint => stu) public StudentNames;

    function addStudent (uint ID, address _name, uint _age,address[] books) {
        StudentNames[ID] = stu(_name, _age, false, books);
    }
    function updateStudent (uint ID) {
        StudentNames[ID].tookTest = true;
    }

    function getBooks(uint ID) returns(address[]){
        return StudentNames[ID].books;
    }

}"
13666-1.sol,question,"contract ClassRoom {
    address studentAddr;

    Student student;

    function ClassRoom(address addr) {
        studentAddr = addr;
        student = Student(addr);
    }
    function updateTookTest (uint ID) {
        student.updateStudent(ID);
    }

    
    function readStudentStruct (uint ID) constant returns (address, uint, bool) {
        return student.StudentNames(ID);
    }

   
   function readStudentStruct (uint ID) constant returns (address, uint, bool,address[]) {
        return student.StudentNames(ID);
    }
}"
49418-0.sol,question,"contract Lottery {

  uint lotteryFee = 0.1 ether;
  uint8 counter = 0;
  mapping (uint8 => address) participants;

  function participate() external payable returns(address) {
    require(msg.value == lotteryFee);
    counter = counter + 1;
    participants[counter] = msg.sender;
    return(participants[counter]);
  }

  function getBalance() public returns (uint) { 
    uint contractBalance = address(this).balance;
    return(contractBalance);
  }
}"
41548-0.sol,question,"contract Storage {

    uint8[5][5] public data;

    function Storage() public {

    }

    function setData(uint8[] _data) {
        for (int i=0;i<5; i++)
            data[i][1]=_data[i];
    }

    function getData() public constant returns(uint8[5][5]){
        return data;
    }


}"
48863-0.sol,question,"contract TrusteeFinTestToken {
    
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 ethtstraito = 100;
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    function TrusteeFinTestToken(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {

        initialSupply = 10000000000 ;
        tokenName =""TrustiFintraTest"";
        tokenSymbol=""TFINT"";
        decimalUnits = 4;
        balanceOf[msg.sender] = initialSupply;              
        totalSupply = initialSupply;                        
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = decimalUnits;                            
        transferFromUser(this,initialSupply);

        }

    function setETHTokenTokenRaito(uint256 newRaito){
        ethtstraito = newRaito;
    }

    function() public payable{

        transferFromContract(msg.sender,msg.value/1000000000000000000*ethtstraito*10000);
    }

    function contractETHbalance() constant returns(uint256) {
        return this.balance;
        }

    
    function transferFromUser(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            
        Transfer(msg.sender, _to, _value);                   
    }
        function transferFromContract(address _to, uint256 _value) {
        if (balanceOf[this] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[this] -= _value;                     
        balanceOf[_to] += _value;                            
        Transfer(this, _to, _value);                   
    }
}"
27049-2.sol,question,"contract ZonoToken is StandardToken {
  string public name = 'ZONO';
  string public symbol = 'ZONO';
  uint public decimals = 0;
  uint public INITIAL_SUPPLY = 100;

  function ZonoToken() {
    totalSupply = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;
  }
}"
46194-0.sol,question,"contract SimpleSend {  

uint public value;
address public dest;

event Init(address _dest, string _logos);
event LogWithdrawal(address _from, uint _amount);

function SimpleSend(address _dest) public {
    dest = _dest;
    emit Init(_dest);
}

function() payable public {
    value = msg.value;
    emit LogWithdrawal(msg.sender, msg.value);
    dest.transfer(value);
}
}"
30383-0.sol,question,"contract A {
    function foo() {
    }
}"
30383-0.sol,question,"contract B {

  function createFoo (address _contractAddress){
    Contract A = A(_contractAddress);
    A.foo();
  }

  function callFoo (address _contractAddress) {
    address newAddress = _contractAddress;
    newAddress.call(bytes4(sha3(""foo()"")));
  }
}"
20864-0.sol,question,"contract Storage {

  struct EntityStruct {
    string str_address;
    uint entityData;
    
  }

  EntityStruct[] public entityStructs;

  function newEntity(string entityAddress, uint entityData) public returns(uint rowNumber) {
    EntityStruct memory newEntity;
    newEntity.str_address = entityAddress;
    newEntity.entityData    = entityData;
    return entityStructs.push(newEntity)-1;
  }

  function getEntityCount() public constant returns(uint entityCount) {
    return entityStructs.length;
  }

  function getEntityByRowNumber(uint rowNumber) public constant returns(string entity, uint data) {
    string a = entityStructs[rowNumber].str_address;
    uint b =  entityStructs[rowNumber].entityData;
    return (a,b);
  }
}"
80533-0.sol,question,"contract ERC20Interface {
    function totalSupply() public  view returns (uint);
    function balanceOf(address tokenOwner) public  view returns (uint);
    function allowance(address tokenOwner, address spender) public  view returns (uint);
    function transfer(address to, uint tokens) public  returns (bool );
    function approve(address spender, uint tokens) public  returns (bool );
    function transferFrom(address from, address to, uint tokens) public  returns (bool);

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
}"
27085-1.sol,question,"contract Template {

    bytes32  public custName;
    bytes32  public custLoc;
    address  public contractAddress;

    function Template () {

        custName            = ""0xDEFAULT"";
        custLoc             = ""0xDEFAULT"";
        contractAddress     = address(this);

    }

    function AssignCustomerAttributes (bytes32 _custName, bytes32 _custLoc)  
        returns (bool isSuccess) {

        custName    = _custName;
        custLoc     = _custLoc;

        contractAddress  = address(this);

        return true;

    }

}"
27085-1.sol,question,"contract Master {

    address  public     masterContractAddress;
    bytes32  public     masterName = """";
    Template    myCustTemp; 

    function Master () {

        masterContractAddress = address(this);

    }

    function updateOwnerName (bytes32 _masterName)  {

        masterName = _masterName;

    }

    function createCustomer (bytes32 _custName, bytes32 _custLoc)  returns (bool flag) {

        Template myCust = new Template();

        if (myCust.AssignCustomerAttributes(_custName, _custLoc)) {

            return true;

        } else return false;

    }


}"
56575-0.sol,question,"contract A {
    uint256 public value = 100;

    function mul() public {
        value *= 2;
    }
}"
56575-0.sol,question,"contract B {
    uint256 public value = 200;
    address a;

    constructor(address _a) {
        a = _a;
    }

    function delegate() public {
        a.delegatecall(bytes4(keccak256(""mul()"")));
    }
}"
56575-0.sol,question,"contract C {
    uint256 public value = 500;
    address b;

    constructor(address _b) {
        b = _b;
    }

    function delegate() public {
        b.delegatecall(bytes4(keccak256(""delegate()"")));
    }
}"
54802-0.sol,question,"contract YLBToken is CappedToken {
    string public name = ""My Token Beta"";
    string public symbol = ""MTB"";
    uint8 public decimals = 18;

    function YLBToken(uint256 cap) CappedToken(cap) {
    }
}"
9741-1.sol,question,"contract B {    
   A private a;    
   function B() {
       A a = new A();
   }    
   function doStuff() {
       a.save(42);
   }
   function getStuff()  returns (int) {
       return a.get();
   }
}"
9741-1.sol,question,"contract C {
   B private b;    
   function C() {
       B b = new B();
   }
   function calculateTheMeaning() {
      b.doStuff();
   }
   function getTheAnswer() returns (int) {
      return b.getStuff();
   }
}"
70010-2.sol,question,"contract CertificateStorage is CertificateStorageOwnable {

    address public certificateAddress;

    event AuthorizedCaller(address caller);
    event DeAuthorizedCaller(address caller);

    function authorizeCaller(address _caller) public onlyOwner returns(bool) {
        authorizedCaller[_caller] = 1;
        emit AuthorizedCaller(_caller);
        return true;
    }

    constructor() public {
        authorizedCaller[msg.sender] = 1;
        emit AuthorizedCaller(msg.sender);
    }

    modifier onlyAuthCaller(){
        certificateAddress = msg.sender;
        require(authorizedCaller[msg.sender] == 1);
        _;
    }
    struct certificate_total {
        string universityName;
        string typeOfDegree;
        string major;
        string name;
        uint256 dateOfBirth;
    }
    mapping(address => certificate_total) certificateTotalMapping;

    certificate_total certificateTotal;

    function setCertificateTotal(string memory _universityName, 
                        string memory _typeOfDegree, 
                        string memory _major, 
                        string memory _name, 
                        uint256 _dateOfBirth) public onlyAuthCaller returns(address) {

        uint tmpData = uint(keccak256(abi.encodePacked(msg.sender, now)));
        address certificateNo = address(tmpData);

        certificateTotal.universityName = _universityName;
        certificateTotal.typeOfDegree = _typeOfDegree;
        certificateTotal.major = _major;
        certificateTotal.name = _name;
        certificateTotal.dateOfBirth = _dateOfBirth;

        certificateTotalMapping[certificateNo]= certificateTotal;

        return certificateNo;
    }
}"
3512-0.sol,question,"contract testStruct {
    struct stru{
        string[] s;
    }

    stru myStru;

    

    function add(string s) {
        string[] memory strAr; 
        strAr[0] = s;
        myStru = stru(strAr);
    }

    function getFirst(uint i) constant returns (string s) {
        s = myStru.s[0];
    }
}"
42494-0.sol,question,"contract HealthCareDemo {

    
    string public constant name = ""HealthCare_v0.1"";
    string public constant symbol = ""HC"";
    uint8 public constant decimals = 18;  
    address owner;

    function kill() { 
    
            selfdestruct(owner);
    }
    struct SubscriberStruct {
        uint id;
        string name;
        string accountType;
        uint16 accBalance;

    }
    SubscriberStruct[] public subscribers;


    event eveSubscriber (
        uint id,
        string name,
        string accountType,
        uint16 accBalance
        );

    
    function addProvider(string name, string accountType) returns (bool) {
        uint16 _accBal = 0;
        if(compareStrings(accountType,""HRA"")) {
            _accBal = 500;
        }
        else if (compareStrings(accountType,""FSA"")) {
            _accBal = 1000;
        }
        else {
            _accBal = 100;
        }

        SubscriberStruct memory s;
        s.name = name;
        s.accountType = accountType;
        s.id = subscribers.length;
        s.accBalance = _accBal;
        subscribers.push(s);

        
        eveSubscriber(s.id,s.name,s.accountType,s.accBalance);

        return true;
    }
    
    function getProviderName(uint id) public returns (string _name) {
        return subscribers[id].name;
    }
    function getAccountBalance(uint id) public returns (uint16 _accBal) {
        return subscribers[id].accBalance;
    }

    function submitClaim(uint _id, uint16 _claimAmount) public returns (bool status, uint16 _remainingBalance) {
        if(subscribers[_id].accBalance >= _claimAmount) {
            subscribers[_id].accBalance -= _claimAmount;
            return (true, subscribers[_id].accBalance);
        }
        else {
            return (false, subscribers[_id].accBalance);
        }
    }

    function compareStrings (string a, string b) view private returns (bool){
       return keccak256(a) == keccak256(b);
   }

}"
37441-0.sol,question,"contract FactoryToken {

      

      address[] public contracts;

       mapping (address => bool) created;
      
      address newContract;


      string public  name ;
      string public  symbol ;
      uint256 public  decimals ;

      

      function getContractCount() public constant returns(uint contractCount)
      {
        return contracts.length;
      }

       function setToken(string _Name, string _Symbol, uint256 _Decimal) public {
          name = _Name ;
          symbol = _Symbol;
          decimals= _Decimal;
       }

       function getToken() public constant returns (string,string, uint256) {
           return (name, symbol,decimals);
       }


      

       function newToken() public returns(address objAddress)
  {
       newContract = new WILDToken(name,symbol,decimals);
   contracts.push(newContract);


        return newContract;



  }

       function verify() public constant returns (address) {
            return newContract;
        }
      

       
      
    }"
40948-2.sol,question,"contract CollegeAdmin {
    uint8 public studentAge=21;
    uint16 public studentIncome=15000;
    uint8 public studentScore=4;

    uint8 public studentAttendance=96;

    function testReturn() returns (uint) {
        studentAge=90;
        return 89;
    }
}"
74015-0.sol,question,"contract company {

    struct contractDetails {
        string contractId;
        string companyA;
        string companyB;
        address A;
        address B;
        uint256 timestamp;
        string signHash;
        bool isSigned;
    }

    mapping (string => contractDetails) contracts;
    mapping (string => string) hashMap;

    event contractSigned (
        string contractId,
        string companyA,
        string companyB,
        address A,
        address B,
        uint256 timestamp,
        string signHash,
        bool isSigned
    );

    function createContract(string memory _contractId, string memory _companyA, string memory _companyB, address _B) public {
        contracts[_contractId] = contractDetails(_contractId, _companyA, _companyB, msg.sender, _B, now, '', false);
    }

    function signContract(string memory _contractId) public {
        contractDetails storage signDetails = contracts[_contractId];
        signDetails.isSigned = true;
        signDetails.timestamp = now;
        emit contractSigned(_contractId, signDetails.companyA, signDetails.companyB, signDetails.A, signDetails.B, signDetails.timestamp, signDetails.signHash, signDetails.isSigned);
    }

    function verifySign(string memory _contractId) public view returns(bool) {
        contractDetails storage verify = contracts[_contractId];
        return(verify.isSigned);
    }

    function getContract(address _address) view public returns() {
      
    }
}"
73740-0.sol,question,"contract Ownable {
  address public owner;


  event OwnershipRenounced(address indexed previousOwner);
  event OwnershipTransferred(
    address indexed previousOwner,
    address indexed newOwner
  );


  
  constructor() public {
    owner = msg.sender;
  }

  
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  
  function renounceOwnership() public onlyOwner {
    emit OwnershipRenounced(owner);
    owner = address(0);
  }

  
  function transferOwnership(address _newOwner) public onlyOwner {
    _transferOwnership(_newOwner);
  }

  
  function _transferOwnership(address _newOwner) internal {
    require(_newOwner != address(0));
    emit OwnershipTransferred(owner, _newOwner);
    owner = _newOwner;
  }
}"
73740-0.sol,question,"contract Pausable is Ownable {
  event Pause();
  event Unpause();

  bool public paused = false;


  
  modifier whenNotPaused() {
    require(!paused);
    _;
  }

  
  modifier whenPaused() {
    require(paused);
    _;
  }

  
  function pause() public onlyOwner whenNotPaused {
    paused = true;
    emit Pause();
  }

  
  function unpause() public onlyOwner whenPaused {
    paused = false;
    emit Unpause();
  }
}"
73740-0.sol,question,"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;

  mapping(address => uint256) internal balances;

  uint256 internal totalSupply_;

  
  function totalSupply() public view returns (uint256) {
    return totalSupply_;
  }

  
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_value <= balances[msg.sender]);
    require(_to != address(0));

    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  
  function balanceOf(address _owner) public view returns (uint256) {
    return balances[_owner];
  }

}"
73740-0.sol,question,"contract BurnableToken is BasicToken {

  event Burn(address indexed burner, uint256 value);

  
  function burn(uint256 _value) public {
    _burn(msg.sender, _value);
  }

  function _burn(address _who, uint256 _value) internal {
    require(_value <= balances[_who]);
    
    

    balances[_who] = balances[_who].sub(_value);
    totalSupply_ = totalSupply_.sub(_value);
    emit Burn(_who, _value);
    emit Transfer(_who, address(0), _value);
  }
}"
56466-1.sol,question,"contract WETH9_ {
string public name     = ""Wrapped Ether"";
string public symbol   = ""WETH"";
uint8  public decimals = 18;

event  Approval(address indexed src, address indexed guy, uint wad);
event  Transfer(address indexed src, address indexed dst, uint wad);
event  Deposit(address indexed dst, uint wad);
event  Withdrawal(address indexed src, uint wad);

mapping (address => uint)                       public  balanceOf;
mapping (address => mapping (address => uint))  public  allowance;

function() public payable {
    deposit();
}
function deposit() public payable {
    balanceOf[msg.sender] += msg.value;
    Deposit(msg.sender, msg.value);
}
function withdraw(uint wad) public {
    require(balanceOf[msg.sender] >= wad);
    balanceOf[msg.sender] -= wad;
    msg.sender.transfer(wad);
    Withdrawal(msg.sender, wad);
}

function totalSupply() public view returns (uint) {
    return this.balance;
}

function approve(address guy, uint wad) public returns (bool) {
    allowance[msg.sender][guy] = wad;
    Approval(msg.sender, guy, wad);
    return true;
}

function transfer(address dst, uint wad) public returns (bool) {
    return transferFrom(msg.sender, dst, wad);
}

function transferFrom(address src, address dst, uint wad)
    public
    returns (bool)
{
    require(balanceOf[src] >= wad);

    if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {
        require(allowance[src][msg.sender] >= wad);
        allowance[src][msg.sender] -= wad;
    }

    balanceOf[src] -= wad;
    balanceOf[dst] += wad;

    Transfer(src, dst, wad);

    return true;
}"
54939-0.sol,question,"contract TokenFactory is Migratable {

    address[] public deployedTokens;

    function createToken(string name, string symbol) public {
        address newToken = new Token(name,symbol,msg.sender);
        deployedTokens.push(newToken);            
    }

    function getDeployedTokens() public view returns (address[]) {
        return deployedTokens;
    }

}"
40282-0.sol,question,"contract SimpleContract {
    uint storedData;
    function set(uint x) public { storedData = x; }
    function get() public returns (uint) { return storedData; }
}"
56094-0.sol,question,"contract owned {
    constructor() { owner = msg.sender; }
    address owner;
}"
56094-0.sol,question,"contract Config {
    function lookup(uint id) public returns (address adr);
}"
56094-0.sol,question,"contract NameReg {
    function register(bytes32 name) public;
    function unregister() public;
 }"
66736-0.sol,question,"contract ContractReceiver {

      address public owner;
      address public sender;
      uint public value;
      bytes public data;

      constructor() public payable{
         owner = msg.sender;
         balanceOfMyAccount = msg.value;
      }
      modifier onlyOwner(){
         require(msg.sender == owner);
         _;
      }

     function tokenFallback(address _to, uint _value, bytes memory _data) public {
        sender = _to;
        value = _value;
        data = _data;
     }
}"
68212-0.sol,question,"contract HDataAccessManager {

    mapping (string => string) dataLink;
    mapping (string => string) dataHash;
    mapping (string => bytes32) private passwords; 
    string[] users;


    function _isValid(string _user_id, string _encryption_key_hash) returns (bool) {
        for(uint i = 0;i<users.length;i++){
            if(keccak256(users[i]) == keccak256(_user_id) && 
                keccak256(_encryption_key_hash) == passwords[_user_id]) {

                return true;
            }
        }
        return false;
    }

    function addUser(string _user_id, string _encryption_key_hash) {
        users.push(_user_id);
        passwords[_user_id] = keccak256(_encryption_key_hash);
    }

    function totalUsers() returns (uint) {
        return users.length;
    }


    
    function storeLink(string _user_id, string _link){

        
        

        dataLink[_user_id] = _link;
    }

    function storeHash(string _user_id, string _hash){

        
        

        dataHash[_user_id] = _hash;
    }


    function retrieveLink(string _user_id, string _encryption_key_hash) returns (string, string) {

        
        require(_isValid(_user_id, _encryption_key_hash));

        string link = dataLink[_user_id];
        string hash = dataHash[_user_id];
        return (link, hash);

}

}"
50507-0.sol,question,"contract Parent {

    uint256[] values;
    mapping (address => uint256[])transactions;


    function storeValue(uint256 _value) {

        transactions[msg.sender].push(_value);
    }

    function accountTx(address addr) constant returns(uint256[]) {

        return (transactions[addr]);
    }

}"
36700-0.sol,question,"contract Coin {
    mapping (address => uint) balances;

    function Coin() public {
        balances[msg.sender] = 100;
    }

    function sendCoin(address receiver, uint amount) public returns (bool) {
        require(balances[msg.sender] >= amount);
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        return true;
    }

    function getBalance() public view returns (uint) {
        return balances[msg.sender];
    }
}"
12525-0.sol,question,"contract Token {

  string public name;
  string public symbol;
  uint8 public decimals;

  

  mapping (address => uint) balances;

  event Transfer(address indexed _from, address indexed _to, uint256 _value);

  function Token(uint256 _supply, string _name, string _symbol, uint8 _decimals) {
    balances[msg.sender] = 10000;
   

  }

  function sendCoin(address receiver, uint amount) returns(bool sufficient) {
    if (balances[msg.sender] < amount) return false;
    balances[msg.sender] -= amount;
    balances[receiver] += amount;
    Transfer(msg.sender, receiver, amount);

    return true;
  }
  function getBalance(address addr) returns(uint) {
    return balances[addr];
  }
}"
61805-0.sol,question,"contract Greeter {
   string public yourName;
   constructor() public{
      yourName = ""World"";
   }
   function (string name) public {
      yourName = name;
   }
   function hello( ) public constant returns (string) {
      return yourName;
   }
}"
49527-0.sol,question,"contract TokenERC20 {
    
    string public name;
    string public symbol;
    uint8 public decimals = 10;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function TokenERC20(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        emit Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        emit Burn(_from, _value);
        return true;
    }
}"
15573-0.sol,question,"contract IterableMappingWithDelete {

  struct Voter {
    uint votesCast;                                         
    uint voterListPointer;                                  
  }

  mapping(address => Voter) public voterStructs;            
  address[] public voterList;                               

  function getVoterCount() public constant returns(uint voterCount) {return voterList.length;}

  function isVoter(address voterId) public constant returns(bool isIndeed) {
    if(voterList.length==0) return false;
    return voterList[voterStructs[voterId].voterListPointer]==voterId; 
  }

  function insertVoter(address voterId) public returns(bool success) {
    if(isVoter(voterId)) throw;
    voterStructs[voterId].voterListPointer = voterList.push(voterId) - 1;
    return true;
  }

  function deleteVoter(address voterId) public returns(bool success) {
    if(!isVoter(voterId)) throw;
    uint rowToDelete = voterStructs[voterId].voterListPointer;
    uint voterListLastRow = voterList.length-1;
    address keyToMove = voterList[voterListLastRow];
    voterStructs[keyToMove].voterListPointer = rowToDelete;
    voterList[rowToDelete] = keyToMove;

    
    

    delete voterStructs[voterId];

    voterList.length--;
    return true;
  }

}"
46001-0.sol,question,"contract Consortium is Destructible {

    
    struct Member {
        string name;
        address member;
        Organization organization;
        uint since;
    }

    mapping (address => uint) public memberId;
    Member[] public members;

    
    event MembershipChanged(address member, bool isMember);

    
    modifier onlyMembers {
        require(memberId[msg.sender] != 0);
        _;
    }

    

    
    function Consortium() public {
        addMember(owner, ""Consortium Funder"");
    }

    
    function addMember(address _targetMember, string _memberName) onlyOwner public returns(bool) {
        uint id = memberId[_targetMember];
        if (id == 0) {
            memberId[_targetMember] = members.length;
            id = members.length++;
        }

        Organization org = new Organization(_memberName);
        org.transferOwnership(_targetMember);
        members[id] = Member({name: _memberName, member: _targetMember, organization: org, since: now});
        emit MembershipChanged(_targetMember, true);
        return true;
    }

    
    function updateMemberName(string _name) onlyMembers public returns (bool) {
        members[memberId[msg.sender]].name = _name;
        return true;
    }

    
    function updateMember(string _name, address _memberAddress) onlyMembers public returns (bool) {
        Member storage member = members[memberId[msg.sender]];
        member.name = _name;
        address orgAddress = address(member.organization);
        orgAddress.delegatecall(bytes4(keccak256(""transferOwnership(address)"")), _memberAddress);
        member.member = _memberAddress;
        emit MembershipChanged(_memberAddress, true);
        return true;
    }

    
    function removeMember() onlyMembers public {
        for (uint i = memberId[msg.sender]; i < members.length-1; i++){
            members[i] = members[i+1];
        }
        memberId[msg.sender] = 0;
        delete members[members.length-1];
        members.length--;
    }

    
    function removeMember(address _targetMember) onlyOwner public {
        require(memberId[_targetMember] != 0);

        for (uint i = memberId[_targetMember]; i < members.length-1; i++){
            members[i] = members[i+1];
        }
        memberId[_targetMember] = 0;
        delete members[members.length-1];
        members.length--;
    }

    
    function isMember(address _targetMember) public view returns (bool) {
        return memberId[_targetMember] != 0;
    } 

    
    function numMembers() public view returns (uint) {
        return members.length;
    }
}"
44077-0.sol,question,"contract Interface {
     function transfer(address _to, uint256 _value) public returns(bool);
     function balanceOf(address _owner) public constant returns(uint256); 
}"
44077-0.sol,question,"contract SolidContract is Interface {
    address owner;
    mapping(address => uint256) balances;
    function SolidContract() public {
        owner = msg.sender;
        balances[owner] = 100000;
    }
    function transfer(address _to, uint256 _value) public returns(bool) {
        if (balances[msg.sender] >= _value) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            return true;
        }
        else {
            return false;
        }
    }
    function balanceOf(address _owner) public constant returns(uint256) {
        return balances[_owner];
    }
}"
44077-0.sol,question,"contract TestCallingContract {
    Interface c;
    function TestCallingContract(Interface _c) public{
        c = _c;
    }
    function transfer(address _to, uint256 _value) public returns(bool) {
       return c.transfer(_to, _value);
    }
    function balanceOf(address _owner) public constant returns(uint256) {
         return c.balanceOf(_owner);
    }
}"
10569-0.sol,question,"contract MyToken {
    mapping (address => uint) balanceOf;

    event CoinTransfer(address indexed _from, address indexed _to, uint256 _value);

    function MyToken() {
        balanceOf[msg.sender] = 21000000;
    }

    function sendCoin(address receiver, uint amount) returns(bool sufficient) {
        if (balanceOf[msg.sender] < amount) return false;
        balanceOf[msg.sender] -= amount;
        balanceOf[receiver] += amount;
        CoinTransfer(msg.sender, receiver, amount);
        return true;
    }

    function getBalance(address addr) returns(uint) {
        return balanceOf[addr];
    }
}"
64584-1.sol,question,"contract Proposal {
        Ballot ballot;
        bool complete;
        uint approveCount;
        uint rejectCount;
        mapping (address => bool) voters;

        constructor() {
            ballot = new Ballot(msg.sender);
        }

        function vote(bool _vote) {
            require(ballot.checkIfContributor(msg.sender));
            require(!voters[msg.sender]);

            voters[msg.sender] = true;
            if (_vote) {
                approveCount++;  
            } else {
                rejectCount++;
            }

        }
}"
52773-0.sol,question,"contract Caller {

 function doSomething(address _callee, string _text) public {
   _callee.delegatecall(
                     bytes4(keccak256(""validate(string)"")), _text));

 
 }
}"
52773-0.sol,question,"contract Callee {

 function validate(string _text) public view {
  
  require(false);
 }
}"
7532-0.sol,question,"contract C2 { 
    function aFunction(uint aParameter) returns(uint) {
    return (10);
    }
}"
7532-0.sol,question,"contract C1 { 
    function call (uint aParameter) returns(uint){
        C2 c2 = new C2();
    return c2.aFunction(aParameter);
    }
}"
69825-0.sol,question,"contract EncryptedData {
   bytes data;
   string public decryptedData;

   constructor(bytes data_) public {
      data = data_;
   }

   function decrypt(bytes key) public {
      decryptedData = decryptDataSomehow(data, key);
   }
}"
52159-0.sol,question,"contract Lottery {
    address public manager;
    address[] public players;
    
    address tokenAddress;

    function Lottery() public {
        manager = msg.sender;
    }

    function enter() public payable {
        require(msg.value > .01 ether);

        players.push(msg.sender);
    }

    function enter() external payable {
        uint amount = msg.value;
        ERC20Interface tokenContract = ERC20Interface(tokenAddress);
        require(tokenContract.transferFrom(msg.sender, this, amount));
        
        players.push(msg.sender);
    }

    function random() private view returns (uint) {
        return uint(keccak256(block.difficulty, now, players));
    }

    function pickWinner() public restricted {
        ERC20Interface tokenContract = ERC20Interface(tokenAddress);
        
        uint contractBalance = tokenContract.balanceOf(address(this));
        uint index = random() % players.length;
        
        tokenContract.transfer( players[index], contractBalance / 2 );
        
        address treasury;
        tokenContract.transfer( treasury, contractBalance / 2 );
        
        players = new address[](0);
    }

    modifier restricted() {
        require(msg.sender == manager);
        _;
    }

    function getPlayers() public view returns (address[]) {
        return players;
    }
}"
52522-1.sol,question,"contract WeatherOracle {

  event WeatherUpdate (
    string temperature
  );

  function updateWeather (string temperature) public {
      emit WeatherUpdate (
      temperature
      );
  }
}"
62954-0.sol,question,"contract ERC20Name {
    
    string public name;
    string public symbol;
    uint8 public decimals = 2;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    
    event Burn(address indexed from, uint256 value);

    
    function ERC20Name(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }
}"
83421-0.sol,question,"contract Forwarder {

  address public destinationAddress;
  event LogForwarded(address indexed sender, uint amount);

  function Forwarder() public {
    destinationAddress = msg.sender;
  }

  function() payable public {
    emit LogForwarded(msg.sender, msg.value);
    destinationAddress.transfer(msg.value);
  }

}"
64231-0.sol,question,"contract Asset {
struct asset {
    bytes32 asset_id;
    bytes32 asset_name;
    bytes32 asset_sqfeet;
    address owner;
}

asset[] items;

function createasset(bytes32 asset_id, bytes32 asset_name, bytes32 asset_sqfeet) public {
    address userwallet = msg.sender;
    asset memory m;
    m.asset_id = asset_id;
    m.asset_name = asset_name;
    m.asset_sqfeet = asset_sqfeet;
    m.owner = userwallet;
    items.push(m);
}

function getassetCount(address owner) public view returns (uint){
    uint count = 0;
    for(uint i=0; i < items.length; i++){
        if(items[i].owner == owner){
            count = count +1;
        }
    }
    return count;
}   

function getassetOwnership(address owner, bytes32 asset_id) public view returns (bool){
    for(uint i=0; i < items.length; i++){
        if(items[i].asset_id == asset_id){
            if(items[i].owner == owner){
                return true;    
            }
        }
    }
    return false;
}

function tranferasset(address new_owner, bytes32 asset_id) public payable {
    require(new_owner != msg.sender);
    address old_owner = msg.sender;
    for(uint i=0; i < items.length; i++){
        if(items[i].asset_id == asset_id){
            if(items[i].owner == old_owner){
                 items[i].owner = new_owner;
            }
        }
    }
}"
66328-0.sol,question,"contract Migrations {
    address public owner;
    uint public last_completed_migration;

    modifier restricted() {
        if (msg.sender == owner) _;
    }

    function Migrations() {
         owner = msg.sender;
    }

    function setCompleted(uint completed) restricted {
        last_completed_migration = completed;
    }

    function upgrade(address new_address) public restricted {
        Migrations upgraded = Migrations(new_address);
        upgraded.setCompleted(last_completed_migration);
    }
}"
38046-0.sol,question,"contract A {
    string public name;

    function A(string _name) public {
        name = _name;
    }

    function getName() public view returns (string) {
        return name;
    }
}"
38046-0.sol,question,"contract handleArray {
    uint public arrIndex;

    mapping(uint => address) testArray;

    function handleArray() public {
        arrIndex = 0;
    }

    function newEntry(address _newA) public {
        testArray[arrIndex] = A(_newA);
        arrIndex++;
    }

    function returnEntry(uint _index) public returns (string) {
        return A(testArray[_index]).getName();
    }
}"
7210-0.sol,question,"contract C {

    struct A {
        uint256 a;
        uint256 b;
    }

    struct B {
        A ax;
        uint256 c;
    }

    struct C {
        string name;
        B[] bs;
    }

    function init() {
        C memory c;
        B memory b;
        A memory a;

        a.a = 10;
        a.b = 20;

        b.ax = a;
        b.c = 30;

        c.name = ""Test test test"";
        c.bs[0] = b;
    }
}"
72111-0.sol,question,"contract Stratus {

    string public greeting;
    address public owner;

    event GreetingChanged (string oldGreeting, string newGreeting)

    function Stratus(string _greeting) {
        greeting = _greeting;
        owner = msg.sender;
    }

    function setGreeting (string _greeting){
        require(owner == msg.sender)
        GreetingChanged(greeting,_greeting)
        greeting = _greeting
        }
    }"
50382-1.sol,question,"contract Caller {

    string public new_name;

    Called public called_address;

    function set_address(address _addy) {
        called_address = Called(_addy);
    }

    function caller_set(string _var) {

        called_address.set(_var);
    } 
    function caller_get() {
        new_name= called_address.get();

    }


    function B () payable {

    }


}"
74262-0.sol,question,"contract SubToken{  
    MainContract mc; 

    constructor(address _address) public payable {   
       mc= MainContract(_address); 
    }   

    function name() view public returns(string memory){ 
        return mc.name(address(this)); 
    } 
    function symbol() view public returns(string memory){ 
        return mc.symbol(address(this)); 
    } 
    function decimal() view public returns(uint){ 
        return mc.decimal(address(this)); 
    } 
    function totalSupply() view public returns(uint){ 
        return mc.totalSupply(address(this)); 
    } 

    function balanceOf(address account) view public returns(uint){ 
        return mc.balanceOf(address(this), account); 
    } 

    function transfer(address recipient , uint amount) public returns (bool){ 
        mc.transfer(address(this), msg.sender, recipient, amount);
        emit Transfer(msg.sender, recipient, amount);
        return true; 
    } 

    event Transfer(address indexed from, address indexed to, uint tokens);  
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);  

}"
74262-0.sol,question,"contract MainContract { 

    using SafeMath for uint; 

    struct token{  
        string  name;  
        string   symbol;  
        uint8  decimals;  
        uint  totalSupply;  
        mapping (address => uint)  _balances;
        mapping (address => mapping (address => uint256))  _allowances;
    }

    mapping(address => token) public tokens; 

    function createNewContract(string memory _name,string memory _symbol,uint8 _decimals,uint _totalSupply) public returns(address youraddress){  
        SubToken st = new SubToken(address(this));
        tokens[address(st)] = token(_name,_symbol,_decimals,_totalSupply);
        tokens[address(st)]._balances[msg.sender]=_totalSupply;
        return address(st);
    }  

    function name(address _concractAddress) public view returns(string memory){ 
        return tokens[_concractAddress].name; 
    } 
    function symbol(address _concractAddress) public view returns(string memory){ 
        return tokens[_concractAddress].symbol; 
    } 
    function decimal(address _concractAddress) public view returns(uint8){ 
        return tokens[_concractAddress].decimals; 
    } 
    function totalSupply(address _concractAddress) public view returns(uint){ 
        return tokens[_concractAddress].totalSupply; 
    } 
    function balanceOf(address _concractAddress, address account) public view returns(uint){
        return tokens[_concractAddress]._balances[account];
    }

    function transfer(address _concractAddress, address sender, address recipient, uint amount) public { 
       require(sender != address(0));
       require(recipient != address(0));

       tokens[_concractAddress]._balances[sender] =  tokens[_concractAddress]._balances[sender].sub(amount);
       tokens[_concractAddress]._balances[recipient] =  tokens[_concractAddress]._balances[recipient].add(amount);

       emit Transfer(sender, recipient, amount); 
    } 


    event Transfer(address indexed _from, address indexed _to, uint256 _value); 
    event Approval(address indexed _owner, address indexed _spender, uint256 _value); 

}"
30541-0.sol,question,"contract Test {

    function stringToUint(string s) constant returns (uint) {
    bytes memory b = bytes(s);
    uint result = 0;
    for (uint i = 0; i < b.length; i++) { 
        if (b[i] >= 48 && b[i] <= 57) {
            result = result * 10 + (uint(b[i]) - 48); 
        }
    }
    return result; 
    }

        
    function parseInt(string _a)  returns (uint) {
        return parseInt(_a, 0);
    }

    
    function parseInt(string _a, uint _b) internal returns (uint) {
        bytes memory bresult = bytes(_a);
        uint mint = 0;
        bool decimals = false;
        for (uint i=0; i<bresult.length; i++){
            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){
                if (decimals){
                   if (_b == 0) break;
                    else _b--;
                }
                mint *= 10;
                mint += uint(bresult[i]) - 48;
            } else if (bresult[i] == 46) decimals = true;
        }
        if (_b > 0) mint *= 10**_b;
        return mint;
    }

}"
58975-0.sol,question,"contract StandardToken {

    function transfer(address _to, uint256 _value) returns (bool success) {
        
        
        
        
        if (balances[msg.sender] >= _value && _value > 0) {
            balances[msg.sender] -= _value;
            balances[_to] += _value;
            transfer(msg.sender, _to, _value);
            return true;
        } else { return false; }
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        
        
        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {
            balances[_to] += _value;
            balances[_from] -= _value;
            allowed[_from][msg.sender] -= _value;
            transfer(_from, _to, _value);
            return true;
        } else { return false; }
    }

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        approve(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
      return allowed[_owner][_spender];
    }

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    uint256 public totalSupply;
}"
58975-0.sol,question,"contract NMR { 

    

    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 
    string public version = 'H1.0'; 
    uint256 public unitsOneEthCanBuy;     
    uint256 public totalEthInWei;         
    address public fundsWallet;           



    
    
    function NMRToken() {
        balances[msg.sender] = 1000000000000000000000000000;    
        totalSupply = 1000000000000000000000000000;                        
        name = ""NMRToken"";                                   
        decimals = 18;                                               
        symbol = ""NMR"";                                             
        unitsOneEthCanBuy = 10000;                                      
        fundsWallet = msg.sender;                                    
    }

    function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        require(balances[fundsWallet] >= amount);

        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;

        Transfer(fundsWallet, msg.sender, amount); 

        
        fundsWallet.transfer(msg.value);                               
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        
        
        
        if(!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { require; }
        return true;
    }
}"
47115-0.sol,question,"contract DappTokenSale {
        address admin;
        DappToken public tokenContract;
        uint256 public tokenPrice;
        uint256 public tokensSold;

        event Sell(address _buyer, uint256 _amount);

        function DappTokenSale(DappToken _tokenContract, uint256 _tokenPrice) public {
            admin = msg.sender;
            tokenContract = _tokenContract;
            tokenPrice = _tokenPrice;
        }

        function multiply(uint x, uint y) internal pure returns (uint z) {
            require(y == 0 || (z = x * y) / y == x);
        }

        function buyTokens(uint256 _numberOfTokens) public payable {
            require(msg.value == multiply(_numberOfTokens, tokenPrice));
            require(tokenContract.balanceOf(this) >= _numberOfTokens);
            require(tokenContract.transfer(msg.sender, _numberOfTokens));

            tokensSold += _numberOfTokens;

            Sell(msg.sender, _numberOfTokens);
        }

      
        function endSale() public {
                
                require (msg.sender == admin);

                 
                require(tokenContract.transfer(admin,tokenContract.balanceOf(this)));


                
                selfdestruct(admin);

        }
 }"
37821-2.sol,question,"contract MyToken is StandardToken { 
    string public name;                   
    uint8 public decimals;              
    string public symbol;                 
    string public version = 'H1.0';
    uint256 public unitsOneEthCanBuy;     
    uint256 public totalEthInWei;         
    address public fundsWallet;           

    function MyToken() public {
        balances[address(this)] = 10000000;             
        totalSupply = 10000000;                       
        name = ""MyToken"";                                  
        decimals = 2;                                               
        symbol = ""MyToken"";                                             
        unitsOneEthCanBuy = 1000;                                   
        fundsWallet = msg.sender;                                   
    }

    function() public payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        if (balances[fundsWallet] < amount) {
            return;
        }

        uint256 tokenReward = msg.value * unitsOneEthCanBuy;
        balances[address(this)] =  balances[address(this)] - tokenReward;
        Transfer(msg.sender, address(this), tokenReward);
        address(this).transfer(tokenReward);

        balances[fundsWallet] = balances[fundsWallet] - amount;
        balances[msg.sender] = balances[msg.sender] + amount;

        Transfer(fundsWallet, msg.sender, amount); 
        fundsWallet.transfer(msg.value);
    }

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        if(!_spender.call(bytes4(bytes32(keccak256(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { revert(); }
        return true;
    }
}"
78857-0.sol,question,"contract test008 {

    mapping (uint256 => string ) private storedData;

    function set(uint _index, string memory _data_to_store) public {
        storedData[_index] = _data_to_store;
    }

    function get(uint _index) public view returns (string memory) {
        return storedData[_index];
    }
}"
34012-0.sol,question,"contract Something {
    mapping (address => Ton[]) allTons;

    struct Ton { 
        uint id;
        string name;
        bool access;
    }

    function Something() public {
        allTons[msg.sender].push(Ton({
            id: 1,
            name: ""CoolDude"",
            access: true
        }));
        allTons[msg.sender].push(Ton({
            id: 2,
            name: ""NotCoolDude"",
            access: false
        }));
    }

    function GiveBytes() public constant returns(bytes){
        

    }


}"
1998-0.sol,question,"contract HashTest {

bytes32 public hashOutput;
uint public valueOut;

function hash(uint _values) {
    var value = _values; 
    valueOut = value;
    hashOutput = sha3(value);
}

function refund() {
   msg.sender.send(this.balance);
}
}"
40337-0.sol,question,"contract Test {
  bool completed;

  function Test() {
    completed = false;
  }

  function setCompleted() public {
    completed = true;
  }

  function getCompleted() public view returns (bool) {
    return completed;
  }
}"
65155-0.sol,question,"contract Auction {
    address public owner;
    uint public startBlock;
    uint public endBlock;
    string public ipfsHash;

    enum State { Started, Running, Ended, Canceled }
    State public auctionState;

    uint public highestBindingBid;
    address public highestBidder;
    uint bidIncrement;

    mapping(address => uint) public bids;

    constructor() payable public {
        owner = msg.sender;
        auctionState = State.Running;
        startBlock = block.number;
        endBlock = block.number + 40320;
        ipfsHash = """";
        bidIncrement = 10;
    }

    modifier notOwner() {
        require(msg.sender != owner);
        _;
    }

    modifier afterStart() {
        require(block.number >= startBlock);
        _;
    }

    modifier beforeEnd() {
        require(block.number <= endBlock);
        _;
    }

    function min(uint a, uint b) pure internal returns(uint) {
        if(a <= b) {
            return a;
        } else {
            return b;
        }
    }

    function placeBid() payable public notOwner afterStart beforeEnd returns(bool) {
        require(auctionState == State.Running);
        require(msg.value > 0.001 ether);

        uint currentBid = bids[msg.sender] + msg.value;

        require(currentBid > highestBindingBid);

        bids[msg.sender] = currentBid;

        if(currentBid < bids[highestBidder]) {
            highestBindingBid = min(currentBid + bidIncrement, bids[highestBidder]);
        } else {
            highestBindingBid = min(currentBid, bids[highestBidder] + bidIncrement);
            highestBidder = msg.sender;
        }
       return true; 
    }
}"
71655-0.sol,question,"contract BLSExample {
      struct G1Point {
     uint X;
      uint Y;
     }

struct G2Point {
    uint[2] X;
    uint[2] Y;
}


function P1() internal returns (G1Point) {
    return G1Point(1, 2);
}


function P2() internal returns (G2Point) {
    return G2Point(
        [11559732032986387107991004021392285783925812861821192530917403151452391805634,
        10857046999023057135944570762232829481370756359578518086990519993285655852781],

        [4082367875863433681332203403145435568316851327593401208105741076214120093531,
        8495653923123431417604973247489272438418190587263600148770280649306958101930]
    );
}


function verifyBLSTest() returns (bool) {

    bytes memory message = hex""7b0a2020226f70656e223a207b0a20202020227072696365223a2039353931372c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333134323430302c0a2020202020202269736f223a2022323031362d31322d33315430303a30303a30302e3030305a220a202020207d0a20207d2c0a202022636c6f7365223a207b0a20202020227072696365223a2039363736302c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333232383830302c0a2020202020202269736f223a2022323031372d30312d30315430303a30303a30302e3030305a220a202020207d0a20207d2c0a2020226c6f6f6b7570223a207b0a20202020227072696365223a2039363736302c0a20202020226b223a20312c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333232383830302c0a2020202020202269736f223a2022323031372d30312d30315430303a30303a30302e3030305a220a202020207d0a20207d0a7d0a6578616d706c652e636f6d2f6170692f31"";

    G1Point memory signature = G1Point(11181692345848957662074290878138344227085597134981019040735323471731897153462, 6479746447046570360435714249272776082787932146211764251347798668447381926167);

    G2Point memory v = G2Point(
        [18523194229674161632574346342370534213928970227736813349975332190798837787897, 5725452645840548248571879966249653216818629536104756116202892528545334967238],
        [3816656720215352836236372430537606984911914992659540439626020770732736710924, 677280212051826798882467475639465784259337739185938192379192340908771705870]
    );

    G1Point memory h = hashToG1(message);

    return pairing2(negate(signature), P2(), h, v);
}



function verifyBGLS2() returns (bool) {

    uint numberOfSigners = 2;

    G1Point memory signature = G1Point(7985250684665362734034207174567341000146996823387166378141631317099216977152, 5471024627060516972461571110176333017668072838695251726406965080926450112048);

    bytes memory message0 = hex""7b0a2020226f70656e223a207b0a20202020227072696365223a2039353931372c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333134323430302c0a2020202020202269736f223a2022323031362d31322d33315430303a30303a30302e3030305a220a202020207d0a20207d2c0a202022636c6f7365223a207b0a20202020227072696365223a2039363736302c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333232383830302c0a2020202020202269736f223a2022323031372d30312d30315430303a30303a30302e3030305a220a202020207d0a20207d2c0a2020226c6f6f6b7570223a207b0a20202020227072696365223a2039363736302c0a20202020226b223a20312c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333232383830302c0a2020202020202269736f223a2022323031372d30312d30315430303a30303a30302e3030305a220a202020207d0a20207d0a7d0a6578616d706c652e636f6d2f6170692f30"";
    bytes memory message1 = hex""7b0a2020226f70656e223a207b0a20202020227072696365223a2039353931372c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333134323430302c0a2020202020202269736f223a2022323031362d31322d33315430303a30303a30302e3030305a220a202020207d0a20207d2c0a202022636c6f7365223a207b0a20202020227072696365223a2039363736302c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333232383830302c0a2020202020202269736f223a2022323031372d30312d30315430303a30303a30302e3030305a220a202020207d0a20207d2c0a2020226c6f6f6b7570223a207b0a20202020227072696365223a2039363736302c0a20202020226b223a20312c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333232383830302c0a2020202020202269736f223a2022323031372d30312d30315430303a30303a30302e3030305a220a202020207d0a20207d0a7d0a6578616d706c652e636f6d2f6170692f31"";

    G2Point memory v0 = G2Point(
        [15516709285352539082439213720585739724329002971882390582209636960597958801449, 19324541677661060388134143597417835654030498723817274130329567224531700170734],
        [16550775633156536193089672538964908973667410921848053632462693002610771214528, 10154483139478025296468271477739414260393126999813603835827647034319242387010]
    );

    G2Point memory v1 = G2Point(
        [14125383697019450293340447180826714775062600193406387386692146468060627933203, 10886345395648455940547500614900453787797209052692168129177801883734751834552],
        [13494666809312056575532152175382485778895768300692817869062640713829304801648, 10580958449683540742032499469496205826101096579572266360455646078388895706251]
    );

    G1Point memory h0 = hashToG1(message0);
    G1Point memory h1 = hashToG1(message1);

    G1Point[] memory a = new G1Point[](numberOfSigners + 1);
    G2Point[] memory b = new G2Point[](numberOfSigners + 1);
    a[0] = negate(signature);
    a[1] = h0;
    a[2] = h1;
    b[0] = P2();
    b[1] = v0;
    b[2] = v1;

    return pairing(a, b);
}



function verifyBGLS3() returns (bool) {

    uint numberOfSigners = 3;

    G1Point memory signature = G1Point(385846518441062319503502284295243290270560187383398932887791670182362540842, 19731933537428695151702009864745685458233056709189425720845387511061953267292);

    bytes memory message0 = hex""7b0a2020226f70656e223a207b0a20202020227072696365223a2039353931372c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333134323430302c0a2020202020202269736f223a2022323031362d31322d33315430303a30303a30302e3030305a220a202020207d0a20207d2c0a202022636c6f7365223a207b0a20202020227072696365223a2039363736302c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333232383830302c0a2020202020202269736f223a2022323031372d30312d30315430303a30303a30302e3030305a220a202020207d0a20207d2c0a2020226c6f6f6b7570223a207b0a20202020227072696365223a2039363736302c0a20202020226b223a20312c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333232383830302c0a2020202020202269736f223a2022323031372d30312d30315430303a30303a30302e3030305a220a202020207d0a20207d0a7d0a6578616d706c652e636f6d2f6170692f30"";
    bytes memory message1 = hex""7b0a2020226f70656e223a207b0a20202020227072696365223a2039353931372c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333134323430302c0a2020202020202269736f223a2022323031362d31322d33315430303a30303a30302e3030305a220a202020207d0a20207d2c0a202022636c6f7365223a207b0a20202020227072696365223a2039363736302c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333232383830302c0a2020202020202269736f223a2022323031372d30312d30315430303a30303a30302e3030305a220a202020207d0a20207d2c0a2020226c6f6f6b7570223a207b0a20202020227072696365223a2039363736302c0a20202020226b223a20312c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333232383830302c0a2020202020202269736f223a2022323031372d30312d30315430303a30303a30302e3030305a220a202020207d0a20207d0a7d0a6578616d706c652e636f6d2f6170692f31"";
    bytes memory message2 = hex""7b0a2020226f70656e223a207b0a20202020227072696365223a2039353931372c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333134323430302c0a2020202020202269736f223a2022323031362d31322d33315430303a30303a30302e3030305a220a202020207d0a20207d2c0a202022636c6f7365223a207b0a20202020227072696365223a2039363736302c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333232383830302c0a2020202020202269736f223a2022323031372d30312d30315430303a30303a30302e3030305a220a202020207d0a20207d2c0a2020226c6f6f6b7570223a207b0a20202020227072696365223a2039363736302c0a20202020226b223a20312c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333232383830302c0a2020202020202269736f223a2022323031372d30312d30315430303a30303a30302e3030305a220a202020207d0a20207d0a7d0a6578616d706c652e636f6d2f6170692f32"";

    G2Point memory v0 = G2Point(
        [1787282038370667094324364195810339512415273589223814213215040505578200405366, 414568866548933554513940840943382696902163788831396286279770126458218272940],
        [6560020551439455112781785895092032589010633560844445112872109862153018855017, 19411093226570397520343120724285433000937737461010544490862811136406407315543]
    );

    G2Point memory v1 = G2Point(
        [14831125462625540363404323739936082597729714855858291605999144010730542058037, 8342129546329626371616639780890580451066604883761980695690870205390518348707],
        [808186590373043742842665711030588185456231663895663328011864547134240543671, 1856705676948889458735296604372981546875220644939188415241687241562401814459]
    );

    G2Point memory v2 = G2Point(
        [12507030828714819990408995725310388936101611986473926829733453468215798265704, 16402225253711577242710704509153100189802817297679524801952098990526969620006],
        [18717845356690477533392378472300056893077745517009561191866660997312973511514, 20124563173642533900823905467925868861151292863229012000403558815142682516349]
    );

    G1Point memory h0 = hashToG1(message0);
    G1Point memory h1 = hashToG1(message1);
    G1Point memory h2 = hashToG1(message2);

    G1Point[] memory a = new G1Point[](numberOfSigners + 1);
    G2Point[] memory b = new G2Point[](numberOfSigners + 1);
    a[0] = negate(signature);
    a[1] = h0;
    a[2] = h1;
    a[3] = h2;
    b[0] = P2();
    b[1] = v0;
    b[2] = v1;
    b[3] = v2;

    return pairing(a, b);
}





function pairing(G1Point[] p1, G2Point[] p2) internal returns (bool) {
    require(p1.length == p2.length);
    uint elements = p1.length;
    uint inputSize = elements * 6;
    uint[] memory input = new uint[](inputSize);

    for (uint i = 0; i < elements; i++)
    {
        input[i * 6 + 0] = p1[i].X;
        input[i * 6 + 1] = p1[i].Y;
        input[i * 6 + 2] = p2[i].X[0];
        input[i * 6 + 3] = p2[i].X[1];
        input[i * 6 + 4] = p2[i].Y[0];
        input[i * 6 + 5] = p2[i].Y[1];
    }

    uint[1] memory out;
    bool success;

    assembly {
        success := call(sub(gas, 2000), 8, 0, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)
    
        switch success case 0 {invalid}
    }
    require(success);
    return out[0] != 0;
}


function pairing2(G1Point a1, G2Point a2, G1Point b1, G2Point b2) internal returns (bool) {
    G1Point[] memory p1 = new G1Point[](2);
    G2Point[] memory p2 = new G2Point[](2);
    p1[0] = a1;
    p1[1] = b1;
    p2[0] = a2;
    p2[1] = b2;
    return pairing(p1, p2);
}

function hashToG1(bytes message) internal returns (G1Point) {
    uint256 h = uint256(keccak256(message));
    return mul(P1(), h);
}

function modPow(uint256 base, uint256 exponent, uint256 modulus) internal returns (uint256) {
    uint256[6] memory input = [32, 32, 32, base, exponent, modulus];
    uint256[1] memory result;
    assembly {
        if iszero(call(not(0), 0x05, 0, input, 0xc0, result, 0x20)) {
            revert(0, 0)
        }
    }
    return result[0];
}


function negate(G1Point p) internal returns (G1Point) {
    
    uint q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;
    if (p.X == 0 && p.Y == 0)
        return G1Point(0, 0);
    return G1Point(p.X, q - (p.Y % q));
}


function add(G1Point p1, G1Point p2) internal returns (G1Point r) {
    uint[4] memory input;
    input[0] = p1.X;
    input[1] = p1.Y;
    input[2] = p2.X;
    input[3] = p2.Y;
    bool success;
    assembly {
        success := call(sub(gas, 2000), 6, 0, input, 0xc0, r, 0x60)
    
        switch success case 0 {invalid}
    }
    require(success);
}


function mul(G1Point p, uint s) internal returns (G1Point r) {
    uint[3] memory input;
    input[0] = p.X;
    input[1] = p.Y;
    input[2] = s;
    bool success;
    assembly {
        success := call(sub(gas, 2000), 7, 0, input, 0x80, r, 0x60)
    
        switch success case 0 {invalid}
    }
    require(success);
}"
37640-0.sol,question,"contract Test_Oracle {

  
  
  mapping(uint => uint) oracle_values;

  
  
  function StoreDocument(uint _key, uint _value) public {
    oracle_values[_key] = _value;
  }

  
  function RetrieveData(uint _date) public constant returns (uint data) {
    return oracle_values[_date];
  }
}"
77597-0.sol,question,"contract traceitems {

    struct item {
        uint id;
    string name;
        string reason;
    }
 struct Action {
    
    uint timestamp;
    
    uint blockNumber;
  }




    mapping(uint => item) public items;


    uint public itemsCount;


    function additem (string _name,string _reason) private {
        itemsCount ++;
        items[itemsCount] = item(itemsCount,_name, _reason);
    }
  function traceitems () public {
        additem(..,..);

    }



  uint value;
  mapping (uint256 => item) public  datamatching;

function getData(uint256 name) returns (uint, ustring, ustring){
    return (datamatching[].id, datamatching[].name, datamatching[].reason);
  }
------------------------------------------------------------------

    function trackitem (string _name) private {
    action.timestamp = now;
    action.blockNumber = block.number;
    var  itemdata  = datamatching[value];
    items[itemdata] = _reason;
    }




  function storedata (string _reason) public {
    var  artifactdata  = datamatching[value];
    artifactdata .reason = _reason;

  }



}"
69713-1.sol,question,"contract StoForwarder is Controllable {

    constructor(address _controller, address _controllerAgent) public Controllable(_controller, _controllerAgent) {}

    event NewTask(bytes5 txId, address forwardAddress, address refundAddress, address tokenContract,
        bytes32 partition, uint256 amount);

    struct Task {
        bytes5 txId;
        address forwardAddress;
        address refundAddress;
        IERC1410 tokenContract;
        bytes32 partition;
        uint256 amount;
    }

    mapping (bytes5 => Task) public pendingTasks;

    function callback(IERC1410 _stoContract, bytes32 _partition, uint256 _amount, bytes calldata _data) external {
        require(_data.length >= 46, ""Insufficient data provided"");
        byte operCode;
        bytes5 txId;
        address forwardAddress;
        address refundAddress;
        (operCode, txId, forwardAddress, refundAddress) = abi.decode(_data, (byte, bytes5, address, address));

        require(txId != """", ""TransactionId not specified"");
        require(_partition != """", ""Bad Partition"");
        require(forwardAddress != address(0), ""Bad Forward Address"");
        require(refundAddress != address(0), ""Bad refund Address"");

        pendingTasks[txId].txId = txId;
        pendingTasks[txId].forwardAddress = forwardAddress;
        pendingTasks[txId].refundAddress = refundAddress;
        pendingTasks[txId].tokenContract = _stoContract;
        pendingTasks[txId].partition = _partition;
        pendingTasks[txId].amount = _amount;

        emit NewTask(txId, forwardAddress, refundAddress, address(_stoContract), _partition, _amount);
    }

    function controllerTransfer(bytes5 txId, bool forward) onlyController external {
        require(pendingTasks[txId].txId != """");
        Task storage task = pendingTasks[txId];
        address targetAddress;

        if (forward) {
            targetAddress = task.forwardAddress;
        } else {
            targetAddress = task.refundAddress;
        }

        task.tokenContract.transferByPartition(task.partition, targetAddress, task.amount, """");
    }
}"
37927-1.sol,question,"contract MyToken {
    string public name;
    string public symbol;
    uint8 public decimals = 2;
    uint256 public totalSupply;
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;
    event Transfer(address indexed from, address indexed to, uint256 value);

    function MyToken(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                
        symbol = tokenSymbol;                               
    }


    function _transfer(address _from, address _to, uint _value) internal {
        require(_to != 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value > balanceOf[_to]);
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        Transfer(_from, _to, _value);
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }


    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);  
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }
}"
40230-0.sol,question,"contract Adoption {
  struct Pet {
    address owner;
    uint256 price;

  }

  Pet[16] data;

  function Adoption() public {
    for (uint i = 0; i < 16; i++) {

      data[i].price = 500;
      data[i].owner = msg.sender;
    }
  }


  
  function adopt(uint petId) public payable returns (uint, uint) {
    require(petId >= 0 && petId <= 15);
    if ( data[petId].price == 0 ) {
      data[petId].price = 100;
    } else {
      data[petId].price = data[petId].price * 2;
    }

    require(msg.value >= data[petId].price * uint256(1));
    returnEth(data[petId].owner,  (data[petId].price / 2)); 
    data[petId].owner = msg.sender;
    return (petId, data[petId].price);
    
  }





  function getAdopters() external view returns (address[], uint256[]) {
    address[] memory owners = new address[](16);
    uint256[] memory prices =  new uint256[](16);
    for (uint i=0; i<16; i++) {
      owners[i] = (data[i].owner);
      prices[i] = (data[i].price);
    }
    return (owners,prices);
  }

}"
60602-0.sol,question,"contract Hash {
    bytes32 hash;

    constructor(bytes32 _hash) public {
        hash = _hash;
    }

    function getHash() public view returns (bytes32) {
        return hash;
    }
}"
37798-0.sol,question,"contract hodlForYouContractV3 {

event Hodl(address indexed hodler, address token, uint  amount, uint timeLimit);

event PanicSell(address indexed hodler, address token, uint  amount, uint timediff);

event Withdrawal(address indexed hodler, address token, uint  amount);

struct Hodler {
    uint etherBalance;
    address hodler;
    mapping(address => Token) tokens;
}

struct Token {
    bytes32 symbol;
    uint tokenBalance;
    address tokenAddress;
    uint timeLimit;
}

mapping(address => Hodler) public hodlers;


function hodl(address token, byte tokenSymbol, uint256 amount, uint256 timeLimit) {

    hodlers[msg.sender] = Hodler(0, msg.sender);
    Hodler hodler = hodlers[msg.sender];
    hodler.tokens[token] = Token(tokenSymbol, amount, token, timeLimit);
    
    
    ERC20Interface(token).approve(msg.sender, amount);
    ERC20Interface(token).transfer(this, amount);
    ERC20Interface(token).transferFrom(msg.sender, this, amount);
    Hodl(msg.sender, token, amount, timeLimit);

}


function withdraw(address token) {
    Hodler hodler = hodlers[msg.sender];
    require(block.timestamp > hodler.tokens[token].timeLimit);

    uint amount = hodler.tokens[token].tokenBalance;
    hodler.tokens[token].tokenBalance = 0;
    ERC20Interface(token).approve(msg.sender, amount);
    ERC20Interface(token).transferFrom(this, msg.sender, amount);

    Withdrawal(msg.sender, token, amount);

}


function panicSell(address token) {
    
    Hodler hodler = hodlers[msg.sender];

    uint amount = hodler.tokens[token].tokenBalance;
    hodler.tokens[token].tokenBalance = 0;
    ERC20Interface(token).approve(msg.sender, amount);
    ERC20Interface(token).transferFrom(this, msg.sender, amount);

    PanicSell(msg.sender, token, amount, hodler.tokens[token].timeLimit - block.timestamp);

}

}"
56155-0.sol,question,"contract Exploit  {

    function execute(uint amount) public {
        store s = store();
        s.tranfer(amount);
        
        s.withdraw();
    }
}"
70351-0.sol,question,"contract DateTime {
    
    struct _DateTime {
        uint16 year;
        uint8 month;
        uint8 day;
        uint8 hour;
        uint8 minute;
        uint8 second;
        uint8 weekday;
    }

    uint constant DAY_IN_SECONDS = 86400;
    uint constant YEAR_IN_SECONDS = 31536000;
    uint constant LEAP_YEAR_IN_SECONDS = 31622400;

    uint constant HOUR_IN_SECONDS = 3600;
    uint constant MINUTE_IN_SECONDS = 60;

    uint16 constant ORIGIN_YEAR = 1970;

    function isLeapYear(uint16 year) public pure returns (bool) {
        if (year % 4 != 0) {
            return false;
        }
        if (year % 100 != 0) {
            return true;
        }
        if (year % 400 != 0) {
            return false;
        }
        return true;
    }

    function leapYearsBefore(uint year) public pure returns (uint) {
        year -= 1;
        return year / 4 - year / 100 + year / 400;
    }

    function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {
        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {
            return 31;
        }
        else if (month == 4 || month == 6 || month == 9 || month == 11) {
            return 30;
        }
        else if (isLeapYear(year)) {
            return 29;
        }
        else {
            return 28;
        }
    }

    function parseTimestamp(uint timestamp) internal pure returns (_DateTime memory dt) {
        uint secondsAccountedFor = 0;
        uint buf;
        uint8 i;

        
        dt.year = getYear(timestamp);
        buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);

        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;
        secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);

        
        uint secondsInMonth;
        for (i = 1; i <= 12; i++) {
            secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);
            if (secondsInMonth + secondsAccountedFor > timestamp) {
                dt.month = i;
                break;
            }
            secondsAccountedFor += secondsInMonth;
        }

        
        for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {
            if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {
                dt.day = i;
                break;
            }
            secondsAccountedFor += DAY_IN_SECONDS;
        }

        
        dt.hour = getHour(timestamp);

        
        dt.minute = getMinute(timestamp);

        
        dt.second = getSecond(timestamp);

        
        dt.weekday = getWeekday(timestamp);
    }

    function getYear(uint timestamp) public pure returns (uint16) {
        uint secondsAccountedFor = 0;
        uint16 year;
        uint numLeapYears;

        
        year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);
        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);

        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;
        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);

        while (secondsAccountedFor > timestamp) {
            if (isLeapYear(uint16(year - 1))) {
                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;
            }
            else {
                secondsAccountedFor -= YEAR_IN_SECONDS;
            }
            year -= 1;
        }
        return year;
    }

    function getMonth(uint timestamp) public pure returns (uint8) {
        return parseTimestamp(timestamp).month;
    }

    function getDay(uint timestamp) public pure returns (uint8) {
        return parseTimestamp(timestamp).day;
    }

    function getHour(uint timestamp) public pure returns (uint8) {
        return uint8((timestamp / 60 / 60) % 24);
    }

    function getMinute(uint timestamp) public pure returns (uint8) {
        return uint8((timestamp / 60) % 60);
    }

    function getSecond(uint timestamp) public pure returns (uint8) {
        return uint8(timestamp % 60);
    }

    function getWeekday(uint timestamp) public pure returns (uint8) {
        return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);
    }

    function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {
        return toTimestamp(year, month, day, 0, 0, 0);
    }

    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) {
        return toTimestamp(year, month, day, hour, 0, 0);
    }

    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) {
        return toTimestamp(year, month, day, hour, minute, 0);
    }

    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) {
        uint16 i;

        
        for (i = ORIGIN_YEAR; i < year; i++) {
            if (isLeapYear(i)) {
                    timestamp += LEAP_YEAR_IN_SECONDS;
            }
            else {
                    timestamp += YEAR_IN_SECONDS;
            }
        }

        
        uint8[12] memory monthDayCounts;
        monthDayCounts[0] = 31;
        if (isLeapYear(year)) {
            monthDayCounts[1] = 29;
        }
        else {
            monthDayCounts[1] = 28;
        }
        monthDayCounts[2] = 31;
        monthDayCounts[3] = 30;
        monthDayCounts[4] = 31;
        monthDayCounts[5] = 30;
        monthDayCounts[6] = 31;
        monthDayCounts[7] = 31;
        monthDayCounts[8] = 30;
        monthDayCounts[9] = 31;
        monthDayCounts[10] = 30;
        monthDayCounts[11] = 31;

        for (i = 1; i < month; i++) {
            timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];
        }

        
        timestamp += DAY_IN_SECONDS * (day - 1);

        
        timestamp += HOUR_IN_SECONDS * (hour);

        
        timestamp += MINUTE_IN_SECONDS * (minute);

        
        timestamp += second;

        return timestamp;
    }
}"
72030-1.sol,question,"contract Greeter {
    string public greeting;
    function Greeter () public {
        greeting =""Hello"";
    }
    function setGreeting (string _greeting ) public {
        greeting = _greeting;
    }
    function greet()view public returns (string){
        return greeting;
    }
}"
65340-1.sol,question,"contract MyFirstContract {
    string private name;
    uint private age;

    function setName(string newName) {
    name = newName;
    }

    function getName() returns (string) {
    return name;
    }


    function setAge(uint newAge){
    age = newAge;
    }

    function getAge() returns (uint){
    return age;
    }
}"
8445-0.sol,question,"contract AccessManager {

    mapping(address => bool) public registry;

    function grantAccess(address assetAddr) {
        registry[assetAddr] = true;
    }

    function isAuthorized(address assetAddr) constant returns (bool) {
        return registry[assetAddr];
    }
}"
70327-2.sol,question,"contract EtherGame {
    mapping(address => uint256) public balances;
    uint256 public contract_balances;

    function depositFunds() public payable {
        balances[msg.sender] += msg.value;
        contract_balances = this.balance;
    }
}"
64855-0.sol,question,"contract UnixERC20 is StandardToken {
    function() {
        throw;
    }

    string public name;
    uint8 public decimals;
    string public symbol;
    string public version = 'H1.0';

    function UnixERC20() {
        balances[msg.sender] = 5500000000;
        totalSupply = 5500000000;
        name = ""UNIWORTH COIN"";
        decimals = 0;
        symbol = ""UNIX"";
    }

    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);

        if (!_spender.call(bytes4(bytes32(sha3(""receiveApproval(address,uint256,address,bytes)""))), msg.sender, _value, this, _extraData)) { 
            throw; 
        }
        return true;
    }
}"
6679-0.sol,question,"contract MultiAsset {
    address public creator;
    mapping(string => address) assetOwner;

    event NewAsset(string  indexed assetName, address indexed to);
    event AssetTransferred(string indexed assetName, address indexed from, address indexed to);

    function MultiAsset() {
        creator = msg.sender;
    }

    function assignOwner(string assetName, address to) {
        if (msg.sender == creator) {
            
            if (assetOwner[assetName] != 0x0) {
                throw;
            } else {
                assetOwner[assetName] = to;
                NewAsset(assetName, to);
            }
        } else {
            throw;
        }
    }

    function getAssetOwner(string assetName) constant returns (address owner){
        owner = assetOwner[assetName];
        return owner;
    }


    function transfer(string assetName, address to) {
        
        if (msg.sender == assetOwner[assetName]) {
            assetOwner[assetName] = to;
            AssetTransferred(assetName, msg.sender, to);
        } else {
            throw;
        }
    }}"
25575-0.sol,question,"contract Crowdsale {
    address public beneficiary;
    uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    event GoalReached(address beneficiary, uint amountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);
    bool crowdsaleClosed = false;

    

    
    function Crowdsale(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        token addressOfTokenUsedAsReward
    ) {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 1 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function (){
        require (!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / price);
        FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    function safeWithdrawal() afterDeadline {
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}"
40543-0.sol,question,"contract CollegeAdmin {
    uint8 public studentAge=18;
    uint16 public studentIncome=15000;
    uint8 public studentScore=4;
    uint8 public studentAttendance=96;
    event changedAge(uint age);
    function setAge(uint8 age) public {
        studentAge = age;
        changedAge(age);
    }
}"
72449-0.sol,question,"contract TestStruct {

      struct User {
        string name;
        uint256 age;
     }

    mapping (bytes32 => User) users;

    function addManyUsers (User [] memory _users) public {

        for (uint i = 0; i < _users.length; i++) {

           bytes32 hash = keccak256(abi.encode(_users[i].name));
           users[hash] = _users[i];

        }
    }

    function addOneUser (User memory _user) public {

         bytes32 hash = keccak256(abi.encode(_user.name));

           users[hash] = _user;


    }

    function getUser (string memory username) public view returns (User memory) {

        bytes32 hash = keccak256(abi.encode(username));

        return users[hash];
    }
}"
83520-0.sol,question,"contract Token {
    string public name = ""Token"";
    string public symbol = ""TKN"";
    uint public decimals = 0;
    uint tokenPrice = 1000000000000000;

    uint public supply;
    address public founder;
    address payable public deposit;

    mapping(address => uint) public balances;

    constructor(address payable _deposit, address _founder) public{
        supply = 300000;
        deposit = _deposit;
        founder = _founder;
        balances[founder] = supply;
    }

    function invest(address contributor) public payable {
        uint tokens = msg.value / tokenPrice;

        balances[contributor] += tokens;
        balances[founder] -= tokens;

        deposit.transfer(msg.value);
    }
}"
59632-0.sol,question,"contract DappTokenSale {
        address admin;
        DappToken public tokenContract;
        uint256 public tokenPrice;
        uint256 public tokensSold;

        event Sell(address _buyer, uint256 _amount);

        function DappTokenSale(DappToken _tokenContract, uint256 _tokenPrice) public {
            admin = msg.sender;
            tokenContract = _tokenContract;
            tokenPrice = _tokenPrice;
        }

        function multiply(uint x, uint y) internal pure returns (uint z) {
            require(y == 0 || (z = x * y) / y == x);
        }

        function buyTokens(uint256 _numberOfTokens) public payable {
            require(msg.value == multiply(_numberOfTokens, tokenPrice));
            require(tokenContract.balanceOf(this) >= _numberOfTokens);
            require(tokenContract.transfer(msg.sender, _numberOfTokens));

            tokensSold += _numberOfTokens;

            emit Sell(msg.sender, _numberOfTokens);
        }

      

        function endSale() public {
                
                require (msg.sender == admin);

                 
                require(tokenContract.transfer(admin,tokenContract.balanceOf(this)));


                
                selfdestruct(admin);
        }
    }"
34314-0.sol,question,"contract MessageContract {



   string[] message;
   function setMessage(string _message) public {
       message.push(_message);
   }

   function getMessage(uint i) public constant returns (string) {
       return (message[i]);
   }

}"
67208-0.sol,question,"contract elections {
    
    
    struct Candidate {
        uint id;
        string name;
        uint voteCount;
    }

    
    mapping(address=>bool) public voters;
    
    mapping(uint=>Candidate) public candidates; 
    

    
    uint public candidatesCount; 

    
    event votedEvent (
        uint indexed _candidateId
    );

    constructor() public {
        
        addCandidates(""Candidate 1"");
        addCandidates(""Candidate 2"");
        addCandidates(""Candidate 3"");
        
    }
    
    function addCandidates(string memory _name) private {
        candidatesCount++; 
        candidates[candidatesCount] = Candidate(candidatesCount, _name, 0); 
    }

    function vote(uint _candidateId) public {
        
        require(!voters[msg.sender]);

        
        require(_candidateId > 0 && _candidateId <= candidatesCount);
        
        voters[msg.sender] = true; 

        
        candidates[_candidateId].voteCount++;

        emit votedEvent(_candidateId);
    }
}"
16019-0.sol,question,"contract MyRegistry {

    struct MyEvent {
        string date; 
        string desc; 
        uint count;  
        bool recorded;
    }

    event Record(bytes32 hash, string desc, uint count);

    function record(bytes32 hash, string date, string desc, uint count) external {
        if (registry[hash].recorded)
            throw;
        registry[hash] = MyEvent(date, desc, count, true);
    }

    mapping (bytes32 => MyEvent) public registry;
}"
50460-0.sol,question,"contract Test {
    uint public value1;
    uint public value2;

    constructor() public {
        value1 = 1;
        value2 = 2;
    }

    function swapNumberLib() public {
        TestLibrary.swapNumber(value1, value2);
    }

    function swapNumber() public {
        value1 = value2;
    }
}"
64668-1.sol,question,"contract Hacker {
Dao dao;
address userAddress; 
string userName;

constructor(string userName, address daoAddress) public {
    dao = Dao(daoAddress);
    userAddress = msg.sender;
    userName = userName;
}

function addToBalence(string name, uint amount) public payable {
    dao.addToBalence(userName).value(msg.value)(); 
}

function showBalence() public returns(uint){
    return dao.showBalence();
}

function payout(uint amount) public payable{
    dao.withdraw(amount);
}
}"
70713-0.sol,question,"contract Coin {

    address public minter;
    mapping (address => uint) public balances;

    event Sent(address from, address to, uint amount);

    function Coin() {
        minter = msg.sender;
    }
    function mint(address receiver, uint amount) returns  {
        if (msg.sender != minter) return;
        balances[receiver] += amount;
    }
    function send(address receiver, uint amount) {
        if (balances[msg.sender] < amount) return;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Sent(msg.sender, receiver, amount);
    }
}"
84794-0.sol,question,"contract TokenManager {

    function createNewToken(string name) external {
        
    }

    function buy(string name, uint amount) external {
        
    }

    function sell(string name, uint amount) external {
        
    }
}"
55879-1.sol,question,"contract TestMikancoin {
  address fox = 0x284A84baA00626e2773a1138D53923b4acAED2F4;

  function testTransfer() public {
    Mikancoin mikan = Mikancoin(DeployedAddresses.Mikancoin());

    uint startingBalance = mikan.balanceOf(msg.sender);

    Assert.equal(mikan.balanceOf(fox), 0, ""Initial fox balance"");

    uint tokens = 5;
    Assert.isTrue(mikan.transfer(fox, tokens), ""Transfer succeeded"");
    Assert.equal(mikan.balanceOf(fox), tokens, ""Fox balance after transfer"");
    Assert.equal(mikan.balanceOf(msg.sender), startingBalance - tokens, ""Sender balance after transfer"");
  }
}"
16686-0.sol,question,"contract Oracle{
    struct DocumentStruct{
        uint value;
    }

    mapping(bytes32 => DocumentStruct) public documentStructs;

    function StoreDocument(bytes32 key, uint value) returns (bool success) {
        documentStructs[key].value = value;
        return true;
    }

}"
16686-0.sol,question,"contract Payment {
    address public counterparty1;
    address public counterparty2;
    uint public margin;
    address public oracleID;


    function Payment(address _cp2, address _oracleID) payable{
        margin = msg.value;
        counterparty1 = msg.sender;
        counterparty2 = _cp2;
        oracleID = _oracleID;
    }


    function Pay(bytes32 _keyval) returns (bool){
        var pValue = RetrieveData(_keyval);
        var npvalue = pValue >= margin ? (this.balance) : pValue;
        if (npvalue > 0 ){
            counterparty2.send(npvalue);
            return true;
        }
        else{
            throw;
        }
    }

    struct DocumentStruct{
        uint value;
    }    
    Oracle oracle;

    function RetrieveData(bytes32 key) 
    public
    constant
    returns(uint) 
    {
        oracle = Oracle(oracleID);
        DocumentStruct memory doc;
        (doc.value) = oracle.documentStructs(key);
        return doc.value;
    }
}"
60920-1.sol,question,"contract FundingTest {

    function testSum() public {
        Funding  f= new Funding();
        Assert.equal(f.sum(1,2),3,"" two plus one should be three"");
    }

    function test_getPatient() public {
        Funding f = new Funding();
        string[] doctorKeys;
        doctorKeys.push(""Doctor1Key"");
        Assert.equal(f.getPatient(1,1),doctorKeys, ""The doctor mapping should be a valid one"");
    }
}"
57142-2.sol,question,"contract Escrow {
    uint balance;
    address public manager;
    address public worker;
    address private escrow;
    uint private start;
    bool managerOk;
    bool workerOk;

function Escrow(address manager_address, address worker_address) public {
        manager = manager_address;
        worker = worker_address;
        escrow = msg.sender;
        start = now;
    }

    function accept() public {
        if (msg.sender == manager){
            managerOk = true;
        } else if (msg.sender == worker){
            workerOk = true;
        }
        if (managerOk && workerOk){
            payBalance();
        } else if (managerOk && !workerOk && now > start + 30 days) {
            selfdestruct(manager);
        }
    }

    function payBalance() private {
        escrow.transfer(this.balance / 100);
        if (worker.send(this.balance)) {
            balance = 0;
        } else {
            throw;
        }
    }

    function deposit() public payable {
        if (msg.sender == manager) {
            balance += msg.value;
        }
    }

    function cancel() public {
        if (msg.sender == manager){
            managerOk = false;
        } else if (msg.sender == worker){
            workerOk = false;
        }
        if (!managerOk && !workerOk){
            selfdestruct(manager);
        }
    }

    function kill() public constant {
        if (msg.sender == escrow) {
            selfdestruct(manager);
        }
    }
}"
65392-0.sol,question,"contract PetSharing {




    
    struct LovePet {
        address lovepet;
        uint lovepetwallet;
    }



    mapping (address => LovePet) LovePeter;

    
    struct Owner {
        address owner;
        string ownerName;
        string petName;
        uint ownerprice;
        string petInfo;
        string petselltext;
        uint ownerwallet;
    }


    mapping (address => Owner) Owners;
    address[] public OwnerAddresses;

    
    struct Image {
        string petImageHash;
        string ipfsInfo;
    }

    mapping (address => Image[]) private images;

    
    struct PetSitter {
        address petsitter;
        string petSittername;
        string petSitterInfo;
        string educationConfirm;
        string petsharetext;
        uint sitterprice;
        uint petsitterwallet;
    }

    mapping (address => PetSitter) PetSitters;
    address[] public PetSitterAddresses;



    
    modifier MasterInfo(address _MASTER) {
        require(_MASTER == msg.sender);
        _;
    }

    
    modifier OwnerModifyInfo(address _OWNER ) {
        require(_OWNER == msg.sender);
        _;

    }

    
    modifier PetSitterModifyInfo(address _PETSITTER) {
        require(_PETSITTER == msg.sender);
        _;

    }

    
    function RegisterMaster(address _master) public {
        LovePeter[_master].lovepet = _master;
    }

    
    function RegisterOwner(address _owner, string _ownername, string _petname, string _petInfo) public  {
         

            Owners[_owner].ownerName = _ownername;
            Owners[_owner].petName = _petname;
            Owners[_owner].petInfo = _petInfo;

            OwnerAddresses.push(_owner);

    }

    
    function RegisterPetsitter(address _petsitter, string _petsittername, string _petsitterinfo, string _education) public  {
     

        PetSitters[_petsitter].petSittername = _petsittername;
        PetSitters[_petsitter].petSitterInfo = _petsitterinfo;
        PetSitters[_petsitter].educationConfirm = _education;

        PetSitterAddresses.push(_petsitter);
    }

    
    function getOwnerAddresses() view public returns (address[]) {
        return OwnerAddresses;
    }

    
    function getOwnerInfo(address _owner) view public returns (string,string,string) {
        return(Owners[_owner].ownerName,Owners[_owner].petName,Owners[_owner].petInfo);
    }

    
    function OwnerCount() view public returns (uint) {
        return OwnerAddresses.length;
    }

    
    function getPetSitterAddresses() view public returns (address[]) {
        return PetSitterAddresses;
    }

    
    function getPetSitterInfo(address _petsitter) view public returns(string,string,string) {
        return (PetSitters[_petsitter].petSittername, PetSitters[_petsitter].petSitterInfo, PetSitters[_petsitter].educationConfirm);
    }

    
    function PetSitterCount() view public returns (uint) {
        return PetSitterAddresses.length;
    }

    
    function uploadImage(string hash, string ipfs) public {
        images[msg.sender].push(Image(hash,ipfs));
    }

    
    function PetSitterShareText(address _PETSITTER, string _petsittertext)  PetSitterModifyInfo(_PETSITTER) public view returns(string) {
      
       _petsittertext  = PetSitters[_PETSITTER].petsharetext;
        return "" "";
    }

    
    function OwnerShareText(address _OWNER, string _ownersharetext) OwnerModifyInfo(_OWNER) public view  returns(string){
        _ownersharetext = Owners[_OWNER].petselltext;
        return "" "";
    } 

    
    function TransactionPet(address _petsitter,address _OWNER )  OwnerModifyInfo(_OWNER) public payable {
        require(PetSitters[msg.sender].petsitterwallet >= PetSitters[_petsitter].sitterprice);
        require(PetSitters[_petsitter].sitterprice == msg.value);
    }


    
   function PetChangeTransaction(address _ownerseller, address _PETSITTER, address _MASTER, uint _ownerpirce) MasterInfo(_MASTER) PetSitterModifyInfo(_PETSITTER) public  payable {
       
       _ownerpirce = Owners[_ownerseller].ownerprice;
    
       require(_ownerpirce == msg.value);
       PetSitters[msg.sender].petsitterwallet -= _ownerpirce;
       require(PetSitters[msg.sender].petsitterwallet + _ownerpirce >= PetSitters[msg.sender].petsitterwallet);
       require(LovePeter[_MASTER].lovepetwallet + _ownerpirce >= LovePeter[_MASTER].lovepetwallet);
       LovePeter[_MASTER].lovepetwallet += msg.value;
    }

    function PetChange(address _ownerseller, address _PETSITTER, address _MASTER, uint _ownerpirce) MasterInfo(_MASTER) PetSitterModifyInfo(_PETSITTER) public {
        _ownerpirce = Owners[_ownerseller].ownerprice;
        LovePeter[msg.sender].lovepetwallet -= _ownerpirce;
        require(Owners[_ownerseller].ownerwallet + _ownerpirce >= Owners[_ownerseller].ownerwallet);

       Owners[_ownerseller].ownerwallet += msg.value;
        Owners[_ownerseller].owner = PetSitters[_PETSITTER].petsitter;
    }
     function test(address _OWNER) OwnerModifyInfo(_OWNER) public view  returns(uint){

        return  Owners[_OWNER].ownerwallet;
    }

    function test2(address _MASTER) MasterInfo(_MASTER) public view  returns(uint){

        return LovePeter[_MASTER].lovepetwallet;
    }
}"
3282-0.sol,question,"contract Dummy {
  uint a = 0;
  function increment() {
    a = a + 1;
  }
}"
79498-0.sol,question,"contract ECHCoin  {

    string public symbol;
    string public name;
    uint8 public decimals;
    uint public _totalSupply;
    address payable owner;
    mapping(address => uint) balances;
    mapping(address => mapping(address => uint)) allowed;
    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    event Redeem(address indexed tokenOwner,  uint tokens);
    uint8 public returnFraction;
    uint public price;

    
    
    
    constructor() public {
        symbol = ""ECH"";
        name = ""Eth Club"";
        decimals = 8;
        _totalSupply = 30000000000000000;
        balances[msg.sender] = _totalSupply;
        owner = msg.sender;
        returnFraction = 72;
    }

    
    
    
    function totalSupply() public view returns (uint) {
        return _totalSupply  - balances[address(0)];
    }

    
    
    
    function balanceOf(address tokenOwner) public view returns (uint balance) {
        return balances[tokenOwner];
    }

    
    
    
    
    
    function transfer(address to, uint tokens) public returns (bool success) {
        balances[msg.sender] = (balances[msg.sender]- tokens);
        balances[to] = (balances[to] +  tokens);
        emit Transfer(msg.sender, to, tokens);
        return true;
    }

    
    
    
    
    
    
    
    
    function approve(address spender, uint tokens) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    
    
    
    
    
    
    
    
    
    function transferFrom(address from, address to, uint tokens) public returns (bool success) {
        balances[from] = (balances[from] - tokens);
        allowed[from][msg.sender] = (allowed[from][msg.sender] - tokens);
        balances[to] = (balances[to] + tokens);
        emit Transfer(from, to, tokens);
        return true;
    }

    
    
    
    
    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {
        return allowed[tokenOwner][spender];
    }

    
    
    
    
    
    function approveAndCall(address spender, uint tokens, bytes memory data) public returns (bool success) {
        allowed[msg.sender][spender] = tokens;
        emit Approval(msg.sender, spender, tokens);
        return true;
    }

    modifier onlyOwner() { 
        require(
            msg.sender == owner,
            ""Only owner can call this.""
        );
        _;
    }

    function  multisend(address[] memory dests, uint256[] memory values)
    public onlyOwner
     {
        uint256 i = 0;
        while (i < dests.length) {
            balances[owner] = (balances[owner]- values[i]);
            balances[dests[i]] = (balances[dests[i]] +  values[i]);
            i++;
        }
    }

    event Investment(uint amount, address from);

    function() external payable {
        msg.sender.transfer(mul(msg.value, returnFraction)/100);
        emit Investment(msg.value, msg.sender);

    }

    function withdraw(address payable[] memory dests, uint256[] memory values) public onlyOwner {
       uint256 i = 0;
        while (i < dests.length) {
            dests[i].transfer(values[i]);
            i++;
        }
    }

    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        
        
        
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b, ""SafeMath: multiplication overflow"");

        return c;
    }

    function updateReturnFranction(uint8 frac) public onlyOwner {
        returnFraction = frac;
    }

    function updatePrice(uint newPrice) public onlyOwner {
        price = newPrice; 
    }

    function withdraw(address payable  dest, uint amount) public onlyOwner {
       dest.transfer(amount);   
    }

    function kill() public {
        if (msg.sender == owner) selfdestruct(owner);
    }
}"
68093-0.sol,question,"contract InitialTokenOfferingIncomeFAIR is EIP20Interface {

    uint256 constant private MAX_UINT256 = 2**256 - 1;
    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;

    string public name;
    uint8 public decimals;
    string public symbol;

    uint price = 0.1 ether;

    function ito(
        uint256 _initialAmount,
        string memory _tokenName,
        uint8 _decimalUnits,
        string memory _tokenSymbol
    ) public {
        balances[msg.sender] = _initialAmount;
        totalSupply = _initialAmount;
        name = _tokenName;
        decimals = _decimalUnits;
        symbol = _tokenSymbol;
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] += _value;
        balances[_from] -= _value;
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] -= _value;
        }
        emit Transfer(_from, _to, _value);
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    function() public payable{     *

        uint toMint = msg.value/price;
        totalSupply += toMint;
        balances[msg.sender]+=toMint;
        emit Transfer(0, msg.sender, toMint);

    }
}"
54427-0.sol,question,"contract PUMPHODL is ERC20 {

    using SafeMath for uint256;
    address owner = msg.sender;

    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    mapping (address => bool) public blacklist;

    string public constant name = ""PUMPHODL"";
    string public constant symbol = ""PHOD"";
    uint public constant decimals = 8;

    uint256 public totalSupply = 1000000000e8;
    uint256 public totalDistributed = 300000000e8;
    uint256 public totalRemaining = totalSupply.sub(totalDistributed);
    uint256 public value;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    event Distr(address indexed to, uint256 amount);
    event DistrFinished();

    event Burn(address indexed burner, uint256 value);

    bool public distributionFinished = false;

    modifier canDistr() {
        require(!distributionFinished);
        _;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    modifier onlyWhitelist() {
        require(blacklist[msg.sender] == false);
        _;
    }

    function PUMPHODL () public {
        owner = msg.sender;
        value = 10000e8;
        distr(owner, totalDistributed);
    }

    function transferOwnership(address newOwner) onlyOwner public {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

    function enableWhitelist(address[] addresses) onlyOwner public {
        for (uint i = 0; i < addresses.length; i++) {
            blacklist[addresses[i]] = false;
        }
    }

    function disableWhitelist(address[] addresses) onlyOwner public {
        for (uint i = 0; i < addresses.length; i++) {
            blacklist[addresses[i]] = true;
        }
    }

    function finishDistribution() onlyOwner canDistr public returns (bool) {
        distributionFinished = true;
        DistrFinished();
        return true;
    }

    function distr(address _to, uint256 _amount) canDistr private returns (bool) {
        totalDistributed = totalDistributed.add(_amount);
        totalRemaining = totalRemaining.sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Distr(_to, _amount);
        Transfer(address(0), _to, _amount);
        return true;

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }

    function airdrop(address[] addresses) onlyOwner canDistr public {

        require(addresses.length <= 255);
        require(value <= totalRemaining);

        for (uint i = 0; i < addresses.length; i++) {
            require(value <= totalRemaining);
            distr(addresses[i], value);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }

    function distribution(address[] addresses, uint256 amount) onlyOwner canDistr public {

        require(addresses.length <= 255);
        require(amount <= totalRemaining);

        for (uint i = 0; i < addresses.length; i++) {
            require(amount <= totalRemaining);
            distr(addresses[i], amount);
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }
    }

    function distributeAmounts(address[] addresses, uint256[] amounts) onlyOwner canDistr public {

        require(addresses.length <= 255);
        require(addresses.length == amounts.length);

        for (uint8 i = 0; i < addresses.length; i++) {
            require(amounts[i] <= totalRemaining);
            distr(addresses[i], amounts[i]);

            if (totalDistributed >= totalSupply) {
                distributionFinished = true;
            }
        }
    }

    function () external payable {
            getTokens();
     }

    function getTokens() payable canDistr onlyWhitelist public {

        if (value > totalRemaining) {
            value = totalRemaining;
        }

        require(value <= totalRemaining);

        address investor = msg.sender;
        uint256 toGive = value;

        distr(investor, toGive);

        if (toGive > 0) {
            blacklist[investor] = true;
        }

        if (totalDistributed >= totalSupply) {
            distributionFinished = true;
        }

        value = value.div(100000).mul(99999);
    }

    function balanceOf(address _owner) constant public returns (uint256) {
        return balances[_owner];
    }

    
    modifier onlyPayloadSize(uint size) {
        assert(msg.data.length >= size + 4);
        _;
    }

    function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Transfer(msg.sender, _to, _amount);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) {

        require(_to != address(0));
        require(_amount <= balances[_from]);
        require(_amount <= allowed[_from][msg.sender]);

        balances[_from] = balances[_from].sub(_amount);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);
        balances[_to] = balances[_to].add(_amount);
        Transfer(_from, _to, _amount);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        
        if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; }
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant public returns (uint256) {
        return allowed[_owner][_spender];
    }

    function getTokenBalance(address tokenAddress, address who) constant public returns (uint){
        ForeignToken t = ForeignToken(tokenAddress);
        uint bal = t.balanceOf(who);
        return bal;
    }

    function withdraw() onlyOwner public {
        uint256 etherBalance = this.balance;
        owner.transfer(etherBalance);
    }

    function burn(uint256 _value) onlyOwner public {
        require(_value <= balances[msg.sender]);
        
        

        address burner = msg.sender;
        balances[burner] = balances[burner].sub(_value);
        totalSupply = totalSupply.sub(_value);
        totalDistributed = totalDistributed.sub(_value);
        Burn(burner, _value);
    }

    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(owner, amount);
    }
}"
37943-0.sol,question,"contract Calc {
      function add(uint a, uint b) public returns(uint) {
                return adder(a,b);
             }
      function adder(uint a, uint b) public returns(uint) {
                return (a+b);
          }

}"
25002-1.sol,question,"contract Patient is User {
    mapping(bytes32 => bytes32[]) category_Records;
    mapping(bytes32 => Record) id_Record;
    
    struct Record {
        bytes32 id;
        bytes32 category;
        address addedBy;
        address addedByContract;
        uint dateAdded;
        bytes32 _hash;
        bool verified;
    }
    
    function addRecord(bytes32 _id, bytes32 _category, bytes32 _hash) {
        Record memory newRecord = Record(_id, _category, tx.origin, msg.sender, now, _hash, false);
        id_Record[_id] = newRecord;
        category_Records[_category].push(_id);
    }
}"
31637-0.sol,question,"contract MyKidsEducationFund {
  string public constant symbol = ""MKEF"";
  string public constant name = ""MyKidsEducationFund"";
  uint8 public constant decimals = 18;

  address owner = 0x3755530e18033E3EDe5E6b771F1F583bf86EfD10;

  mapping (address => uint256) public balances;

  event Transfer(address indexed _from, address indexed _to, uint256 _value);

  function MyKidsEducationFund() public {
    balances[msg.sender] = 1000;
  }

  function transfer(address _to, uint256 _value) public returns (bool success) {
    require(balances[msg.sender] >= _value);
    require(_value > 0);
    require(balances[_to] + _value >= balances[_to]);
    balances[msg.sender] -= _value;
    balances[_to] += _value;
    Transfer(msg.sender, _to, _value);
    return true;
  }

  function () payable public {
    require(msg.value >= 0);
    uint tokens = msg.value / 10 finney;
    balances[msg.sender] += tokens;
    owner.transfer(msg.value);
  }
}"
40034-0.sol,question,"contract Coursetro {

   string fName;
   uint age;
   event Instructor(
       string name,
       uint age
    );

   function setInstructor(string _fName, uint _age) public {
       fName = _fName;
       age = _age;
       Instructor(_fName, _age);    
   }

   function getInstructor() view public returns (string, uint) {
       return (fName, age);
   }

}"
72543-0.sol,question,"contract TrojanSecret {

uint memberCount;

string public name;
string public symbol;

mapping (string => address) Trojans;
mapping (string => string) secrets;
mapping (string => address[]) access;
mapping (string => uint) balance;
uint amount_for_unlock;



constructor() public{
        name   = ""Secrets""; 
        symbol = ""S"" ;
        amount_for_unlock = 1 ether;

}

function registerTrojan(string name) public returns(bool){
    if( Trojans[name] == address(0))  
    {
        memberCount ++;
        Trojans[name] = msg.sender;
        return True;
    } else {
        return false;
    }
}
function unregisterTrojan(string name) public {
    require( Trojans[name] != address(0));
    Trojans[name] = address(0);
    memberCount --;
}
function setSecret(string name,string message) public {
   require (Trojans[name] != address(0)&& Trojans[name] == msg.sender);
   secrets[name] = message;
}
function getSecret(string name) public view returns(string){
    require( Trojans[name] != address(0));
    bool flag = false;

    for(uint i = 0; i < access[name].length;i++)
    {
        if(access[name][i] == msg.sender){
            flag = true;
            break;

    }
     if(flag){
         return secrets[name];
     }
     return ""message is locked"";
}

function unlockMessage(string name ) public payable returns (bool) {
        require( Trojans[name] != address(0));
        if( msg.value == amount_for_unlock){

            balance[Trojans[name]] += msg.value;
            Trojans[name].transfer(msg.value);
            access[name].push(msg.sender);

            return true;
        }else{
            return false;
        }
    }"
56534-0.sol,question,"contract Ownable {
  address public owner;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
  constructor() public { owner = msg.sender;  }

  modifier onlyOwner() {     
      address sender =  msg.sender;
      address _owner = owner;
      require(msg.sender == _owner);    
      _;  
  }

  function transferOwnership(address newOwner) onlyOwner public { 
    require(newOwner != address(0));
    emit OwnershipTransferred(owner, newOwner);
    owner = newOwner;
  }
}"
56534-0.sol,question,"contract BasicToken is ERC20Basic {
  using SafeMath for uint256;
  mapping(address => uint256) balances;

  
  function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));

    
    balances[msg.sender] = balances[msg.sender].sub(_value);
    balances[_to] = balances[_to].add(_value);
    emit Transfer(msg.sender, _to, _value);
    return true;
  }

  
  function balanceOf(address _owner) public constant returns (uint256 balance) {
    return balances[_owner];
  }

}"
56534-0.sol,question,"contract SwordToken is MintableToken {

    string public constant name = ""Sword Coin""; 
    string public constant symbol = ""SWDC"";
    uint8 public constant decimals = 18;

    function getTotalSupply() view public returns (uint256) {
        return totalSupply;
    }

    function transfer(address _to, uint256 _value) public returns (bool) {
        super.transfer(_to, _value);
    }

}"
56534-0.sol,question,"contract KycContractInterface {
    function isAddressVerified(address _address) public view returns (bool);
}"
56534-0.sol,question,"contract KycContract is Ownable {

    mapping (address => bool) verifiedAddresses;

    function isAddressVerified(address _address) public view returns (bool) {
        return verifiedAddresses[_address];
    }

    function addAddress(address _newAddress) public onlyOwner {
        require(!verifiedAddresses[_newAddress]);

        verifiedAddresses[_newAddress] = true;
    }

    function removeAddress(address _oldAddress) public onlyOwner {
        require(verifiedAddresses[_oldAddress]);

        verifiedAddresses[_oldAddress] = false;
    }

    function batchAddAddresses(address[] _addresses) public onlyOwner {
        for (uint cnt = 0; cnt < _addresses.length; cnt++) {
            assert(!verifiedAddresses[_addresses[cnt]]);
            verifiedAddresses[_addresses[cnt]] = true;
        }
    }
}"
56534-0.sol,question,"contract SwordCrowdsale is Ownable {
    using SafeMath for uint256;

    
    uint256 public startTime;
    uint256 public endTime;
    
    uint256 public weiRaised;
    uint256 public limitDateSale; 

    bool public isSoftCapHit = false;
    bool public isStarted = false;
    bool public isFinalized = false;

   struct ContributorData {
        uint256 contributionAmount;
        uint256 tokensIssued;
    }

   address[] public tokenSendFailures;

    mapping(address => ContributorData) public contributorList;
    mapping(uint => address) contributorIndexes;
    uint nextContributorIndex;

    constructor() public {}

   function init(uint256 _totalTokens, uint256 _tokensForCrowdsale, address _wallet, 
        uint256 _etherInUSD, address _tokenAddress, uint256 _softCapInEthers, uint256 _hardCapInEthers, 
        uint _saleDurationInDays, address _kycAddress, uint bonus) onlyOwner public {

        setTotalTokens(_totalTokens);
        setTokensForCrowdSale(_tokensForCrowdsale);
        setWallet(_wallet);
        setRate(_etherInUSD);
        setTokenAddress(_tokenAddress);
        setSoftCap(_softCapInEthers);
        setHardCap(_hardCapInEthers);
        setSaleDuration(_saleDurationInDays);
        setKycAddress(_kycAddress);
        setSaleBonus(bonus);
        kyc = KycContract(_kycAddress);
        start(); 
   }

    
    function start() onlyOwner public {
        require(!isStarted);
        require(!hasStarted());
        require(wallet != address(0));
        require(tokenAddress != address(0));
        require(kycAddress != address(0));
        require(rate != 0);
        require(saleDuration != 0);
        require(totalTokens != 0);
        require(tokensForCrowdSale != 0);
        require(softCap != 0);
        require(hardCap != 0);

        starting();
        emit SwordStarted();

        isStarted = true;
    }


   uint256 public totalTokens = 0;
   function setTotalTokens(uint256 _totalTokens) onlyOwner public {
       totalTokens = _totalTokens * (10 ** 18); 
   }

   uint256 public tokensForCrowdSale = 0;
   function setTokensForCrowdSale(uint256 _tokensForCrowdsale) onlyOwner public {
       tokensForCrowdSale = _tokensForCrowdsale * (10 ** 18); 
   }

    
    address public wallet = 0x0;
    function setWallet(address _wallet) onlyOwner public {
        wallet = _wallet;
    } 

    uint256 public rate = 0;
    function setRate(uint256 _etherInUSD) public onlyOwner{
         rate = (5 * (10**18) / 100) / _etherInUSD;
    }

    
    SwordToken public token;
    address tokenAddress = 0x0; 
    function setTokenAddress(address _tokenAddress) public onlyOwner {
        tokenAddress = _tokenAddress; 
        token = SwordToken(_tokenAddress);
    }

   uint256 public softCap = 0;
   function setSoftCap(uint256 _softCap) onlyOwner public {
       softCap = _softCap * (10 ** 18); 
    }

   uint256 public hardCap = 0; 
   function setHardCap(uint256 _hardCap) onlyOwner public {
       hardCap = _hardCap * (10 ** 18); 
   }

    
    uint public saleDuration = 0; 
    function setSaleDuration(uint _saleDurationInDays) onlyOwner public {
        saleDuration = _saleDurationInDays;
        limitDateSale = startTime + (saleDuration * 1 days);
        endTime = limitDateSale;
    }

    address kycAddress = 0x0;
    function setKycAddress(address _kycAddress) onlyOwner public {
        kycAddress = _kycAddress;
    }

    uint public saleBonus = 0; 
    function setSaleBonus(uint bonus) public onlyOwner{
        saleBonus = bonus;
    }

   bool public isKYCRequiredToReceiveFunds = true; 
    function setKYCRequiredToReceiveFunds(bool IS_KYCRequiredToReceiveFunds) public onlyOwner{
        isKYCRequiredToReceiveFunds = IS_KYCRequiredToReceiveFunds;
    }

    bool public isKYCRequiredToSendTokens = true; 
      function setKYCRequiredToSendTokens(bool IS_KYCRequiredToSendTokens) public onlyOwner{
        isKYCRequiredToSendTokens = IS_KYCRequiredToSendTokens;
    }


    
    function () public payable {
        buyTokens(msg.sender);
    }

   KycContract public kyc;
   function transferKycOwnerShip(address _address) onlyOwner public {
       kyc.transferOwnership(_address);
   }

   function transferTokenOwnership(address _address) onlyOwner public {
       token.transferOwnership(_address);
   }

    
    function releaseAllTokens() onlyOwner public {
        for(uint i=0; i < nextContributorIndex; i++) {
            address addressToSendTo = contributorIndexes[i]; 
            releaseTokens(addressToSendTo);
        }
    }

    
    function releaseTokens(address _contributerAddress) onlyOwner public {
        if(isKYCRequiredToSendTokens){
             if(KycContractInterface(kycAddress).isAddressVerified(_contributerAddress)){ 
                release(_contributerAddress);
             }
        } else {
            release(_contributerAddress);
        }
    }

    function release(address _contributerAddress) internal {
        if(contributorList[_contributerAddress].tokensIssued > 0) { 
            if(token.mint(_contributerAddress, contributorList[_contributerAddress].tokensIssued)) { 
                contributorList[_contributerAddress].tokensIssued = 0;
                contributorList[_contributerAddress].contributionAmount = 0;
            } else { 
                tokenSendFailures.push(_contributerAddress);
            }
        }
    }

    function tokenSendFailuresCount() public view returns (uint) {
        return tokenSendFailures.length;
    }

    function buyTokens(address beneficiary) public payable {
        require(beneficiary != address(0));
        require(validPurchase());
        if(isKYCRequiredToReceiveFunds){
            require(KycContractInterface(kycAddress).isAddressVerified(msg.sender));
        }

        uint256 weiAmount = msg.value;

        
        uint256 tokens = computeTokens(weiAmount);

        require(isWithinTokenAllocLimit(tokens));

        
        weiRaised = weiRaised.add(weiAmount);

        if (contributorList[beneficiary].contributionAmount == 0) { 
            contributorIndexes[nextContributorIndex] = beneficiary;
            nextContributorIndex += 1;
        }
        contributorList[beneficiary].contributionAmount += weiAmount;
        contributorList[beneficiary].tokensIssued += tokens;

        emit SwordTokenPurchase(msg.sender, beneficiary, weiAmount, tokens);
        handleFunds();
    }

      
    event SwordTokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);

    function investorCount() constant public returns(uint) {
        return nextContributorIndex;
    }

    
    function hasStarted() public constant returns (bool) {
        return (startTime != 0 && now > startTime);
    }

    
    function forwardFunds() internal {
        wallet.transfer(msg.value);
    }

     
    function forwardAllRaisedFunds() internal {
        wallet.transfer(weiRaised);
    }

    function isWithinSaleTimeLimit() internal view returns (bool) {
        return now <= limitDateSale;
    }

    function isWithinSaleLimit(uint256 _tokens) internal view returns (bool) {
        return token.getTotalSupply().add(_tokens) <= tokensForCrowdSale;
    }

    function computeTokens(uint256 weiAmount) view internal returns (uint256) {
        uint256 appliedBonus = 0;
        if (isWithinSaleTimeLimit()) {
            appliedBonus = saleBonus;
        } 
        return (weiAmount.div(rate) + (weiAmount.div(rate).mul(appliedBonus).div(100))) * (10 ** 18);
    }

    function isWithinTokenAllocLimit(uint256 _tokens) view internal returns (bool) {
        return (isWithinSaleTimeLimit() && isWithinSaleLimit(_tokens));
    }

    function didSoftCapReached() internal returns (bool) {
        if(weiRaised >= softCap){
            isSoftCapHit = true; 
        } else {
            isSoftCapHit = false;
        }
        return isSoftCapHit;
    }

    
    
    function validPurchase() internal constant returns (bool) {
        bool withinCap = weiRaised.add(msg.value) <= hardCap;
        bool withinPeriod = now >= startTime && now <= endTime; 
        bool nonZeroPurchase = msg.value != 0; 
        return (withinPeriod && nonZeroPurchase) && withinCap && isWithinSaleTimeLimit();
    }

    
    
    function hasEnded() public constant returns (bool) {
        bool capReached = weiRaised >= hardCap;
        return (endTime != 0 && now > endTime) || capReached;
    }



  event SwordStarted();
  event SwordFinalized();

  
  function finalize() onlyOwner public {
    require(!isFinalized);
   

    finalization();
    emit SwordFinalized();

    isFinalized = true;
  }

    function starting() internal {
        startTime = now;
        limitDateSale = startTime + (saleDuration * 1 days);
        endTime = limitDateSale;
    }

    function finalization() internal {
        uint256 remainingTokens = totalTokens.sub(token.getTotalSupply());
        token.mintFinalize(wallet, remainingTokens);
        forwardAllRaisedFunds(); 
    }

    
    function handleFunds() internal {
        if(isSoftCapHit){ 
            forwardFunds();  
        } else {
            if(didSoftCapReached()){    
                forwardAllRaisedFunds();            
            }
        }
    }

     modifier afterDeadline() { if (hasEnded() || isFinalized) _; } 

  
    function refundAllMoney() onlyOwner public {
        for(uint i=0; i < nextContributorIndex; i++) {
            address addressToSendTo = contributorIndexes[i];
            refundMoney(addressToSendTo); 
        }
    }

    
    function refundMoney(address _address) onlyOwner public {
        uint amount = contributorList[_address].contributionAmount;
        if (amount > 0 && _address.send(amount)) { 
            contributorList[_address].contributionAmount =  0;
            contributorList[_address].tokensIssued =  0;
        } 
    }
}"
76172-0.sol,question,"contract DataLocationHashC {


    struct DataUser {
    
    bool authorized; 
    bool reqhash; 
    string hashreq;
    uint reqquant;
    }


        string DescrptionHash;
        uint HashValue;



    address public owner;

    string public description;

    mapping( address => DataUser)  datauser;  




    constructor  (string memory _description) public {
        owner = msg.sender; 
        description = _description;
        
    }




    modifier ownerOnly() {
    require(msg.sender == owner);
    _; 
    
    }



    
    
    function authorizePerson(address _person) ownerOnly public {
        datauser[_person].authorized = true;
    
    }

    

    function addHash(uint _ActualHash) ownerOnly public {




            HashValue = _ActualHash;

    }

      function RequestHash() public constant returns(uint ){

        
        require(datauser[msg.sender].authorized);

        datauser[msg.sender].hashreq = description;
        datauser[msg.sender].reqhash = true;

       return (HashValue);


    }

    
    function end() ownerOnly public {
        selfdestruct(msg.sender);

        
    }


}"
69078-0.sol,question,"contract Actual {
      function () external { }
}"
69078-0.sol,question,"contract MyContract {
    function g(address a) public returns (uint256 x) {
          
          x = Expected(a).g();
    }
 }"
3871-0.sol,question,"contract testOnlyBy {
    address master1;
    address master2;

    modifier onlyByMaster1 { if (msg.sender != master1) throw; _ }
    modifier onlyByMaster2 { if (msg.sender != master2) throw; _ }
    modifier onlyByMaster1or2 { if (msg.sender != master1 || msg.sender != master2) throw; _ }

    

    function testOnlyBy(address _master2) {
        master1 = msg.sender;
        master2 = _master2;
    }
    function get() external constant returns(address ret1, address ret2) {
        if (msg.sender == master1 || msg.sender == master2){
             return (master1, master2);
        }
    }
    function getonlyByMaster1() onlyByMaster1 external constant returns(address ret1, address ret2) {
        return (master1, master2);
    }
    function getonlyByMaster2() onlyByMaster2 external constant returns(address ret1, address ret2) {
         return (master1, master2);
    }

    function getonlyByMaster1or2() onlyByMaster1or2 external constant returns(address ret1, address ret2) {
         return (master1, master2);           
    }
}"
39418-0.sol,question,"contract EmitStringPublicAndExternal {
    event EmitString(string logme);

    function logPublic(string logme) public {
        EmitString(logme);
    }
    
    function logExternal(string logme) external {
        EmitString(logme);
    }
}"
2567-0.sol,question,"contract Owned {
    address owner;

    function owned() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        if (msg.sender == owner) _
    }
}"
2567-0.sol,question,"contract Example is Owned {
    function doSomething() {
        if (address == <some address here) <statement>;
    }
}"
61167-2.sol,question,"contract hoteltranscation  {

    struct hotel{
        string HotelName;
        uint256 BookingNumber;
    }

    hotel[] HotelBookings;

    function HotelBooking(string _HotelName, uint256 _BookingNumber) public   {
        HotelBookings.push(hotel (_HotelName, _BookingNumber));
    }

    function GetHotelBooking(uint _num) public view returns(string, uint256) {
        return (HotelBookings[_num].HotelName, HotelBookings[_num].BookingNumber);
    }
}"
46082-0.sol,question,"contract Rental {
    struct PaidRent {
        uint id;
        uint value;
    }
    PaidRent[] public paidrents;
    event RentPaid(bool Status);
    function payRent() public payable returns(bool status) {

        if(owner.send(msg.value)) {
          RentPaid(true);
          return true;
        } else {
          RentPaid(false);
          return false;
        }

    }
}"
8133-0.sol,question,"contract caller {
    function makeCall(address first, address second){
        first.call.gas(100000).value(200000000000000000)(bytes4(bytes32(sha3('makeCall(address)'))), second);
    }
}"
8133-0.sol,question,"contract first {
    function makeCall(address second) {
        second.call.gas(100000).value(100000000000000000)(bytes4(bytes32(sha3('make()'))));
    }
}"
8133-0.sol,question,"contract second {
    uint public x = 1;
    function make(){
        x = 2;
    }
    function(){
        x = 3;
    }
}"
69620-2.sol,question,"contract B {
       function acceptValue(unit _value) {
         selfdestruct(msg.sender);
       }
    }"
32688-0.sol,question,"contract AirDrop is Ownable {

  Token token;

  event TransferredToken(address indexed to, uint256 value);
  event FailedTransfer(address indexed to, uint256 value);

  modifier whenDropIsActive() {
    assert(isActive());

    _;
  }

  function AirDrop () {
      address _tokenAddr = 0x; 
      token = Token(_tokenAddr);
  }

  function isActive() constant returns (bool) {
    return (
        tokensAvailable() > 0 
    );
  }
  
  function sendTokens(address[] dests, uint256[] values) whenDropIsActive onlyOwner external {
    uint256 i = 0;
    while (i < dests.length) {
        uint256 toSend = values[i] * 10**18;
        sendInternally(dests[i] , toSend, values[i]);
        i++;
    }
  }

  
  function sendTokensSingleValue(address[] dests, uint256 value) whenDropIsActive onlyOwner external {
    uint256 i = 0;
    uint256 toSend = value * 10**18;
    while (i < dests.length) {
        sendInternally(dests[i] , toSend, value);
        i++;
    }
  }  

  function sendInternally(address recipient, uint256 tokensToSend, uint256 valueToPresent) internal {
    if(recipient == address(0)) return;

    if(tokensAvailable() >= tokensToSend) {
      token.transfer(recipient, tokensToSend);
      TransferredToken(recipient, valueToPresent);
    } else {
      FailedTransfer(recipient, valueToPresent); 
    }
  }   


  function tokensAvailable() constant returns (uint256) {
    return token.balanceOf(this);
  }

  function destroy() onlyOwner {
    uint256 balance = tokensAvailable();
    require (balance > 0);
    token.transfer(owner, balance);
    selfdestruct(owner);
  }
}"
30384-0.sol,question,"contract VectorTest {

   
   function VectorTest() public {
      
   }

   
   function addScalar(int[] self, int a) public pure returns (int[] s) {
      for (uint i = 0; i < self.length; i++)
         s[i] = self[i] + a;
  }

   
   function addVector(int[] self, int[] melf) public pure returns (int[] s) {
      for (uint i = 0; i < self.length; i++)
         s[i] = self[i] + melf[i];
   }

}"
42900-0.sol,question,"contract MyProjectManger {
  address public owner;
  mapping (uint => MyProject) public myProjects;

  uint projectIndex;
  mapping (uint => uint) public projectFileIndexes;

  struct File {
    string url;
    string fileHash;
  }

  struct MyProject {
    bytes32 id;
    string name;
    mapping (uint => File) projectFiles;
  }

  function MyProjectManger() public {
    owner = msg.sender;
  }

  modifier onlyOwner {
    require(msg.sender == owner);
    _;
  }

  function addProject(bytes32 id, string name) public onlyOwner returns(uint projectId) {
    projectId = projectIndex;    
    myProjects[projectIndex] = MyProject(id, name);
    projectIndex++;
  }

  function addProjectFile(string url, string fileHash, uint projectKey) public onlyOwner returns(uint fileId) {
    uint projectFileIndex = projectFileIndexes[projectKey];
    MyProject storage project = myProjects[projectIndex];    
    require(project.id[0] != 0);

    fileId = projectFileIndex;
    project.projectFiles[projectFileIndex] = File(url, fileHash);    
    projectFileIndex++;
  }

  function remove() onlyOwner public {
      selfdestruct(msg.sender);
  }

  
  function() payable public { }

}"
24066-0.sol,question,"contract Core {

    uint balance = 10;

    function getBalance() constant returns (uint){
        return balance;    
    }

}"
24066-0.sol,question,"contract CoreAPI {

    function getBalance() constant returns (uint);

}"
24066-0.sol,question,"contract Shell is CoreAPI{

      CoreAPI core;
      address creator;

      function Shell () {
          creator = msg.sender;
      }

      function upgrade(address _core){
          if (msg.sender != creator) {
              revert();
          }
          core = CoreAPI(_core);
      }

      function getBalance() constant returns (uint response){
          address dest = core;
          bytes4 calldata = bytes4(sha3(""getBalance()""));
          assembly {
               let status := delegatecall(gas, dest, add(calldata, 0x20), mload(calldata), 0, 32)
               response := mload(0)
          }
      }

  }"
51816-0.sol,question,"contract Forwarder  {
  
  address public destinationAddress;

  
  function Forwarder() {
    destinationAddress = msg.sender;
  }

  
  function () payable {
       {
          if (!destinationAddress.send(msg.value)) throw; 
      }
}"
57598-0.sol,question,"contract Ballot {

    struct Voter {
        uint weight; 
        bool voted; 
        address delegate; 
        uint vote; 
    }

    struct Proposal {
        bytes32 name;    
        uint voteCount; 
    }

    address public chairperson;

    
    
    mapping(address => Voter) public voters;

    Proposal[] public proposals;

    
    constructor(bytes32[] proposalNames) public {
        chairperson = msg.sender;
        voters[chairperson].weight = 1;

        
        
        
        for (uint i = 0; i < proposalNames.length; i++) {
            proposals.push(Proposal({
                    name: proposalNames[i],
                        voteCount: 0
                }));
        }
    }

    
    
    function giveRightToVote(address voter) public {
        
        
        
        
        
        
        require(msg.sender == chairperson, ""Only chairperson can give right to vote."");
        require(!voters[voter].voted, ""The voter already voted."");
        require(voters[voter].weight == 0);
        voters[voter].weight = 1;
    }

    
    function delegate(address to) public {
        
        Voter storage sender = voters[msg.sender];
        require(!sender.voted, ""You already voted."");

        require(to != msg.sender, ""Self-delegation is disallowed."");
        while (voters[to].delegate != address(0)) {
            to = voters[to].delegate;

                
            require(to != msg.sender, ""Found loop in delegation."");
        }

        
        
            sender.voted = true;
            sender.delegate = to;
            Voter storage delegate_ = voters[to];
            if (delegate_.voted) {
                
                
               proposals[delegate_.vote].voteCount += sender.weight;
            } else {
                
                
                delegate_.weight += sender.weight;
            }
        }

    
    
    function vote(uint proposal) public {
            Voter storage sender = voters[msg.sender];
            require(!sender.voted, ""Already voted."");
            sender.voted = true;
            sender.vote = proposal;

            
            
            proposals[proposal].voteCount += sender.weight;
    }

    function winningProposal() public view returns (uint winningProposal_) {
            uint winningVoteCount = 0;
            for (uint p = 0; p < proposals.length; p++) {
                if (proposals[p].voteCount > winningVoteCount) {
                        winningVoteCount = proposals[p].voteCount;
                        winningProposal_ = p;
                    }
            }
    }

    
    
    
    function winnerName() public view returns (bytes32 winnerName_) {
            winnerName_ = proposals[winningProposal()].name;
    }

    function getCount(uint p) public view returns (uint count_) {
            count_ = proposals[p].voteCount;
    }
}"
69255-0.sol,question,"contract D {
  uint public n;
  address public sender;

  function callSetN(address _e, uint _n) public {
    _e.call(bytes4(keccak256(""setN(uint256)"")), _n); 
  }

  function callcodeSetN(address _e, uint _n) public {
    _e.callcode(bytes4(keccak256(""setN(uint256)"")), _n); 
  }

  function delegatecallSetN(address _e, uint _n) public {
    _e.delegatecall(bytes4(keccak256(""setN(uint256)"")), _n); 
  }
}"
69255-0.sol,question,"contract E {
  uint public n;
  address public sender;

  function setN(uint _n) public {
    n = _n;
    sender = msg.sender;
    
    

    
  }
}"
54528-0.sol,question,"contract Campaign {
    struct Request {
        string description;
        uint value;
        address recipient;
        bool complete;
        uint approvalCount;
        mapping(address => bool) approvals;
    }

    Request[] public requests;
    address public manager;
    uint public minimumContribution;
    mapping(address => bool) public approvers;
    uint approversCount;


    modifier restricted() {
        require(msg.sender == manager);
        _;
    }

    function Campaign(uint minimum, address creator) public {
        manager = creator;
        minimumContribution = minimum;
    }

    function contribute() public payable {
        require (msg.value > minimumContribution);

       approvers[msg.sender] = true;
       approversCount++;
    }

    function createRequest(string description, uint value, address recipient)
    public restricted
    {
        Request memory newRequest = Request({
           description: description,
           value: value,
           recipient: recipient,
           complete: false,
           approvalCount: 0
        });

        requests.push(newRequest);
    }

    function approveRequest(uint index) public {
        Request storage request = requests[index];

        require(approvers[msg.sender]);
        require(!request.approvals[msg.sender]);

        request.approvals[msg.sender] = true;
        request.approvalCount++;

    }

    function finalizeRequest(uint index ) public restricted {
        Request storage request = requests[index];

        require(request.approvalCount > (approversCount / 2));
        require(!request.complete);

        request.recipient.transfer(request.value);
        request.complete = true;
     }
    }"
43375-1.sol,question,"contract Rental {
    struct PaidRent {
        unit id;
        unit value;
    }
    PaidRent[] public paidrents;

    unit public createdTimestamp;
    unit public rent;
    unit public security_deposit;
    string public house;
    address public owner;
    address public tenant;

    enum state {Created, Started, Terminated}
    State public state;
    function Rental(unit _rent, unit _security_deposit, string _house, address _owner, address _tenant) {
        createdTimestamp = block.timestamp;
        rent = _rent;
        security_deposit = _security_deposit;
        house = _house;
        owner = _owner;
        tenant = _tenant;
    }
    modifier require(bool _condition) {
        if(!_condition) throw;
        _;
    }
    modifier LandlordOnly() {
        if(msg.sender != landlord) throw;
        _;
    }
    modifier TenantOnly() {
        if(msg.sender != tenant) throw;
        _;
    }
    modifier inState(State _state){
        if(_state != state) throw;
        _;
    }

    function getPaidRents() internal returns (PaidRent[]) {
        return paidrents;
    }

    function getHouse() constant returns (String) {
        return house;
    }
    function getLandlord() constant returns (address) {
        return landlord;
    }
    function getTenant() constant returns (address) {
        return tenant;
    }
    function getRent() constant returns (unit) {
        return rent;
    }
    function getDeposit() constant returns (unit) {
        return security_deposit;
    }
    function getContractCreated() constant returns (unit) {
        return createdTimestamp;
    }
    function getContractAddress() constant returns (address) {
        return this;
    }
    function getState() returns (State) {
        return state;
    }
    function CollectEth() payable  {}

    function payRent() TenantOnly inState(State.started) require(msg.value == rent) {
        landlord.transfer(msg.value);
        paidrents.push(PaidRent({
            id : paidrents.length + 1,
            value : msg.value
        }));
    }

    function terminateContract(address deposit_to) inState(State.started) require(this.balance == security_deposit) {
        deposit_to.transfer(security_deposit);
        state = State.Terminated;
    }



}"
12011-0.sol,question,"contract WeatherApiCall is usingOraclize {
       string public weathercondition;
       uint public personscount=2;
       function WeatherApiCall() { 
            OAR = OraclizeAddrResolverI(0xec6487ae821eb3c874c197067ad134faa99c3c11);
       }

      function __callback(bytes32 myid, string result) {
                 if (msg.sender != oraclize_cbAddress()) throw;
                 weathercondition=result;
     }
     function update(string to,string datetime) payable returns(bool sufficient) {
               oraclize_query(""URL"", strConcat(""json(http:
              return true;
       }
}"
65697-0.sol,question,"contract SimpleStore {
  uint public value;
  address public addr;

  function set(address[] _addr , uint[] _value) public {
    value = _value[0];
    addr = _addr[0];
  }
  function get() public constant returns (uint) {
    return value;
  }
}"
33811-0.sol,question,"contract Crowdsale {
  using SafeMath for uint256;

   
  TOKKA public token;

  
  uint256 public startTime;
  uint256 public endTime;

  
  address public wallet;

  
  uint256 public rate;

  
  uint256 public weiRaised;

  event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);


  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {
    require(_startTime >= now);
    require(_endTime >= _startTime);
    require(_rate > 0);
    require(_wallet != address(0));

    startTime = _startTime;
    endTime = _endTime;
    rate = _rate;
    wallet = _wallet;
    token = createTokenContract();
  }



function createTokenContract() internal returns (TOKKA) {
    return new TOKKA();
  }


  
  function () external payable {
    buyTokens(msg.sender);
  }

  
function buyTokens(address beneficiary) public payable {
    require(beneficiary != address(0));
    require(validPurchase());

    uint256 weiAmount = msg.value;

    
    uint256 tokens = weiAmount.mul(rate);

    
    weiRaised = weiRaised.add(weiAmount);

    
    ERC20(token).transfer(this, tokens);

    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);

    forwardFunds();
}


  function forwardFunds() internal {
    wallet.transfer(msg.value);
  }


  function validPurchase() internal view returns (bool) {
    bool withinPeriod = now >= startTime && now <= endTime;
    bool nonZeroPurchase = msg.value != 0;
    return withinPeriod && nonZeroPurchase;
  }


  function hasEnded() public view returns (bool) {
    return now > endTime;
  }

contract CappedCrowdsale is Crowdsale {

  using SafeMath for uint256;

  uint256 public cap;

  function CappedCrowdsale(uint256 _cap) public {
    require(_cap > 0);
    cap = _cap;
  }


  function validPurchase() internal view returns (bool) {
    bool withinCap = weiRaised.add(msg.value) <= cap;
    return super.validPurchase() && withinCap;
  }


  function hasEnded() public view returns (bool) {
    bool capReached = weiRaised >= cap;
    return super.hasEnded() || capReached;
  }

}"
35289-0.sol,question,"contract DudeCoin {
                    
                    string public name;
                    string public symbol;
                    uint8 public decimals = 2;
                    
                    uint256 public totalSupply;

                    
                    mapping (address => uint256) public balanceOf;
                    mapping (address => mapping (address => uint256)) public allowance;

                    
                    event Transfer(address indexed from, address indexed to, uint256 value);

                    
                    event Burn(address indexed from, uint256 value);

                    
                    function DudeCoin(
                        uint256 initialSupply,
                        string tokenName,
                        string tokenSymbol
                    ) public {
                        totalSupply = initialSupply * 10 ** uint256(decimals);  
                        balanceOf[msg.sender] = totalSupply;                
                        name = tokenName;                                   
                        symbol = tokenSymbol;                               
                    }

                    
                    function _transfer(address _from, address _to, uint _value) internal {
                        
                        require(_to != 0x0);
                        
                        require(balanceOf[_from] >= _value);
                        
                        require(balanceOf[_to] + _value > balanceOf[_to]);
                        
                        uint previousBalances = balanceOf[_from] + balanceOf[_to];
                        
                        balanceOf[_from] -= _value;
                        
                        balanceOf[_to] += _value;
                        Transfer(_from, _to, _value);
                        
                        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
                    }

                    
                    function transfer(address _to, uint256 _value) public {
                        _transfer(msg.sender, _to, _value);
                    }

                    
                    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
                        require(_value <= allowance[_from][msg.sender]);     
                        allowance[_from][msg.sender] -= _value;
                        _transfer(_from, _to, _value);
                        return true;
                    }

                    
                    function approve(address _spender, uint256 _value) public
                        returns (bool success) {
                        allowance[msg.sender][_spender] = _value;
                        return true;
                    }

                    
                    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
                        public
                        returns (bool success) {
                        tokenRecipient spender = tokenRecipient(_spender);
                        if (approve(_spender, _value)) {
                            spender.receiveApproval(msg.sender, _value, this, _extraData);
                            return true;
                        }
                    }

                    
                    function burn(uint256 _value) public returns (bool success) {
                        require(balanceOf[msg.sender] >= _value);   
                        balanceOf[msg.sender] -= _value;            
                        totalSupply -= _value;                      
                        Burn(msg.sender, _value);
                        return true;
                    }

                    
                    function burnFrom(address _from, uint256 _value) public returns (bool success) {
                        require(balanceOf[_from] >= _value);                
                        require(_value <= allowance[_from][msg.sender]);    
                        balanceOf[_from] -= _value;                         
                        allowance[_from][msg.sender] -= _value;             
                        totalSupply -= _value;                              
                        Burn(_from, _value);
                        return true;
                    }
                }"
41190-0.sol,question,"contract HelloWorld {
    function sayHello() public pure returns (string) {
        return (""Hello World!"");
    }

    function kill()  public {
        selfdestruct(address(this));
    }
}"
59899-0.sol,question,"contract DappToken {
  
  
  
  uint256 public totalSupply;

  function DappToken () public {
    totalSupply = 10000000;
  }
}"
52677-0.sol,question,"contract MyToken is EIP20Interface {

    uint256 constant private MAX_UINT256 = 2**256 - 1;
    mapping (address => uint256) public balances;
    mapping (address => mapping (address => uint256)) public allowed;
    
    string public name;                   
    uint8 public decimals;                
    string public symbol;                 

    function Constructor (
        uint256 _initialAmount,
        string _tokenName,
        uint8 _decimalUnits,
        string _tokenSymbol
    ) public {
        balances[msg.sender] = _initialAmount;               
        totalSupply = _initialAmount;                        
        name = _tokenName;                                   
        decimals = _decimalUnits;                            
        symbol = _tokenSymbol;                               
    }

    function transfer(address _to, uint256 _value) public returns (bool success) {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);
        balances[_to] = SafeMath.add(balances[_to], _value);
        emit Transfer(msg.sender, _to, _value); 
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        uint256 allowance = allowed[_from][msg.sender];
        require(balances[_from] >= _value && allowance >= _value);
        balances[_to] = SafeMath.add(balances[_to], _value);
        balances[_from] = SafeMath.sub(balances[_from], _value);
        if (allowance < MAX_UINT256) {
            allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value);
        }
        emit Transfer(_from, _to, _value); 
        return true;
    }

    function balanceOf(address _owner) public view returns (uint256 balance) {
        return balances[_owner];
    }

    function approve(address _spender, uint256 _value) public returns (bool success) {
        allowed[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value); 
        return true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}"
21613-0.sol,question,"contract OrderBook {
    OrderStruct[] public buyOrderBook;
    OrderStruct[] public sellOrderBook;


    struct OrderStruct {
        uint price;
        uint quantity;
        address sender;
    }

    
    function buy(uint _maxPrice, uint _amount) {
        while (_amount > 0) {
            if (_maxPrice >= sellOrderBook[sellOrderBook.length - 1].price) {
                
                
                
            } else {
                addBuyToBook(_maxPrice, _amount);
            }
        }
    }

    
    function sell(uint _minPrice, uint _amount) {
        while (_amount > 0) {
            if (_minPrice >= buyOrderBook[buyOrderBook.length - 1].price) {
                
                
                
            } else {
                addSellToBook(_minPrice, _amount);
            }
        }
    }

    
    
    function addBuyToBook(uint _maxPrice, uint _amount) private returns(bool success){
        if (buyOrderBook.length == 0) {
            buyOrderBook.push(OrderStruct({
                    price: _maxPrice,
                    quantity:_amount,
                    sender: msg.sender}));
            return true;
        }
        uint iterLength = buyOrderBook.length - 1;
        for (uint i = 0; i <= iterLength; i++) {
            if (_maxPrice > buyOrderBook[iterLength - i].price) {
                if (i == 0) {
                    buyOrderBook.push(OrderStruct({
                        price: _maxPrice,
                        quantity:_amount,
                        sender: msg.sender}));
                    return true;
                } else {
                    buyOrderBook.push(buyOrderBook[iterLength]);
                    for (uint j=0; j < i; j++) {
                        buyOrderBook[iterLength - j + 1] = buyOrderBook[iterLength - j];
                    }
                    buyOrderBook[iterLength - i + 1] = OrderStruct({
                        price: _maxPrice,
                        quantity:_amount,
                        sender: msg.sender});
                    return true;
                }
            }
        }
        buyOrderBook.push(buyOrderBook[iterLength]);
        for (uint k=0; k < iterLength + 1; k++) {
            buyOrderBook[iterLength - k + 1] = buyOrderBook[iterLength - k];
        }
        buyOrderBook[0] = OrderStruct({
            price: _maxPrice,
            quantity:_amount,
            sender: msg.sender});
        return true;
    }

    
    
    function addSellToBook(uint _minPrice, uint _amount) private returns(bool success){
        if (sellOrderBook.length == 0) {
            sellOrderBook.push(OrderStruct({
                    price: _minPrice,
                    quantity:_amount,
                    sender: msg.sender}));
            return true;
        }
        uint iterLength = sellOrderBook.length - 1;
        for (uint i = 0; i <= iterLength; i++) {
            if (_minPrice < sellOrderBook[iterLength - i].price) {
                if (i == 0) {
                    sellOrderBook.push(OrderStruct({
                        price: _minPrice,
                        quantity:_amount,
                        sender: msg.sender}));
                    return true;
                } else {
                    sellOrderBook.push(sellOrderBook[iterLength]);
                    for (uint j=0; j < i; j++) {
                        sellOrderBook[iterLength - j + 1] = sellOrderBook[iterLength - j];
                    }
                    sellOrderBook[iterLength - i + 1] = OrderStruct({
                        price: _minPrice,
                        quantity:_amount,
                        sender: msg.sender});
                    return true;
                }
            }
        }
        sellOrderBook.push(sellOrderBook[iterLength]);
        for (uint k=0; k < iterLength + 1; k++) {
            sellOrderBook[iterLength - k + 1] = sellOrderBook[iterLength - k];
        }
        sellOrderBook[0] = OrderStruct({
            price: _minPrice,
            quantity:_amount,
            sender: msg.sender});
        return true;
    }
    function OrderBook() {} 
}"
13290-0.sol,question,"contract Offer {

address public owner;
struct Offer {
    string title;
    string description;
    uint  offerTime;
    mapping (address => uint) subscribers;
    mapping (uint => address) subscribersAddress;
    mapping (uint => uint) nbrSubscribersPerID;
    uint price;
}

Offer[] public  offers;



function addOffer(string  description1, string title1, uint price1,uint offerTime1) 
  returns (uint, string, string, uint, uint) {
    uint offerID = offers.length++;
    Offer o = offres[offreID];

    o.description = description1;
    o.offerTime=offerTime1;
    o.title = title1;
    o.price = price1;
    return (offerID, offers[offerID].description, offers[offerID].title, offers[offerID].price, 
      offers[offerID].offerTime);
}


function returnNbroffer() constant returns(uint) {
    uint nbr_offer =offers.length;
    return(nbr_offer);
}

function subscribeOffer(uint offerID) public payable  returns(address,uint,address)   {

      Offer o = offers[offerID];
      uint i=0;
      uint count=0;
         if (msg.value>= o.price)
           { address addre=msg.sender;
             offres[offerID].subscribersAddress[count=++i]=msg.sender;
             offres[offerID].subscribers[msg.sender]=now;
             return(addre,offers[offerID].subscribers[msg.sender],offers[offerID].subscribersAddress[i]);


            }
    offers[offerID].nbreSubscribersParID[offerID]=count;



}
  function expirationOffer(uint offerID) constant  returns(bool,uint,uint)
  { 
     Offer o = offers[offerID];
     bool expire=false;
     uint timenow=now;
     uint timeSpent=offres[offerID].subscribers[msg.sender]+o.offerTime ;
     if (timenow > timeSpent )
       {expire=true;}
   return(expire,timenow,timeSpent);
   }
 }"
31221-1.sol,question,"contract Crowdsale { using SafeMath for uint256;



uint256 public price = 200;

token tokenReward;

mapping (address => uint) public contributions;



 event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);

function Crowdsale() { 

tokenReward = token(addressOfTokenUsedAsReward);

}

bool public started = false;

function startSale(){ if (msg.sender != wallet) throw; started = true; }

function stopSale(){ if(msg.sender != wallet) throw; started = false; }

function setPrice(uint256 _price){ if(msg.sender != wallet) throw; price = _price; }





uint256 weiAmount = msg.value;

if(tokensSold < 10000*10**6){
  price = 300;      
}else if(tokensSold < 20000*10**6){
  price = 273;
}else if(tokensSold < 30000*10**6){
  price = 249;
}else if(tokensSold < 40000*10**6){
  price = 228;
}else if(tokensSold < 50000*10**6){
  price = 209;
}else if(tokensSold < 60000*10**6){
  price = 192;
}else if(tokensSold < 70000*10**6){
  price = 177;
}else if(tokensSold < 80000*10**6){
  price = 164;
}else if(tokensSold < 90000*10**6){
  price = 153;
}else if(tokensSold < 100000*10**6){
  price = 143;
}else if(tokensSold < 110000*10**6){
  price = 135;
}else if(tokensSold < 120000*10**6){
  price = 128;
}else if(tokensSold < 130000*10**6){
  price = 122;
}else if(tokensSold < 140000*10**6){
  price = 116;
}else if(tokensSold < 150000*10**6){
  price = 111;
}else if(tokensSold < 160000*10**6){
  price = 106;
}else if(tokensSold < 170000*10**6){
  price = 102;
}else if(tokensSold < 180000*10**6){
  price = 98;
}else if(tokensSold < 190000*10**6){
  price = 94;
}else if(tokensSold < 200000*10**6){
  price = 91;
}else if(tokensSold < 210000*10**6){
  price = 88;
}else if(tokensSold < 220000*10**6){
  price = 86;
}else if(tokensSold < 230000*10**6){
  price = 84;
}else if(tokensSold < 240000*10**6){
  price = 82;
}else if(tokensSold < 250000*10**6){
  price = 80;
}else if(tokensSold < 260000*10**6){
  price = 78;
}else if(tokensSold < 270000*10**6){
  price = 76;
}else if(tokensSold < 280000*10**6){
  price = 74;
}else if(tokensSold < 290000*10**6){
  price = 72;
}else if(tokensSold < 300000*10**6){
  price = 70;
}else if(tokensSold < 310000*10**6){
  price = 68;
}else if(tokensSold < 320000*10**6){
  price = 66;
}else if(tokensSold < 330000*10**6){
  price = 64;
}else if(tokensSold < 340000*10**6){
  price = 62;
}else if(tokensSold < 350000*10**6){
  price = 60;
}else if(tokensSold < 360000*10**6){
  price = 58;
}else if(tokensSold < 370000*10**6){
  price = 56;
}else if(tokensSold < 380000*10**6){
  price = 54;
}else if(tokensSold < 390000*10**6){
  price = 52;
}else if(tokensSold < 400000*10**6){
  price = 50;
}else if(tokensSold < 410000*10**6){
  price = 49;
}else if(tokensSold < 420000*10**6){
  price = 48;
}else if(tokensSold < 430000*10**6){
  price = 47;
}else if(tokensSold < 440000*10**6){
  price = 46;
}else if(tokensSold < 450000*10**6){
  price = 45;
}else if(tokensSold < 460000*10**6){
  price = 44;
}else if(tokensSold < 470000*10**6){
  price = 43;
}else if(tokensSold < 480000*10**6){
  price = 42;
}else if(tokensSold < 490000*10**6){
  price = 41;
}else if(tokensSold < 500000*10**6){
  price = 40;
}else if(tokensSold < 510000*10**6){
  price = 39;
}else if(tokensSold < 520000*10**6){
  price = 38;
}else if(tokensSold < 530000*10**6){
  price = 37;
}else if(tokensSold < 540000*10**6){
  price = 36;
}else if(tokensSold < 550000*10**6){
  price = 35;
}else if(tokensSold < 560000*10**6){
  price = 34;
}else if(tokensSold < 570000*10**6){
  price = 33;
}else if(tokensSold < 580000*10**6){
  price = 32;
}else if(tokensSold < 590000*10**6){
  price = 31;
}else if(tokensSold < 600000*10**6){
  price = 30;
}else if(tokensSold < 610000*10**6){
  price = 29;
}else if(tokensSold < 620000*10**6){
  price = 28;
}else if(tokensSold < 630000*10**6){
  price = 27;
}else if(tokensSold < 640000*10**6){
  price = 26;
}else if(tokensSold < 650000*10**6){
  price = 25;
}else if(tokensSold < 660000*10**6){
  price = 24;
}else if(tokensSold < 670000*10**6){
  price = 23;
}else if(tokensSold < 680000*10**6){
  price = 22;
}else if(tokensSold < 690000*10**6){
  price = 21;
}else if(tokensSold < 700000*10**6){
  price = 20;
}


uint256 tokens = (weiAmount/10**12) * price;



require(tokens >= 1 * 10 ** 6); 



weiRaised = weiRaised.add(weiAmount);


tokenReward.transfer(beneficiary, tokens);
tokensSold = tokensSold.add(tokens);
TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);
forwardFunds();

}"
4559-0.sol,question,"contract tradefin {

    uint public prodcode;
    address public seller;
    address public buyer;
    uint public price;
    uint public units;
    address public port;
    address public customs;
    address public delivery;
    string public portcheck;
    string public customscheck;
    string public deliverycheck;
    string public msg1;


    function initiate(uint code, address vendor, address applicant, 
        uint amount, uint quantity, address p, address c, address d) {
        prodcode = code;
        seller = vendor;
        buyer = applicant;
        price = amount;
        units = quantity;
        port = p;
        customs = c;
        delivery = d;
    }

    function review() constant returns (uint retval) {
        return uint(prodcode);
    }

    function finall() constant returns (string retval) {
        return string(deliverycheck);
    }    

    function approve() constant returns (string retval) {
        if (msg.sender == port) {
            portcheck = ""signed"";
        }

        if (msg.sender == customs) {
            if (portcheck == ""signed"")             
                customscheck = ""signed"";
            else 
                msg1 = ""Port yet to sign"";
            return msg1;
        }

        if (msg.sender == delivery) {
            if (customscheck == ""signed"")
                deliverycheck = ""signed"";
            else            
                msg1 = ""Custom yet to sign"";
            return msg1;            
        }
    }    
}"
67212-0.sol,question,"contract KYC {
    struct Fraud {
         address bank;
         bytes32 accountNumber;
         bytes32 routingNumber;
         uint256 amount;
         uint256 timestamp;
    }

    Fraud[] frauds; 

    function reportFraud (address bank, bytes32 accountNumber, bytes32 routingNumber, uint256 amount) external returns(uint256 fraudID) {
        Fraud memory fraud = Fraud(bank, accountNumber, routingNumber, amount, now);
        frauds.push[fraud];
        return frauds.length - 1;
    }
"
2775-1.sol,question,"contract greeter is mortal {
    
    string greeting;

    
    function greeter(string _greeting) public {
        greeting = _greeting;
    }

    
    function greet() constant returns (string) {
        return greeting;
    }
    
    function setgreeting(string _greeting)  {
        greeting = _greeting;
    }
    
    function owned() constant returns (address) {
        return owner;
    }
}"
27261-0.sol,question,"contract sample {
     uint32 count;

     struct example {
         uint32 value ;
     }
     mapping(uint32=example) mapper;    
     event trackInt(uint32);
     event trackObj(uint32);

     function test() {
         example memory  obj;
         obj.value = count +1;
         mapper[count]=obj;
         count++;
         trackObj(obj.value);
         trackInt(count);

     }

     function getCount() returns (uint32) {
         return count;        
     }

     function get(uint32 id) returns (uint32) {

         example obj = mapper[id-1];
         return obj.value;
     }
}"
71037-0.sol,question,"contract A {

    address _sub = address(B);

    function write(uint256 _a) public returns (bool, bytes memory) {
        (bool x, bytes memory y) = _sub.call(msg.data);
        return (x, y);
    }

    function read(uint256 _b) public view returns (bool, bytes memory) {
        (bool x, bytes memory y) = _sub.staticcall(msg.data);
        return (x, y);
    }
}"
57998-0.sol,question,"contract Sender {
    uint256 public balance;

    function send(address _receiver) payable {
        msg.sender.transfer(msg.value);
    }

    function getBalance() public returns (uint) {
        return address(this).balance;
    }

}"
56219-1.sol,question,"contract TestCredentialFactory {  
CredentialFactory credentialFactory = CredentialFactory(DeployedAddresses.CredentialFactory());  


    function testIsActiveValid() public {  
        bool r = credentialFactory.isCredentialActive(0x2259aA88Cc0aa3d83d5ec5aF6096C627778FBD06, 0);  
        Assert.isTrue(r, ""Valid isActive Test."");  
    }  

    function testIsActiveInvalid() public {  
        bool r = credentialFactory.isCredentialActive(0x5a186B7FeC36909678211F69beB67EC3b1E4fFBB, 5);  
        Assert.isFalse(r, ""Outside Range IsActive Test"");  
    }  
    function SelectOrgCredentialCount() public {  
        uint256 testVal = uint256(credentialFactory.SelectOrgCredentialCount(0x2259aA88Cc0aa3d83d5ec5aF6096C627778FBD06));  
        uint256 expected = 1;  
        Assert.equal(testVal, expected, ""Expected Credential Count (1)"");  
    }  

}"
21584-0.sol,question,"contract Demo {

    uint a;

    function set(uint b) returns (uint) {
        a = b;
        return a * b;
    }

    function get() constant returns (uint) {
        return a;
    }
}"
67009-0.sol,question,"contract SKYLotto {

  uint256 private secretNumber;
  uint256 public releasedNumber;
  uint256 public time;

    function randomGen() public {
        secretNumber = uint(keccak256(abi.encodePacked(now, msg.sender))) % 10;
        time = now + 30 seconds;
    }    

    function revealNumber() public {
      enter code here  require(now > time);
        releasedNumber = secretNumber;
        randomGen();
    }
}"
12649-0.sol,question,"contract OrganisationsFactory {
    mapping(string => OrganisationObject[]) organisations;
    event CreatedOrg(address indexed hsAddr);

    function add(string name, string vat, string headquaterAddress) public returns(address) {
        OrganisationObject newOrg = new OrganisationObject(name, vat, headquaterAddress);
        organisations[name].push(newOrg);
        CreatedOrg(newOrg);
        return newOrg;
    }

    function get(string name) public returns(OrganisationObject[]){
        return organisations[name];
    }
}"
12649-0.sol,question,"contract OrganisationObject {
    struct organisationDetails {
        string name; 
        string vat; 
        string headquaterAddress;
    }

    organisationDetails public details;

    address[] public staff;

    function OrganisationObject (string name, string vat, string headquaterAddress){
        details.name = name;
        details.vat = vat;
        details.headquaterAddress = headquaterAddress;
    }

    function addStaff(address x){
        staff.push(x);
    }
}"
71037-2.sol,question,"contract A {

    address _sub = address(B);

    function write(uint256 _a) public returns (bool, bytes memory) {
        (bool x, bytes memory y) = _sub.delegatecall(msg.data);
        return (x, y);
    }

    function read(uint256 _b) public returns (bool, bytes memory) {
        (bool x, bytes memory y) = _sub.delegatecall(msg.data);
        return (x, y);
    }
}"
61766-0.sol,question,"contract B {
  A a;
  constructor(address a_address) { a = I_A(a) };

  function exb(bytes32 _structaddr){
    
    a.myStructs(_structaddr); 
  }
}"
61766-0.sol,question,"contract TestB {
  B testb;
  A testa;

   function beforeAll() {
     testa = new A();
     testB = new B(testa);
   }

  function test_exb() {
    b.exb();
  }
}"
84806-2.sol,question,"contract Own {

    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }
}"
720-1.sol,question,"contract Second {
  address public sender;

  function Second() {
    sender = msg.sender;
  }
}"
24273-0.sol,question,"contract token { function transfer(address, uint){  } }"
24273-0.sol,question,"contract Crowdsale {
    address public beneficiary;
    uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    event GoalReached(address beneficiary, uint amountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);
    bool crowdsaleClosed = false;

    

    
    function Crowdsale(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        token addressOfTokenUsedAsReward
    ) {
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 1 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function () payable {
        if (crowdsaleClosed) revert();
        uint amount = msg.value;
        balanceOf[msg.sender] = amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / price);
        FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() afterDeadline {
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    function safeWithdrawal() afterDeadline {
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}"
15164-0.sol,question,"contract Tester {
    function getBytes() returns (bytes32) {
        return bytes32(0x1);
    }
}"
67134-1.sol,question,"contract SampleToken is PausableToken {
    string public constant name = ""Sample Token""; 
    string public constant symbol = ""STT"";
    uint256 public constant decimals = 18;

    mapping (address => uint256) freezes;

    
    event Burn(address indexed from, uint256 value);

    
    event Freeze(address indexed from, uint256 value);

    
    event Unfreeze(address indexed from, uint256 value);

    constructor() public {
        totalSupply_ = 500000000 * (10 ** uint256(decimals));
        balances[msg.sender] = totalSupply_;
        
    }

    function freezeOf(address _owner) public view returns (uint256) {
        return freezes[_owner];
    }

    function burn(uint256 _value) whenNotPaused public returns (bool) {
        require(_value <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        totalSupply_ = totalSupply_.sub(_value);
        emit Burn(msg.sender, _value);
        return true;
    }

    function freeze(uint256 _value) whenNotPaused public returns (bool) {
        require(_value <= balances[msg.sender]);

        balances[msg.sender] = balances[msg.sender].sub(_value);
        freezes[msg.sender] = freezes[msg.sender].add(_value);
        emit Freeze(msg.sender, _value);
        return true;
    }

    function unfreeze(uint256 _value) whenNotPaused public returns (bool) {
        require(_value <= freezes[msg.sender]);

        freezes[msg.sender] = freezes[msg.sender].sub(_value);
        balances[msg.sender] = balances[msg.sender].add(_value);
        emit Unfreeze(msg.sender, _value);
        return true;
    }

    
    function transferOwnership(address newOwner) onlyOwner whenNotPaused public {
        super.transferOwnership(newOwner);
    }

    
    function() payable external {
        revert();
    }
}"
39181-0.sol,question,"contract CheckBet is usingOraclize {
    struct Weather {
        uint curr_temperature;
        uint high_temperature;
        uint low_temperature;
    }
    Weather weather;

function get_weather_status() payable{
    Log(""Oraclize query was sent, waiting for the answer..""); 
    (oraclize_query(""URL"",""json(http:

}


function __callback(bytes32 _myid, string _result) {
    require (msg.sender == oraclize_cbAddress());
    Log(_result);
    assign_value_to_weather[low_temperature]= parseInt(_result, 2); 
}"
11277-0.sol,question,"contract Transfer {

        address public userA;
        address public user;
        mapping (address => uint) balances;
        uint value2;

       

       function Transfer() {
              userA=msg.sender;
              balances[userA]=1000;     
       }

      function sendEther(address user,uint value)returns (bool success){

             if(balances[userA]< value){
                      return false;
             }
             else {
                      balances[userA] -= value;
                      balances[user] += value;
              return true;
             }
   }
   function sendAddressToAddress(address fromuser,address touser)returns      (bool success){
            uint value=balances[fromuser];
            if(value < 0){
                return false;
            }
            else {
                balances[fromuser] -= value;
                balances[touser] += value;
                return true;
            }
  }
  function getBalance(address user) returns (uint _balance){
           return balances[user];
  }
}"
11277-0.sol,question,"contract SecondTransfer {

 function sendEtherCall(address contractaddr,address user,uint value) returns (bool success) {
      Transfer transfer=Transfer(contractaddr);
      return transfer.sendEther(user,value);
}
function sendAddressToAddressCall(address contractaddr,address fromuser,address touser) returns (bool success) {
      Transfer transfer=Transfer(contractaddr);
      return transfer.sendAddressToAddress(fromuser,touser);
}
function getBalanceCall(address contractaddr,address user) returns (uint _balance) {
      Transfer transfer=Transfer(contractaddr);
      return transfer.getBalance(user);
  }

 }"
30460-1.sol,question,"contract Crowdsale {

    

    function buyTokens(address beneficiary) public payable {
        require(beneficiary != 0x0);
        require(validPurchase());

        
        token.mint(beneficiary, tokens); 
        
  }
}"
82817-0.sol,question,"contract ERC20 {
    function totalSupply() public view returns (uint supply);
    function balanceOf(address _owner) public view returns (uint balance);
    function transfer(address _to, uint _value) public returns (bool success);
    function transferFrom(address _from, address _to, uint _value) public returns (bool success);
    function approve(address _spender, uint _value) public returns (bool success);
    function allowance(address _owner, address _spender) public view returns (uint remaining);
    function decimals() public view returns(uint digits);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
}"
82817-0.sol,question,"contract MySmartContract {
    function approveDeposit(address tokenAddress) public {
        ERC20 token = ERC20(tokenAddress);
        token.approve(address(this), token.balanceOf(msg.sender));
    }

    function depositToken(address tokenAddress) public {
        ERC20 token = ERC20(tokenAddress);
        uint tokenAmount = token.balanceOf(msg.sender);
        token.transferFrom(msg.sender, address(this), tokenAmount);
    }
}"
71815-1.sol,question,"contract ListingGenerator {
    
   Listing[] public deployedListings;

    
    function createListing(uint assessedValue, uint listPrice, string memory description, string memory location) public {
       Listing newListing = new Listing(assessedValue, listPrice, description, location, msg.sender);
        deployedListings.push(newListing);
    }

    
    function getDeployedListings() public view returns (Listing[] memory){
        return deployedListings;
    }
}"
71815-1.sol,question,"contract Listing {
    uint public assessedValue;
    uint public listPrice;
    string public description;
    string public location;
    address public seller;
    bool public sold;
    mapping(address => bool) public buyers;
    uint public buyersCount;

    modifier restricted() {
        require(msg.sender == seller);
        _;
    }

    constructor(uint propertyValue, uint salePrice, string memory propertyDetails, string memory propertyLocation, address owner) public {
        propertyValue = assessedValue;
        listPrice = salePrice;
        description = propertyDetails;
        location = propertyLocation;
        seller = owner;
        }

    function confirmSale(uint confirm) public restricted returns(bool) {
        if (confirm == 1) {
            sold = true;
            return sold;
        }
    }
}"
15087-0.sol,question,"contract Steal{
      function delegatecall_selfdestruct(address _target) external returns (bool _ans) {
          _ans = _target.delegatecall(bytes4(sha3(""selfdestruct(address)"")), this); 
      }
}"
15087-0.sol,question,"contract Mark { 
  function Deposit() payable {
  }
}"
40832-0.sol,question,"contract MyFirstContract {
    string private name;
    uint private age;

    function setName(string newName) {
        name = newName;
    }

    function getName() returns (string) {
        return name;
    }
}"
11652-0.sol,question,"contract ApiCall is usingOraclize {

       uint public DieselPriceUSD;

       function DieselPrice() {

                OAR = OraclizeAddrResolverI(0x920cd3f7ed02c5d61e2556308d53a4d9d1e58bf2); 
       }

       function __callback(bytes32 myid, string result) {
                if (msg.sender != oraclize_cbAddress()) throw;
                       DieselPriceUSD = parseInt(result, 2); 
       }

      function update() payable {
                oraclize_query(""URL"", ""xml(https:
     }

}"
30000-0.sol,question,"contract TokenVesting is Ownable {
  using SafeMath for uint256;
  using SafeERC20 for ERC20Basic;

  event Released(uint256 amount);
  event Revoked();

  
  address public beneficiary;

  uint256 public cliff;
  uint256 public start;
  uint256 public duration;

  bool public revocable;

  mapping (address => uint256) public released;
  mapping (address => bool) public revoked;

  
  function TokenVesting(address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable) {
    require(_beneficiary != address(0));
    require(_cliff <= _duration);

    beneficiary = _beneficiary;
    revocable = _revocable;
    duration = _duration;
    cliff = _start.add(_cliff);
    start = _start;
  }

  
  function release(ERC20Basic token) public {
    uint256 unreleased = releasableAmount(token);

    require(unreleased > 0);

    released[token] = released[token].add(unreleased);

    token.safeTransfer(beneficiary, unreleased);

    Released(unreleased);
  }

  
  function revoke(ERC20Basic token) public onlyOwner {
    require(revocable);
    require(!revoked[token]);

    uint256 balance = token.balanceOf(this);

    uint256 unreleased = releasableAmount(token);
    uint256 refund = balance.sub(unreleased);

    revoked[token] = true;

    token.safeTransfer(owner, refund);

    Revoked();
  }

  
  function releasableAmount(ERC20Basic token) public constant returns (uint256) {
    return vestedAmount(token).sub(released[token]);
  }

  
  function vestedAmount(ERC20Basic token) public constant returns (uint256) {
    uint256 currentBalance = token.balanceOf(this);
    uint256 totalBalance = currentBalance.add(released[token]);

    if (now < cliff) {
      return 0;
    } else if (now >= start.add(duration) || revoked[token]) {
      return totalBalance;
    } else {
      return totalBalance.mul(now.sub(start)).div(duration);
    }
  }
}"
29217-2.sol,question,"contract Writer {

  struct Paragraph {
    string sentances;
  }

  struct Essay {
    string title;
    Paragraph[] paragraphs;
  }

  Essay[] private essays;

  function Writer(Essay essay) {
    essays.push(essay);
  }

}"
12154-0.sol,question,"contract UserA {

  address public owner;
  address public user;
  address public SCAddress; 

 function UserA(string _provider,address _user,address _scaddress) {
        owner = msg.sender;
        user = _user;
        SCAddress = _scaddress;
    }

  function setColor(string c) { 
    if (msg.sender == user) { 
             color = c;
        }
    }
"
26674-1.sol,question,"contract User {
    address[] userList;
    function addUser (address a) returns (bool) {
        userList.push(a);
    }"
57055-0.sol,question,"contract zeppelinSales {
  using SafeMath for uint256;
  using SafeERC20 for ERC20;

  
  ERC20 public token;

  
  address public wallet;

  
  
  
  
  uint256 public rate;

  
  uint256 public weiRaised;

  
  event TokenPurchase(
    address indexed purchaser,
        address indexed beneficiary,
    uint256 value,
    uint256 amount
  );

  
  constructor(uint256 _rate, address _wallet, ERC20 _token) public {
    require(_rate > 0);
    require(_wallet != address(0));
    require(_token != address(0));

    rate = 8 * (10**8);
    wallet = 0xF76075Cf3B674fB9656E393e9e17091B01243666;
    token = token = ERC20(0x0f26c1c05f1bbBC7Eff0488F1a98619e8a9758cf);
  }

  
  
  

  
  function () external payable {
    buyTokens(msg.sender);
  }

  
  function buyTokens(address _beneficiary) public payable {

    uint256 weiAmount = msg.value;
    _preValidatePurchase(_beneficiary, weiAmount);

    
    uint256 tokens = _getTokenAmount(weiAmount);

    
    weiRaised = weiRaised.add(weiAmount);

    _processPurchase(_beneficiary, tokens);
    emit TokenPurchase(
      msg.sender,
      _beneficiary,
      weiAmount,
      tokens
    );

    _updatePurchasingState(_beneficiary, weiAmount);

    _forwardFunds();
    _postValidatePurchase(_beneficiary, weiAmount);
  }

  
  
  

  
  function _preValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    require(_beneficiary != address(0));
    require(_weiAmount != 0);
  }

  
  function _postValidatePurchase(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _deliverTokens(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    token.safeTransfer(_beneficiary, _tokenAmount);
  }

  
  function _processPurchase(
    address _beneficiary,
    uint256 _tokenAmount
  )
    internal
  {
    _deliverTokens(_beneficiary, _tokenAmount);
  }

  
  function _updatePurchasingState(
    address _beneficiary,
    uint256 _weiAmount
  )
    internal
  {
    
  }

  
  function _getTokenAmount(uint256 _weiAmount)
    internal view returns (uint256)
  {
    return _weiAmount.mul(rate);
  }

  
  function _forwardFunds() internal {
    wallet.transfer(msg.value);
  }
}"
77157-1.sol,question,"contract C2 {
    C1 c1;
    constructor(address _c1) public {
        c1 = C1(_c1);
    }

    function setX(int _x) public {
        c1.setX(_x);
    }

    function getX() public view returns (int) {
        c1.getX();
    }
}"
64877-0.sol,question,"contract Destructor {
    address owner;

    constructor() {
        owner = msg.sender;
    }

    function done() public {
        selfdestruct(owner);
    }
}"
64877-0.sol,question,"contract Test {
    ...
    function test(address dtor) public returns(bool) {
        Destructor(dtor).done();
        
        bla += 42;
        return true;
    }
}"
15404-0.sol,question,"contract DataStore {

    struct Datum {
        uint8   id;
        bytes32 serialNum;
        string  name;
        uint256 createdAt;
    }

    mapping (address => Datum) private entityData; 

    function getName(address entity) public constant returns (string) {
        if (isAllowed(msg.sender) {
            return name;
        }
        else {
            return """";
        }
    } 
    ...
    ...
"
55805-2.sol,question,"contract Tenno2 {


address Player;

string Warframe = ""Ember Prime"";
uint Rank = 1;
bool Potato = false;
uint HP = 150;
uint MP = 200;





constructor() public payable {
    Player = msg.sender;

}

event AbilityUsed(string ability);
event Restored(uint health, uint energy);
event RankChange(uint rank);



function getWarframe() public constant returns (string) { return Warframe; }

function getPotato() public constant returns (bool) { return Potato; }
function PotatoFrame() public { Potato = true; }

function getHP() public constant returns (uint) { return HP; }
function getMP() public constant returns (uint) { return MP; }

function getRank() public constant returns (uint) { return Rank; }
function getCapacity() public constant returns(uint) {
    if (Potato == true) {
        return Rank * 2;
    }
    else {
        return Rank;
    }
}

function First() public{
    if (MP >= 25) {
        MP -= 25;
    }
    emit AbilityUsed(""Fireball"");
}

function Second() public {
    if (MP >= 50) {
        MP -= 50;
    }
    emit AbilityUsed(""Accelerant"");
}

function Thirth() public {
    if (MP >= 75) {
        MP -= 75;
    }
    emit AbilityUsed(""Fireblast"");
}

function Fourth() public {
    if (MP >= 100) {
        MP -= 100;
    }
    emit AbilityUsed(""World on Fire"");
}

function Heal(uint amount) public returns (uint) {
    HP += amount;
    emit Restored(amount, 0);
    return HP;
}

function TakeDamage(uint amount) public returns (uint) {
    HP -= amount;
    return HP;
}

function Recharge(uint amount) public returns (uint) {
    MP += amount;
    emit Restored(0, amount);
    return MP;
}

function RankUp() public returns (uint) {
    if (Rank < 30) {
        Rank += 1;
    }
    emit RankChange(Rank);
    return Rank;
}

function ResetRank() public returns (uint) {
    if (Rank == 30) {
        Rank = 1;
    }
    emit RankChange(Rank);
    return Rank;
}
}"
35733-0.sol,question,"contract Storage {

    address approvedAddress;

    function update(address _sendingAddress, __MORE_HERE__) public {
        if(_sendingAddress == approvedAddress){
          
        }
    }
}"
66228-2.sol,question,"contract Crowdsale is ReentrancyGuard {
  using SafeMath for uint256;
  using SafeERC20 for IERC20;

  
  IERC20 private _token;

  
  address private _wallet;

  
  
  
  
  uint256 private _rate;

  
  uint256 private _weiRaised;

  
  event TokensPurchased(
    address indexed purchaser,
    address indexed beneficiary,
    uint256 value,
    uint256 amount
  );

  
  constructor(uint256 rate, address wallet, IERC20 token) internal {
    require(rate > 0);
    require(wallet != address(0));
    
    require(address(token) != address(0));

    _rate = rate;
    _wallet = wallet;
    _token = token;
  }



  
  
  

  
  function () external payable {
    buyTokens(msg.sender);
  }


  
  function token() public view returns(IERC20) {
    return _token;
  }


  
  function wallet() public view returns(address) {
    return _wallet;
  }


  
  function rate() public view returns(uint256) {
    return _rate;
  }


  
  function weiRaised() public view returns (uint256) {
    return _weiRaised;
  }


  
  function buyTokens(address beneficiary) public nonReentrant payable {
    uint256 weiAmount = msg.value;
    _preValidatePurchase(beneficiary, weiAmount);

    
    uint256 tokens = _getTokenAmount(weiAmount);

    
    _weiRaised = _weiRaised.add(weiAmount);

    _processPurchase(beneficiary, tokens);

    emit TokensPurchased(msg.sender, beneficiary, weiAmount, tokens);

    _updatePurchasingState(beneficiary, weiAmount);

    _forwardFunds();
    _postValidatePurchase(beneficiary, weiAmount);
  }


  
  
  

  
   
   
  function _preValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
    require(beneficiary != address(0));
    require(weiAmount != 0);
  }


  
  function _postValidatePurchase(address beneficiary, uint256 weiAmount) internal view {
    
  }


  
  function _deliverTokens(address beneficiary, uint256 tokenAmount ) internal {
    _token.safeTransfer(beneficiary, tokenAmount);
  }



  
  function _processPurchase(address beneficiary, uint256 tokenAmount) internal {
    _deliverTokens(beneficiary, tokenAmount);
  }


  
  function _updatePurchasingState(address beneficiary, uint256 weiAmount) internal {
    
  }


  
  function _getTokenAmount(uint256 weiAmount) internal view returns (uint256) {
    return weiAmount.mul(_rate);
  }


  
  function _forwardFunds() internal {
    _wallet.transfer(msg.value);
  }


}"
42889-0.sol,question,"contract TransManager {
  

  
  address private creator;

  uint transCounter;

  
  struct metaData{
    uint id;
    address owner;
    string docType;
    string fileHash;
  }

  
  mapping (address => metaData[])  fileLogs;


  

  function regTransaction(string _docType, string _fileHash) public {
    transCounter++;
    var fileLog = metaData(transCounter, msg.sender, _docType, _fileHash );

    fileLogs[msg.sender].push(fileLog);

  }

  function getTransactions() public returns (uint []){
    var temp = fileLogs[msg.sender];


    uint[] memory ids = new uint[](transCounter);


    for (uint i=0; i<= transCounter; i++){
        ids[i]=temp[i].id;
    }

    return ids;
  }



  
    function TransManager() {
        creator = msg.sender;
    }

  
   function kill() {
       if (msg.sender == creator) {
           selfdestruct(creator);
       }
   }

}"
18661-0.sol,question,"contract test {

  int _multiplier;
  struct MyCustomData {
    bool exists;
    string Name1;
  }
  mapping(string => MyCustomData) myData;

  event Multiplied(int indexed a, address indexed sender, int result );

  function test(int multiplier) {
    _multiplier = multiplier;
  }

  function multiply(int a) returns (int r) {

    myData[""a""] = MyCustomData(true, ""aa1"");

    r = a * _multiplier;
    Multiplied(a, msg.sender, r);
    return r;
  }
}"
44380-0.sol,question,"contract Receiver {

function notify(uint count) returns(uint);

function getCurrentCounter() constant returns(uint);

}"
44380-0.sol,question,"contract Producer {

uint private count;
uint private subscriberCount;
mapping(uint => Subscriber) subscribers;
event CountIncreased(uint num);

struct Subscriber {
    string subscriberName;
    address subscriberAddress;
}

function Producer() {
    count = 0;
    subscriberCount = 0;
}

function increaseCount() returns(uint,address) {
    count++;
    Receiver receiver = Receiver(subscribers[0].subscriberAddress);
    receiver.notify(count);
    CountIncreased(count);
    return (count,subscribers[0].subscriberAddress);
}

function addSubscriber(string name, address subAddress) {
    subscriberCount++;
    subscribers[subscriberCount].subscriberName = name ;
    subscribers[subscriberCount].subscriberAddress = subAddress ;
}

function removeSubscriber(string subscriberName) {
    for (uint i=0; i<subscriberCount; i++) {
        Subscriber sub = subscribers[i];
        if(keccak256(sub.subscriberName) == keccak256(subscriberName)) {
            delete subscribers[i];
            subscriberCount--;
        }
    }

}


}"
81985-1.sol,question,"contract Master {
    mapping(address => uint) public balances;
    address public implementation;

    function setBalance(address _address, uint _balance) public {
        balances[_address] = _balance;
    }

    function getBalance(address _balance) public view returns (uint) {
        return balances[_balance];
    }


}"
81985-1.sol,question,"contract Child {
    mapping(address => uint) public balances;
    address public implementation;

    function setImplementation(address _address) public {
        implementation = _address;
    }


    fallback () payable external {
        _fallback();
    }

    function _fallback() internal {
        _delegate(implementation);
    }


   function _delegate(address _implementation) internal {
    assembly {
      
      
      
      calldatacopy(0, 0, calldatasize())

      
      
      let result := delegatecall(gas(), _implementation, 0, calldatasize(), 0, 0)

      
      returndatacopy(0, 0, returndatasize())

      switch result
      
      case 0 { revert(0, returndatasize()) }
      default { return(0, returndatasize()) }
    }
  }

}"
65660-0.sol,question,"contract dCoders {
    
    
    address public owner;
    uint public regFee;

    mapping (address => uint) public balance; 

    constructor() public {
        owner = msg.sender;
        regFee = 2 ether;
    }

    event reg(address indexed _from);

    
    function register() payable public {
        

        balance[msg.sender] -= regFee;
        balance[address(this)] += regFee;   

        emit reg(msg.sender);
    }

    

    
}"
66820-0.sol,question,"contract Rent is Owned {    
struct Person {

    address eth;
    string legalName;
    string email;
    uint aadhaar;

    string signTerms; 

    uint[] myOwned;
    uint[] myRented;
}

struct Parties {

    address landlord;
    address tenant;

    string signLandlord;
    string signTenant;

    bool completed;
}


struct House {

    string addressHouse;
    string type_of_property;

    uint startEpoch;
    uint endEpoch; 

    uint monthDuration; 

    uint rentAmount;
    uint securityFee;
    uint registerFee;

    bool completed;
}

struct OtherDetails {

    string latitude;
    string longitude;

    string ipfs_url; 

    uint squareFootage;
    uint numberBedrooms;
    string others;

    bool completed;
}

struct Checks {

    bool isValid;

    bool tenantApprove;
    bool govApprove;

    bool tenantCheck;

    bool paidRegisterFee;
    bool paidSecurityFee;
}

Parties[] public allParties; 
House[] public allHouses;
OtherDetails[] public allOtherDetails;
Checks[] private allChecks;

mapping(address => Person) public addressToPerson;
mapping(address => bool) private checkUser;
mapping(uint => bool) private checkAadhaar;

mapping(address => uint) private registerFeeMap;
mapping(address => uint) private securityFeeMap;


function Rent() public {

    checkUser[owner] = true;
    var govt = Person(owner, 'Owner', 'Owner', 0, 'No Sign', new uint[](0), new uint[](0));

    addressToPerson[owner] = govt;
}


event registerParty(string message);

function registerParties(address _tenant) external  {

    require(msg.sender != _tenant);

    if(checkUser[msg.sender] == true)
    {
        if(checkUser[_tenant] == true)
        {
            var newParty = Parties(msg.sender, _tenant,'N/A', 'N/A', true);
            var index = allParties.push(newParty) - 1;

            var newHouse = House('No Address Added', 'No Property Type', 0, 0, 0, 0, 0, 0, false);
            allHouses.push(newHouse);

            var newDetails = OtherDetails('28.7041', '77.1025', 'Currently IPFS Not Supported', 0, 0, 'N/A', false);
            allOtherDetails.push(newDetails);

            var newChecks = Checks(false, false, false, false, false, false);
            allChecks.push(newChecks);

            var user = addressToPerson[msg.sender];
            user.myOwned.push(index);

            var tenant = addressToPerson[_tenant];
            tenant.myRented.push(index);

            registerParty('Tenant was Successfully added to Contract, Proceed to Step 2');
        }

        else
        {
            registerParty('Tenant is not registered on Charter, registration of both parties is required');
        }
    }

    else
    {
        registerParty('Kindly register on Charter, before drafting a Contract');
    }
}


event registerHome(string message, uint FeePayable);

function newHome(string _add, string _type, uint _startEpoch, uint _endEpoch, uint _months, uint _rent, uint _security) external {

    if(checkUser[msg.sender] == true)
    {
        var user = addressToPerson[msg.sender];

        uint num = user.myOwned.length - 1;

        if(num < 0)
        {
            registerHome('Kindly fill Tenant Info in Step 1 before proceeding to Step 2', 0);
        }

        else
        {
            uint index = user.myOwned[num];
            var houseOwner = allParties[index];

            if(houseOwner.landlord != msg.sender)
            {
                registerHome('Kindly register on Charter, before drafting a Contract', 0);
            }

            else
            {
                var home = allHouses[index];

                if(home.completed == false)
                {
                    home.addressHouse = _add;
                    home.type_of_property = _type;

                    home.startEpoch = _startEpoch;
                    home.endEpoch = _endEpoch;

                    home.monthDuration = _months;

                    home.rentAmount = _rent;
                    home.securityFee = _security;

                    var _tenant = allParties[index].tenant; 

                    if((home.monthDuration < 12)&&(home.monthDuration > 0))
                    {
                        home.registerFee = 100;
                        home.completed = true;

                        registerHome(""Property's Information successfully entered, Proceed to Step-3"", home.registerFee);
                    }

                    else if(home.monthDuration <= 60)
                    {
                        if(_security > 0)
                        home.registerFee = 100 + ((2 * 12 * _rent) / 100) + 1100;

                        else
                        home.registerFee = ((2 * 12 * _rent) / 100) + 1100;

                        home.completed = true;

                        registerHome(""Property's Information successfully entered, Proceed to Step-3"", home.registerFee);
                    }

                    else if(home.monthDuration <= 120)
                    {
                        if(_security > 0)
                        home.registerFee = 100 + ((3 * 12 * _rent) / 100) + 1100;

                        else
                        home.registerFee = ((3 * 12 * _rent) / 100) + 1100;     

                        home.completed = true;

                        registerHome(""Property's Information successfully entered, Proceed to Step-3"", home.registerFee);       
                    }

                    else if(home.monthDuration <= 240)
                    {
                        if(_security > 0)
                        home.registerFee = 100 + ((6 * 12 * _rent) / 100) + 1100;

                        else
                        home.registerFee = ((6 * 12 * _rent) / 100) + 1100;

                        home.completed = true;
                        registerHome(""Property's Information successfully entered, Proceed to Step-3"", home.registerFee);
                    }

                    else
                    {
                        home.completed = false;
                        registerHome('Kindly Enter Duration of Contract Correctly.. (Min - 1 month, Max - 240 Months' , 0);
                    }
                }

                else
                {
                    registerHome('Home Registration is already Completed ', 0);
                }

                registerFeeMap[msg.sender] = home.registerFee;
                securityFeeMap[_tenant] = home.securityFee;
            }

        }
    }

    else
    {
        registerHome('Kindly register on Charter, before drafting a Contract', 0);
    }
}



event feePay(string message);

function feePayment(string _sign, uint _currentRate) external payable {

    require(msg.value == (registerFeeMap[msg.sender] * 10**18 / _currentRate));

    if(checkUser[msg.sender] == true)
    {
        var user = addressToPerson[msg.sender];

        uint num = user.myOwned.length - 1;

        if(num < 0)
        {
            feePay('Complete all the Steps, before paying Registration Fee Payment');
        }

        else
        {

            uint index = user.myOwned[num];
            var party = allParties[index];
            var house = allHouses[index];
            var details = allOtherDetails[index];
            var checks = allChecks[index];

            if((details.completed == true)&&(house.completed == true)&&(party.completed == true))
            {
                user = addressToPerson[msg.sender];
                checks.paidRegisterFee = true;
                party.signLandlord = _sign;

                feePay('Government Registration Fee Payment Successful, Tenant Verification pending..');
            }

            else 
            {
                feePay('Complete all the Steps given above before Fee Payment');
            }
        }
    }

    else
    {
        feePay('Kindly register on Charter, before drafting a Contract');
    }
}
}"
66530-0.sol,question,"contract Locations {

    function doSomething() public pure returns (uint[] memory) {

    uint[] memory localMemoryArray1 = new uint[](3);
    localMemoryArray1[0] = 4;
    localMemoryArray1[1] = 5;
    localMemoryArray1[2] = 6;

    uint[] memory localMemoryArray2 = localMemoryArray1;
    delete localMemoryArray1; 
    return localMemoryArray2;
  }
}"
58171-0.sol,question,"contract SendAndTransferExample {

    function SimpleSendToAccount() public returns(bool) {
       return msg.sender.send(10000000000000000000);
    }

    function SimpleTransferToAccount() public {
       msg.sender.transfer(10000000000000000000);
    }
}"
62670-0.sol,question,"contract RecurringLottery {
         struct Round {
            uint deployBlock;
            uint endBlock;
            uint drawBlock;
            Entry[] entries;
            uint totalQuantity;
            address winner;
       }
struct Entry {
    address buyer;
    uint quantity;
}

uint constant public TICKET_PRICE = 1e15;

mapping(uint => Round) public rounds;
uint public round;
uint public duration;
mapping (address => uint) public balances;


function RecurringLottery (uint _duration) public {
    round = 1;
    duration = _duration;
    rounds[round].deployBlock = block.number;
    rounds[round].endBlock = block.number + duration;
    rounds[round].drawBlock = block.number + duration + 5;
}

function buy () payable public {
    require(msg.value % TICKET_PRICE == 0);

    if (block.number > rounds[round].endBlock) {
        round += 1;
        rounds[round].deployBlock = block.number;
        rounds[round].endBlock = block.number + duration;
        rounds[round].drawBlock = block.number + duration + 5;
    }

    uint quantity = msg.value / TICKET_PRICE;
    Entry memory entry = Entry(msg.sender, quantity);
    rounds[round].entries.push(entry);
    rounds[round].totalQuantity += quantity;
}

function drawWinner (uint roundNumber) public {
    Round storage drawing = rounds[roundNumber];
    require(drawing.winner ==  address(0));
    require(block.number > drawing.drawBlock);
    require(drawing.entries.length > 0);

    
    bytes32 rand = keccak256(
        block.blockhash(drawing.drawBlock)
    );
    uint counter = uint(rand) % drawing.totalQuantity;
    for (uint i=0; i < drawing.entries.length; i++) {
        uint quantity = drawing.entries[i].quantity;
        if (quantity > counter) {
            drawing.winner = drawing.entries[i].buyer;
            break;
        }
        else
            counter -= quantity;
    }

    balances[drawing.winner] += TICKET_PRICE * drawing.totalQuantity;
}

function withdraw () public {
    uint amount = balances[msg.sender];
    balances[msg.sender] = 0;
    msg.sender.transfer(amount);
}

function deleteRound (uint _round) public {
    require(block.number > rounds[_round].drawBlock + 100);
    require(rounds[_round].winner != address(0));
    delete rounds[_round];
}

function () payable public {
    buy();
}"
70142-0.sol,question,"contract C {
    address a;
    constructor(address _a) public {
        a = _a;
    }

    function get() external view returns (address) {
        return a;
    }
}"
74156-0.sol,question,"contract Testing {
    using GetName for address;

    mapping (address => string) public record;

    function recordName(address addr) public {
        record[addr] = addr.getNameOrEmpty();
    }
}"
21469-0.sol,question,"contract MarketMaker {
address iplogic;
address ipxaddr;
function MarketMaker(address _iplogic, address _ipx) {
    iplogic = _iplogic;
    ipxaddr = _ipx;
    log(ipxaddr);
    log(_ipx);
}
event log(address ipx);
function createNewMarket(string prop, uint256 minBet, bool initUtility) onlyIplogic returns (address, address) {
    log(ipxaddr);
    log(iplogic);}"
79070-0.sol,question,"contract Contract {

struct A {
  int a;
}

struct B {
  A[] as;
}

mapping(address => B[]) bs;

function addB(B memory b) {
  bs[msg.sender].push(...???...);
}

}"
6975-0.sol,question,"contract C {
  function Get() constant returns(bytes8[]) {
    bytes8[] stuff;
    return stuff;
  }
  function Copy() {
    bytes8[] memory stuff = Get();
  }
}"
65647-0.sol,question,"contract OrcBase is InterfaceOrcs {
    struct Orc {
        uint health;
        uint strenth;
    }

    Orc[] orcs;

    function createOrc(uint _health, uint _strenth) public returns(uint) {
        
        Orc memory _orc = Orc({
            health: _health,
            strenth: _strenth
        });
        uint256 newOrcId = orcs.push(_orc) - 1;

        return newOrcId;
    }

    
    
    function totalSupply() public view returns (uint) {
        uint length = orcs.length;
        return length;
    }

    function getOrcHealth(uint id) public view returns (uint) {
        uint health = orcs[id].health;
        return health;
    }

    function getOrcStrenth(uint id) public view returns (uint) {
        uint strenth = orcs[id].strenth;
        return strenth;
    }
}"
67870-0.sol,question,"contract Election {
    
    struct Candidate {
        uint id;
        string name;
        uint voteCount;
    }

    
    
    mapping(uint => Candidate) public candidates;
    
    uint public candidatesCount;

    function Elections () public {
        addCandidate(""Candidate 1"");
        addCandidate(""Candidate 2"");
    }

    function addCandidate (string memory _name) private {
        candidatesCount ++;
        candidates[candidatesCount] = Candidate(candidatesCount, _name, 0);
    }

}"
24521-0.sol,question,"contract testContract {

   uint256 test;

   function testContract() {    
   }

   function getTest() constant returns (uint256) {
       return test;    
   }

   function setTest(uint256 _test) {
       test = _test;    
   } 
}"
56092-0.sol,question,"contract Recoverable is Ownable {

  
  function Recoverable() public {
  }

  
  
  function recoverTokens(ERC20Basic token) onlyOwner public {
    token.transfer(owner, tokensToBeReturned(token));
  }

  
  
  
  function tokensToBeReturned(ERC20Basic token) public returns (uint) {
    return token.balanceOf(this);
  }
}"
63224-0.sol,question,"contract SortStruct {


    struct TestStruct {
        address user;
        uint256 value;
    }
    TestStruct[] public testStructArray;
    TestStruct[] public sortedArray;

    function add(uint256 _value) public {


        TestStruct memory test;

        test.value = _value;
        testStructArray.push(test);

    }


    function sort() public {
        sortedArray = sort(testStructArray);
    }


    
    
    
    function sort(TestStruct[] memory  data) internal returns (TestStruct[] memory) {
       quickSort(data, int(0), int(data.length - 1));
       return data;
    }

    function quickSort(TestStruct[] memory arr, int left, int right) internal {
        int i = left;
        int j = right;
        if(i==j) return;
        uint pivot = arr[uint(left + (right - left) / 2)].value;
        while (i <= j) {
            while (arr[uint(i)].value < pivot) i++;
            while (pivot < arr[uint(j)].value) j--;
            if (i <= j) {

                
                TestStruct memory tempSortCandidate;
                tempSortCandidate = arr[uint(i)];
                arr[uint(i)] = arr[uint(j)];
                arr[uint(j)] = tempSortCandidate;

                i++;
                j--;
            }
        }
        if (left < j)
            quickSort(arr, left, j);
        if (i < right)
            quickSort(arr, i, right);
    }

}"
46054-0.sol,question,"contract PublishService {

    using strings for *;
    using SafeMath for uint;
    struct ServiceListStruct {
        string cloudID;
        address gatewayID;
        string serviceProducerID;
        mapping (string => string) serviceProducerMetadata;
        string serviceConsumerMetaAttr;
        string accessControlModel;
    }

    ServiceListStruct[] public BCServiceList;

    uint BCServiceListIndex;

    function PublishService() {
        BCServiceListIndex = 0;
    }

    modifier onlyServiceProducerOwner(address _gatewayID) {
        require(msg.sender == _gatewayID);
        _;
    }

    ServiceListStruct sls;
    uint public maxParams = 0;


    function addEntry(string _cloudID, address _gatewayID, string _serviceProducerID, string _serviceProducerMetadata, string _serviceConsumerMetaAttr, string _accessControlModel) public onlyServiceProducerOwner(_gatewayID) returns (uint) {
        sls.cloudID = _cloudID;
        sls.gatewayID = _gatewayID;
        sls.serviceProducerID = _serviceProducerID;
        sls.serviceConsumerMetaAttr = _serviceConsumerMetaAttr;
        sls.accessControlModel = _accessControlModel;
        BCServiceList.push(sls);
        
        string memory s1;
        string memory s2 = _serviceProducerMetadata;
        string memory s3;
        bytes memory s2bytes = bytes(_serviceProducerMetadata);
        uint paramCount = 0;
        while(s2bytes.length != 0) {
            (s1,s2) = splitString(s2,"";"");
            (s1,s3) = splitString(s1,"":"");
            BCServiceList[BCServiceListIndex].serviceProducerMetadata[s1] = s3;
            paramCount = paramCount.add(1);
            s2bytes = bytes(s2);
        }
        if(maxParams < paramCount) {
            maxParams = paramCount;
        }
        BCServiceListIndex = BCServiceListIndex.add(1);
        return 1;
    }

    function deleteEntry(string _cloudID, address _gatewayID, string _serviceProducerID) public onlyServiceProducerOwner(_gatewayID) returns (uint) {
        require(msg.sender == _gatewayID);
        int pos = -1;
        for(uint index = 0; index < BCServiceList.length; index++) {
            if(compareStringsbyBytes(_cloudID, BCServiceList[index].cloudID)) {
                if(_gatewayID == BCServiceList[index].gatewayID) {
                    if(compareStringsbyBytes(_serviceProducerID, BCServiceList[index].serviceProducerID)) {
                        pos = int(index);
                    }
                }
            }
        }
        if(pos > -1) {
             BCServiceList[index] = BCServiceList[BCServiceList.length -1];
             delete BCServiceList[BCServiceList.length - 1];
             BCServiceList.length--;
             return 1;
        }
        else
            return 0;
    }

    function compareStringsbyBytes(string s1, string s2) internal pure returns(bool) {
        bytes memory s1bytes = bytes(s1);
        bytes memory s2bytes = bytes(s2);
        if(s1bytes.length!=s2bytes.length) {
            return false;
        }
        else {
            for(uint i = 0; i < s1bytes.length; i++) {
                if(s1bytes[i] != s2bytes[i])
                return false;
            }
            return true;
        }
    }

    function splitString(string _s, string _seperator) internal returns(string, string) {
        var s_slice = _s.toSlice();
        var seperator_slice = _seperator.toSlice();
        string memory result = """";
        var result_slice = result.toSlice();
        result_slice = s_slice.split(seperator_slice);
        return (result_slice.toString(), s_slice.toString());
    }
}"
61780-1.sol,question,"contract InterfaceWithMe {

    function call() returns (string) {
        return ""Hello"";
    }
}"
54747-0.sol,question,"contract Pausable is Ownable {
  event Pause();
  event Unpause();

  bool public paused = false;


  
  modifier whenNotPaused() {
    if (paused) throw;
    _;
  }

  
  modifier whenPaused {
    if (!paused) throw;
    _;
  }

  
  function pause() onlyOwner whenNotPaused returns (bool) {
    paused = true;
    Pause();
    return true;
  }

  
  function unpause() onlyOwner whenPaused returns (bool) {
    paused = false;
    Unpause();
    return true;
  }
}"
54747-0.sol,question,"contract TokenTimelock {

  
  ERC20Basic token;

  
  address beneficiary;

  
  uint releaseTime;

  function TokenTimelock(ERC20Basic _token, address _beneficiary, uint _releaseTime) {
    require(_releaseTime > now);
    token = _token;
    beneficiary = _beneficiary;
    releaseTime = _releaseTime;
  }

  
  function claim() {
    require(msg.sender == beneficiary);
    require(now >= releaseTime);

    uint amount = token.balanceOf(this);
    require(amount > 0);

    token.transfer(beneficiary, amount);
  }
}"
8442-0.sol,question,"contract Allower {
    Allowed allowed;

    function doSth() onlyallowed;

    modifier onlyallowed {
        if (msg.sender != address(allowed))
            throw;
        _
    }
}"
8442-0.sol,question,"contract Allowed {
    Allower allower;

    function doSthOnAllower() {
        allower.doSth();
    }
}"
84400-0.sol,question,"contract Slot_Machine is Mortal{

  
  
  
  struct Player{
      address payable wallet;
      uint deposit;
      uint guess;
  }

  mapping (address => Player) public player;

  constructor() public{
      newPlayer(10,5);
  }

  function sendPay(address to, uint amount) public {
      player[to].wallet.transfer(amount);

  }"
39316-0.sol,question,"contract AAAtoken is IERC20{

    using SafeMath for uint256;

    uint public _totalSupply=0;
    string public constant symbol = ""AAA"";
    string public constant name= ""AAA Token"";
    uint8  public constant decimals = 18;

    
    uint256 public constant RATE = 500;
    address public owner;
    mapping(address=>uint256) balances;
    mapping(address=> mapping(address=> uint256)) allowed;


    function() payable {
        createTokens();

    }

    function AAAtoken(){
        owner=msg.sender;

    }

    function createTokens() payable {
        require(msg.value > 0);
        uint256 tokens = msg.value.mul(RATE);
        balances[msg.sender] = balances[msg.sender].add(tokens);
        _totalSupply = _totalSupply.add(tokens);
        owner.transfer(msg.value);

    }



    function totalSupply() constant returns (uint256 totalSupply){

        return _totalSupply;


    }
    function balanceOf(address_owner) constant returns (uint256 balance){

        return balances[_owner];


    }
    function transfer(address_to, uint256_value) returns(bool success){

        require(
            balances[msg.sender] >= _value
            && _value > 0
        );
        balances[msg.sender]=balances[msg.sender].sub(_value);
        balances[_to]=balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;


    }
    function transferFrom(address_from, address_to, uint256_value) returns(bool success){

        require(
            allowed[_from][msg.sender] >= _value
            && balances[_from] >= _value
            && _value >0

        );
        balances[_from] =balances[_from].sub(_value);
        balances[_to] =balances[_to].add(_value);
        allowed[_from][msg.sender] =allowed[_from][msg.sender].sub(_value);
        Transfer(_from, _to, _value);
    return true;


    }
    function approve(address_spender, uint256_value) returns(bool success){

        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;


    }
    function allowance(address_owner, address_spender) constant returns(uint256 remaining){
        return allowed[_owner] [_spender];


    }
        event Transfer(address indexed_from, address indexed_to, uint256_value);
        event Approval(address indexed_owner, address indexed_spender, uint256_value);







}"
62116-0.sol,question,"contract Bank{
    uint private value;

    constructor(uint amount) public{
        value = amount;
    }
    function deposit(uint amount) public{
        value += amount;
    }

    function withdraw(uint amount) public{
        value -= amount;
    }

    function balance()view public returns (uint){
        return value;
    }
}"
49342-0.sol,question,"contract SafeMath{    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        assert(c >= a);
        return c;
    }
}"
49342-0.sol,question,"contract TestSafeMath{ 
    function test_add_10_and_max_should_return_err() {
          uint256 max = 2**256 - 1;
          uint256 expected = ""revert overflow error"";
          Assert.errorsEqual(SafeMathExt.add(10, max), expected, ""Addition of 10 and max should revert"");
    }
}"
83790-0.sol,question,"contract Add{
struct User {
    uint256 id;
    string name;

    

    bool set; 
}
 address owner;
 modifier onlyOwner() {
       require(owner == msg.sender);
            _;
}

mapping(address => User) public users;

function createUser(address _userAddress, uint256 _userId, string memory _userName) public onlyOwner {
    User storage user = users[_userAddress];
    
    require(!user.set);
    
    users[_userAddress] = User({
        id: _userId,
        name: _userName,
        set: true
    });
}

}"
46321-0.sol,question,"contract Test{
  bytes4 public method;
  string public method_s;

  function Test() {
    method = this.get_f.selector;
  }

  function makeString(){
   method_s = somefunc(method);
  }

}"
59784-0.sol,question,"contract EtherTransferTo{
address public owner;

constructor() public {
owner = msg.sender;
}

modifier onlyOwner() {
    require (msg.sender == owner);
    _;

}

function () payable public {
    
}

function getBalance() public view returns (uint256) {
    return address(this).balance;
}

function withdraw(uint amount) onlyOwner returns(bool) {
    require(amount <= this.balance);
    owner.transfer(amount);
    return true;

}


}"
83515-1.sol,question,"contract B{


    event Payment(address recipient, uint value);
    event Receive(address sender, uint value);

    address sender;
    address payable receiver;
    uint sentValue;
    uint receiptValue;
    uint gasPrice;

    function pay(address payable recipient) external payable{\\Transfers some ether to A
        recipient.transfer(msg.value);
        A(recipient).cash(msg.value, tx.gasprice);
        receiver=recipient;
        sentValue=msg.value;
        gasPrice=tx.gasprice;
        emit Payment(recipient, msg.value);
    }

    function payView() public view returns(address, string memory, string memory, string memory){\\Shows some data about the last transfer.
        return (receiver, uint2str(sentValue), uint2str(gasPrice), uint2str(address(this).balance));
    }

    function cash(uint cashValue, uint GasPrice) external payable{\\Records some data about the last received transaction
        sender=msg.sender;
        receiptValue=cashValue;
        gasPrice=GasPrice;
        emit Receive(msg.sender, cashValue);
    }

    function cashView() public view returns(address, string memory, string memory, string memory){\\Shows some data about the last received transaction
        return (sender, uint2str(receiptValue), uint2str(gasPrice), uint2str(address(this).balance));
    }

    function uint2str(uint _i) internal pure returns (string memory ) {
        if (_i == 0) {
                return ""0"";
         }
        uint j = _i;
        uint len;
        while (j != 0) {
                len++;
              j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint k = len - 1;
        while (_i != 0) {
             bstr[k--] = byte(uint8(48 + _i % 10));
             _i /= 10;
         }
        return string(bstr);
    }
    function() external payable{}
}"
80741-0.sol,question,"contract test{


address payable owner;
mapping (address => bool) pd;
uint public sS;
function lnA(address addr) public view returns(uint n) {
        
        n = uint(keccak256(uint(addr), sS)[0]) % 8;

    }
}"
58058-0.sol,question,"contract Student{
    struct stu{
        string name;
        uint age;
        bool tookTest;
    }
    mapping(uint => stu) studentNames;
    function addStudent (uint ID, string _name, uint _age) {
        studentNames[ID] = stu(_name, _age, false);
    }
    function updateStudent (uint ID) {
        studentNames[ID].tookTest = true;
    }
}"
2979-0.sol,question,"contract testConstant{
string testString;

function testConstant(string _testString) {
    testString=_testString;
}
function gettestString() public constant returns(string) {
    return testString;
}
}"
84668-0.sol,question,"contract SellTokens{
    
       IUniswapV2Router02 usi = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
          
    function sellDai(uint256 daiQty , address cryptoToken) public payable returns(uint256){



    uint256 ethAmountDerivable = getEstimatedTokenForETH(daiQty , cryptoToken)[0];
 
  uint deadline = now + 300; 

    usi.swapExactTokensForETH(daiQty , ethAmountDerivable, getPathForTokenToETH(cryptoToken), address(this), deadline);

   return ethAmountDerivable;

}
    
    function getEstimatedTokenForETH(uint daiQty , address crypto) public view returns (uint[] memory) {
        return usi.getAmountsIn(daiQty, getPathForTokenToETH(crypto));
      }
    
     function getPathForTokenToETH(address crypto) private view returns (address[] memory) {
        address[] memory path = new address[](2);
        path[0] = crypto;
        path[1] = usi.WETH();
        
        return path;
      }
    
    }"
79690-1.sol,question,"contract BankA{
  function creation() public returns(string memory){
    customer client=new customer();
    client.prime(""Alireza Kiakojouri"",""5000077563"", true, 2, here);
    return uint2str(uint(client.Array()));
  }
  function uint2str(uint _i) internal pure returns (string memory ) {
    if (_i == 0) {
        return ""0"";
    }
    uint j = _i;
    uint len;
    while (j != 0) {
        len++;
        j /= 10;
    }
    bytes memory bstr = new bytes(len);
    uint k = len - 1;
    while (_i != 0) {
        bstr[k--] = byte(uint8(48 + _i % 10));
        _i /= 10;
    }
    return string(bstr);
  }
  function() external payable{}
  }"
59924-0.sol,question,"contract Test{

struct student{
uint bonus;
uint value1;
uint value2;
uint Priority;  
 }


mapping(address => student) students ; 
declaration of a function of type mapping so we define array of addresses
address [] public student_list;  

function Recieve_Request(address _address,uint _bonus, uint _value1, uint 
_value2) public {          

var student = students[_address]; 
 students mapping
student.bonus=_bonus;
student.value1=_value1;
student.value2=_value2;
student.Priority=(0.5 * _value1 + 0.5 * _value2)/ _bonus;  

 student_list.push(_address) -1;
     }


      function get_ESU(address ins) view public returns (uint, uint, uint) {
    return (students[ins].value1, students[ins].value2, 
  students[ins].Priority);
}

}"
8058-0.sol,question,"contract test{
   uint a ;
   function test() {
       a = 1;
   }
   function val() returns(uint){
       return a;
   }  
}"
8058-0.sol,question,"contract test2 is test{ 
    uint b = a++;
    function show() returns(uint){
        return b; 
    }
}"
72475-1.sol,question,"contract caseEvidence{
    uint CODE_SUCCESS = 0;
    uint FILE_NOT_EXIST = 3002;
    uint FILE_ALREADY_EXIST  = 3003;
    uint USER_NOT_EXIST = 3004;

mapping(uint => address) caseEvidenceMap;
event SaveEvi(address _oper,uint _time,uint _caseId);
event GetEvi(address _oper,uint _time,uint _caseId);

function saveEvidence(uint caseId,bytes fileHash,uint fileUploadTime) public returns(uint code,address addr){
    address fileEviAddr = caseEvidenceMap[caseId];
    if (fileEviAddr == 0) {
      fileEviAddr = new fileEvidence(); 
      caseEvidenceMap[caseId] = fileEviAddr;
    } 
    fileEvidence fileEvi = fileEvidence(fileEviAddr);
    fileEvi.saveFileEvi(fileHash,fileUploadTime);
    emit SaveEvi(fileEviAddr,fileUploadTime,caseId);
    return (0,fileEviAddr);
}

function getEviAddr(uint caseId) public view returns(address addr){
    return caseEvidenceMap[caseId];
}
function getEvidence(uint caseId,bytes fileHash) public view returns(uint _code,bytes memory _hash,uint _upTime,address _upOperator) {
    address fileEviAddr = caseEvidenceMap[caseId];
    fileEvidence fileEvi = fileEvidence(fileEviAddr);
    (_upTime,_upOperator) = fileEvi.getFileEvi(fileHash);

    if(_upTime == 0){
        return (FILE_NOT_EXIST,"""",0,msg.sender);
    }
    return (CODE_SUCCESS,fileHash,_upTime,_upOperator);
}

}"
70327-3.sol,question,"contract send_ether{
    mapping(address => uint256) public balances;

    function depositFunds() public payable {
        balances[msg.sender] += msg.value;
        }

    function close() public {
        selfdestruct(0x692a70d2e424a56d2c6c27aa97d1a86395877b3a);
    }
}"
12394-0.sol,question,"contract MemDeposit
{
   struct deposit {
   string[] ss_ids;  
   int[][] si_deposit;
}
mapping(address=>deposit) private si_md;  
.......

function addMemDeposit(address p_memacct,string p_acctstr,uint p_idx2,int p_money) external returns(int) {
   int li_idx1;
   li_idx1 = 0 ; 
   ...
   si_md[p_memacct].si_deposit[p_idx2][li_idx1] = p_money; 
   ...

   }

}"
30391-0.sol,question,"contract BOLData{
struct Data {
    string sData;
    string ssCompanyData;
    string ConsigneeData;
    string BOL_ID;
}

mapping(string => Data) private BOL_Data;

function BOLData (string s_Data, string  bolid)
{
    BOL_Data[bolid] = Data(s_Data,'', '', bolid);
}

function addData(string ssCompany_Data, string Consignee_Data, string bolid) public {
    string s_DataO = BOL_Data[bolid].sData;
    string ssCompany_DataO = BOL_Data[bolid].ssCompanyData;
    string Consignee_DataO = BOL_Data[bolid].ConsigneeData;
    if(ssCompany_DataO == '')
    {}
    BOL_Data[bolid] = Data(s_DataO,ssCompany_Data, Consignee_Data, bolid);
}


function getData(string DataID) returns (string, string, string){
    string s_Data = BOL_Data[DataID].sData;
    string ssCompany_Data = BOL_Data[DataID].ssCompanyData;
    string Consignee_Data = BOL_Data[DataID].ConsigneeData;
    return(s_Data, ssCompany_Data, Consignee_Data);
}"
72441-0.sol,question,"contract NewHello{

    struct kullanicilar{
        string name;
        string surname;
        uint age;
    }

    event infoChanged(
        string name,
        string surname,
        uint age
    );

    uint newUser;
    mapping(address => string) public users; 
    

    function updateUser(string memory name , string memory surname , unit age) public returns(uint userID){
        userID = newUser++;
        users[userID] = kullanicilar(string name, string surname, age);
        emit infoChanged(name,surname,age);
    }
    function getUser(address a) public view returns(string memory) {
        return users[a]; 
    }
}"
83022-0.sol,question,"contractPrivacyPreferences {

bool preference = false;
bool monitoringType = false;


mapping (address => bool) addresses;

contructor () public {
    adresses [address(0x00281055afc982d96fab65b3a49cac8b878184cb16)] = true;
}

function changePreferences() public {
     if (addresses [msg.sender])
           preference = true;
}

function changeMonitoringType () public {
   if (addresses [msg.sender]) {
      monitoringType = true;
}

function preferenceStatus() public view returns (bool) {
    return preference;
}

function monitoringStatus() public view returns (bool) {
    return monitoringType;
}
}
"
26605-0.sol,question,"contract Oracle{
    event Print(string _name, bytes32 _value);
    bytes32 key;

    function Store(bytes32 _key) returns (bytes32) {
        key = _key;
        Print(""Key"",_key);
        return _key;
    }

}"
10878-0.sol,question,"contract People{
    bool public isActive = false;
    uint public objectId;
    string public ownerName;
    string somePrivateData;
    mapping (address => bool) owned;

    function initPeopleContract(string name){
        if (!isActive) {
            isActive = true;
            ownerName = name;
        }
    }

    function getOwnerName() returns (string val) {
        if (!isActive) {
          val = ownerName;
        }else {
          val = ""Account Deactivated"";
        }
    }

    function getPrivateData() returns (string data) {
        if (msg.sender == address){
          
        } else {
          
        }
    }
}"
26187-0.sol,question,"contract MyBank{

    mapping (address => uint) public balance;

    address bankManager;

    event Transfer(address _from, address _to, uint _value);

    function MyBank() {
        bankManager = msg.sender;
        balance[msg.sender] = 10000;
    }

    function transfer(address _to, uint _value) {
        if (balance[msg.sender] >= _value) {
            balance[msg.sender] -= _value;
            balance[_to] += _value;
        }
        Transfer(msg.sender, _to, _value);
    }
}"
39290-0.sol,question,"contract testcoin{

    using SafeMath for uint256;

    uint public _totalSupply = 0;

    string public constant symbol = ""TES"";
    string public constant name = ""testcoin"";
    uint8 public constant decimals = 3;
    string public contractString = 'hello';

    uint256 public constant RATE = 500;
    address public owner;

    mapping(address => uint256) balances;
    mapping(address => mapping(address => uint256)) allowed; 

    function releaseToken(string _string)  payable{
        require(keccak256(_string) == keccak256(contractString));
        createTokens();
    }

    function testcoin(){
        owner = msg.sender;
    }

    function totalSupply() constant returns (uint256 totalSupply){
        return _totalSupply;
    }

    function balanceOf(address _owner) constant returns (uint256 balance){
        return balances[_owner];
    }

    function transfer(address _to, uint256 _value) returns (bool success){
        require(
            balances[msg.sender] >= _value
            && _value > 0
        );
        balances[msg.sender] -= _value;
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function createTokens() payable {
        uint256 tokens = msg.value.mul(RATE);
        balances[msg.sender] = balances[msg.sender].add(tokens);
        _totalSupply = _totalSupply.add(tokens);
        owner.transfer(msg.value);
    }

    function totalSupply() constant returns (uint256 totalSupply){
        return _totalSupply;
    }

    function balanceOf(address _owner) constant returns (uint256 balance){
        return balances[_owner];
    }

    function transfer(address _to, uint256 _value) returns (bool success){
        require(
            balances[msg.sender] >= _value
            && _value > 0
        );
        balances[msg.sender] = balances[msg.sender].sub(_value); 
        balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        return true;
    }

    function transferFrom(address _from, address _to, uint256 _value) returns (bool success){
        require(
            allowed[_from][msg.sender] >= _value
            && balances[_from] >= _value
            && _value > 0
        );
        balances[_from] -= _value;
        balances[_to] += _value;
        allowed[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) returns (bool success){
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining){
        return allowed[_owner][_spender];
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}"
57904-1.sol,question,"contract Called{

    uint public number;

    function myuint() public view returns(uint _number) {
        _number = number;
    }

    function set() public {
        number++;
    }

    function get() public view returns (uint){
        return number;
    }
}"
51477-2.sol,question,"contract TRY{

    uint public temp=0;
    uint public b=0;
    uint public c ether;

    function set_c(uint _c ){
        c=_c ;
    }

    function transfer_ether() public payable{

       if(msg.value>=c ){
            temp=msg.value;
             b=temp-(60 ether);
            temp=60 ether;
           msg.sender.transfer(b );
       }
    }

    function to_contract() public payable {
        uint a=temp;
        temp=0;
        msg.sender.transfer(a);
    }
}"
70888-0.sol,question,"contract OpenAddressLottery{
    struct SeedComponents{
        uint component1;
        uint component2;
        uint component3;
        uint component4;
    }
    
    address owner; 
    uint private secretSeed; 
    uint private lastReseed; 
    uint LuckyNumber = 7; 
        
    mapping (address => bool) winner; 
    
    function OpenAddressLottery() {
        owner = msg.sender;
        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); 
    }
    
    function participate() payable {
        if(msg.value<0.1 ether)
            return; 
        
        
        require(winner[msg.sender] == false);
        
        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ 
            winner[msg.sender] = true; 
            
            uint win=msg.value*7; 
            
            if(win>this.balance) 
                win=this.balance; 
            msg.sender.transfer(win);
        }
        
        if(block.number-lastReseed>1000) 
            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); 
    }
    
    function luckyNumberOfAddress(address addr) constant returns(uint n){
        
        n = uint(keccak256(uint(addr), secretSeed)[0]) % 8;
    }
    
    function reseed(SeedComponents components) internal {
        secretSeed = uint256(keccak256(
            components.component1,
            components.component2,
            components.component3,
            components.component4
        )); 
        lastReseed = block.number;
    }
    
    function kill() {
        require(msg.sender==owner);
        
        selfdestruct(msg.sender);
    }
    
    function forceReseed() { 
        require(msg.sender==owner);
        
        SeedComponents s;
        s.component1 = uint(msg.sender);
        s.component2 = uint256(block.blockhash(block.number - 1));
        s.component3 = block.difficulty*(uint)(block.coinbase);
        s.component4 = tx.gasprice * 7;
        
        reseed(s); 
    }
    
    function () payable { 
        if(msg.value>=0.1 ether && msg.sender!=owner) 
            participate();
    }

}"
3649-0.sol,question,"contract MultiplyContract{
    address public buyer;
    address public seller;
    uint public price;
    function MultiplyContract(
      address _buyer,
      address _seller,
      uint _price,
      ){
      buyer = _buyer;
      seller = _seller;
      price = _price;
    }
    function Execution (address _buyer, address _seller) {
    eth.getBalance(_buyer) -=  price; 
    eth.getBalance(_seller) += price;
  }
}"
39570-0.sol,question,"contract MyFirstSafeICO{

 uint public buyPrice;

 Token public token;

 function MyFirstSafeICO(Token _token) {

    token = _token;  
    buyPrice = 1000;
}

 function() payable {
  
     _buy( msg.sender, msg.value);
 }

 function buy() payable returns (uint ){

  uint tokens = _buy(msg.sender, msg.value);
  return tokens;
}

 function buy(address _sender, uint256 _amount) internal returns (uint){

 uint tokens = _amount/buyPrice;

  token.transfer( _sender, tokens);

  return tokens;
}
"
62665-0.sol,question,"contract Contract{
    event LOG_Increase();
    uint sum = 0;

    function Increase() public {
        sum++;
        emit LOG_Increase();
    }    
}"
46502-0.sol,question,"contract Blackjack is usingOraclize{

   uint public random;

   event Paid(address indexed _from, uint _value);

   function() external payable {
       Paid(msg.sender, msg.value);
   }

   function Blackjack() public {
       OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);
   }

   function getRandom() public constant {
       oraclize_newRandomDSQuery(0, 4, 200000);
   }

   function __callback(bytes32 _queryId, string _result, bytes _proof) public{
        random = uint(keccak256(_result)) % 52 + 1;
   }
}"
57903-0.sol,question,"contract TheCaseOfTHeMissingCoins{

    string public name;
    string public symbol;
    uint8 public decimals = 18;
    address public owner;

    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;


    event Transfer(address indexed from, address indexed to, uint256 value);


    constructor(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
       initialSupply = initialSupply * 10 ** uint256(decimals); 
        balanceOf[msg.sender] = initialSupply;               
        name = tokenName;                                 
        symbol = tokenSymbol;    
        owner = msg.sender;

    }

        
    
    
    function TESTbuyCoins() public payable{
        uint amount = TESTcalculateAmountOfCoins(msg.value);
        _transfer(owner, msg.sender, amount);
        owner.transfer(msg.value);
    }
    
    
    

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }


    
    function transfer(address _to, uint256 _value) public returns (bool success) {
        _transfer(msg.sender, _to, _value);
        return true;
    }

    function TESTcalculateAmountOfCoins(uint coinsWanted) public returns(uint totalCoins){
            totalCoins = coinsWanted * 48;
        return(totalCoins);
    } 
}"
29199-2.sol,question,"contract Plays
{
    
    struct TopLevelPlayInfo {
      address PlayOwnerAddress;
      bytes32 PlayOwnerName;
      bytes32 PlayTitle;
    }

TopLevelPlayInfo playi;


mapping (address => TopLevelPlayInfo) public theTopLevelPlayInfo;


struct PlayActionInfo  {
  bytes32   PlayTitle;       
  bytes32   PlayWorkerName;
  address   PlayWorkerAddress;
  bytes32   PlayAction;
  bytes32   PlayActionDescription;
  uint256   PlayActionTimestamp;
  bytes32   PlayStatus;
}

PlayActionInfo [] play1;


mapping (uint => PlayActionInfo) public thePlayActionInfo;



uint    numUpdates;
address theOwnerAddress;


modifier onlyOwner(){
  if(msg.sender != theOwnerAddress) revert();
  _;
}


function Plays(bytes32 thisPlayOwnerName, bytes32 thisPlayTitle) public  {
    
    playi.PlayOwnerAddress = msg.sender;
    theOwnerAddress        = msg.sender;
    playi.PlayOwnerName    = thisPlayOwnerName;
    playi.PlayTitle        = thisPlayTitle;
}


function PlayUpdate(
      bytes32   PlayTitle,
      bytes32   PlayWorkerName,
      bytes32   PlayAction,
      bytes32   PlayActionDescription,
      bytes32   PlayStatus)
      public {
        play1.PlayTitle                          = PlayTitle;
        play1.PlayWorkerName[numUpdates]         = PlayWorkerName;
        play1.PlayWorkerAddress[numUpdates]      = msg.sender;
        play1.PlayAction[numUpdates]             = PlayAction;
        play1.PlayActionDescription[numUpdates]  = PlayActionDescription;
        play1.PlayActionTimestamp[numUpdates]    = block.timestamp;
        play1.PlayStatus[numUpdates]             = PlayStatus;

        
        numUpdates++;
}
}"
13936-0.sol,question,"contract queue
{
    struct Queue {
        uint256[] data;
        uint256 front;
        uint256 back;
    }
    
    function length(Queue storage q) constant internal returns (uint256) {
        return q.back - q.front;
    }
    
    function capacity(Queue storage q) constant internal returns (uint256) {
        return q.data.length - 1;
    }
    
    function push(Queue storage q, uint256 data) internal
    {
        if ((q.back + 1) % q.data.length == q.front)
            return; 
        q.data[q.back] = data;
        q.back = (q.back + 1) % q.data.length;
    }
    
    function pop(Queue storage q) internal returns (uint256 r)
    {
        if (q.back == q.front)
            return; 
        r = q.data[q.front];
        delete q.data[q.front];
        q.front = (q.front + 1) % q.data.length;
        return r;
    }
    Queue requests;
    function queue() {
        requests.data.length = 200;
    }
    function addRequest(uint256 d) {
        push(requests, d);
    }
    function popRequest() constant returns (uint256) {
        return pop(requests);
    }
    function queueLength()  constant returns (uint256) {
        return length(requests);
    }
    function hello() constant returns(string s){ 
        return 'hello world!';
    }
}"
33651-0.sol,question,"contract Crowdsale{
using SafeMath for uint256;


Token public token;


address public wallet;


mapping (uint256 => uint256) public rate;


mapping (uint256 => uint256) public cap;


uint256 public currentTier;


uint256 public tokenRaised  = 0;


uint256 public weiRaised    = 0;

event TokenPurchase(address indexed purchaser, address indexed 
beneficiary, uint256 value, uint256 amount);

function Crowdsale(address _wallet, IWToken _token) public {
require(_wallet != address(0));
require(_token  != address(0));



token = _token;
owner = msg.sender;


rate[1] = 23000;
rate[2] = 22000;
rate[3] = 21000;
rate[4] = 20000;


cap[1] = 100000000000000000;
cap[2] = 200000000000000000;
cap[3] = 300000000000000000;
cap[4] = 1000000000000000000;


currentTier = 1;

wallet = _wallet;


}


function buyTokens(address beneficiary) public payable {
require(beneficiary != address(0));
require(!stopped);
require(msg.value <= 100000000000000000);
require(msg.value > 0);

uint256 weiAmount = msg.value;

uint256 tokens;


if(weiRaised.add(weiAmount) > cap[currentTier]){

  
  uint256 overFunded     = weiRaised.add(weiAmount).sub(cap[currentTier]);
  weiAmount              = msg.value.sub(overFunded);

  
  
  tokens        = weiAmount.mul(rate[currentTier]);
  weiRaised     = weiRaised.add(weiAmount);
  tokenRaised   = tokenRaised.add(tokens);

  
  token.ICOmint(beneficiary, tokens);
  TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);
  forwardFunds(weiAmount);

  
  currentTier = currentTier+1;

  if(currentTier > 4){
    
    msg.sender.transfer(overFunded);

    
    stopped = true;
    } else {
     
     tokens        = overFunded.mul(rate[currentTier]);
     weiRaised     = weiRaised.add(overFunded);
     tokenRaised   = tokenRaised.add(tokens);

     
     token.ICOmint(beneficiary, tokens);
     TokenPurchase(msg.sender, beneficiary, overFunded, tokens);
     forwardFunds(overFunded);
   }

   } else {
    
    tokens        = weiAmount.mul(rate[currentTier]);
    weiRaised     = weiRaised.add(weiAmount);
    tokenRaised   = tokenRaised.add(tokens);

    token.ICOmint(beneficiary, tokens);
    TokenPurchase(msg.sender, beneficiary, weiAmount, tokens);
    forwardFunds(msg.value);
  }
}

function forwardFunds(uint256 _amount) internal {
  wallet.transfer(_amount);
}"
72124-0.sol,question,"contract MKotET1_1{
   address payable king; uint public claimPrice = 100;

   function calculateCompensation() public returns(uint) {
}

function( ) external payable {
   if (msg.value  < claimPrice) revert();
      uint compensation = calculateCompensation();
      (bool success, bytes memory returnMessage) = 
      king.call.value(compensation)("""");
      require(success); 
      king = msg.sender;
   }
}"
9861-0.sol,question,"contract Test{  
    uint public id;  
    address public addr;  
    bytes32 public name;  

    struct t {
     bytes32 name;
     uint id;
    address addr;  
   }  
   mapping (address => t) addr_map;
    function f1 (uint param_1, bytes32 param_2) returns (bool) {  
       id = param_1;  
       name = param_2;  
    }

   function f2 (uint param_1, bytes32 param_2) returns (bool) {  
      addr_map[msg.sender].name = param_2;  
      addr_map[msg.sender].id = param_1;  
   }  
}"
42676-2.sol,question,"contract Contract3{
    uint256 public num; 
    function storeNum(uint256 newNum) public returns(bool) {
        num = newNum; 
    }
}"
59642-0.sol,question,"contract RegisterContract{

event setNewUser(bytes32 name,address etherAddr, address contractAddr,uint now);
address owner;
struct User{
    bytes32 name;
    address etherAddr;
    address contractAddr;
}
User[] private users;

constructor() public{
    owner = msg.sender;
}
modifier checkOwner(){
    require(msg.sender == owner);
    _;
}
function getOwner() public view returns (address){
    return owner;
}

function registerUser(bytes32 name,address etherAddr, address contractAddr) public checkOwner{
    User memory newUser;
    newUser.name = name;
    newUser.etherAddr = etherAddr;
    newUser.contractAddr = contractAddr;
    users.push(newUser);
    emit setNewUser(name,etherAddr,contractAddr,now);
}

function setAddress(bytes32 name,address etherAddr, address contractAddr) public checkOwner{
    for(uint8 i=0;i<users.length;i++){
        if(users[i].name==name){
            users[i].etherAddr=etherAddr;
            users[i].contractAddr=contractAddr;
        }
    }
}

function getUsers() public checkOwner view returns (bytes32[],address[],address[]) {
    bytes32[] memory names= new bytes32[](users.length);
    address[] memory etherAddr = new address[](users.length);
    address[] memory contractAddr = new address[](users.length);
    for(uint8 i=0;i<users.length;i++){
        names[i]= users[i].name;
        etherAddr[i] = users[i].etherAddr;
        contractAddr[i] = users[i].contractAddr;
    }
    return (names,etherAddr,contractAddr);
}

function getContractAddress(address etherAddr) public checkOwner view returns (bytes32,address) {
    for(uint8 i=0;i<users.length;i++){
        if(users[i].etherAddr==etherAddr){
            return (users[i].name,users[i].contractAddr);
        }
    }
}
}"
72666-0.sol,question,"contract Inbox{
    string message;

    function set(string memory initialMessage) public {
        message = initialMessage;
    }
    function setMessage(string memory newMessage) public{
        message = newMessage;
    }
}"
44616-1.sol,question,"contract Caller{

    Callee callee;
    uint public anyNumber;

    function Caller(address calleeAddr) public {
        callee = Callee(calleeAddr);
    }

    function usingCallee(uint callerData) external {
        callee.theOnlyFunctionCallerNeeds(callerData);
    }
}"
57989-0.sol,question,"contract mypool{
    address public manager;
    string poolname;
    uint256 poolEndDate;
    uint256 poolAmount;

    constructor () public {
        manager = msg.sender;
    }

    mapping (address => uint256) public balanceOf;

    
    struct Payer {
        string name;
        address player;
        uint256 amount;
    }

    Payer[] public players;
    
    function enterPoolInfo(string name,uint256 endDate, uint256 amount) public {
        poolname = name;
        poolEndDate = endDate;
        poolAmount = amount;
    }
    
    function enter(string name,uint256 amount) public payable {

        Payer memory m;
        
        m.player = msg.sender;
        m.amount = amount;
        m.name = name;
        players.push(m);
    }

    function getBalance() public view returns (uint) {
        return this.balance;
    }



     function transferd(address _to) payable {
        
        
        
        

        uint256 balance = this.balance;
        _to.transfer(balance);                        
    }
}"
63523-0.sol,question,"contract InsuranceClaimFactory{
    address public claimer;
    address[] public deployedInsuranceClaim;
    function createInsuranceClaim () public {
        address newInsuranceClaim = new InsuranceClaim(msg.sender);
        deployedInsuranceClaim.push(newInsuranceClaim);
    }

    function getDeployedInsuranceClaims () public view returns (address[] memory){
        return deployedInsuranceClaim;
    }
}"
43331-0.sol,question,"contract GLOERC20Coin is Ownable{
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    event Transfer(address from, address to, uint256 value);
    event Approval(address from, address to, uint256 value);
    event Mint(address indexed to, uint256 amount);
    event Burn(address indexed burner, uint256 amount);

    function GLOERC20Coin(){
        decimals = 8;
        totalSupply = 10000000 * (10 ** uint256(decimals));
        balanceOf[msg.sender] = totalSupply;
        name = ""MyToken"";
        symbol = ""MTS"";
    }

    function _transfer(address _from, address _to, uint256 _value) internal {
        require(_to != 0x0);
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);

        balanceOf[_to] += _value;
        balanceOf[_from] -= _value;

        Transfer(_from, _to, _value);
    }

    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    function transferFrom(address _from, address _to, uint256 _value) public {
        require(_value <= allowance[_from][_to]);
        allowance[_from][_to] -= _value;
        _transfer(_from, _to, _value);
    }

    function approve(address _to, uint256 _value) public {
        allowance[msg.sender][_to] = _value;
        Approval(msg.sender, _to, _value);
    }

    function mint(address _to, uint256 _amount) public onlyOwner {
        _amount = _amount * (10 ** uint256(decimals));
        totalSupply += _amount;
        balanceOf[msg.sender] += _amount;
        Transfer(address(0), msg.sender, _amount);
        Mint(msg.sender, _amount);
    }

    function burn(uint _amount) public onlyOwner {
        require(_amount <= balanceOf[msg.sender]);
        address burner = msg.sender;
        balanceOf[burner] -= _amount;
        totalSupply -= _amount;
        Burn(burner, _amount);
        Transfer(burner, address(0), _amount);
    }

    function insuranceCaseTransfer(address _from, address _to, uint256 _amount) public onlyOwner {
        _transfer(_from, _to, _amount);
    }
}"
43331-0.sol,question,"contract MyFirstSafeICO is Ownable{
    address owner;
    uint public buyPrice;
    MyFirstERC20ICO public token;

    function MyFirstSafeICO(MyFirstERC20ICO _token){
        token = _token;
        buyPrice = 10000;
        owner = msg.sender;
    }

    function () payable {
        _buy(msg.sender, msg.value);
    }

    function buy() payable returns (uint){
        uint tokens = _buy(msg.sender, msg.value);
        return tokens;
    }

    function buyFor(address _addressee, uint256 _amount) public onlyOwner returns (uint) {
        uint tokens = _buy(_addressee, _amount * buyPrice);
        return tokens;
    }

    function _buy(address _sender, uint256 _amount) internal returns (uint){
        uint tokens = _amount / buyPrice;
        token.transfer(_sender, tokens);
        return tokens;
    }
}"
50333-0.sol,question,"contract {
...
  struct EtherBox {
    bytes32 label;
    address owner;
    string ownerUrl;
    uint256 expiration;
  }

  mapping (address => bytes32) public nicknames;
  mapping (address => address[]) public ownerToEtherBoxes;
  mapping (address => EtherBox) public etherBoxes;
  mapping (address => uint256) etherBoxesNonce;
...
  function publishEtherBox (bytes32 _label, string _ownerUrl, uint _lifespan) external onlyWhenRunning() payable {
      require(ownerToEtherBoxes[msg.sender].length < 10);
      assert(bytes(_ownerUrl).length <= 200);
      address etherBoxAddress = address(keccak256(msg.sender, etherBoxesNonce[msg.sender]++));
      ownerToEtherBoxes[msg.sender].push(etherBoxAddress);
      etherBoxes[etherBoxAddress] = EtherBox({
        label: _label,
        owner: msg.sender,
        ownerUrl: _ownerUrl,
        expiration: now + _lifespan
      });
      if(msg.value > 0){
        owner.transfer(msg.value);
      }
      emit EtherBoxPublished(msg.sender, nicknames[msg.sender], etherBoxAddress, _label, now);
  }
...
}"
28206-0.sol,question,"contract Parent
{

    uint value;

    function isValueOne() public constant returns (bool) {
        return value == 1;
    }

}"
28206-0.sol,question,"contract Child is Parent
{

    uint public value;

    function test() public {
        value = 1;
    }

    function verify() {
        require(isValueOne());
    }
}"
15194-0.sol,question,"contract {
  mapping (bytes32 => uint256) private balances;

  function setValue(uint256 a) {
    uint index = sha3(msg.sender);
    balances[index] = a;
  }
}"
26535-1.sol,question,"contract TestConst{
    uint public a = 10;

    function constantFnA() constant returns (uint) {
        return  a+5;
    }

    
    
    function NonCosntUsesConst(){
        a = constantFnA();
    }

    
    
    function nonConstantFn(){
        a = a+5;
    }    
}"
84448-0.sol,question,"contract  Attacker{
   Victim  public v;
   uint public  count;
   event LogFallback(uint c, uint balance);
   
   
   constructor (address victim) public {
      v=Victim(victim);
   }
  

   function attack() public {
      v.withdraw();
   }

   function () external payable{
      count++;
      emit LogFallback(count, address(this).balance);
      if(count < 10 ) {
         v.withdraw();
      }
    }
}"
29391-0.sol,question,"contract SplitBalance{

    address a1;
    address a2;

    function SplitBalance(address _a1, address _a2) public{
        a1 = _a1;
        a2 = _a2;
    }

    function withdraw() public {
        uint money = this.balance;

        
        if (money % 2 == 1)   
           money = money - 1; 

        a1.transfer(money/2);
        a2.transfer(money/2);
    }

    function updateAddress1(address newAddress) public {
        if(msg.sender != a1)
           revert();
        a1 = newAddress;
    }

    function updateAddress2(address newAddress) public {
        if(msg.sender != a2)
           revert();
        a2 = newAddress;
    }

    
    function() payable public { }
}"
3455-0.sol,question,"contract test
{
    bytes32 lastblockhashused;
    uint lastblocknumberused;

    function test()
    {
        lastblocknumberused = (block.number-1)  ;               
        lastblockhashused = block.blockhash(lastblocknumberused);
    }

    function getTest1() constant returns (bytes32) {
        bytes32 number1 =lastblockhashused;
        return number1 & 0xfff;
    }
}"
73395-0.sol,question,"contract fileCtxEvidence{
    enum EviState { FINISHED,START_MOD,WAIT_OTHER_SIG,CANCEL_MOD,WAIT_LEFT_TILES }
    uint caseId;
    struct FileEvi{
        string fileName;
        bytes fileCtx;
        uint upTime;
        address upOperator;
        EviState state;
    }
    mapping(string => FileEvi) evi;
    event SaveEvi(address _oper,uint _time,string _name,uint _flag);
    constructor (uint _id) public{
        caseId = _id;
    }
    function saveFileEvi(string _name,bytes _file,uint _upTime ) public{
            evi[_name].fileName = _name;
            evi[_name].upTime = _upTime;
            evi[_name].upOperator = tx.origin;
            evi[_name].fileCtx = _file;            
           emit SaveEvi(tx.origin,_upTime,_name,0);


    }
    function getFileEvi(string _name) public view returns(bytes _file,uint _upTime,address _upOperator) {
        _file = evi[_name].fileCtx;
        _upTime = evi[_name].upTime;
        _upOperator = evi[_name].upOperator;
    }
}"
84639-0.sol,question,"contract BuyExample{
          
    IUniswapV2Router02 usi = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
       
        
    function buyDai(uint256 amountOfEther) public payable returns(uint256){
    
    address cryptoToken = 0xc7AD46e0b8a400Bb3C915120d284AafbA8fc4735;
    
          uint deadline = now + 15; 
            usi.swapETHForExactTokens.value(amountOfEther)(0, getPathForETHToToken(cryptoToken), address(this), deadline);
    
            
            msg.sender.call.value(address(this).balance)("""");
    
           return 1000;
        
        }

  function getPathForETHToToken(address crypto) private view returns (address[] memory) {
    address[] memory path = new address[](2);
    path[0] = usi.WETH();
    path[1] = crypto;
    
    return path;
  }

    }"
70208-0.sol,question,"contract Test{
    function test1(address payable addr, uint256 value) payable public {
        addr.transfer(value);
    }
}"
42382-0.sol,question,"contract d4{
    function showAddress() view public returns (address addr_v) {
        assembly {
            addr_v := mload(0x30)
        }
    }
}"
68846-0.sol,question,"contract homeAutomation{
  string public greeting;

  constructor(string memory _greet) public {
    greeting=_greet;
  }

  function greet(string memory _gree) public {
    greeting =_gree;
  }
}"
12036-0.sol,question,"contract CarRentalServiceCustomer is GeneralAccount{
    string public customerName;
    string public postalAddress;
    string public phoneNumber;
    string public emailAddress;

    mapping(address=>CarRentService) public rentCar;

    struct CarRentService{ 
        bool active;
        uint lastUpdate;
        uint registrationFee;   
        uint256 rent;              
    }

    function CarRentalServiceCustomer(string _name,string _postalAddress,
                                    string _phoneNumber,string _emailAddress) payable {
        customerName  = _name;
        postalAddress = _postalAddress;
        phoneNumber   = _phoneNumber;
        emailAddress  = _emailAddress;
    }

    function registerToCarRentalServiceProvider(address _providerAddress) onlyOwner {

        rentCar[_providerAddress] = CarRentService({
                                    active: true, 
                                    lastUpdate: now,
                                    registrationFee: 0,
                                    rent: 0
                                    });
    }

    function setRegistrationFee(uint256 _registrationFee) {
        if(rentCar[msg.sender].active){
            rentCar[msg.sender].lastUpdate      = now;
            rentCar[msg.sender].registrationFee = _registrationFee;
        }
        else{
            throw;
        }
    }

    function setCarRent(uint256 _rent) {
        if(rentCar[msg.sender].active){
            rentCar[msg.sender].lastUpdate = now;
            rentCar[msg.sender].rent       = _rent;
        }
        else{
            throw;
        }
    }

    function payRegistrationFeeToCarRentalServiceProvider(address _providerAddress) returns (bool){
        if(_providerAddress.send(rentCar[_providerAddress].registrationFee))
        {
            rentCar[_providerAddress].registrationFee = 0;
            return true;
        }
        else{
            return false;
        }
    }

    function payRentToCarRentalServiceProvider(address _providerAddress) returns (bool){
        if(_providerAddress.send(rentCar[_providerAddress].rent))
        {
            rentCar[_providerAddress].rent = 0;
            return true;
        }
        else{
            return false;
        }
    }

    function unsubscribeFromCarRentalService(address _providerAddress){
        if(rentCar[_providerAddress].active = false && rentCar[_providerAddress].rent == 0 
        && rentCar[_providerAddress].registrationFee == 0 ){
            rentCar[_providerAddress].active = false;
        } else {
            throw;
        }
    }

    function payTestFunds() payable{
        
    }
}"
71956-2.sol,question,"contract Sample{
    
    address payable owner;

    
   constructor() public{
        owner = msg.sender;
   }

    function doSomething() external payable {
        int i = 10 + 10;
        i++;
   }
}"
74562-0.sol,question,"contract EternalStorage{

      struct Storage {
        mapping(bytes32 => address) _address;
        mapping(bytes32 => string) _string;
       }

      Storage internal s;

      address public owner;

     function setString(bytes32 h, string memory v) public  {
        s._string[h] = v;
     }

function getString(bytes32  h) public view returns (string memory){
    return s._string[h];
  }

function setAddress(bytes32 h, address v) public  {
    s._address[h] = v;
  }
function getAddress(bytes32 h) public view returns (address){
    return s._address[h];
  }
}"
32957-0.sol,question,"contract SafeMath{
  function safeMul(uint a, uint b) internal pure returns (uint) {
    uint c = a * b;
    assert(a == 0 || c / a == b);
    return c;
  }

  function safeDiv(uint a, uint b) internal pure returns (uint) {
    assert(b > 0);
    uint c = a / b;
    assert(a == b * c + a % b);
    return c;
  }

    function safeSub(uint a, uint b) internal pure returns (uint) {
        assert(b <= a);
        return a - b;
  }

    function safeAdd(uint a, uint b) internal pure returns (uint) {
        uint c = a + b;
        assert(c >= a);
        return c;
  }

}"
43195-0.sol,question,"contract Sc1{
      mapping (address => uint) token_balance;
      mapping (address => bool) valid_caller_contracts;
                                                      
      address owner;
      function Sc1(){
        owner = msg.sender;
      }
       
      function register_valid_contract() external {
          require(tx.origin==owner);
          valid_caller_contracts[msg.sender] = true;
      }
      function decrement_token(uint val) external{
        require(token_balance[tx.origin] >= val);
        token_balance[tx.origin] -=val;
      }
   }"
43195-0.sol,question,"contract Sc2{
     mapping (address => uint) token_balance2;
     address owner;
     function SC2(){
        owner = msg.sender;
      }
      function register() external{
       Sc1 c1=Sc1(0x22);
                        
       c1.register_valid_contract();
      }
      
      
      function fetch_tokens(uint val) external{
       Sc1 c1=Sc1(0x22);
                        
      c1.decrement_token(val);
      token_balance2[msg.sender] += val;
      }
    }"
3285-0.sol,question,"contract answer{
  mapping(address => mapping(string => bool)) voters;

  struct qList {
    uint count; 
    mapping(address => mapping(uint => uint)) answer;
  }

  mapping(string => qList) questionnaires;

  function vote(string ID, uint qNum, uint ans) returns (bool) {
    if(voters[msg.sender][ID]) throw;
    voters[msg.sender][ID] = true;
    questionnaires[ID].count += 1;
    questionnaires[ID].answer[msg.sender][qNum] = ans;
    return true;
  }

  function getNumResult(string ID) constant returns (uint res) {
    return questionnaires[ID].count;
  }
}"
70211-0.sol,question,"contract GetandSet{

    string name;
    uint age;

    function GetandSet() public {



    }

    function set(string newName, uint newAge) public {

        name = newName;
        age = newAge;
    } 


    function get() public view returns (string, uint) {

        return (name,age);
    }


}"
51953-1.sol,question,"contract IpfsLink{
    address owner;
    uint public lastHashId;
    uint hashCost = 0.001 ether;

    struct IpfsHash{
        address sender;
        string hashString;
        uint timestamp;
    }

    mapping (uint => IpfsHash) hashes;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    constructor() public{
        owner = msg.sender;
        lastHashId = 0;
    }

    function saveHash(string _hashContent) external payable {
        require(msg.value >= hashCost);

        uint hashId = ++lastHashId;
        hashes[hashId].sender = msg.sender;
        hashes[hashId].hashString = _hashContent;
        hashes[hashId].timestamp = now;
    }
}"
78707-0.sol,question,"contract Sample{

    struct Structure{
        uint a;
        string b;
    }

    mapping(string => Structure) public s;

    function add(uint a, string memory b)public {
        s[b] = Structure(a,b);
    }
}"
52333-0.sol,question,"contract Converter{
    function Converter(){

    }

    function stringToBytes32(string memory source) returns (bytes32 result) {
        bytes memory tempEmptyStringTest = bytes(source);
        if (tempEmptyStringTest.length == 0) {
            return 0x0;
        }

        assembly {
            result := mload(add(source, 32))
        }
    }
}"
79290-0.sol,question,"contract Item{

    uint id;
    uint items;
    uint startDate;
    uint endDate;
    bool isValid;

    address public owner;

    constructor() public {
        owner = msg.sender;
        isValid = false;
    }

    modifier restricted() {
        require(
            msg.sender == owner,
            ""Only owner can call this.""
        );
        _;
    }

    function createItem(uint _id,  uint _startDate, uint _endDate, uint _items, bool _isValid) public {
        id = _id;
        startDate = _startDate;
        endDate = _endDate;
        items = _items;
        isValid = _isValid;
    }

    function validateItem() public {
        isValid = true;
    }

    function getItemData() public view returns (uint, uint, uint, uint, bool) {
        return (id, startDate, endDate, items, isValid);
    }

    function getId() public view returns (uint) {    
        return id;    
    } 

    function getItems() public view returns (uint) {    
        return items;    
    } 

    function getStartDate() public view returns (uint) {    
        return startDate;    
    } 

    function getEndDate() public view returns (uint) {    
        return endDate;    
    } 

    function isValidItem() public view returns (bool) {    
        return isValid;    
    } 

}"
58089-0.sol,question,"contract Base{
    uint public num;
    event mint(uint n);
    constructor() public {
    }

    function Minit(uint _n) external returns (bool) {
        num = _n;
        emit mint(num);
        return true;
    }
    function getN() external view returns(uint result){
        result =  num;

    }
}"
11990-0.sol,question,"contract CarRentalServiceCustomer is GeneralAccount{
    string public customerName;
    string public postalAddress;
    string public phoneNumber;
    string public emailAddress;

    mapping(address=>CarRentService) public rentCar;

    struct CarRentService{ 
        bool active;
        uint lastUpdate;
        uint registrationFee;   
        uint rent;              
    }

    function CarRentalServiceCustomer(string _name,string _postalAddress,string _phoneNumber,string _emailAddress){
        customerName  = _name;
        postalAddress = _postalAddress;
        phoneNumber   = _phoneNumber;
        emailAddress  = _emailAddress;
    }

    function registerToCarRentalServiceProvider(address _providerAddress) onlyOwner {

        rentCar[_providerAddress] = CarRentService({
                                    active: true, 
                                    lastUpdate: now,
                                    registrationFee: 0,
                                    rent: 0
                                    });
    }

    function setRegistrationFee(uint _registrationFee) {
        if(rentCar[msg.sender].active){
            rentCar[msg.sender].lastUpdate      = now;
            rentCar[msg.sender].registrationFee = _registrationFee;
        }
        else{
            throw;
        }
    }

    function setCarRent(uint _rent) {
        if(rentCar[msg.sender].active){
            rentCar[msg.sender].lastUpdate = now;
            rentCar[msg.sender].rent       = _rent;
        }
        else{
            throw;
        }
    }

    function payRegistrationFeeToCarRentalServiceProvider(address _providerAddress) returns (bool){

        bool regFeeStatus = true;
        if(_providerAddress.send(rentCar[_providerAddress].registrationFee))
        {
            rentCar[_providerAddress].registrationFee = 0;
            return regFeeStatus;
        }
        else{
            return !regFeeStatus;
        }
    }

    function payRentToCarRentalServiceProvider(address _providerAddress) returns (bool){

        bool payStatus = true;
        if(_providerAddress.send(rentCar[_providerAddress].rent))
        {
            rentCar[_providerAddress].rent = 0;
            return payStatus;
        }
        else{
            return !payStatus;
        }
    }

    function unsubscribeFromCarRentalService(address _providerAddress){
        if(rentCar[_providerAddress].active = false && rentCar[_providerAddress].rent == 0 
        && rentCar[_providerAddress].registrationFee == 0 ){
            rentCar[_providerAddress].active = false;
        } else {
            throw;
        }
    }
}"
72046-0.sol,question,"contract Manage{

 struct Policy{
  string  PolicyID ;
 }
 mapping (address => mapping(string => Policy)) private policy;

 function storePolicy(address insuranceHolder,string memory _PolicyID) public {        
   policy[insuranceHolder][_PolicyID].PolicyID = _PolicyID;
 }
 function getPolicy(address insuranceHolder,string memory _PolicyID) public view returns(Policy memory) {
  return policy[insuranceHolder][_PolicyID];
 }
}"
55799-0.sol,question,"contract Array{
    using Library for Library.data;
    mapping(address => Library.data) map;
    function addCluster(address id) {
        if(map[id].isValue) throw; 
        
    }
}"
47377-0.sol,question,"contract Contract1{
    function simple() external view returns (bool) {
        return true;
    }
}"
47377-0.sol,question,"contract Contract2{
    bool public result;
    constructor(address contract1Address) public {
        Contract1 contract1 = Contract1(contract1Address);
        result = contract1.simple();
    }
}"
72333-0.sol,question,"contract NewHello{

    mapping(address => string) public users; 

    function updateUser(string memory name) public {
        if(string name != users[name]){
            users[msg.sender] = name; 
        }

    }
    function getUser(address userAddress) public view returns(string memory) {
        return users[userAddress]; 
    }
}"
50382-0.sol,question,"contract Called{

    string public name;

    function set(string _var) {
        name = _var;
    }

    function   get() view returns (string){
        return name;
    }


    function A () payable {

    }



}"
31567-0.sol,question,"contract RestaurantMASTER{
event logStatus(uint orderNumber, bytes input, uint256 timestamp);


function RestaurantMASTER(){
tokens[0]++;
CU = Customer(newCustomer());                       
WA = Waiter(newWaiter());                           
CH = Chef(newChef());                               
DB = dataBase(newDataBase());                       

}

    
    address[] public contracts;
    Customer CU;
    Waiter WA;
    Chef CH;
    dataBase DB;


    
    int[] public tokens = new int[](7);
    uint public orderNumber = -1;


    function newCustomer() private returns(address newContract){
        CU = new Customer();
        contracts.push(CU);
        return (CU);
    }
      function newWaiter () private returns(address newContract) {
       WA = new Waiter();
        contracts.push(WA);
        return (WA);
    }
     function newChef () private returns(address newContract) {
        CH = new Chef();
        contracts.push(CH);
        return (CH);
    }
    function newDataBase() private returns(address newContract){
        DB = new dataBase();
        contracts.push(DB);
        return (DB);
    }

   function OrderPizza(){
        orderNumber++;
        if(tokens[0] == 1){
            tokens[0] = 0;
            tokens[2]++;
            logStatus(orderNumber,""Pizza ordered"", now);
        } else {revert();}
    }

    function TakeTheOrder(){
        if(tokens[2] == 1){
            tokens[2] = 0;
            tokens[3]++;
            logStatus(orderNumber,""Order taken"", now);
        } else {revert();}
    }

        function PreparePizza(){
        if(tokens[3] == 1){
            tokens[3] = 0;
            tokens[4]++;
            logStatus(orderNumber,""Pizza Prepared"", now);
        } else {revert();}
    }
        function PokeTheWaiter(){
        if(tokens[4] == 1){
            tokens[4] = 0;
            tokens[6]++;
            logStatus(orderNumber,""Waiter has been poked"", now);
        } else {revert();}

        function WaiterBringsPizza(){
        if(tokens[4] == 1){
            tokens[4] = 0;
            tokens[7]++;
            logStatus(orderNumber,""Waiter is bringing Pizza"", now);
        } else {revert();}
    }
     function CustomerReceivesPizza(){
        if(tokens[7] == 1){
            tokens[7] = 0;
            logStatus(orderNumber,""Customer eats Pizza"", now);
        } else {revert();}
    }



    }
}"
31567-0.sol,question,"contract Customer{
event logStatus(uint orderNumber, bytes input, uint256 timestamp);

}"
31567-0.sol,question,"contract Chef{
event logStatus(uint orderNumber, bytes input, uint256 timestamp);

}"
31567-0.sol,question,"contract Waiter{
event logStatus(uint orderNumber, bytes input, uint256 timestamp);

}"
31567-0.sol,question,"contract dataBase{
event logStatus(uint orderNumber, bytes input, uint256 timestamp);

}"
51477-0.sol,question,"contract TRY{

    uint public temp=0;
    uint public b=0;

    function transfer_ether() public payable{
       uint c=60;
       if(msg.value>=c ether){
            temp=msg.value;
             b=temp-(60 ether);
            temp=60 ether;
           msg.sender.transfer(b );
       }
    }

    function to_contract() public payable {
        uint a=temp;
        temp=0;
        msg.sender.transfer(a);
    }
}"
83877-1.sol,question,"contract Verify{
    address owner ; 
    mapping (uint256 => bool) public usedNonces;

    constructor() public {
        owner = msg.sender ;
    }

    function withdraw(uint256 nonce , address recipientAddress , uint256 tokens, bytes memory signature) public {
        require(!usedNonces[nonce]);
        usedNonces[nonce] = true ;
        bool done ; 
        done = isValidSignature( recipientAddress , nonce , tokens  , signature );
        emit Success(done);
    }
    event Success(bool done);


    function isValidSignature(address recipient , uint256 nonce , uint256 amount, bytes memory signature)
        internal
        view
        returns (bool)
    {

        bytes32 message = keccak256(abi.encodePacked(recipient , address(this), nonce, amount));
        return recoverSigner(message, signature) == owner ;
    }

    function splitSignature(bytes memory sig)
        internal
        pure
        returns (uint8 v, bytes32 r, bytes32 s)
    {
        require(sig.length == 65 , ""invalid length"");

        assembly {
            r := mload(add(sig, 32))
            s := mload(add(sig, 64))
            v := byte(0, mload(add(sig, 96)))
        }
        if (v < 27) {
            v += 27;
        }

        require(v == 27 || v == 28);
        return (v, r, s);
    }

    function recoverSigner(bytes32 message, bytes memory sig)
        internal 
        pure
        returns (address)
    {
        (uint8 v, bytes32 r, bytes32 s) = splitSignature(sig);
        return ecrecover(message, v, r, s);
    }
}"
47933-1.sol,question,"contract Contact2{
    function test() {
          address test = msg.sender; 
          Token(0x5faf852d0bae90ae3adb58f68deae7fcfc065a6d).transfer(this, 1);
        }
}"
48816-0.sol,question,"contract Foo
{
    modifier ifHasOneOf(uint[] roles) {
        for (uint i=0; i < roles.length; i++) {
            if (getRoleForUser(msg.sender) == roles[i]) {
                _;
            }
        }
    }

    function A() public ifHasOneOf([UserRoles.AUTHOR, UserRoles.EDITOR]) {
        
    }

    function B() public ifHasOneOf([UserRoles.AUTHOR, UserRoles.CONTRIBUTOR]) {
        
    }
}"
10536-0.sol,question,"contract Foo
{
    function Foo() {}
}"
10536-0.sol,question,"contract FooFactory
{
    function newFoo() returns (Foo) {
       return new Foo();
    }
}"
46872-2.sol,question,"contract Supplier{
    struct supply{
        string NameoProd;
        uint QuantityoProd;
        string MnfofProd;
        string toSrv;
        string stat;
        string comments;
    }
    uint SaleID=100000;
    mapping (uint=>supply) fmr;
    event getSupplier( address indexed OwnAdd, string _NameoProd,
        uint _QuantityoProd,
        string _MnfofProd,
        string _toSrv,
        string _status,
        string _comments);

    function setSupply(string _NameoProd,
        uint _QuantityoProd,
        string _MnfofProd,
        string _toSrv,
        string _status,
        string _comments) public{
        address snd = msg.sender;
        fmr[SaleID]=supply(_NameoProd,_QuantityoProd,_MnfofProd,_toSrv,_status,_comments);
        emit getSupplier(snd, _NameoProd,_QuantityoProd,_MnfofProd,_toSrv,_status,_comments);
        SaleID++;
    }
  function getSomething(uint ID) public view returns (string , uint  , string , string , string , 
    string  ){
        supply a=fmr[ID];
       return (a.NameoProd, a.QuantityoProd, a.MnfofProd, a.toSrv, a.stat, a.comments);
    }
    function update(uint ID, string rpf) public {
        supply b =fmr[ID];
        b.stat=rpf;
        fmr[ID]=b;
        emit getSupplier(msg.sender, b.NameoProd,b.QuantityoProd,b.MnfofProd,b.toSrv,b.stat,b.comments);
    }

    }"
40228-0.sol,question,"contract Airdrop{
    address[] public recipients;
    uint256[] public balances;
    ERC20Basic public token;
  address owner;


    function Airdrop(address _token) public{
        require(_token != address(0));
        token = ERC20Basic(_token);
    owner = msg.sender;
    }

    function setRecipientsAndBalances(address[] _recipients, uint256[] _balances) public {
        require(_recipients.length == _balances.length);
    require(msg.sender == owner);
        recipients = _recipients;
        balances = _balances;
    }

    function doAirdrop() public returns(uint){
      require(msg.sender == owner);
        require(recipients.length>0);
        for(uint i=0; i < recipients.length; i++){
            if(token.balanceOf(this)>=balances[i]){
                token.transfer(recipients[i],balances[i]);
            }
            else{
                return i;
            }
        }
        return recipients.length;
    }

}"
64230-0.sol,question,"contract ProofofExistence{
   event ProofCreated(
      uint256  indexed id,
      bytes32 documentHash);

   address public owner;
   mapping  (uint => bytes32) hashesById;

   modifier onlyOwner() {
      require(msg.sender == owner);
      _;
   }

   modifier noHashExistsYet(uint256 id) {
      require(hashesById[id] == """");
      _;
   }

   constructor() public {
      owner = msg.sender;
   }

   function notarizeHash(uint256 id, bytes32 documentHash) onlyOwner noHashExistsYet(id) public{
      hashesById[id] = documentHash;
      emit ProofCreated(id, documentHash);
   }
   

   function doesProofExist(uint256 id, bytes32 documentHash) public view returns (bool) {
      return hashesById[id] == documentHash;
   }
}"
13433-2.sol,question,"contract Array{
  using ReceiptLib for ReceiptLib.intervalNode;
  ReceiptLib.intervalNode receiptList;

  function Array(){
    receiptList.constructReceipt();
  }
  function test(uint32 s, uint32 e, int32 c) {
    receiptList.number(s, e, c);
  }
}"
70240-0.sol,question,"contract greeter{
    string greeting;

    function greet(string memory _greeting)public {
        greeting=_greeting;
    }
    function getGreeting() public view returns(string memory) {
        return greeting;
    }
}"
56920-0.sol,question,"contract game
 {

     struct users
     {
         string name;
         uint level;
         uint score;
     }

     mapping(uint => users[]) mulusers;

     function addusers (string _name, uint _level, uint _score) public {

         users memory use= users(_name,_level,_score); 
     }

     function getusers (uint _level) public view returns (string)
     {
        uint index= mulusers[_level].length;
         for(uint i=0; i<index; i++)
         {       
           return mulusers[_level].users[i].name;    
         }   
     }   
 }"
26535-3.sol,question,"contract TestConst{
    uint public a = 10;

    function constantFnA() constant returns (uint) {
        return  a+5;
    }

    
    
    function NonCosntUsesConst(){
        a = constantFnA();
    }

    
    

    function nonConstantFn(){
        a = a+5;
    }


    uint8 public b = 10;
    function constantFnB() constant returns (uint8) {
        return  b+5;
    }

    
    
    function nonConstUisngB(){
        b = b+5;
    }

    
    
    function NonConstUsingConstB(){
        b = constantFnB();
    }
}"
80792-0.sol,question,"contract Department{

    struct Employee{
        uint empId;
        string empName;
        uint256 empSalary;
    }

    uint departmentId;
    string departmentName;
    mapping (uint => Employee) public employees;
    uint public employeeCount;

    constructor(uint _departmentId, string memory _departmentName) public {
        employeeCount = 0;
        departmentId = _departmentId;
        departmentName = _departmentName;
    }

    function addEmployee(uint _empId, string memory _empName, uint _empSalary ) public {
        employees[employeeCount] = Employee(_empId, _empName, _empSalary);
        employeeCount++;
    }

    
    function get(uint _index) public view returns(Employee memory) {
        return employees[_index];
    }

    
    function getEmployee() public view returns (uint[] memory, string[] memory, uint[] memory) {
        uint[]    memory id = new uint[](employeeCount);
        string[]  memory name = new string[](employeeCount);
        uint[]    memory salary = new uint[](employeeCount);
        for (uint i = 0; i < employeeCount; i++) {
          Employee storage employee = employees[i];
          id[i] = employee.empId;
          name[i] = employee.empName;
          salary[i] = employee.empSalary;
        }
        return (id, name, salary);
    }

    
    function getEmployees() public view returns (Employee[] memory) {
        Employee[]  memory id = new Employee[](employeeCount);
        for (uint i = 0; i < employeeCount; i++) {
          Employee storage employee = employees[i];
          id[i] = employee;
        }
        return id;
    }

}"
13973-0.sol,question,"contract queue
{
    struct Queue {
        uint256[] data;
        uint256 front;
        uint256 back;
    }
    
    function length(Queue storage q) constant internal returns (uint256) {
        return q.back - q.front;
    }
    
    function capacity(Queue storage q) constant internal returns (uint256) {
        return q.data.length - 1;
    }
    
    function push(Queue storage q, uint256 data) internal
    {
        if ((q.back + 1) % q.data.length == q.front)
            return; 
        q.data[q.back] = data;
        q.back = (q.back + 1) % q.data.length;
    }


    
    function pop(Queue storage q) internal returns (uint256 r)
    {
        if (q.back == q.front)
            return; 
        r = q.data[q.front];
        delete q.data[q.front];
        q.front = (q.front + 1) % q.data.length;
        return r;
    }
    Queue requests;
    event PopEvent(bool ok); 
    function queue() {
        requests.data.length = 200;
    }
    function addRequest(uint256 d) {
        push(requests, d);
    }
    function popRequest()  returns (uint256) {
        PopEvent(true);
        return pop(requests);
    }
    function queueLength()  constant returns (uint256) {
        return length(requests);
    }
    function hello() constant returns(string s){ 
        return 'hello world!';
    }
}"
72475-0.sol,question,"contract fileEvidence{
    struct FileEvi{
        uint caseId;
        bytes fileHash;
        uint upTime;
        address upOperator;
    }
    mapping(bytes => FileEvi) evi;
    constructor () public{
    }
    function saveFileEvi(bytes _hash,uint _upTime ) public{
        evi[_hash].fileHash = _hash;
        evi[_hash].upTime = _upTime;
        evi[_hash].upOperator = msg.sender;
    }
    function getFileEvi(bytes _hash) public view returns(uint _upTime,address _upOperator) {
        _upTime = evi[_hash].upTime;
        _upOperator = evi[_hash].upOperator;
    }
}"
82221-2.sol,question,"contract customer{
   string public firstname;
   string public lastname;
   uint256 public id;
   bool public KYC;
   uint256 public level;
   string public docsHash;
   uint256 public cost=3 ether;
   uint256 public upcost=3 ether;
   string public bankName;
   address payable[] onboarded;

   function fill(string memory fname, string memory lname ,uint256 iden, string memory KYCresult, uint256 categor, string memory hash, string memory bank) public{
      firstname=fname;
      lastname=lname;
      id=iden;
         if(keccak256(bytes(KYCresult))==keccak256(bytes("""")))
            {
               KYC=true;
            }
     level=categor;
     cost/=(3/categor);
     docsHash=hash;
     bankName=bank;
        onboarded.push(address(uint160(msg.sender)));
        customerFinder(0x9638101cb6571cc3A807A2a4e770Ee040dD0275c).filling(id, address(uint160(address(this))));
     }

   function contribution() public payable {
      if(msg.value==cost/(onboarded.length+1))
         {
            for(uint i=0; i<onboarded.length; i++)
               {
                  onboarded[i].transfer(msg.value/onboarded.length);
               }    
           onboarded.push(address(uint160(msg.sender)));
         }
      }
   function KYC_hash() public view returns(string memory, string memory){
       if(KYC==true)
         {
            return ("""", docsHash);
         }else
             {
                return ("" "", docsHash);
             }
   }


   function update(string memory fname, string memory lname ,uint256 iden, string memory KYCresult, uint256 categor, string memory hash, string memory bank) public {
      firstname=fname;
      lastname=lname;
      id=iden;
         if(keccak256(bytes(KYCresult))==keccak256(bytes("""")))
           {
              KYC=true;
           }
      level=categor;
      upcost/=(3/categor);
      docsHash=hash;
      bankName=bank;
   }
   function representation() public view returns(string memory, string memory, string memory, string memory, string memory, string memory, string memory){
      return (firstname, lastname, uint2str(uint(id)), uint2str(uint(level)), uint2str(uint(cost)), uint2str(uint(onboarded.length)), uint2str(uint(cost/(onboarded.length+1))));
   }

    function uint2str(uint _i) internal pure returns (string memory ) {
    if (_i == 0) {
        return ""0"";
    }
    uint j = _i;
    uint len;
    while (j != 0) {
        len++;
        j /= 10;
    }
    bytes memory bstr = new bytes(len);
    uint k = len - 1;
    while (_i != 0) {
        bstr[k--] = byte(uint8(48 + _i % 10));
        _i /= 10;
    }
    return string(bstr);
}
   function() external payable{}
}"
38592-0.sol,question,"contract X{
   function reservePlace(string _name) public payable returns (bool isNotReserved) {
      
   }
}"
19622-0.sol,question,"contract userPasswd
{
    mapping(bytes32 => bytes32) private  userPasswds ;
    event RecordReturnResult(bool res);

    
    function newPair(string user, string password)  returns (bool) {      
        bytes32  sha3_user = sha3(user);
        bytes32  sha3_password = sha3(password);
        bool res = true;
        if (userPasswds[sha3_user] > 0) {
            res = false;
            RecordReturnResult(res);
            return res;
        }           
        else{
            userPasswds[sha3_user] = sha3_password;
            res = true;
            RecordReturnResult(res);
            return res;
        }      
    }

    
    function verify(string user, string password) returns (bool) {
        bytes32  sha3_user = sha3(user);
        bytes32  sha3_password = sha3(password);
        

        
        if (userPasswds[sha3_user] == sha3_password){
            RecordReturnResult(true);
            return true;
        }           
        else{
            RecordReturnResult(false);
            return false;
        }
    }

     
    function del(string user) returns (bool) {
        bytes32  sha3_user = sha3(user);

        if (userPasswds[sha3_user] > 0){
           delete userPasswds[sha3_user];
           RecordReturnResult(true);
           return true;
        }
        else {
            RecordReturnResult(false);
            return false;   
        }

    }
      
    function change(string user, string password) returns (bool) {
        bytes32  sha3_user = sha3(user);
        bytes32  sha3_password = sha3(password);

        if (userPasswds[sha3_user] > 0){
           userPasswds[sha3_user] = sha3_password;
           RecordReturnResult(true);
           return true;
        }
        else {
            RecordReturnResult(false);
            return false;
        }                
    }
}"
67572-0.sol,question,"contract SimpleFallback{
    event FallbackCalledEvent(bytes data);
    event AddEvent(uint a, uint b, uint result);
    event DoubleEvent(uint a, uint b);
    event GetNameEvent(string);

    function() external{
        emit FallbackCalledEvent(msg.data);
    }

    function add(uint a, uint b) public returns(uint){
        
        
        

        uint _result = a + b;
        emit AddEvent(a, b, _result);

        return _result;
    }

    function double(uint a) public returns(uint){
        
        
        uint _result = 2*a;

        emit DoubleEvent(a, _result);

        return _result;
    }

    function getName(string memory name) public returns(string memory){
        emit GetNameEvent(name);

        return name;
    }
}"
67572-0.sol,question,"contract RunTest{


    function callAddlTest(address other) public {
        
        
        other.call(abi.encodeWithSignature(""add(uint,uint)"", 85, 60));
    }

    function callDoublelTest(address other) public {
        
        
        other.call(abi.encodeWithSignature(""double(uint)"", 100));
    }

    function callgetNameTest(address other) public{
        other.call(abi.encodeWithSignature(""getName(string)"", ""hello""));
    }
}"
75951-0.sol,question,"contract Ether_Transfer_To{
    function () external payable { 

    }
    function get_balance() public returns(uint){
        return address(this).balance;
    }
}"
75951-0.sol,question,"contract Ether_Transfer_From{
    Ether_Transfer_To private the_instance;
    constructor() public{
        
        the_instance=new Ether_Transfer_To();
    }
    function get_balance() public returns(uint){
        return address(this).balance;
    }
    function get_balance_of_instance() public returns(uint){
        
        return the_instance.get_balance();
    }
    function () external payable {
        
        address(the_instance).send(msg.value);
    }
}"
28680-0.sol,question,"contract EtherMon{ 
    uint public starterEgg;
    address public owner;



    struct player{
        uint256 goldAmount;
      uint[10] listOfEggs;
        bool eggCoolDown;
        uint eggTime;
        uint eggID;
        bool battleCoolDown;
        bool breedingCoolDown;
        uint[] ownedEthermon;
    }

      mapping (address => player) public listOfPlayers;

    function EtherMon(){
        owner = msg.sender;

    }

    function createAccount(){


     starterEgg = block.timestamp % 10;

     listOfPlayers[msg.sender].goldAmount  = 100;
     listOfPlayers[msg.sender].listOfEggs[0] = starterEgg;


        }



  function getCurrentEggs() returns (uint[]) {
 uint length =  listOfPlayers[msg.sender].listOfEggs.length;
 uint[] eggArray;
            for(uint i = 0; i < length; i++){
               eggArray[i] =  listOfPlayers[msg.sender].listOfEggs[i];
            }
            return eggArray;
        }

    }"
26542-0.sol,question,"contract Token{
       function Token() payable{...}
       function _transfer(...) internal {...}
       function transfer (..) payable{..}
}"
48816-1.sol,question,"contract Foo
{
    modifier ifHasRole(uint role) {
        if (getRoleForUser(msg.sender) == role) {
            _;
        }
    }

    function A() public ifHasRole(UserRoles.AUTHOR) ifHasRole(UserRoles.EDITOR) {
        
    }

    function B() public ifHasRole(UserRoles.AUTHOR) ifHasRole(UserRoles.CONTRIBUTOR) {
        
    }
}"
51442-1.sol,question,"contract MyContract is CustomToken{

    function transferCustom(address _to, uint _value) public returns (bool) {
        require(_to != address(0));


        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender,_to,_value);

        return true;
    }
}"
67429-1.sol,question,"contract Factory{
    CrowdFunding[] public deployedContractAddresses;

    constructor(uint minimum) public {
        CrowdFunding newContract = new CrowdFunding(minimum, msg.sender);
        deployedContractAddresses.push(newContract);
    }

    function getDeployedContractAddresses() public view returns(CrowdFunding[] memory) {
        return deployedContractAddresses;
    }
}"
12242-0.sol,question,"contract X{

    uint amount;

    function X() {
        amount = amount + msg.value;
    }
}"
19295-0.sol,question,"contract TestContract{
    string coaf;
    string choice;
    string info;
    string isin;
    string recordDate;
    string exDate;

    function TestContract(string _coaf, string _choice, string _info,string _isin,string _recordDate,string _exdate){
        coaf = _coaf;
        choice = _choice;
        info = _info;
        isin =_isin;
        recordDate=_recordDate;
        exDate=_exdate;
    }


    function getFields() constant returns(string, string, string,string,string,string){
        return(coaf,choice,info,isin,recordDate,exDate);

    }
   function SetFields(string _coaf,string _choice,string _info,string _isin,string _recordDate,string _exdate){
     coaf=_coaf;
     choice=_choice;
     info=_info;
     isin=_isin;
     recordDate=_recordDate;
     exDate=_exdate;
   }
    function setChoice(string _choice) {
        info = _choice;
    }

}"
62196-0.sol,question,"contract Broker
{
    using SafeMathOZ for uint256;
    Target                      public target;
    mapping(address => uint256) public m_balance;
    mapping(address => uint256) public m_reward;

    constructor(address _target) public {
        target = Target(_target);
    }

    function () public payable {
        m_balance[msg.sender] = m_balance[msg.sender].add(msg.value);
    }

    function deposit() public payable {
        m_balance[msg.sender] = m_balance[msg.sender].add(msg.value);
    }

    function depositFor(address _account) public payable {
        m_balance[_account] = m_balance[_account].add(msg.value);
    }

    function withdraw(uint256 _amount) public {
        m_balance[msg.sender] = m_balance[msg.sender].sub(_amount);
        msg.sender.transfer(_amount);
    }

    function setReward(uint256 _reward) public {
        m_reward[msg.sender] = _reward;
    }

    function XXX(Data data) public returns (bytes32) {
        uint256 gasBefore = gasleft();
        bytes32 result = target.XXX(data);
        address payer = data.requester;
        uint256 price = tx.gasprice * (87000 + gasBefore - gasleft()) + m_reward[payer];
        m_balance[payer] = m_balance[payer].sub(price);
        msg.sender.transfer(price);
        return result;
    }
}"
50101-0.sol,question,"contract Damble is usingOraclize{

function Damble() {
    getRandomNumber();

}
    function __callback(bytes32 _queryId, string _result, bytes _proof) { 
    if (msg.sender != oraclize_cbAddress()) throw;

    if (oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) != 0) {
        
    } else {
        
        

        newRandomNumber_bytes(bytes(_result)); 

        
        uint maxRange = 10000000; 
        uint randomNumber = uint(sha3(_result)) % maxRange; 

        newRandomNumber_uint(randomNumber); 
    }
}

function getRandomNumber() payable{ 
    oraclize_setProof(proofType_Ledger); 
    uint N = 4; 
    uint delay = 0; 
    uint callbackGas = 200000; 
    bytes32 queryId = oraclize_newRandomDSQuery(delay, N, callbackGas);
}
"
45479-0.sol,question,"contract ShapeCalculator{
    function rectangle(uint w, uint h) returns (uint s, uint p) {
        
        s = w * h;
        p = 2 * (w + h);
    }
}"
62443-0.sol,question,"contract MetaToken is Pausable{

string public name = 'MetaMetaMeta! Token';
uint8 public decimals = 8;
string public symbol = 'M3T';
string public version = '0.4.0';

uint256 public blockReward = 1 * (10**uint256(decimals));
uint32 public halvingInterval = 210000;
uint256 public blockNumber = 0; 
uint256 public totalSupply = 0;
uint256 public target   = 0x0000ffff00000000000000000000000000000000000000000000000000000000; 
uint256 public powLimit = 0x0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;
uint40 public lastMinedOn; 
uint256 public randomness;

address public newContractAddress;

function MetaToken() Ownable() {
    lastMinedOn = uint40(block.timestamp);
    updateRandomness();
}


function updateRandomness() internal {
    randomness = uint256(sha3(sha3(uint256(block.blockhash(block.number-1)) + uint256(block.coinbase) + uint256(block.timestamp))));
}


function getRamdomness() view returns (uint256 currentRandomness) {
    return randomness;
}


function hash(uint256 nonce, uint256 currentRandomness) pure returns (uint256){
    return uint256(sha3(nonce+currentRandomness));
}


function checkProofOfWork(uint256 nonce, uint256 currentRandomness, uint256 currentTarget) pure returns (bool workAccepted){
    return uint256(hash(nonce, currentRandomness)) < currentTarget;
}


function checkMine(uint256 nonce) view returns (bool success) {
    return checkProofOfWork(nonce, getRamdomness(), target);
}


function mine(uint256 nonce) whenNotPaused returns (bool success) {
    require(checkMine(nonce));

    Mine(msg.sender, blockReward, uint40(block.timestamp) - uint40(lastMinedOn)); 

    balances[msg.sender] += blockReward; 
    blockNumber += 1;
    totalSupply += blockReward; 
    updateRandomness();

    
    var mul = (block.timestamp - lastMinedOn);
    if (mul > (60*2.5*2)) {
        mul = 60*2.5*2;
    }
    if (mul < (60*2.5/2)) {
        mul = 60*2.5/2;
    }
    target *= mul;
    target /= (60*2.5);

    if (target > powLimit) { 
        target = powLimit;
    }

    lastMinedOn = uint40(block.timestamp); 
    if (blockNumber % halvingInterval == 0) { 
        blockReward /= 2;
        RewardHalved();
    }

    return true;
}

function setNewContractAddress(address newAddress) onlyOwner {
    newContractAddress = newAddress;
}

event Mine(address indexed _miner, uint256 _reward, uint40 _seconds);
event RewardHalved();"
63701-0.sol,question,"contract UniToken{
    string value=""Hello"";

    function set(string x) public {
        value = x;
    }
    function get() public view returns (string) {
        return value;
    }
}"
65797-0.sol,question,"contract Dice{

    TokenSale public tokenSale;
    address tokensaleaddress;

    struct player_details{
        address pAddress;
        string pName;
         }

    struct gameRecords{
        address playerAddress;
        uint selected_num;
        uint rolled_num;
        bool result;
        uint ptoken;
        uint timestamp;
    }

    constructor (TokenSale _tokenSale) public {
      tokenSale = _tokenSale;
    }


    mapping(uint =>gameRecords) public outcome;
    mapping(uint => player_details) public details;

    uint public playerid=0;
    uint played=1;
    uint playercount=0;

      function setplayerDetails(string memory _pName) public{
        details[playerid] = player_details(msg.sender,_pName);
        playerid++;
        playercount++;
      }

    function addGameEvent(uint _betplaced, uint _rollresult,bool _result,uint _ptoken) public{
        require(playercount >=1 );
        outcome[played] = gameRecords(msg.sender,_betplaced,_rollresult,_result,_ptoken,now);
        played++;
    }

    function tokenfetch() public {
        
        tokenSale.buyTokens(100);
    }

  }"
76269-0.sol,question,"contract Product{ 
    uint public totalProducts = 0;
    struct ProductStruct {  
        address productOwner; 
        uint productId;
        string uniqueName;  
        string platform;
        uint aspect1Score;
        uint aspect2Score;
        uint aspect3Score;
        uint aspect4Score;
        uint aspect5Score;
        uint totalScore;
    }

    mapping(uint => ProductStruct) public ProductStructs;

    function setProduct (string memory _productName, string memory _platform) public {
        totalProducts ++;
        ProductStruct storage newProduct = ProductStructs[totalProducts];
        newProduct.productOwner = msg.sender;
        newProduct.productId = totalProducts;
        newProduct.uniqueName = _productName;
        newProduct.platform = _platform;
        newProduct.aspect1Score = 100;
        newProduct.aspect2Score = 100;
        newProduct.aspect3Score = 100;
        newProduct.aspect4Score = 100;
        newProduct.aspect5Score = 100;
        newProduct.totalScore = 500;
    }

    function getProduct(uint _productId) public view returns (string memory _uniqueName) {
        _productId = totalProducts;
        return ProductStructs[_productId].uniqueName;
    }
}"
6662-0.sol,question,"contract PriceFeed is usingOraclize{
  uint public BTCUSD;

  function PriceFeed(){
    oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
    update(0); 
  }

  function __callback(bytes32 myid, string result, bytes proof) {
    if (msg.sender != oraclize_cbAddress()) throw;
    BTCUSD = parseInt(result, 2); 
    
   

    update(360); 
  }

  function update(uint delay){
    oraclize_query(delay, ""URL"",
      ""json(https:
  }
}"
44275-0.sol,question,"contract Allowance is Ownable{
        uint AllowanceWeek = 0.01 ether;
        address ledger;
        uint32 coolDownTime = 1 weeks;
        uint32 overflow;
        uint32 weekCooldown;

        modifier onlyLedgerOrOwner{
            require(msg.sender == ledger || msg.sender == owner);
            _;
        }

        function _triggerCooldown()internal onlyOwner{
          weekCooldown = uint32(now + coolDownTime);
      }

        function () public payable{

        }

        function _changeCoolDownTime(uint32 _CoolDownTime) external onlyOwner{
            coolDownTime = _CoolDownTime;
        }

        function withdraw() external payable onlyLedgerOrOwner {
            require(now >= weekCooldown);
            require(this.balance >= AllowanceWeek);
            ledger.transfer(AllowanceWeek);
            _triggerCooldown();
            overflow = uint32(this.balance - (AllowanceWeek * 76));
            if(overflow > 0){
                msg.sender.transfer(overflow);
            }
      }

      function _setAllowance(uint _Allowance) external onlyOwner{
          AllowanceWeek = _Allowance;
      }

      function _changeAddress(address _Address) external onlyOwner{
          ledger = _Address;
      }

      function transferOwnership (address newOwner) onlyOwner{
        require(newOwner != address(0));
        OwnershipTransferred(owner, newOwner);
        owner = newOwner;  
    }  
    }"
29120-0.sol,question,"contract C{
    using L for L.S;
    L.S LS;

    function setCF(uint CInP)external {
        L.SetLF(LS,CInP); 
    }

    function GetCF() external returns(uint COutP){
        return L.GetLF(LS); 
    }
}"
70241-0.sol,question,"contract FreeSpeech{

address owner;
struct Message{
    string Message;
    int Vote;
    uint timeSubmit;
    bool isImportant;
    uint senderId;
}

mapping(address=>uint) public addressId;
mapping(address=> uint) addressMessageCount;

modifier onlyOwner(){
    require(msg.sender == owner);
    _;
}

Message[] messageArr;
constructor() public{
    owner = msg.sender;
}

function addMessage(string memory _message) public {
    if(addressId[msg.sender] == 0){
       addressId[msg.sender] = uint(keccak256(abi.encodePacked(msg.sender)));
    }
    addressMessageCount[msg.sender]++;
    messageArr.push(Message(_message,0, now, true, addressId[msg.sender]));
}

function getMessageCount() public view returns(uint){
    return addressMessageCount[msg.sender];
}

function getAddressId() public view returns(uint){
    return addressId[msg.sender];
}

function getMessageString() public view returns(string memory){
    return (messageArr[1].Message);
}

function upvoteMessage(uint _messageId) public {
    messageArr[_messageId].Vote += 1;
}

function downvoteMessage(uint _messageId) public {
    messageArr[_messageId].Vote -= 1;
}

function getMyMessageUpvoted() public view returns(string memory){
    int largest = 0;
    uint idLargest = 0;
    for(uint i = 0; i<addressMessageCount[msg.sender]; i++){
        if(messageArr[i].Vote > largest){
            largest = messageArr[i].Vote;
            idLargest = i;
        }
    }
    return messageArr[idLargest].Message;
}
}"
78661-0.sol,question,"contract DebuggerSampleContract{
   int counter = 10;
   function LoopCounter(int _input) public view returns (int) {
      int returnValue;
      for(; _input <counter; _input++)
      {
         returnValue += _input;
       }
       returnValue;
   }
}"
82863-0.sol,question,"contract crowdsale{

     Token public mytoken; 

      address payable public wallet;  

      uint public rate; 
      uint public weiraised; 

       event token_purchased(address indexed purchaser, address indexed benefeciary, uint value, uint amount);

       constructor(uint _rate, address payable _wallet, Token  _token) public{
         require(_rate > 0);
         require(_wallet != address(0));
       
          rate = _rate;
          wallet = _wallet;
          mytoken = _token;

       }
       function buytokens(address _beneficiary) public payable{
            uint wei_amount = msg.value;
            _prevalidate_purchase(_beneficiary, wei_amount);

            

            uint tokens = _gettokenamount(wei_amount);

            

            weiraised = weiraised + wei_amount;

            _processpurchase(_beneficiary, tokens);
            emit token_purchased(msg.sender, _beneficiary, wei_amount, tokens);
            _forwardfunds();

       }

       function () external payable{
           buytokens(msg.sender);
       }

       function _prevalidate_purchase(address _beneficiary, uint wei_amount) internal  {
           require(_beneficiary != address(0));
           require(wei_amount != 0);
       }


       function _delivertokens(address _beneficiary, uint _tokenamount) internal{
           mytoken.transfer(_beneficiary, _tokenamount);
       }

       function  _processpurchase(address _beneficiary, uint _tokenamount) internal{
           _delivertokens(_beneficiary, _tokenamount);
       }




       function _gettokenamount(uint wei_amount) internal view returns(uint){
           return wei_amount * rate;
       }

       function _forwardfunds() internal {


            wallet.transfer(msg.value);

       }


}"
77020-0.sol,question,"contract Campaign
{
    struct Request
    {
        string description;
        uint value;
        address recipient;
        bool compelete;
        uint approvalCount;
        mapping(address=>bool) approvals;
    }
    Request[] public requests;
    address public manager;
    uint public minimumContribution;
    mapping (address=> bool) public approvers;

    modifier restricted()
    {
        require(msg.sender==manager);
        _;
    }
    function Campaign(uint minimum) public
    {
        manager = msg.sender;
        minimumContribution = minimum;
    }
    function Contribute() public payable
    {
        require(msg.value >= minimumContribution);
        approvers[msg.sender]=true;

    }
    function createRequest(string description, uint value, address recipient) public restricted 
    {
        require(approvers[msg.sender]);
        Request memory newRequest = Request({
            description:description,
            value:value,
            recipient:recipient,
            complete:false,
            approvalCount: 0
            });
        requests.push(newRequest);
    }
    function approveRequest(uint index) public {

        require(approvers[msg.sender]);
        require(!requests[index].approvals[msg.sender]);

        requests[index].approvals[msg.sender]=true;
        requests[index].approvalCount++;
    }
}"
74516-0.sol,question,"contract arraytest{

struct Player {
    uint estimation;
    
    
}

Player[] public playersArr;
address[] public playersaddress;

    function setbid(uint _prediction, address _playeraddr) public{
    Player memory player;
    player.estimation = _prediction;
    playersArr.push(player);
    playersaddress.push(_playeraddr);

}

    function getWinnersArray() public view returns (address[] memory) {
    uint i=0;


    uint counter = 0;
    uint j=1;
    uint minvalue=playersArr[i].estimation;

    address[] memory winners = new address[](j);
    winners[counter] = playersaddress[i];
    counter++;


    for (i = 1; i < playersArr.length; i++) {



        if (playersArr[i].estimation < minvalue) {

            minvalue=playersArr[i].estimation;
            delete winners;

            winners = new address[](j);
            counter=0;

            winners[counter] = playersaddress[i];
            counter++;
        }else if(playersArr[i].estimation == minvalue){

            
        }
    }
    return (winners);
}"
43049-0.sol,question,"contract TestChainCoin is RefundableCrowdsale
{
    function TestChainCoin() RefundableCrowdsale() {
            balances[msg.sender] = 100;                                                                   
        }
}"
64325-0.sol,question,"contract Lottery{
address[] public players; 
address public manager; 


constructor() public{
    
    manager = msg.sender; 
}


   somebody

function  ()  payable  external {
    require(msg.value >= 0.01 ether);
    players.push(msg.sender); 

                              
   }

function get_balance() public view returns(uint){
    require(msg.sender == manager);
    return address(this).balance; 
}


function random() public view returns(uint256){
return uint256(keccak256(block.difficulty, block.timestamp, 
players.length));  
}

function selectWinner() public {
    require(msg.sender == manager);


    uint r = random();

    address winner;

    
    uint index = r % players.length;
    winner = players[index];

    
    winner.transfer(address payable(this).balance);

    players = new address[](0); 
}
}"
55212-1.sol,question,"contract Testing{
    address [] public adds;
    uint [] public amounts;

    function bet() public payable {
        adds.push(msg.sender);
        amounts.push(msg.value);
    }

    function give() public {
        adds[0].transfer(amounts[0]);
    }
}"
65733-0.sol,question,"contract 721TokenFreezer{

  function freezeToken(address _tokenToFreezeAddress, uint256 _tokenToFreezeId) {
    
  }

  function unfreezeToken(address _tokenToFreezeAddress, uint256 _tokenToFreezeId, address _to){
    
  }"
56001-0.sol,question,"contract Bar{

    struct Foo{
        uint x;
    }
    mapping(uint => Foo[]) foo;

    function add(uint id, uint _x) public {
        foo[id].push(Foo(_x));
    }

    function get(uint id, uint index) public returns(uint){
        return foo[id][index].x;
    }
}"
73529-0.sol,question,"contract Institute{
struct InstituteDetails {
    uint id;
    string name;
    uint studentCount;
}


mapping(uint => InstituteDetails) public Institutes;

constructor() public{
    addInstitute('test');
}

event instituteCreatedEvent (
    uint  id
);
 
uint public instituteCount;

function addInstitute (string memory _name) public {
    instituteCount ++;
    Institutes[instituteCount] = InstituteDetails(instituteCount, 
_name, 0);
    emit instituteCreatedEvent(instituteCount);
}
}"
46892-0.sol,question,"contract MyToken is ERC721Token{
function MyToken(string _name, string _symbol) ERC721Token(_name, _symbol) public {
}"
43552-0.sol,question,"contract IamHongKongTokenBack_00{ 

  
function SeeMyAddAndETHVar() public constant returns (address, uint) {
    address _myadd = msg.sender;
    return ( _myadd,  _myadd.balance);
}   


function SeeSheEthVar(address _InputAdd) public constant returns (address, uint) {
    address _SheAc = _InputAdd;
    return (_SheAc, _SheAc.balance);
}   


}"
43605-0.sol,question,"contract Bar
{
  uint n ;
  event Argle(uint arg);
  function argle_int(uint arg) internal {
    n = arg ;
  }

  function argle(bool pass, uint arg) public {
    Argle(arg) ;
    require(pass) ;
    argle_int(arg);
  }

  function get() public view returns (uint) {
    return n ;
  }
}"
46672-0.sol,question,"contract AssetFactory{

    address[] deployedAssets;

      function createAsset(string name) public {
        address newAsset = new Asset(name);
        deployedAssets.push(newAsset);
        return newAsset;
      }

    }"
46672-0.sol,question,"contract Asset{

     string name;

     function Asset(string name) public{
       name = name;
     }

     function ModifyAssetAndCreateNew(string name, address factory){
       factory.createAsset(name);
       name = name;
     }

   }"
15076-0.sol,question,"contract queue
{
    Queue requests;

    event ElementPopped(uint256 _element); 
    event ElementPushed(uint256 _element, uint256 _index); 

    function queue() {
        requests.data.length = 200;
    }

    struct Queue {
        uint256[] data;
        uint256 front;
        uint256 back;
    }
    
    function length(Queue storage q) constant internal returns (uint256) {
        return q.back - q.front;
    }
    
    function capacity(Queue storage q) constant internal returns (uint256) {
        return q.data.length - 1;
    }

    function isOverlapped(Queue storage q) internal returns (bool) {
        return (q.back + 1) % q.data.length == q.front;
    }

    
    function push(Queue storage q, uint256 data) internal {
        if (isOverlapped(q)) throw;
        q.data[q.back] = data;

        ElementPushed(data, q.back);

        q.back = (q.back + 1) % q.data.length;
    }


    
    function pop(Queue storage q) internal returns (uint256 r)
    {
        if (q.back == q.front)
            return; 
        r = q.data[q.front];
        delete q.data[q.front];
        q.front = (q.front + 1) % q.data.length;
        return r;
    }


    function addRequest(uint256 d) {
        push(requests, d);
    }

    function popRequest() {
        ElementPopped(pop(requests));
    }

    function queueLength() constant returns (uint256) {
        return length(requests);
    }
}"
76969-0.sol,question,"contract TestBasicToken{
   uint public inintialBalance = 10**17 * 10;

   address payable Owner = 0x65727c4c3869EA9BbB3BE13613F0a2Fd37e28259;
   address contractAddress = address(this);
   BasicToken basicToken = new BasicToken(Owner);

   uint expectedSupply = 0;
   uint expectedBalance = 300;


   function testTotalSupply() public {
      uint _totalSupply = basicToken.totalSupply();
      Assert.equal(expectedSupply, _totalSupply, ""Expected supply should match return value"");
   }
   function testBalanceOf() public {
      uint _balance = basicToken.balanceOf(Owner);
      Assert.equal(expectedBalance, _balance, ""Expected balance should match return value"");
   }
   function testBuyToken() public {
      basicToken.buyToken.value(10**17);
      uint _balance = basicToken.balanceOf(contractAddress);
      Assert.notEqual(0, _balance, ""Balance should no longer be 0"");
   }
}"
83602-0.sol,question,"contract ContractExp1{
    string public value;
    uint256 public count=0;

mapping(uint256 => Person) public people;

struct Person{
    string name;
    uint256 balance;
}


constructor() public{
    value='myValue';
}


function setPeople (string memory _name, uint256 memory _val) public {
    count=count+1;
    people[count]=Person(_name,_val);
    }
}"
70638-0.sol,question,"contract permission{
struct transaction {
        address payable sender;
        address receiver;
        string datatype;
        Status status;
    }

function getTransactionCount() public view returns(uint256 cnt) {
        uint256 len = transactions.length;
        return(len);
    }
}"
44421-0.sol,question,"contract changer{


       habibconcert firstObject =    habibconcert(0x692a70d2e424a56d2c6c27aa97d1a86395877b3a);

       interfacer public changers;

      function changeTickets(uint new_tickets)  {


       

          changers.changeTickets_numberTicket(new_tickets);

        
        
        
  }


    function displayTickets_numbers()constant returns(uint){

               return displayTickets_numbers();
    }


    }"
44421-0.sol,question,"contract habibconcert{

      uint  public tickets = 6;

      address owner_of_tickets;

      uint constant price = 1 ether;

       mapping(address=>uint) public purchasers;

      function habibconcert()payable{

            owner_of_tickets =  msg.sender;
      }


                function  displayTickets_numbers()constant returns(uint){

                    return tickets;


                }






              function changeTickets_numberTicket (uint newtickets) {

                         tickets +=newtickets;

                   }











        modifier ownLycreature(){


            require(msg.sender ==  owner_of_tickets) ;

            
            _;

            }



               function changeTickets_number (uint newtickets) ownLycreature{

                         tickets +=newtickets;

                   }




    function buytickets(uint amount)payable{

          if(msg.value!=(amount*price) || amount>tickets){

              throw;
          }

          purchasers[msg.sender] +=amount;

          tickets -=amount;


        

        

        


    }        





}"
60622-0.sol,question,"contract FuncToken is IERC20{

using SafeMath for uint256;

uint public constant _totalSupply = 0;

string public constant symbol = ""UB"";
string public constant name = ""UNIFIED BET"";
uint8 public constant decimals = 18;


uint256 public constant RATE = 1;

address public owner;

mapping (address => uint256) balances;
mapping (address => mapping(address => uint256)) allowed;

function () payable{
    createToken();
}

constructor () public{
    owner = msg.sender;

}

function createToken() public payable {
    require(msg.value > 0);

    uint256 tokens = msg.value;
    balances[msg.sender] = balances[msg.sender].add(tokens);

    owner.transfer(msg.value);
}

function totalSupply() public constant returns (uint256 totalSupply){
    return _totalSupply;
}

function balanceOf(address _owner) public constant returns (uint256 balance){
    return balances[_owner];
}

function transfer(address _to, uint256 _value) public returns (bool success){
    require (
        balances[msg.sender] >= _value
        && _value > 0
        );
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        emit Transfer(msg.sender, _to, _value);
        return true;

}

function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){
    require(
        allowed[_from][msg.sender] >= _value
        && balances[_from] >= _value
        && _value > 0
        );

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].add(_value);
        emit Transfer(_from, _to, _value);
        return true;
}

function approve(address _spender, uint256 _value) public returns (bool success){
    allowed[msg.sender][_spender] = _value;
    emit Approval(msg.sender, _spender, _value);
    return true;
}

function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
}

}"
42014-0.sol,question,"contract ParentCompany{
    address public parentAddress;

    function ParentCompany() public{
        parentAddress = msg.sender;
    }
    function getB() public view returns(uint){
        return this.balance;
    }

    function() payable {
    }
}"
42014-0.sol,question,"contract Subsidiary{

    address public subsidiaryAddress;
    address parentCompany;
    function Subsidiary(address _parentCompany) public payable{
        subsidiaryAddress = msg.sender;
        parentCompany = _parentCompany;
    }

    function sendToParent() public {
        parentCompany.transfer(this.balance);
    }
    function() payable{

        sendToParent();  
    }
}"
42014-0.sol,question,"contract Client{
    address clientAddress;

    function Client() public payable{
        clientAddress = msg.sender;
    }
    function payment(address _subCompany, uint _amount) public{
        uint amount = _amount *(10**18);
        _subCompany.transfer(amount);
    }

}"
49674-0.sol,question,"contract Transfer{
function test() public payable {msg.sender.transfer(msg.value);}
}"
51466-0.sol,question,"contract TRY{  
    uint public temp=0;  
    function transfer_ether() public payable{  
        require(msg.value>=60);  
        temp=60;  
        msg.sender.transfer(msg.value-60);  
    }  
    function to_contract() public payable {  
        uint a=temp;  
        temp=0;  
        msg.sender.transfer(a);  
    }  
}"
71846-0.sol,question,"contract DappTokenSale{
    address admin;
    DappToken public tokenContract;
    uint256 public tokenPrice;
    uint256 public tokensSold;

    event Sell(address _buyer, uint256 _amount);

    constructor(DappToken _tokenContract, uint256 _tokenPrice)public{
        
        
        admin = msg.sender;

        
        tokenContract = _tokenContract;

        
        tokenPrice = _tokenPrice;
    }

    
    
    
    
    function multiply(uint x, uint y) internal pure returns(uint z) {
        require( y == 0|| (z = x* y ) / y == x);
    }       


    
    function buyTokens(uint256 _numberOfTokens) public payable{
        
        
        require(msg.value == multiply(_numberOfTokens, tokenPrice));

        
        require(tokenContract.balanceOf(address(this)) >= _numberOfTokens);

        
        require(tokenContract.transfer(msg.sender, _numberOfTokens));  
        
        
        tokensSold += _numberOfTokens;

        
        emit Sell(msg.sender, _numberOfTokens);
    }

    
    function endSale() public {
        
        require(msg.sender == admin);
        
        require(tokenContract.transfer(admin, tokenContract.balanceOf(address(this))));
        
            
            
            
        selfdestruct(msg.sender);

    }
}"
58650-1.sol,question,"contract Gallery{
uint public emojiCount;
struct Token {
    uint token;
    string ipfsHash;
}
mapping (address => Token[]) public emoji;

function addEmoji (uint _token, string _ipfsHash) public {
   emojiCount ++;
   emoji[msg.sender].push(Token(_token, _ipfsHash));
 }
}"
47528-0.sol,question,"contract Payout
{
    function payout() public {
        msg.sender.transfer(2);
    }
}"
84419-0.sol,question,"contract Menu{
    uint256 public BookingId;
    address public Guest;
    uint256 Qty;
    
    struct Menuitem{
        uint256  id;
        string name;
        uint256 Price;
    }
    struct table{
        uint256 tableid;
        uint256 numberofseats;
    }
      mapping (uint256 => Menuitem) public Order;
      mapping (uint256  =>mapping(uint256 => Menuitem)) public tableno;
      Menuitem[] itemarray;
      table[5] tablearray;
     
      
      function welcome() public {
          log0(""welcome"");   
      }
      
      function additem(uint256 _id, string memory _name, uint256 _price) public{
          
        Menuitem memory newitem = Menuitem(_id, _name, _price);
        Order[_id] = newitem;
        itemarray.push(newitem);
        Qty++;
      }
      function itemcount() public view returns(uint256){
          return Qty;
      }
      function deleteitem(uint256 _id) public{
          delete Order[_id];
          Qty--;
      }
     
      
      function getItem(uint256 _id) view public returns (string memory _name, uint256 _price) {   
         return(Order[_id].name, Order[_id].Price);
    }
}"
79353-0.sol,question,"contract ItemBill{

    enum ProductState {Shipped, Store, Owned, Sale}
    address owner;
    bytes32 public name;
    uint public productCount = 0;

    struct Product 
    {
            uint id;
            bytes32 name;
            bytes32 serlialNo;
            uint price;
            address UpdatedBy;
            bytes10 pro_state; 
    }

    mapping(address => Product[]) OwnerOfProducts;

    
    

    event ProductCreated
    (
        uint id,
        bytes32 name,
        bytes32 serlialNo,
        uint price,
        address owner,
        bytes10 pro_state 
    );

    constructor() public {
            owner = msg.sender;
    }

    function createProduct(address _OwnerAddress, bytes32 _name, bytes32 _serialNo, uint _price, bytes10 _pro_state) public {
        
        require(_name.length > 0);
        
        require(_price >= 0);
        
        require(_serialNo.length > 0);
        
        Product memory p;
        
        p.id = productCount++;
        p.name = _name;
        p.serlialNo = _serialNo;
        p.price = _price;
        p.UpdatedBy = msg.sender;
        p.pro_state = _pro_state;

        OwnerOfProducts[_OwnerAddress].push(p);

        
        emit ProductCreated(productCount, _name, _serialNo, _price, msg.sender, _pro_state );
    }

    function getProduct(address _address) view public returns(uint, bytes32, bytes32, uint, address, bytes10) {

        returns(OwnerOfProducts[_address].id, OwnerOfProducts[_address].name, OwnerOfProducts[_address].serlialNo, OwnerOfProducts[_address].price, OwnerOfProducts[_address].owner, OwnerOfProducts[_address].pro_state); 

**

    }

    function getproductcount() view public returns(uint){
        returns OwnerOfProducts.length;
    }
}"
57747-0.sol,question,"contract Lottery{
address public manager;
address[] public players;

constructor() public payable{
 manager = msg.sender;   
}

function enter() public payable {
    require(msg.value > 0.01 ether);

    players.push(msg.sender);
}

function random() private view returns(uint){
  return uint(keccak256(block.difficulty, now, players));
}

function pickWinner() public {
    uint index = random() % players.length;
    players[index].transfer(this.balance);
}
}"
74210-0.sol,question,"contract simpleexample{

bytes32 public inputHash;
bytes32[] inputHashArray;

function addNewHash(bytes32 input) public {
  inputHash = input;
  inputHashArray.push(inputHash)-1;
  return;
}

function getHash() view public returns (bytes32[] memory){
  return inputHashArray;
}

function getLength() view public returns (uint) {
  return inputHashArray.length;
}

function blockTime() view public returns (uint blkTime) {
  return block.number;
}
}"
11283-0.sol,question,"contract Caller
{
    event SendingTransaction(address indexed _requestor, uint8 indexed action);     

    address public minter;
    bytes public email;      

    modifier onlyOwner {
    if (msg.sender != minter)
        throw;
       _;
    }

    function() {
        throw;
    }

    function Caller(bytes _email) {

        
        minter= msg.sender;
        email= _email;
    }

    function proxyRequest(address _target, string _payload) onlyOwner public {

        SendingTransaction(_target, 1);
        

        if (!_target.call(""registrationRequest"",_target, _payload))
        {
            SendingTransaction(_target, 2);
            
        }
        else
        {
            SendingTransaction(_target, 3);
            
        }


    }

}"
53261-0.sol,question,"contract HouseholdFactory{
    address[] public deployedHouseholds;
    mapping (address => uint) public balances;
    address public owner;

    constructor() public{
        owner = address(this);
    }

    function createHousehold(uint capacity ) public{
        address newHousehold = new Household(capacity, msg.sender, owner);
        deployedHouseholds.push(newHousehold);
    }

    function getDeployedHouseholds() public view returns (address[]) {
        return deployedHouseholds;
    }
}"
53261-0.sol,question,"contract Household{

uint public demand;
uint public supply;
uint public batteryCapacity;
uint public amountOfCharge;
uint public excessEnergy;



struct Bid{
    address origin;
    uint price;
    uint amount;
    uint date;
}

Bid[] public Bids;
Bid[] public Asks;
address public owner;
address public contractAddress;
address public parent;
address public exchangeAddress;
uint public balanceContract;
Exchange ex;


constructor(uint capacity, address creator, address watch_address) public {
    owner = creator;
    batteryCapacity = capacity;
    parent = watch_address;
    contractAddress = address(this);
}

function deposit() public payable {
}

function () public payable {}

function getBids(uint index) public view returns(address, uint, uint, uint){
    return (Bids[index].origin,
            Bids[index].price,
            Bids[index].amount,
            Bids[index].date
    );
}

function getAsks(uint index) public view returns(address, uint, uint, uint){
    return (Asks[index].origin,
            Asks[index].price,
            Asks[index].amount,
            Asks[index].date
    );
}

function setExchange(address exchange) public {
    exchangeAddress = exchange;
}

function charge(uint amount) public {
    require(msg.sender == owner);
    amountOfCharge += amount;
}

function discharge(uint amount) public {
    require(msg.sender == owner);
    amountOfCharge -= amount;
}

function submitBid(uint price, uint amount) public {
    Bid memory newBid = Bid({
        origin: contractAddress,
        price: price,
        amount: amount,
        date: now
    });

    Bids.push(newBid);
    ex = Exchange(exchangeAddress);
    ex.submitBid(price, amount);
}

function submitAsk(uint price, uint amount) public {
    Bid memory newAsk = Bid({
        origin: contractAddress,
        price: price,
        amount: amount,
        date: now
    });

    Asks.push(newAsk);
    ex = Exchange(exchangeAddress);
    ex.submitAsk(price, amount);
}

function buyEnergy(uint amount, address recipient, uint price ) external payable returns(bool successful){
    require(address(this).balance < price);

    amountOfCharge += amount;

    recipient.transfer(price*amount/1000); 
    return true;
}

function sellEnergy(uint amount, address recipient, uint price ) public {

    if(amountOfCharge>amount){
        amountOfCharge -= amount;
    }

    recipient.transfer(price*amount/1000);
}

}"
15168-0.sol,question,"contract Bank{       
    address client;
    uint gainedWei;
    function pay() payable {
       client    = msg.sender;
       gainedWei = msg.value;
    }
    function payMeBack() {
     if(<some condition check>)
        
    }
}"
46908-0.sol,question,"contract Test{
    int256[] public test;

    function setTest(int256 b) public{
        test.push(b);
    }

    function setTest2(uint256 a, int256 b) public {
        test[a] = b;
    }
}"
26535-0.sol,question,"contract TestConst{
    uint public a = 10;

    function constantFnA() constant returns (uint) {
        return  a+5;
    }

    
    
    function const_NonConst_A(){
        a = constantFnA();
    }

    
    
    function nonConst_A(){
        a = a+5;
    }
}"
67072-0.sol,question,"contract test
{

uint[] values = [1,2,3,4,5,6];

function removeValueFromArray(uint _num) public returns(uint[]) {

    uint[] storage auxArray;

    for (uint i = 0; i < values.length; i++){
        if(values[i] != _num)
            auxArray.push(values[i]);
    }

    return auxArray;
}
}"
82760-0.sol,question,"contract simple{

  address payable[] private addressIndex;
  uint price = 100;

  
  function distribute() private returns (uint) {

    uint amount = (address(this).balance-1) / addressIndex.length;
    for (uint i = 0; i < addressIndex.length; i++) {
      addressIndex[i].transfer(amount); 
    }
    return amount;
  }

  function () external payable {

    if ( msg.value != price ) { revert(); }
    addressIndex.push(msg.sender);
    distribute();
  }

}"
34215-0.sol,question,"contract sample{

    string name;
    uint age;

    function setName(string newName) {
        name=newName;
    }

    function getName()returns (string) {
        return name;
    }
}"
13469-5.sol,question,"contract Test
        {
            event TestEvent(uint a);
            function Test() {}
        `;
    for (let i=0;i<functions_count;i++)
    {
        code+=""\nfunction f""+i+`(uint i)
        {
            TestEvent(i);
        }`;
    }
    code+=""\n}"
17318-0.sol,question,"contract Music is owned{

    string public themeMusic;
    string public idMusic;
    int public money;

    function Music (string setThemeMusic, string setIdMusic, int setmoney) {
        themeMusic = setThemeMusic;
        idMusic = setIdMusic;
        money = setmoney;
    }

    function setMoney(int moneyUpdate) onlyOwner {
        money = moneyUpdate;
    }
}"
61072-0.sol,question,"contract CardToDefense is InterfaceCardToDefense{
mapping(int => mapping (int => int)) public AttackPosition2Defense;
mapping(int => string) public CardType2String;
mapping(int => string) public AttackType2String;
mapping(int => string) public Position2String;

function setAttackPositionToDefense(int attack, int position, int defense) public {
    AttackPosition2Defense[attack][position] = defense;
}
function setCardType2String(int _id, string name) public {
    CardType2String[_id] = name;
}
function setAttackType2String(int _id, string name) public {
    AttackType2String[_id]= name;
}
function setPosition2String(int _id, string name) public {
    Position2String[_id]= name;
}
}"
44616-0.sol,question,"contract Callee{

    uint public anyNumber;

    function theOnlyFunctionCallerNeeds (uint someData) external {
        anyNumber = someData;
    }

    function justSomeRandomFunction(uint someOtherData) public view returns (uint){
        return anyNumber + someOtherData + 42;
    }
}"
9227-0.sol,question,"contract RecordStore{
  struct Record {
    string value;
    address owner;
  }

  mapping(string => Record) records;
  Record lastRecord;

  function addRecord(string _recordId, string _value, address _owner) returns (bool) {
    Record r = records[_recordId];
    r.value = _value;
    r.owner = _owner;
    lastRecord = r;
    return true;
  }

  function getLastRecordOwner() returns (addr) {
    return lastRecord.owner;
  }

}"
77642-0.sol,question,"contract A{
    function b() public returns(uint) {return 4;}    
    uint public c = b();
}"
57728-0.sol,question,"contract GoldenEgg{
uint[] public spinHistory;


function spin() constant returns (uint) {
    uint spin = uint8(uint256(keccak256(block.timestamp, block.difficulty))%37);
    addToHistory(spin);
    return spin;
}

function getHistory() constant returns (uint[]) {
    return spinHistory;
}

function addToHistory( uint spin ) constant returns (uint[]) {
   spinHistory.push(spin); 
   return spinHistory;
}}"
54503-0.sol,question,"contract ERC20Basic{

function balanceOf(address _owner) external constant returns (uint256 balance);
function transfer(address to, uint256 value) public returns (bool);


}"
54503-0.sol,question,"contract TokenTransferContract{

using SafeMath for uint256;

address _owner;
address _tokenAddress;
ERC20Basic erc20Instance;

constructor () public {

    _owner = msg.sender; 

}



function setTokenInstance(address _tokenContractAddress) public {

    _tokenAddress = _tokenContractAddress;
    erc20Instance = ERC20Basic(_tokenContractAddress);

}



function transferContractTokenToOwner(uint256 _tokenAmount) public {
    require(_owner == msg.sender);

    erc20Instance.transfer(_owner, _tokenAmount); 

}

function getAmountOfTokenOfOwner() view public returns (uint256 _amount){
    require(_owner == msg.sender);

    _amount = (erc20Instance.balanceOf(_owner)).div(1000000000000000000);

}

function getAmountOfTokenOfContract() view public returns (uint256 _amount){

    require(_owner == msg.sender);

    _amount = (erc20Instance.balanceOf(address(this))).div(1000000000000000000);

}

 function noneDecimalGetAmountOfTokenOfOwner() view public returns (uint256 _amount){
    require(_owner == msg.sender);

    _amount = erc20Instance.balanceOf(_owner);

}

function noneDecimalgetAmountOfTokenOfWalletContract() view public returns (uint256 _amount){
    require(_owner == msg.sender);

    _amount = erc20Instance.balanceOf(address(this));

}


function getOwnerAddress() view public returns (address _ownerAddress){
    _ownerAddress = _owner;

}

function getContractAddress() view public returns (address _contractAddress){
    _contractAddress = address(this);

}

function getContractInstanceAddress() view public returns (address _contractInstanceAddress){ 
    _contractInstanceAddress = _tokenAddress;

}

}"
74683-0.sol,question,"contract TestToken{
    
    mapping (address => uint256) public balanceOf;

    string public name = ""TestToken1"";
    string public symbol = ""TTO"";
    uint8 public decimals = 18;

    uint256 public totalSupply = 1000000 * (uint256(10) ** decimals);

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() public {

        balanceOf[msg.sender] = totalSupply;

    }


    function isContract(address _addr) private view returns (bool is_contract) {
        uint length;
        assembly {
            
            length := extcodesize(_addr)
        }
        return length > 0;
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        bytes memory empty;
        return transfer(to, value, empty);
    }

    function transfer(address to, uint256 value, bytes memory data) public returns (bool) {
        require(balanceOf[msg.sender] >= value);

        balanceOf[msg.sender] -= value;
        balanceOf[to] += value;
        emit Transfer(msg.sender, to, value);

       
       
       
        return true;
    }

    event Approval(address indexed owner, address indexed spender, uint256 value);

    mapping(address => mapping(address => uint256)) public allowance;

    function approve(address spender, uint256 value)
        public
        returns (bool success)
    {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value)
        public
        returns (bool success)
    {
        require(value <= balanceOf[from]);
        require(value <= allowance[from][msg.sender]);

        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}"
61337-0.sol,question,"contract Post{

struct tags{
bytes32[] tagged; 
}

mapping(address => tags) adminTags;

function appendTags(address addrs, bytes32 tag) public { 
 adminTags[addrs].tagged.push(tag); 
} 

function getTagsofAdmin(address addrs) public view returns(bytes32[]){ 
return adminTags[addrs].tagged; 
}

}"
42322-0.sol,question,"contract Test{
uint fee;

function Test(uint _feeNumerator, uint _feeDenominator){
    fee = _feeNumerator/_feeDenominator;
}

function updateFee(uint _numerator, uint _denominator){
    fee = _numerator / _denominator;
}

function testPayable(string _doesNothing) payable {
    require(msg.value == fee * (10**18));

}

function getFee() returns (uint fee){
    return fee;
}"
41391-0.sol,question,"contract SimpleTokenCoin{

string public constant name = ""Simple Coin Token"";

string public constant symbol = ""SCT"";

uint32 public constant decimals = 18;

uint public totalSupply = 0;

mapping (address => uint) balances;

function balanceOf(address _owner) public constant returns (uint balance){ return balances[_owner]; }

function transfer(address _to, uint _value) public returns (bool success){ if(balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]){ balances[msg.sender] -=_value; balances[_to] += value; Transfer(msg.sender, _to, _value); return true; } return false; }

function transferFrom(address _from, address _to, uint _value) public returns (bool success){ if(balances[_from] >= _value && balances[_to] + _value >= balances[_to]){
balances[_from] -=_value; balances[_to] += value; Transfer(_from, _to, _value); return true; } return false; } }"
62989-0.sol,question,"contract financialContracts4{

     address issuer; constructor() public{    issuer = msg.sender; }
     modifier ifIssuer(){    if(issuer != msg.sender){
           revert();    }else {
             _;
function receiveFunds( )public payable{
         } 
function getValue() public view returns(uint) {   address myAddress = this; return myAddress.balance; } 
function withdrawFunds(uint funds) ifIssuer{   issuer.transfer(funds); } }
"
3661-0.sol,question,"contract MultiplyContract{
    address public sender;
    address public receiver;
    uint public price;
    function MultiplyContract(
      address _sender,
      address _receiver,
      uint _price
      ){
      sender = _sender;
      receiver = _receiver;
      price = _price;
    }
    function Execution(){
      
    }
    function () {
      throw;
    }
}"
70386-1.sol,question,"contract Example{

uint public i = 0;


function store() {

 i = 100;

}

function check() public returns(uint){

 returns i;

}
"
83039-2.sol,question,"contract TestContract{

  function multilpy(uint a,uint b) public pure returns (uint) {
      return a * b;
  }
}"
59169-0.sol,question,"contract ethTransfer 
{
    address public creator;
    mapping (address => uint) public balances;

    event Sent(address from, address to, uint amount);

    constructor() public {
        creator = msg.sender;
    }

    function update(uint newBalance) public {
        balances[msg.sender] = newBalance;
    }

    function send(address receiver, uint amount) public {
        if (balances[msg.sender] < amount) return;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        emit Sent(msg.sender, receiver, amount);
    }
}"
65451-0.sol,question,"contract SendableERC20{

 struct Transfer {
    address contract_;
    address to_;
    uint amount_;
    bool failed_;
 }
 mapping(address => uint[]) public transactionIndexesToSender;

 Transfer[] public transactions;
 address public owner;
 address invalidTo_; 
 mapping(string => address) tokens;
 IERC20 public IERC20Interface;
 event TransferSuccessful(address indexed from_, address indexed to_, uint256 amount_);

 event TransferFailed(address indexed from_, address indexed to_, uint256 amount_);

 constructor() public {
    owner = msg.sender;
 }
 function addNewToken(string symbol_, address address_) public onlyOwner returns(bool){
    tokens[symbol_] = address_;

    return true;
 }

 function removeToken(string symbol_) public onlyOwner returns(bool){
    require(tokens[symbol_] != 0x0);

    delete(tokens[symbol_]);

    return true;
 }
 function returnSymbol(string symbol_)public view returns(address){
    return(tokens[symbol_]);
 }
 function transferTokens(string symbol_, address to_, uint256 amount_) public {
    require(tokens[symbol_]!= 0x0);
    require(amount_ > 0);

    address contract_ = tokens[symbol_];
    address from_ = msg.sender;

    IERC20Interface = IERC20(contract_);

    uint256 transactionId = transactions.push(
        Transfer({
            contract_: contract_,
            to_: to_,
            amount_: amount_,
            failed_: true
        }));

    transactionIndexesToSender[from_].push(transactionId -1);

    if(amount_ > IERC20Interface.allowance(from_, address(this))){
        emit TransferFailed(from_, to_, amount_);
        revert();
    }

    IERC20Interface.transferFrom(from_, to_, amount_);

    transactions[transactionId -1].failed_ = false;

    emit TransferSuccessful(from_, to_, amount_);
 }
 modifier onlyOwner(){
    require(msg.sender == owner);
    _;
 }



}"
57601-1.sol,question,"contract Called{
    uint public myuint;

    function myuint() public view returns(uint _myuint) {
        _myuint = myuint;
    }

    function set(uint _var) public {
        myuint = _var;
    }

    function get() public view returns (uint){
        return myuint;
    }
}"
77418-1.sol,question,"contract vote
{
    uint public c0=0;
    uint public c1=0;
    uint public c2=0;
    uint public c3=0;
    uint public c4=0;
    uint public c5=0;
    function set(uint x) public {
        if(x==0)
        {
            c0+=1;
        }
        else if(x==1)
        {
            c1+=1;
        }
        else if(x==2)
        {
            c2+=1;
        }
        else if(x==3)
        {
            c3+=1;
        }
        else if(x==4)
        {
            c4+=1;
        }
        else if(x==5)
        {
            c5+=1;
        }
        else
        {

        }
    }
    function get() public view returns(uint,uint,uint,uint,uint,uint)
    {
        return (c0,c1,c2,c3,c4,c5);
    }
}"
62821-0.sol,question,"contract financialContracts3{

address issuer;
constructor() public{
   issuer = msg.sender;
}
modifier ifIssuer(){
   if(issuer != msg.sender){
      revert();
   }else {
        _;
   }
}
function receiveFunds( )public payable{

}
function getValue() public constant {
   return issuer.balance;
}
}"
59086-1.sol,question,"contract B{
    uint public n;

    function test2() public { n = n + 1; }
}"
59086-1.sol,question,"contract A is B{
    uint public n;
}"
37565-0.sol,question,"contract Betting is usingOraclize{
            address public player_;
            uint256 public betamount_;
            uint public winningamount_;
            uint private balance_;
            uint public betnumber_;
            uint public winningnumber_;
            uint public result_;
            string private question_;

        event LogNewOraclizeQuery(string description);
        event WinningNumber(uint winningnumber_);
        event BetResult(string result_);
        event Log( string mystring_);

        mapping (address => uint256) public balances;

        
        

        
        function checkBalance (address player_, uint betamount_) private returns (bool isSuccess) {

        
            Log (""Checking players balance"");
            require(player_.balance >= betamount_);

        
            Log (""Checking host's balance"");
            require (msg.sender.balance >= 10*(betamount_));    

            Log (""Validation pass"");
            return true;

        }

        function executeBetting (address player_, uint betamount_, uint betnumber_ ) public payable
             returns(uint answer_, string result_) {

        
            checkBalance(player_, betamount_);
            require (true); 

        
             question_ = ""random number between 2 and 12"";
             askOraclize (question_);


        

                if (betnumber_ ==  winningnumber_){
                    winningamount_ = 10e18;
                    player_.transfer(winningamount_);
                    result_ = 'You are lucky and have Won 1 Ether';
                }else
                if (betnumber_ !=  winningnumber_){ 
                    balances[player_] -= betamount_;
                    balances[msg.sender] += betamount_;
                    result_ = 'You lost';
                   }
                WinningNumber(winningnumber_);
                BetResult(result_);
                answer_ = winningnumber_;
        }


        
          
            function askOraclize(string question_) public payable{
             if (oraclize_getPrice(""WolframAlpha"") > this.balance) {
                 LogNewOraclizeQuery(""Oraclize query was NOT sent, please add some ETH to cover for the query fee"");
                }else{
                 LogNewOraclizeQuery(""Oraclize query was sent, standing by for the answer.."");    
                 oraclize_query(""WolframAlpha"", question_);
                }
            }    



            
              function __callback(
                bytes32 _myid,
                string _result,
                bytes _proof
              ) public
                  {
                    require(msg.sender == oraclize_cbAddress());
                    winningnumber_ = parseInt(_result); 
            }

        }"
44525-7.sol,question,"contract Shitlist{

    
    mapping(string => uint) countevents;

    
    mapping(string => mapping(uint => string)) database;

    struct Victim {
        address person;
        uint stake;
        uint time;
    }

    
    mapping(address => mapping(string =>Victim)) victimDatabase;

    uint RefundTime;
    uint MinimumStake;

    function Shitlist(uint _refundtime, uint _minimumStake) public {
        RefundTime = _refundtime;
        MinimumStake = _minimumStake;

    }

    function makeClaim(string _name, string _ipfs) payable public {
        
        countevents[_name] += 1;
        database[_name][countevents[_name]] = _ipfs;
        victimDatabase[msg.sender][_name].person = msg.sender;
        victimDatabase[msg.sender][_name].stake = msg.value;
        victimDatabase[msg.sender][_name].time = block.timestamp;
    }

    function checkClaimExists(string _name) view public returns(uint){
        
        if(countevents[_name] == 0)
            return(0);
        else
            return(countevents[_name]);
    }

    function getClaimDetails(string _name, uint _number) view public returns(string){
        require(_number >= 1);
        require( keccak256(database[_name][_number]) != keccak256(""""));
        return(database[_name][_number]);
    }

    function refundStake(string _name)  public {
        require(victimDatabase[msg.sender][_name].stake > 0);
        require(victimDatabase[msg.sender][_name].time <= block.timestamp + RefundTime);
        msg.sender.transfer(victimDatabase[msg.sender][_name].stake);

    }

}"
44306-2.sol,question,"contract changer{


   habibconcert firstObject =    habibconcert(0xdc544654fefd1a458eb24064a6c958b14e579154);

  function changeTickets(uint new_tickets) returns(uint) {


      firstObject.tickets = new_tickets;

      uint updateTickets =  firstObject.tickets  = firstObject.tickets + new_tickets;
      return ( updateTickets);

        }


}"
44306-2.sol,question,"contract habibconcert{

  uint  public tickets = 6;

  address owner_of_tickets;

  uint constant price = 1 ether;

   mapping(address=>uint) public purchasers;

  function habibconcert()payable{

        owner_of_tickets =  msg.sender;
  }


function  displayTickets_numbers()constant returns(uint){

    return tickets;


}

    modifier ownLycreature(){


        require(msg.sender ==  owner_of_tickets) ;

        
        _;

        }



               function changeTickets_number (uint newtickets) ownLycreature{

                     tickets +=newtickets;

               }




function buytickets(uint amount)payable{

      if(msg.value!=(amount*price) || amount>tickets){

          throw;
      }

      purchasers[msg.sender] +=amount;

      tickets -=amount;


    

    

    


}        


}"
3964-2.sol,question,"contract Gizmo
{
    int public value;
    function Gizmo(int v) {
        value = v;
    }
}"
3964-2.sol,question,"contract Factory
{
    address gizmoAddr;
    function Create(int _value) returns (address) {
        gizmoAddr = new Gizmo(_value);
        return gizmoAddr;
    }
}"
44924-0.sol,question,"contract TicTacToe{


struct Cell {
    uint row;
    uint column;
    address played;
}


struct GameBoard {
    bool gameWon;
    address _player1;
    address _player2;
    Cell[] board;
}

uint private numberOfGames = 0; 
GameBoard[] public _games; 


function getGameNum() public returns(uint){
    return numberOfGames;
}


function newGame() public {
    
    GameBoard tempBoard;
    
    tempBoard._player1 = msg.sender;
    tempBoard._player2 = msg.sender;
    tempBoard.gameWon = false;

    uint counter = 0;
    
    for (uint row = 1; row <= 3; row++) {
        
        for (uint column = 1; column <= 3; column++) {
            tempBoard.board.length++;
            tempBoard.board[counter].row = row;
            tempBoard.board[counter].column = column;
            tempBoard.board[counter].played = 0x0;
            counter++;
        }
    }
}
}"
48755-2.sol,question,"contract sample{
address owner=0x1234;    
uint32 firstTimeUserPoints=10;
struct struUser{
    bytes32 orginalName;
    bytes32 originalKshoplink;
    bytes32 orginalDocumentConvention;
    bool validated;
    uint32 Points;
    uint32 totalPoints;
}
struct struUserTotalPoints{
    bytes32 orginalName;
    uint32 totalPoints;
}

mapping(bytes32=>struUser)bytesMappingToken;
struUser[] struUsers;
struUserTotalPoints[] struArrayUserTotalPoints;
string[] docConventionMappers;
string[] orginalName;
event printAddUserSuccess(string message);
event viewUser(string username, uint32 totalpoints);

modifier isOwner() {
    
    require (msg.sender == owner) ;
    _;
}



function AddUser(string namestring,string linkstring,string docConventionstring) public{

    


    bytes32 name=keccak256(abi.encodePacked(namestring));
    bytes32 link=keccak256(abi.encodePacked(linkstring));
    bytes32 docConvention=keccak256(abi.encodePacked(docConventionstring));
    uint32 existingTotalPoints=userTotalPoints(name);
     var user=bytesMappingToken[name];
    user.orginalName=name;
    user.originalKshoplink=link;
    user.validated=false;
    user.Points=firstTimeUserPoints;
    user.totalPoints=existingTotalPoints+firstTimeUserPoints;
    updateUserTotalPoints(name,user.totalPoints);
    user.orginalDocumentConvention=docConvention;
    struUsers.push(user);
    

    
    
    

    

    
    emit printAddUserSuccess(""user added successfully!"");

}


 function userTotalPoints(bytes32 name) public returns(uint32){  

     bool isUserTotalPointsCalculated=false;

        for(uint j=0;j<struArrayUserTotalPoints.length;j++){
            
            if(comparebytes(struArrayUserTotalPoints[j].orginalName,name)){
                isUserTotalPointsCalculated=true;
                return struArrayUserTotalPoints[j].totalPoints;
            }
        }
        if(!isUserTotalPointsCalculated){
            struArrayUserTotalPoints.push(struUserTotalPoints({orginalName:name,totalPoints:firstTimeUserPoints}));
            return 0;                
        }  
}

function userexists(string namestring) view public returns(uint32){
    bytes32 name=keccak256(abi.encodePacked(namestring));
     for(uint j=0;j<struArrayUserTotalPoints.length;j++){
            if(comparebytes(struArrayUserTotalPoints[j].orginalName,name)){
               return bytesMappingToken[name].Points;
            }
        }
        return 5;
}

   function comparebytes (bytes32 a, bytes32 b) pure public returns (bool){
   
   return keccak256(abi.encodePacked(a))==keccak256(abi.encodePacked(b));
   }


function viewuser(string name)public returns(string,uint32,uint32){ 
    bytes32 bytesname=keccak256(abi.encodePacked(name));
    uint32 totalpoints=userTotalPoints(bytesname);
    return (name,bytesMappingToken[bytesname].Points,totalpoints);
}

function updateUserTotalPoints(bytes32 name,uint32 totalPoints) public{
    for(uint j=0;j<struArrayUserTotalPoints.length;j++){
            if(comparebytes(struArrayUserTotalPoints[j].orginalName,name)){
                struArrayUserTotalPoints[j].totalPoints=totalPoints;
            }
        }
}


function () public payable {

}
}"
1004-0.sol,question,"contract smallMarket{

    struct transaction {
      uint timeStamp;
      uint qtyT;
      uint price;
      address client;
      bytes32 typee;
    }
    struct sellOrder {
      uint timeStamp;
      uint qty;
      uint price;
      address seller;
    }

    mapping(uint => transaction) public transactions;
    mapping(uint => sellOrder) public sellorders;

    uint public lastTransactionId;
    uint public lastBOrderId;
    uint public lastSOrderId;
    address public owner;

    function smallMarket(){
      owner = msg.sender;
      lastSOrderId = 0;
    }
    function newTransaction(uint amount,uint price,bytes32 typee){
      uint transac = lastTransactionId + 1;
      transaction t = transactions[transac];
      t.timeStamp = block.timestamp;
      t.qtyT = amount;
      t.price = price;
      t.client = msg.sender;
      t.typee = typee;
      lastTransactionId = transac; 
    }

    function newSellOrder(uint amount,uint price,uint currency) {
        uint order = lastSOrderId + 1; 
        sellOrder s = sellorders[order];
        s.timeStamp = block.timestamp;
        s.qty = amount;
        s.price = price;
        s.seller = msg.sender;
        lastSOrderId = order;
    }
    function buy(uint amount, uint price) {
      uint idCounter = lastSOrderId;
      uint _amountLeftToBuy = amount;
      while (_amountLeftToBuy > 0){
          if (price >= sellorders[idCounter].price && sellorders[idCounter].qty >= amount) {
            newTransaction(amount,price,'cas 1');
            _amountLeftToBuy = 0;

          }
          else if (price >= sellorders[idCounter].price && amount > sellorders[idCounter].qty ){
              newTransaction(amount,price,'cas 2');
              _amountLeftToBuy =  amount - sellorders[idCounter].qty;
              idCounter = idCounter - 1;
          }
          else if (sellorders[idCounter].price > price){
              newTransaction(amount,price,'cas 3');
              _amountLeftToBuy = 0;
          }
          else{}
      }    
    }
  }"
79272-0.sol,question,"contract EnergyToken is IERC20{
using SafeMath for uint;
mapping(address => uint256) balances;
mapping(address => mapping(address => uint256)) allowed;
uint256 totalSupply_;
address minter;

constructor(uint256 total) public{


totalSupply_ = total;
balances[msg.sender] = totalSupply_;
minter = msg.sender;

}

  modifier onlyMinter() {
    require(msg.sender == minter);
    _;
  }
function totalSupply() public view returns(uint256){
    return totalSupply_;
}
function balanceOf(address tokenOwner)  public view returns(uint256){
    return balances[tokenOwner];
}

function transfer(address receiver, uint numTokens) public returns (bool) {

  require(numTokens <= balances[msg.sender]);
  balances[msg.sender] = balances[msg.sender].sub(numTokens);
  balances[receiver] = balances[receiver].add(numTokens);
  emit Transfer(msg.sender, receiver, numTokens);
  return true;

}

function approve(address delegate, uint numTokens) public returns (bool){

    allowed[msg.sender][delegate] = numTokens;
    emit Approval(msg.sender, delegate, numTokens);
    return true;

}

function allowance(address owner, address delegate) public view returns (uint){

    return allowed[owner][delegate];

}

function increaseAllowance(address delegate, uint numTokens) public returns (bool){

    allowed[msg.sender][delegate] = allowed[msg.sender][delegate].add(numTokens);
    return true;
}

function decreaseAllowance(address delegate, uint numTokens) public returns (bool){

    allowed[msg.sender][delegate] = allowed[msg.sender][delegate].sub(numTokens);
    return true;

}

function transferFrom(address owner, address buyer, uint numTokens) public returns (bool)
 {

    require(balances[owner]>= numTokens);
    require(allowed[owner][msg.sender] >= numTokens);
    allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);
  balances[owner] = balances[owner].sub(numTokens);
  balances[buyer] = balances[buyer].add(numTokens);
  emit Transfer(owner, buyer, numTokens);
  return true;

  }


function _mint(address account, uint256 amount) public  {

        require(account != address(0), ""ERC20: mint to the zero address"");
        require(msg.sender == minter, ""ERC20: unauthorised mint!"");
        totalSupply_ = totalSupply_.add(amount);
        balances[account] = balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint256 amount) public onlyMinter 
{

        require(account != address(0), ""ERC20: burn from the zero address"");

        balances[account] = balances[account].sub(amount, ""ERC20: burn amount exceeds balance"");
        totalSupply_ = totalSupply_.sub(amount);
        emit Transfer(account, address(0), amount);

    }
}"
38906-0.sol,question,"contract ERC20{

function totalSupply() constant returns (uint256 totalSupply) {}
function balanceOf(address _owner) constant returns (uint256 balance) {}
function transfer(address _recipient, uint256 _value) returns (bool success) {}
function transferFrom(address _from, address _recipient, uint256 _value) returns (bool success) {}
function approve(address _spender, uint256 _value) returns (bool success) {}
function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}

event Transfer(address indexed _from, address indexed _recipient, uint256 _value);
event Approval(address indexed _owner, address indexed _spender, uint256 _value);


}"
50670-0.sol,question,"contract Damble is usingOraclize{
using SafeMath for uint256;

mapping(address => uint) public users;
mapping(uint => bool) private allowedValues;
address[] public userAddresses;
uint[] public partAmounts;
address owner;

uint minEther;
uint public totalEth;
uint maxUsers;
uint maxValue = 5 ether;
uint public randomNumber;
function Damble() {
    owner = msg.sender;
    minEther = 0.5 ether;

    
    allowedValues[(1 ether / 100)] = true;
    allowedValues[(1 ether / 10)] = true;
    allowedValues[(1 ether / 4)] = true;
    allowedValues[(1 ether / 2)] = true;
    allowedValues[(1 ether)] = true;
    allowedValues[(5 ether)] = true;
}

event NewUser(address userAddress, uint amount);
event WinnerPicked(address winner);
event NewRandomNumber_bytes(bytes);
event NewRandomNumber_uint(uint);
event ProofFailed();


function placeBet() public payable{
    require(msg.value <= maxValue && msg.value > 0);
    require(allowedValues[msg.value]);

    if (users[msg.sender] > 0) {
        userPullout(); 
    }

    
    userAddresses.push(msg.sender);
    partAmounts.push(msg.value);
    totalEth = SafeMath.add(msg.value, totalEth);
    users[msg.sender] = msg.value;
    NewUser(msg.sender, msg.value);
}


function getPartAmounts() view public returns(uint[]){
    return partAmounts;
}

function getUserBalance(address user) view public returns(address, uint){
    return(user, users[user]);
}

function accountAmount() view public returns(uint) {
    uint arrLen = 0;
    for (uint i = 0; i < userAddresses.length; i++) {
        if (users[userAddresses[i]] > 0){
            arrLen++;
        }
    }
    return arrLen;
}

function minEthIsMet() view public returns(bool){
    return (totalEth >= minEther);
}

function userPullout() private {
    require(users[msg.sender] > 0);
    for (uint i = 0; i < userAddresses.length; i++) {
        if (userAddresses[i] == msg.sender){
            delete userAddresses[i];
            delete partAmounts[i];
        }
    }

    totalEth = SafeMath.sub(totalEth, users[msg.sender]);
    msg.sender.transfer(users[msg.sender]);
    users[msg.sender] = 0;
}


function pickWinner(uint randomNumber) view private returns(address){
    uint lastMax = 1;

    for (uint i = 0; i < userAddresses.length; i++) {
        if (randomNumber >= lastMax && randomNumber <= (users[userAddresses[i]] + lastMax)){
            WinnerPicked(userAddresses[i]);
            return (userAddresses[i]);
        }
        lastMax =  SafeMath.add(users[userAddresses[i]], lastMax);
    }
}



function endRaffle() public{
    require(msg.sender == owner);
    require(accountAmount() > 1);
    require(totalEth >= minEther);

    address winner = pickWinner(randomNumber);
    if (winner == address(0)){
        onNoAddress();
    } else {
        uint winnings; 
        if (SafeMath.div((SafeMath.mul(totalEth, 98)), 100) > this.balance) {
            winnings = SafeMath.div((SafeMath.mul(totalEth, 98)), 100);
        } else {
            winnings = SafeMath.div((SafeMath.mul(this.balance, 98)), 100);
        }

        winner.transfer(winnings);
        owner.transfer(address(this).balance);
    }
    totalEth = 0;
    clearParticipants();
}

function getContractBalance() public view returns(uint){
    return address(this).balance;
}

function clearParticipants() private {
    for (uint i = 0; i < userAddresses.length; i++) {
        users[userAddresses[i]] = 0;
        delete userAddresses[i];
        delete partAmounts[i];
    }
}

function onNoAddress() private{
    for (uint i = 0; i < userAddresses.length; i++) {
        userAddresses[i].transfer(users[userAddresses[i]]);
        users[userAddresses[i]] = 0;
    }
}



function __callback(bytes32 _queryId, string _result, bytes _proof)
{ 
    if (msg.sender != oraclize_cbAddress()) throw;

    if (oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) != 0) {
        ProofFailed();
        
    } else {
        
        uint maxRange = totalEth -1; 
        randomNumber = (uint(sha3(_result)) % maxRange) + 1; 

        NewRandomNumber_uint(randomNumber); 
    }
}

function getRandomNumber() payable { 
    require(msg.sender == owner);
    require(accountAmount() > 1);
    require(totalEth >= minEther);

    oraclize_setProof(proofType_Ledger); 
    uint N = 4; 
    uint delay = 0; 
    uint callbackGas = 200000; 
    bytes32 queryId = oraclize_newRandomDSQuery(delay, N, callbackGas);
}

}"
40237-0.sol,question,"contract Recorder{
  event Record(
    address _from,
    string _message,
    uint _cash
  );

  function record(string message) public payable {
    Record(msg.sender,message,msg.value);
  }

  function () public payable {} 
}"
58668-0.sol,question,"contract PromotedDapp is Ownable{

    uint price;
    address tokenOwner;
    uint nextOwnerAllowed;

    constructor() public {
        owner = msg.sender;
    }

    function becomeOwner() public {
        require(now >= nextOwner);
        nextOwnerAllowed = now + 604800; 
        tokenOwner = msg.sender;
    }

}"
70406-0.sol,question,"contract Campaign{
    struct Transaction {
        address Creditor;
        uint Amount;
    }
    Transaction[] public Transactionss;
    mapping(address => Transaction) public TransactionsMap;

    function addTransaction(address _address,uint _amount) public {

        Transaction memory newRequest = Transaction({
           Creditor: _address,
           Amount: _amount });
        Transactionss.push(newRequest); 
        TransactionsMap[_address]=Transactionss[Transactionss.length-1];


    }
    function Testing()public {
        addTransaction(0xaef0B7Edd5D2E9315027ADFA4642E16a5c85Afd8,100);
        TransactionsMap[0xaef0B7Edd5D2E9315027ADFA4642E16a5c85Afd8].Amount++;
    }


    function a()public view  returns (uint){
        return TransactionsMap[0xaef0B7Edd5D2E9315027ADFA4642E16a5c85Afd8].Amount;
    }

    function b()public view  returns (uint){
        return Transactionss[0].Amount;
    }


}"
28440-0.sol,question,"contract HelloWorld{

    address public owner;
    address public helloAddress;

    function HelloWorld (address _helloAddress) public {
        owner = msg.sender;
        helloAddress = _helloAddress;
    }

}"
48758-0.sol,question,"contract ParentContract{

    ConfigContract _config;

    constructor(ConfigContract config) public{
        _config = ConfigContract(config);
    }

    function getNameFromOtherContract() public view returns(string) {
        return _config.getName();
    }
}"
72486-0.sol,question,"contract NewHello{ 

    address owner;
    address newOwner;

    constructor()public{
        owner = msg.sender;
    }

    modifier onlyOwner (){
        if(msg.sender != owner){
            require(msg.sender == newOwner);
            _;
        }
        else{
            require(msg.sender == owner);
            _;
        }

    }

    struct user{
        string name;
        string surname;
        uint age;
    }
     event infoChanged(
        string name,
        string surname,
        uint age
    );

    mapping(address => user) public users; 

    function setUser(string memory name,string memory surname,uint age) public payable{
        users[msg.sender] = user(name,surname,age);
        emit infoChanged(name,surname,age);
    }
    function setUserbyAdmin(address _address, string memory name,string memory surname,uint age) public payable onlyOwner{
        users[msg.sender] = user(name,surname,age);
        emit infoChanged(name,surname,age);
    }

    function getUser(address _address) public view returns(string memory name , string memory surname, uint age)  {

        return (users[_address].name,users[_address].surname,users[_address].age);        
    }
}"
13722-0.sol,question,"contract project{

    address public user;
    bytes32[10] name;
    address[10] customer;
    uint public i=0;
    function project(){
        user=msg.sender;
    }



    function add(bytes32 _name){
        name[i]=_name;
        customer[i]=msg.sender;
        i++;
    }

    function get_address() constant returns(address[10]){
        return customer;
    }

    function reward() {
        for(uint i=0;i<10;i++)
        {
            customer[i].send(1);
        }

    }

}"
67920-1.sol,question,"contract UserRegistration
{
    function getUserCount() public returns(uint);
    function getUser(uint) public returns(uint,string,string,uint,uint);
}"
67920-1.sol,question,"contract Exam
{
    address private addrUsr;
    uint public count;
    UserRegistration r;
    constructor(address _addrUsr)
    {
        addrUsr=_addrUsr;
        r = UserRegistration(addrUsr);
    }

    function updateCount() public {

        count=r.getUserCount();
    }

    function getUserData(uint _id) public
    {
        
    }       

}"
30284-0.sol,question,"contract SplitBalance{

    address a1;
    address a2;
    uint account1;
    uint account2;

    function SplitBalance(address _a1, address _a2) public{
        a1 = _a1;
        a2 = _a2;
    }

    function withdraw(address _addr) public {
        if (_addr == a1)   
        {
            account1 = 0;
            a1.transfer(account1);
        }
        else if (_addr == a2)   
        {
            account2 = 0;
            a2.transfer(account2);
        }
    }

    function updateAddress1(address newAddress) public {
        if(msg.sender != a1)
           revert();
        a1 = newAddress;
    }

    function updateAddress2(address newAddress) public {
        if(msg.sender != a2)
           revert();
        a2 = newAddress;
    }

    function() payable public { 
        uint amount = msg.value/2;
        account1 = account1 + amount;
        account2 = account2 + amount;
    }
}"
67537-0.sol,question,"contract testAdoption{
    Adoption adoption = Adoption(DeployedAddresses.Adoption());

    
    function testUserCanAdoptPet() public{
        uint returnedId = adoption.adopt(8);

        uint expected = 8;

        Assert.equal(returnedId, expected, ""Adoption of pet ID 8 should be recorded"");
    }

    
    function testGetAdopterAddressBypetId() public {
        
        address expected = this;

        address adopter = adoption.adopters(8);

        Assert.equal(adopter, expected, ""Owner of pet ID 8 should be recorded"");
    }

    
    function testGetAdopterAddressBypetIdInArray() public {
        
        address expected = this;

        
        address[16] memory adopters = adoption.getAdopters();

        Assert.equal(adopters[8], expected, ""Owner of pet ID 8 should be recorded"");
    }


}"
68875-0.sol,question,"contract Election{
  
  struct candidate
  {
    uint id;
    string name;
    uint votecount;
  }
  
  

  mapping(uint => candidate) public candidates;

  

  uint public candidatescount;

  function () Election public {
    addcandidate(""candidate1"");
    addcandidate(""candidate2"");
  }
  function addcandidate (string _name) private
  {
    candidatecount ++;
    candidates[candidatescount] = candidate(candidatescount, _name, 0);
  }
}"
53333-1.sol,question,"contract PenContract{

    struct Pen{
        uint productCode;
        address ownerAddress;
    }

    address public owner;
    Pen public _pen;

    
    address[] public __history;


    constructor (uint _productCode, address _ownerAddress) public{
        owner = msg.sender;
        _pen.productCode = _productCode;
        _pen.ownerAddress = _ownerAddress;

        
        __history.push(_ownerAddress);
    }


    function exchangePen(address _buyer) public returns (bool) {
        _pen.ownerAddress = _buyer;
        __history.push(_buyer);
        return true;            
    }

    function getHistoryForPen() public view returns (address[]) {
        return __history;
    }
}"
3076-0.sol,question,"contract Savings
{
    struct Deposit
    {
        string name;
        uint deposit;
    }

    uint        cEnd = now + 10 years;
    address[]   dAddresses;

    mapping(address => Deposit[]) deposits;

    function depositEther(string _name)
    {
        deposits[msg.sender].push(Deposit({
            name: _name,
            deposit: msg.value
        }));
        dAddresses.push(msg.sender);

        if(now >= cEnd){
            distribute(); 
        }
    }

    
    function distribute() internal {
    }   
}"
83629-0.sol,question,"contract test{
    uint[] public array = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];
    function removewithgap(uint index)  returns(uint[]) {
        if (index >= array.length) return;
        delete array[index];
        return array;
    }
    function removewithoutgap(uint index)  returns(uint[]) {
        if (index >= array.length) return;

        for (uint i = index; i<array.length-1; i++){
            array[i] = array[i+1];
        }
        delete array[array.length-1];
        array.length--;
        return array;
    }
}"
43887-1.sol,question,"contract B{
   uint res;
   function call_double(uint val) {
   A a=A(0x1);
   res = a.double(val);
   }
 }"
43887-1.sol,question,"contract A{
    function double(uint a)external returns (uint res);
    struct St{
    uint val;
   }
 }"
65737-0.sol,question,"contract Calculator{
   int private lastValue =0;
   function Add(int a, int b) public returns (int){
      lastValue = a+ b;
      return lastValue;
   }
   function Subtract(int a, int b) public returns (int) {
      lastValue = a-b;
      return lastValue;
    }
    function LastOperation()public constant returns (int) {
       return lastValue;
    }
 }"
59393-1.sol,question,"contract DriverProfile{
    address watch_adrs=0x0971b5d216af52c411c9016bbc63665b4e6f2542;

    struct Driver{
        string lisenceId;
        string firstName ;
        string lastName; 
        address account;
        string vehicle;
        string vehicleType;
        uint totalOffenceAmount;
        uint offenceCount;
        uint pendingPayments;
        mapping(uint=>Fine)  fines;
    }




    TrafficFine trafficfine;
    Driver public driver;

    constructor(string lisenceId,string firstName,string lastName,string vehicle,string vehicleType,address owner) public{
        trafficfine = TrafficFine(watch_adrs);
        trafficfine.addDriver();
        driver = Driver({
            lisenceId:lisenceId,
            lastName:lastName,
            firstName:firstName,
            account:owner,
            vehicle:vehicle,
            vehicleType:vehicleType,
            totalOffenceAmount:0,
            offenceCount:0,
            pendingPayments:0
        });

    }




     function doFine(uint offenceID,string location,address officer) public {
        address officersel=trafficfine.getOfficer(officer);
        require(officer==officersel);
        driver.offenceCount++;
     }

}"
59393-1.sol,question,"contract TrafficFine{
        function addOfficer(string firstName,string lastName,address officer) public;
        function getOfficer(address officer) public view returns (address);

    }"
83515-0.sol,question,"contract A{

    event Payment(address recipient, uint value);
    event Receive(address sender, uint value);

    address sender;
    address payable receiver;
    uint sentValue;
    uint receiptValue;
    uint gasPrice;

    function pay(address payable recipient) external payable{\\Transfers some ether to B
        recipient.transfer(msg.value);
        B(recipient).cash(msg.value, tx.gasprice);
        receiver=recipient;
        sentValue=msg.value;
        gasPrice=tx.gasprice;
        emit Payment(recipient, msg.value);
    }

    function payView() public view returns(address, string memory, string memory, string memory){\\Shows some data about the last transfer.
        return (receiver, uint2str(sentValue), uint2str(gasPrice), uint2str(address(this).balance));
    }

    function cash(uint cashValue, uint GasPrice) external payable{\\Records some data about the last received transaction
        sender=msg.sender;
        receiptValue=cashValue;
        gasPrice=GasPrice;
        emit Receive(msg.sender, cashValue);
    }

    function cashView() public view returns(address, string memory, string memory, string memory){\\Shows some data about the last received transaction
        return (sender, uint2str(receiptValue), uint2str(gasPrice), uint2str(address(this).balance));
    }

    function uint2str(uint _i) internal pure returns (string memory ) {
        if (_i == 0) {
                return ""0"";
         }
        uint j = _i;
        uint len;
        while (j != 0) {
                len++;
              j /= 10;
        }
        bytes memory bstr = new bytes(len);
        uint k = len - 1;
        while (_i != 0) {
             bstr[k--] = byte(uint8(48 + _i % 10));
             _i /= 10;
         }
        return string(bstr);
    }

    function() external payable{}

}"
70327-1.sol,question,"contract send_ether{
mapping(address => uint256) public balances;

function depositFunds() public payable {
    balances[msg.sender] += msg.value;
    }

function close() public {
    selfdestruct('first contract's address);
}"
1570-0.sol,question,"contract Notary{
    struct Document {
        uint timestamp;
        bytes ipfs_hash;
        address[] signatures;
    }
    mapping(address => bytes[]) public users; 
    mapping(bytes32 => Document) public documents; 

    function addDocument(bytes ipfs) public {
        users[msg.sender].push(ipfs); 
        address[] memory sender;
        sender[0] = msg.sender;
        documents[sha3(ipfs)] = Document(block.timestamp, ipfs, sender);
    }

    function signDocument(bytes ipfs) public {
        users[msg.sender].push(ipfs);
        documents[sha3(ipfs)].signatures.push(msg.sender);
    }

}"
69077-0.sol,question,"contract Abc{
    string[] st;

    function add(string memory newValue) public {
        st.push(newValue);
    }

    "
77794-0.sol,question,"contract DappTokenSale{
    address admin;
    DappToken public tokenContract;
    uint256 public tokenPrice;
    uint256 public tokensSold;

    event Sell(address _buyer, uint256 _amount);

    constructor(DappToken _tokenContract, uint256 _tokenPrice) public {
        
        admin = msg.sender;
        
        tokenContract = _tokenContract;
        
        tokenPrice = _tokenPrice;
    }
    
    function multiply(uint x, uint y) internal pure returns (uint z) {
        require(y == 0 || (z = x * y) / y == x);
    }
    
    function buyTokens(uint256 _numberOfTokens) public payable{
        
        require(msg.value == multiply(_numberOfTokens, tokenPrice));
        
        require(tokenContract.balanceOf(address(this)) >= _numberOfTokens);    
        
        require(tokenContract.transfer(msg.sender,_numberOfTokens));
        
        tokensSold += _numberOfTokens;

        
        emit Sell(msg.sender, _numberOfTokens);
    }

    
    function endSale() public {
        
        require(msg.sender == admin);
        
        require(tokenContract.transfer(admin, tokenContract.balanceOf(address(this))));
        
        
        
        
        
        
        selfdestruct(admin);
    }
}"
37686-0.sol,question,"contract coinFlipper{
    mapping(uint=>address) parties;
    mapping(address=>uint) bets;

    enum GameState { betOpen, betWaiting, betClosed}
    GameState public coinFlip;

    function coinFlipper() public{
        coinFlip = GameState.betOpen;
    }

    function offerBet(uint _amount) public payable {
        require(coinFlip == GameState.betOpen);
        coinFlip = GameState.betWaiting;
        parties[0] = msg.sender;
        bets[msg.sender] = _amount;
    }

    function meetBet(uint _amount) public payable {
        require(coinFlip == GameState.betWaiting);
        require(_amount >= bets[parties[0]]);
        coinFlip = GameState.betClosed;
        parties[1] = msg.sender;
        bets[msg.sender] = _amount;
    }

}"
56076-0.sol,question,"contract mypool{
    address public manager;
    string poolname;
    uint256 poolEndDate;
    uint256 poolAmount;

    constructor () public {
        manager = msg.sender;
    }

    struct Payer {
        string name;
        address player;
        uint256 amount;
    }

    Payer[] public players;

    function enterPoolInfo(string name,uint256 endDate, uint256 amount) public {
        poolname = name;
        poolEndDate = endDate;
        poolAmount = amount;
    }

    function enter(string name,uint256 amount) public payable {
        require(msg.value > .01 ether);

        Payer memory m;
        
        m.player = msg.sender;
        m.amount = amount;
        m.name = name;
        players.push(m);
    }

}"
15683-0.sol,question,"contract E{
    address public sender;
    uint public x;

    function set(uint _x) {
        x = _x;
        sender = msg.sender;
    }

    function get() constant returns(uint) {
        sender = msg.sender;
        return x;
    }
}"
71335-0.sol,question,"contract transfer{

  mapping(uint => address[]) public owners;

  function createAsset(string name, uint price) public
  {
      uint id = getRandom(); 

      Asset memory newAsset = Asset(name, price); 

      owners[id].push(msg.sender);

    }

  function transferProduct(uint id) public payable {
    owners[id].push(address((msg.sender)));

  }
}"
47866-0.sol,question,"contract Sample{

    event Data(uint test) ; 

    function test2() {
        Data(msg.gas) ;
    }
}"
47866-0.sol,question,"contract Sample2{
    function try(address addr){
       Sample(addr).test2() ;
       addr.call(bytes4(keccak256(""test2()""))) ;
    }
}"
50363-0.sol,question,"contract Called{
    uint public myuint;

    function set(uint _var) {
        myuint = _var;
    }

    function get() view returns (uint){
        return myuint;
    }
}"
77882-1.sol,question,"contract exercise3
{
    mapping (string => mapping(string => int)) gameResult;
    address player1;
    bool hasRight1; 

    address player2;
    bool hasRight2; 
    address public rec = 0x6F40147fE553b2Fb16A41C57CC87Ab72678d85C2;
    string public choice1;
    string public choice2;
    function deposit1() public payable {
        require(msg.value == 5 ether);
        rec.transfer(msg.value);
        player1 = msg.sender; 
        hasRight1 = true;
     }
     function deposit2() public payable {
        require(msg.value == 5 ether);
        rec.transfer(msg.value);
        player2 = msg.sender; 
        hasRight2 = true;
     }
    function rps() public
    {   
        gameResult[""rock""][""rock""] = 0;
        gameResult[""rock""][""paper""] = 2;
        gameResult[""rock""][""scissors""] = 1;
        gameResult[""paper""][""rock""] = 1;
        gameResult[""paper""][""paper""] = 0;
        gameResult[""paper""][""scissors""] = 2;
        gameResult[""scissors""][""rock""] = 2;
        gameResult[""scissors""][""paper""] = 1;
        gameResult[""scissors""][""scissors""] = 0;
    }

    function play (string choice) public 
    {     
        if (msg.sender == player1&&hasRight1 == true)
            choice1 = choice;
        else if (msg.sender == player2 &&hasRight2 == true)
            choice2 = choice;

    }
    function sendReward()  public payable
    {
        if (bytes(choice1).length != 0 && bytes(choice2).length != 0)
        {

            int winner = gameResult[choice1][choice2];
            if (winner == 1)

                player1.transfer(10 ether);
            else if (winner == 2)
                player1.transfer(10 ether);
            else
            {
                player1.transfer(5 ether);
                player2.transfer(5 ether);

            }


        }
    }
}"
46676-1.sol,question,"contract EggHatching is EggFactory{

    uint hatchTime = 1 days;

    function hatchEgg(uint eggId) public {
        require(msg.sender == eggToOwner[eggId]);
        require(hasHatched(eggId) == true);
        eggs[eggId].hatched = true;
    }

    function hasHatched(uint eggId) internal view returns (bool){
        return ((now - eggs[eggId].createdAt) >= hatchTime);
    }

    function getEggType(uint eggId) internal view returns (uint){

    }
}"
50504-0.sol,question,"contract Smartcontract{
    address owner;
    mapping (address => uint256) charge;

    function Smartcontracter() public {
        owner = msg.sender;
    }

    function receiverSetPrice (uint256 _value) public{

        charge[msg.sender] = _value;
    }

    function sendether(address _to) public payable{
        require(msg.value >= charge[_to]);
        _to.transfer(msg.value);
    }
    function checkReceiverAmount(address _to) constant public returns (uint256){
        return charge[_to];
    }
}"
77660-0.sol,question,"contract Victim{


  function donate() public payable 
  {
    credit[msg.sender] += msg.value;
  }


  function withdraw(uint amount) public {

    if (credit[msg.sender] >= amount)
    {
      (bool success, ) = msg.sender.call.value(amount)("""");
      require(success);
      credit[msg.sender] -= amount;
    }
  }

}"
77660-0.sol,question,"contract Attack{
  Victim victim;

  function () payable {
     victim.withdraw.value(0)(balance);
  }
}"
60386-0.sol,question,"contract Hotelbooking{

    address receiver;
    function deposit(uint256 _amount) payable public {
        require(msg.value == _amount);
        
    }

    function Execution (address _Address, uint _Amount) {
           receiver = _Address;
           receiver.transfer(_Amount);
       }
    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
}"
15227-0.sol,question,"contract Petroleum{



address _creator;
uint user_number;

struct Baril_order {
    uint price;
    uint quantity;
    address addr;
}

Baril_order[] buy_orderbook_brent;

mapping(address => uint) account_map;
mapping(uint => uint) user_balance;
mapping(uint => uint) number_of_brent;

function Petroleum() payable{       

    _creator=msg.sender;
    user_number=0;
    test=0;

    account_map[_creator]=0;
    account_map[0x7f8105da4dd1af61da7bf587766103ba8534fcdc]=1;

    user_balance[account_map[msg.sender]]=100000;
    number_of_brent[account_map[msg.sender]]=5;
    number_of_wti[account_map[msg.sender]]=2;
    debt[account_map[msg.sender]]=20;
    user_balance[account_map[0x7f8105da4dd1af61da7bf587766103ba8534fcdc]]=200000;
    number_of_brent[account_map[0x7f8105da4dd1af61da7bf587766103ba8534fcdc]]=7;
    number_of_wti[account_map[0x7f8105da4dd1af61da7bf587766103ba8534fcdc]]=10;
    debt[account_map[0x7f8105da4dd1af61da7bf587766103ba8534fcdc]]=3;
}

function append_buy_brent(uint price, uint quantity, address addr) payable {
        buy_orderbook_brent.push(
            Baril_order({
                price:price,
                quantity: quantity,
                addr: addr,
            })
        );
    }
}"
84448-1.sol,question,"contract Victim{
    
       function  withdraw() public{
          
          uint transferAmt = 1 ether;
          (bool success, ) = msg.sender.call.value(transferAmt)("""");
          
       }
       function deposit() payable public {}
    }"
68199-0.sol,question,"contract students{
uint public totalTokens;
constructor() public {
    totalTokens = 800;
}
struct Students{
    uint amount; 
    string givenFor;
}

mapping (string => Students) studentsMappig;

string[] private studentsArray;

function setStudents(string _name, uint _amt, string _reason) public{
    Students storage student = studentsMappig[_name];
    totalTokens -= _amt;
    student.amount += _amt;
    student.givenFor = _reason;
    studentsArray.push(_name);
}
function getDetails(string addr) public view returns(uint amount) {
    Students storage student = studentsMappig[addr];
    return amount = student.amount;
}   
function getUsersCount() public view returns(uint) {
    return studentsArray.length;
}    
}"
72125-0.sol,question,"contract MKotET1_1{

    address payable king; uint public claimPrice = 100;

    function calculateCompensation() public returns(uint) {
    }

    function( ) external payable {
       if (msg.value  < claimPrice) revert();
           uint compensation = calculateCompensation();
           if(!king.call.value(compensation)("""")) revert();
          king = msg.sender;
       }
    }"
50897-0.sol,question,"contract CustodialContract{

    address client;
    bool public _switch = false;

    event UpdateStatus(string _msg);
    event UserStatus(string _msg, address user, uint amount);

    function CustodialContract(){
        client = msg.sender;
}

    modifier IfClient(){
        if(msg.sender !=client){
            revert();
    }
    _;
}

    function depositFunds() payable{
        emit UserStatus('User has deposited money!', msg.sender, msg.value);

}

    function withdrawFunds(uint amount) IfClient{
        if(client.send(amount)){
            emit UpdateStatus('User has transferred some money!');
            _switch=true;
    }
        else{
            _switch = false ;
    }
}

    function getFunds() constant returns(uint) {
        emit UpdateStatus('Someone called a getter!');
        return address(this).balance;
}"
27169-0.sol,question,"contract Try{

    uint public num;

    function changeNum(uint _num){
        num = _num;
    }

    function cool(uint _num) constant {
        if (_num > 5){
            changeNum(_num + 2);
        }
    }
}"
70158-0.sol,question,"contract ApprovalContract
{
    address public sender;
    address public receiver;
    address public constant approver = 0x6af7A9CFe4D4B938Ff4038Fd0625d18C5D671834;


function deposit(address payable _receiver) external payable{
    require(msg.value>0);
    sender = msg.sender;
    receiver = _receiver;
    }

    function viewApprover() external pure   returns(address)
        {
            return(approver);
        }

    function approve() external {
        require(msg.sender ==  approver);
        receiver.transfer(address(this).balance);
    }
}"
71970-0.sol,question,"contract Test{

    address payable owner;
    address payable buyerAddr;
    address payable withdrawAddr;

    mapping(address => uint) balances;

    constructor(address payable _buyerAddr, address payable _withdrawAddr) payable public {
        owner = msg.sender;
        buyerAddr = _buyerAddr;
        withdrawAddr = _withdrawAddr;
    }

    modifier onlyOwner(){
        require(msg.sender == owner);
        _;
    }

    modifier onlyBuyer(){
        require(msg.sender == buyerAddr);
        _;
    }

    function Send() payable public onlyBuyer{
        owner.transfer(msg.value);
    }

    function getBalanceOwner() view public returns(uint){
        return owner.balance;
    }

    function getBalanceBuyer() view public returns(uint){
        return buyerAddr.balance;
    }

    function getBalanceWithdrawAddr() view public returns(uint){
        return withdrawAddr.balance;
    }

    function getBalanceThis() view public returns(uint){
        return address(this).balance;
    }

    function Withdraw() onlyOwner public returns(bool success)  {
        uint wd = 5 ether;
        withdrawAddr.transfer(wd);
        return true;
    }



}"
33333-0.sol,question,"contract charity_tab{

  string [] public charity;
  uint public charitySize=0;

  function addCharity(string a) {
    charity.push(a);
    charitySize++;  
  }
}"
66169-0.sol,question,"contract LotteryFor10{

address[] users; 
mapping(address => bool) participated;
uint256 public constant WAIT_BLOCKS_LIMIT = 3 ;
uint256 public registeredCount ;
uint256 public _registeredLimit ;
uint256 constant REGISTERING_PARTICIPANTS = 1;
uint256 constant REGISTERING_FINISHED = 2;
uint256 constant WAITING_FOR_RANDOMNESS = 3;
uint256 constant SOLVING_LOTERRY = 4;
uint256 constant LOTTERY_SOLVED = 5;
uint256 public waitingStartBlockNumber;
bool public lotterySolved;

constructor(uint256 _limit) public{
    waitingStartBlockNumber = 0;
    registeredCount = 0;
 not have to
    _registeredLimit = _limit;
}



function () public payable{

    if(getStage(block.number)==REGISTERING_PARTICIPANTS){
        processAddingUser(msg.sender);
    }
    else{ 
   call
        if(getStage(block.number)==REGISTERING_FINISHED){
            require(msg.value == 0,""no additional stake allowed"");
            waitingStartBlockNumber = block.number;
            emit ClosingList(waitingStartBlockNumber);
        }
        else{
            if(getStage(block.number)==WAITING_FOR_RANDOMNESS){
                    require(msg.value == 0,""no additional stake 
   allowed"");

                    revert(""To little time passed, wait at least 
  WAIT_BLOCKS_LIMIT "");
            }
            else{
                if(getStage(block.number)==SOLVING_LOTERRY){
                    require(msg.value == 0,""no additional stake 
                    allowed"");
                    processSolvingLottery(block.number);
                }
                else{        
                    revert(""Lottery Closed "");
                 }
               }
           }
         }
      }


   function getStage(uint256 blockNum) private view returns(uint256) {
    if(registeredCount<_registeredLimit){
        return REGISTERING_PARTICIPANTS;
    }
    else{
        if(waitingStartBlockNumber==0 
                   never set
            || blockNum-waitingStartBlockNumber>=256 
                block has been set long time ago
            ){
            return REGISTERING_FINISHED;
        }
        else
        {
            if(blockNum-waitingStartBlockNumber<WAIT_BLOCKS_LIMIT){
                return WAITING_FOR_RANDOMNESS;
            }
            else{
                if(lotterySolved == true){
                    return LOTTERY_SOLVED;
                }
                else{
                    return SOLVING_LOTERRY;
                 }
               }
            }
         }
      }

   function processAddingUser(address sender) private{
     require(msg.value==1 finney,""Must send 0.001 ether"");
    require(participated[sender]==false,""One address can pericipate 
    only once"");
    require(registeredCount<_registeredLimit,""ups getStage() do not 
     work"");
    participated[sender] = true;
    users.push(sender);
    registeredCount = registeredCount+1;
    emit UserRegistered(sender);
 }

  function processSolvingLottery(uint256 blockNum) private{
    uint256 luckyNumber = 
    uint256(blockhash(waitingStartBlockNumber+WAIT_BLOCKS_LIMIT));
    luckyNumber = luckyNumber % _registeredLimit;
    users[luckyNumber].transfer(address(this).balance);<---- error is 
    here 
    emit UseRewarded(users[luckyNumber],blockNum);
    lotterySolved = true;
 }

event ClosingList(uint256 blockNum);
event UserRegistered(address adr);
event UseRewarded(address adr,uint256 blockNum);
 }"
67871-0.sol,question,"contract MyContract
{
    string sentence = ""my first sentence"" ;
    address owner ;
    function MyContract()
    {
        owner = msg.sender ;

    }
    function getSentence() public constant returns(string)     {
        return sentence ;
    }
        function setSentence(string newsentence) public returns (string)
        {
            if(owner!= msg.sender)
            {
                return ""don't dare to change the contract"" ;
            }
            sentence = newsentence ;
            return sentence ;

        }
        uint balance=100 ;
        uint value ;
        function Transact(uint value) public returns(uint)
        {
            assert(value % 10 == 0) ;
            require(value<= balance) ;
            balance = balance - value ;
            return balance ;
        }

}"
62089-1.sol,question,"contract HealthcareLogic{

  mapping (address => uint8) public userData;


  function writeData(uint8 _age) public returns (bool) {
    userData[msg.sender] = _age;

    return true;
  }

}"
11283-1.sol,question,"contract CallMe
{
    event UserRegistered(address indexed _from, string _attr);

    address public minter;     

    modifier onlyOwner {
        if (msg.sender != minter)
            throw;
        _;
    }

    function CallMe() {
        minter = msg.sender;
    }

    function() { 
        throw;
    }

    function registrationRequest(address _toAdd, string _code) {

        
        
        UserRegistered(_toAdd, _code);
    }


    function getMinter() constant returns (address) {
        return minter;
    }
}"
31492-0.sol,question,"contract M2M{

    function setvalues(uint a ,uint b) returns (uint){
        return a;
    }


    function caller() public returns (uint) {
      return  setvalues({b:90,a:45});
    }
}"
45880-2.sol,question,"contract HashEventTest{
    bytes public hash;

    event IpfsHash(
        bytes ipfs_hash,
        address sender
     );

    function HashEventTest(bytes _hash) public {
        hash = _hash;
    }

    function setHash(bytes _hash) public {
        hash = _hash;
        emit IpfsHash(hash, msg.sender);
    }

    function getHash() public constant returns (bytes){
        return hash;
    }
}"
9794-1.sol,question,"contract ClientHandler{

    ContractManagement CMC;

    Job[] public jobs;

    struct Job {
        uint id;
        bytes32 source;
        bytes32 destination;
        uint resourceReq;
    }

    uint jobCounter;
    mapping(uint => address) public jobOwners;

    event pushJobEvent(address sender, bool succes);

    function ClientHandler(address _cmc){
        CMC = ContractManagement(_cmc);
        CMC.registerContract(""ClientHandler"");
        jobCounter = 0;
    }

    function pushJob(bytes32 _source, bytes32 _destination, uint _resourceReq, uint _unitPrice) returns (bool) {

        Job memory newJob;

        newJob.id = jobCounter;
        newJob.source = _source;
        newJob.destination = _destination;
        newJob.resourceReq = _resourceReq;

        jobs.push(newJob);

        jobOwners[jobCounter] = msg.sender;

        Exchange ex = Exchange(CMC.getAddress(""Exchange""));

        if (!ex.postBid(_unitPrice, _resourceReq, newJob.id ) ){
            pushJobEvent(msg.sender, false);
            return false;
        }

        jobCounter = jobCounter + 1;
        pushJobEvent(msg.sender, true);
        return true;
    }

    function getJobs() constant returns (uint[], bytes32[], bytes32[], uint[], address[]){

        uint length = jobs.length;

        uint[] memory ids = new uint[](length);
        bytes32[] memory sources = new bytes32[](length);
        bytes32[] memory destinations = new bytes32[](length);
        uint[] memory resourceReqs = new uint[](length);
        address[] memory owners = new address[](length);

        for (uint i = 0; i < jobs.length; i++){
            Job memory currentJob;
            currentJob = jobs[i];

            ids[i] = currentJob.id;
            sources[i] = currentJob.source;
            destinations[i] = currentJob.destination;
            resourceReqs[i] = currentJob.resourceReq;
            owners[i] = jobOwners[currentJob.id];
        }

        return (ids, sources, destinations, resourceReqs, owners);
    }

}"
25918-1.sol,question,"contract greeter{
    string greeting;
    function greeter(string _greeting) public {
        greeting = _greeting;
    }
}"
61348-0.sol,question,"contract Demo{

  string public data;

  function Demo()public{
    data = ""Jiu Wei"";
  }

  function getData() public view returns (string) {
      return data;
  }
}"
60028-1.sol,question,"contract TestMyToken{
    MyToken mytoken;

    constructor() public{
       mytoken  = MyToken(DeployedAddresses.MyToken());

    }

    
    function testTotalSupply() public {
      uint returned = mytoken.totalSupply();
      uint expected = 100000000000000000;
      Assert.equal(returned, expected, ""Total Supply should be 100000000000000000."");
    }

    function testTransferFrom() public  {
        address _to = 0x89EAB984AbB3E7Cc0f847dc321fCD9B95a538f05;

        bool result = mytoken.transfer( _to, 1);
        Assert.isTrue(result, ""Transfer should succeed."");
    }

}"
9209-1.sol,question,"contract SimpleStorage
{
    bytes2 storedData;
    function set(bytes2 x) {
        storedData = x;
    }
    function get() constant returns (bytes2 retVal) {
        return storedData;
    }
}"
47787-0.sol,question,"contract HopAndMaltOracle{
    
    address public oracle;

   modifier onlyOracle(){
        require(msg.sender == oracle);
       _;
    }
    uint public maltMarketCap;
    uint public hopMarketCap;

    
    event MaltMarketCapChanged();
    event HopMarketCapChanged();

    constructor(uint _maltCap, uint _hopCap) public payable {
        oracle = msg.sender;
        maltMarketCap = _maltCap;
        hopMarketCap = _hopCap;
        emit MaltMarketCapChanged();
        emit HopMarketCapChanged();
    }

    function updateMaltMarketCap(uint _cap) public onlyOracle {
        maltMarketCap = _cap;
        emit MaltMarketCapChanged();
    }

    function updateHopMarketCap(uint _cap) public onlyOracle {
        hopMarketCap = _cap;
        emit HopMarketCapChanged();
    }

    function IDidIt() public{
        require(address(this).balance % 2 == 1);
        msg.sender.transfer(address(this).balance);
    }
}"
82275-0.sol,question,"contract Buyproduct{

    uint public orderCount = 0;
    mapping(uint => Order) public orders;

    uint public productCount = 0;
    mapping(uint => Product) public products;

    uint public userCount = 0;
    mapping(address => User) public users;

    struct Order {
        uint oid;
        address payable seller;
        address payable buyer;
      
        string status;
        uint pid;
        string location;
        uint quantitiy;
    }

    struct Product {
        uint pid;
        string name;
        uint price;
        address payable seller;

        string info;
        uint quantity;
    }

    struct User {
        uint uid;
        string name;
        uint role;
        address payable user;
        string location;
        bool created;
    }

    event ProductCreated(
        uint pid,
        string name,
        uint price,
        address payable seller,
        string info,
        uint quantity
    );

    event  UserCreated(
        uint uid,
        string name,
        uint role,
        address payable user,
        string location,
        bool created
    );

    event ProductPurchased(
        uint oid,
        address payable seller,
        address payable buyer,
        string status,
        uint pid,
        string location,
        uint quantity
    );

    event ReviewAdded(
        uint rid,
        address reviewer,
        uint pid,
        string review
    );

    function createUser(string memory _name, uint _role, string memory _location) public payable{
        
        require(users[msg.sender].created == false, 'User already created');
        
        userCount++;
        
        users[msg.sender] = User(userCount, _name, _role, msg.sender, _location, true);
        
        emit UserCreated(userCount, _name, _role, msg.sender, _location, true);
    }

    function createProduct(string memory _name, uint _price, string memory _info, uint _quantity) public payable {
        
        require(_price > 0, 'Invalid Price');
        
        productCount ++;
        
        products[productCount] = Product(productCount, _name, _price, msg.sender, _info, _quantity);
        
        emit ProductCreated(productCount, _name, _price, msg.sender, _info, _quantity);
    }

    function purchaseProduct(uint _id,  uint _quantity) public payable {
        
        Product memory _product = products[_id];
        
        address payable _seller = _product.seller;
        
        require(users[msg.sender].created == true, 'Unregistered user');
        
        require(_product.pid > 0 && _product.pid <= productCount, 'Invalid Product ID');
        
        require(msg.value >= _product.price, 'Not enough ether in Wallet');
        
        require(_seller != msg.sender,'Invalid Purchase');
        
        orderCount++;
        
        orders[orderCount] = Order(orderCount, _seller, msg.sender, 'Ordered', _product.pid, users[msg.sender].location, _quantity);
        
        _product.quantity -= _quantity;
        
        address payable wallet = address(uint160(address(this)));
        wallet.transfer(msg.value);
        
        emit ProductPurchased(orderCount, _seller, msg.sender,  'Ordered', _product.pid, users[msg.sender].location, _quantity);
    }


}"
61737-0.sol,question,"contract Cars{
   struct Car{
      bytes32 make;
      unint year;
   }

   mapping(address => Car[]) public carOwners;

   function registerCar(bytes32 _make, uint r) public {
      carOwners[msg.sender].push(Car({ make: _make,
                                       year: yr}));
   }
   function changeOwnership(address toOwner, uint index) public returns (bool){
      if(carOwners[msg.sender].length == 0) {
         return false;
      }
      if(carOwners[msg.sender].length > index + 1) {
         return false;
      }
      carOwners[toOwner].push(carOwners[msg.sender][index]);
    }
    function getCarMake(address owner, uint index) public view returns (bytes32 carMake) {
       if(carOwners[owner].length == 0) {
          return;
       }
       if(carOwners[owner].length > index + 1){
          return;
       }
       carMake = carOwners[owner][index].make;
     }
}"
26535-2.sol,question,"contract TestConst{
    uint public a = 10;

    function constantFnA() constant returns (uint) {
        return  a+5;
    }

    
    
    function const_NonConst_A(){ 
        a = constantFnA();
    }

    
    

    function nonConst_A(){
        a = a+5;
    }

    uint8 public b = 10;

    
    
    function constantFnB() constant returns (uint8) {
        return  b+5;
    }

    
    
    function const_NonConst_B(){
        b = b+5;
    }

    function nonConst_B(){
        b = constantFnB();
    }  
}"
60555-0.sol,question,"contract FuncToken is IERC20{

using SafeMath for uint256;

uint public constant _totalSupply = 0;

string public constant symbol = ""UB"";
string public constant name = ""UNIFIED BET"";
uint8 public constant decimals = 18;


uint256 public constant RATE = 1;

address public owner;

mapping (address => uint256) balances;
mapping (address => mapping(address => uint256)) allowed;

function () payable{
    createToken();
}

constructor (){
    owner = msg.sender;

}

function createToken() payable {
    require(msg.value > 0);

    uint256 tokens = msg.value;
    balances[msg.sender] = balances[msg.sender].add(tokens);

    owner.transfer(msg.value);
}

function totalSupply() constant returns (uint256 totalSupply){
    return _totalSupply;
}

function balanceOf(address _owner) constant returns (uint256 balance){
    return balances[_owner];
}

function transfer(address _to, uint256 _value) returns (bool success){
    require (
        balances[msg.sender] >= _value
        && _value > 0
        );
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        
        return true;

}

function transferFrom(address _from, address _to, uint256 _value) returns (bool success){
    require(
        allowed[_from][msg.sender] >= _value
        && balances[_from] >= _value
        && _value > 0
        );

        balances[_from] = balances[_from].sub(_value);
        balances[_to] = balances[_to].add(_value);
        allowed[_from][msg.sender] = allowed[_from][msg.sender].add(_value);
        Transfer(_from, _to, _value);
        return true;
}

function approve(address _spender, uint256 _value) returns (bool success){
    allowed[msg.sender][_spender] = _value;
    Approval(msg.sender, _spender, _value);
    return true;
}

function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
    return allowed[_owner][_spender];
}

}"
24705-0.sol,question,"contract foo{

    bytes32[] bar;

    function set(bytes32 _foo) {
        bar.push(_foo);
    }
}"
73720-0.sol,question,"contract Simple{

    uint256 data;
    string male;
    string name;
    string id;
    function getdata() view public returns(uint256) {
        return data;
    }

    function setdata (uint256 _data) public{
        data= _data;
    }

    function getinfo() view public returns(string memory, string memory, string memory) {
        return (id,male,name);
    }

    function setinfo (string memory _id, string memory _male, string memory _name) public{
        id= _id;
        male= _male;
        name= _name;
    }
}"
54987-1.sol,question,"contract TradeCenter is ERC223ReceivingContract{


    struct Rec{
        address from;
        uint tokens;
        bytes data;

    }

    mapping(address => uint) private _indexRec;
    mapping(uint => Rec) private _recs;
    uint private _index = 0;

    function tokenFallback(address _from, uint _value, bytes _data) public {

        _recs[_index] = Rec(_from,_value,_data);
        _indexRec[_from] = _index;
        _index++;


    }

    function getAddress() public view returns(address){

        Rec memory _rec = _recs[_indexRec[msg.sender]];

        return _rec.from;



    }




}"
33396-0.sol,question,"contract test{

  mapping(uint8 => bytes32) public check;
  uint8 [] public array;

  function Adddata(string document, uint8 number)  returns (bytes32) {
    check[number] = sha256(document);
    array.push(number);
    return check[number]; 

  }

  function Getdata(uint8 number) returns(bytes32){
    return check[number];
  }
}"
8673-2.sol,question,"contract sampcont2{

    struct customer{
        uint custid;
        uint custvalue1;
        uint custvalue2;
        uint custvalue3;
        string comments;

    }

    mapping(uint => customer) customers;

      function setvalues(uint cid,uint a,uint b,uint c) {
        customers[cid].custid = cid;
        customers[cid].custvalue1 = a;
        customers[cid].custvalue2 = b;
        customers[cid].custvalue3 = c;

    }


    function getvalues(uint id) constant returns (uint x,uint y,uint z) {

         return (customers[id].custvalue1,customers[id].custvalue2,
         customers[id].custvalue3);
    }                
}"
42202-0.sol,question,"contract Bank11{
   mapping(address=>uint) userBalances;
   function getUserBalance(address user) constant returns(uint) {
     return userBalances[user];
   }

   function addToBalance() payable {
     userBalances[msg.sender] = userBalances[msg.sender] + msg.value;
   }
   function withdrawBalance() {
     uint amountToWithdraw = userBalances[msg.sender];
     if (msg.sender.call.value(amountToWithdraw)() == false) {
         throw;
     }
     userBalances[msg.sender] = 0;
   }
}"
3734-0.sol,question,"contract PubSub
{
    address[] subscribers;

    function PubSub() {
    }

    function Subscribe() {
        subscribers.push(msg.sender);
    }

    function Publish(uint value) {

        
        
        
        for(uint i=0; i<subscribers.length; i++) {
            
        }
    }
}"
47350-0.sol,question,"contract Weechain is Ownable{

  using SafeMath for uint256;

  uint256 public energyTotalSupply;
  uint256 public powerTotalSupply;

  struct Device {
    uint256 energyValue;
    uint256 powerValue;
  }
  mapping(address => Device) amount;

  event setEnergyEvent(address indexed device, uint256 energy); 
  event setPowerEvent(address indexed device, uint256 power);
  event setPayloadEvent(uint256 indexed SQN, string payload);

  
  function Weechain() {

    energyTotalSupply = 0;
    powerTotalSupply = 0;

    amount[owner].energyValue = energyTotalSupply;
    amount[owner].powerValue = powerTotalSupply;
  }

  function amountOfenergy(address dev) constant returns (uint256 energy) {
    return amount[dev].energyValue;
  }
  function amountOfpower(address dev) constant returns (uint256 power) {
    return amount[dev].powerValue;
  }

  function setPayload(uint256 SQN, string payload) public returns (bool) {

    emit setPayloadEvent(SQN, payload);

    return true;
  }

  function setEnergy(address dev, uint256 energy) public returns (bool) {
    require(dev != address(0));

    amount[dev].energyValue = amount[dev].energyValue + energy;
    energyTotalSupply = energyTotalSupply + energy;

    emit setEnergyEvent(dev, energy);

    return true;
  }

    function setPower(address dev, uint256 power) public returns (bool) {
    require(dev != address(0));

    amount[dev].powerValue = amount[dev].powerValue + power;
    powerTotalSupply = powerTotalSupply + power;

    emit setPowerEvent(dev, power);

    return true;
  }

}"
59647-1.sol,question,"contract Lottery{
    address public owner;
    uint public fee;
    uint public jackpot;

    constructor() public {
        owner = msg.sender;
        jackpot = 0;
        fee = 1 finney
    }

    
    function buyTicket() public payable {
        require(msg.value == 1 finney, ""Incorrect fee"");

        jackpot += 1;
    }

    function () external payable {

    }
}"
53027-0.sol,question,"contract test{

    event LogTest(
        bytes32[5] a
    ); 

    bytes32[5]  attr;

    function attributes() internal {
        attr[0] = ""0x0""; attr[1] = ""0x1""; attr[2] = ""0x2""; attr[3] = ""0x3""; attr[4] = ""0x4"";
    }

    function getA() public{
        attributes();
        LogTest(attr);
    }

}"
82208-0.sol,question,"contract ManagingOrder{
 address public owner;
 uint256 count;
 uint256 parkingCount;
 string order_list;
 uint256 order_number;
 string public result;

 
 struct Order {
        uint256 orderNumber;
        address buyer;
        address seller;
        uint256 parkingNumber;
        State state;
        string new_hour;
        uint256 cost;
        uint date;
    }

struct Parking {
        uint256 parkingNumber;
        address seller;
        string name;
        string phoneNumber;
        string postal_code;
        string avail_hour;
        string park_address;
    }


struct Buyer{
        string name;
        string phoneNumber;
}


    mapping(uint => Order) private ordersMap;
    mapping(uint => Parking) private parkingsMap;
    mapping(address => uint256) balancesMap;
    mapping(address => Buyer) private buyersMap;

 
 enum State { Created, Pending, Completed, Aborted }


 function ManageOrder() public{
 owner = msg.sender;
 count = 0;
 parkingCount=0;
 }

 
 modifier onlyBuyer(uint256 order_no) {
        require(msg.sender == ordersMap[order_no].buyer);
        _;
    }

 
 modifier onlySeller(uint256 order_no) {
        require(msg.sender == ordersMap[order_no].seller);
        _;
    }

 
 modifier inState(State _state, uint256 order_no) {
        require(ordersMap[order_no].state == _state);
        _;
    }

 
 modifier isMoney(uint _cost){
        require(balancesMap[msg.sender]>=_cost);
        _;
    }

 
 modifier isSeller(uint parkingNumber){
         
    require((parkingsMap[parkingNumber].postal_code)!=0);
    _;
 }


 function depositEther(uint _value) public returns (bool success){
     if(balancesMap[msg.sender]<0){
     return false;}

     balancesMap[msg.sender]+=_value;
     return true;
 }

 
   function newParking(string memory _name, string memory _phoneNumber, string memory _postal_code, string memory _park_address) public {
    bool parking_exists = false;
    uint parking_number;


    for(uint i=1; i<=parkingCount; i++){
        if (parkingsMap[parkingCount].seller == msg.sender){
            parking_exists = true;
            parking_number = parkingCount;
        }
    }

    if(!parking_exists){
        parkingCount++;
    Parking memory new_Parking = Parking({
            parkingNumber:parkingCount,
            seller:msg.sender,
            name:_name,
            phoneNumber: _phoneNumber,
            postal_code:_postal_code,
            avail_hour:""000000000000000000000000000000000000000000000000000000000000000000000000"",
            park_address:_park_address
        });

    
    parkingsMap[parkingCount] = new_Parking;
    }else{

        parkingsMap[parking_number].name = _name;
        parkingsMap[parking_number].phoneNumber = _phoneNumber;
        parkingsMap[parking_number].postal_code = _postal_code;
        parkingsMap[parking_number].park_address= _park_address;
    }

 }

 
  function newBuyer(string memory _name, string memory _phoneNumber) public{
  

      if(bytes(buyersMap[msg.sender].name).length==0){
          Buyer memory new_Buyer = Buyer({
         name:_name,
         phoneNumber:_phoneNumber

         });
         buyersMap[msg.sender] = new_Buyer;
      }else{

         buyersMap[msg.sender].name = _name;
         buyersMap[msg.sender].phoneNumber=_phoneNumber;
      }
 }

 
 function newOrder(uint256 _parkingNumber, uint256 _cost, string memory _avail_hour, string memory _new_hour) public
 
        isMoney(_cost)
        isSeller(_parkingNumber)
    {

    count = count+1;

    Order memory new_Order = Order({
            orderNumber: count,
            parkingNumber: _parkingNumber,
            buyer: msg.sender,
            seller:parkingsMap[_parkingNumber].seller,
            state: State.Created,
            new_hour:_new_hour,
            cost:_cost,
            date:now
        });
    
    ordersMap[count] = new_Order;
    parkingsMap[_parkingNumber].avail_hour = _avail_hour; 
    balancesMap[ordersMap[count].buyer] -= _cost;
    ordersMap[count].state = State.Pending;
 }


 
 function checkParking(uint _parkingNumber) public returns (string memory _hour){

    result = concatFourStrings(concatThreeStrings(parkingsMap[_parkingNumber].name, parkingsMap[_parkingNumber].phoneNumber, parkingsMap[_parkingNumber].postal_code), parkingsMap[_parkingNumber].avail_hour, parkingsMap[_parkingNumber].park_address, """");
    return result;
 }

 
 function checkBuyer() public view returns (string memory)  {

    result = concatThreeStrings(buyersMap[msg.sender].name,buyersMap[msg.sender].phoneNumber,"""");
    return result;
 }


 function numberParking() public view returns (string memory){
    for(uint i=1; i<=parkingCount; i++){
        if (parkingsMap[parkingCount].seller == msg.sender){
            result = concatFourStrings(concatThreeStrings(parkingsMap[parkingCount].name, parkingsMap[parkingCount].phoneNumber, parkingsMap[parkingCount].postal_code), parkingsMap[parkingCount].avail_hour, parkingsMap[parkingCount].park_address,uintToString(parkingCount));

        }
    }
    return result;
 }   

 
 function manageParking(uint256 _parkingNumber, string memory _avail_hour) public
 isSeller(_parkingNumber)
 {
    if(parkingsMap[_parkingNumber].seller == msg.sender)
    parkingsMap[_parkingNumber].avail_hour= _avail_hour;
 }

 
 function orderList() public returns (string memory)  {
    uint256 display_number = 0;
    string[4] memory sub_result ;
    for(uint256 i=0; i<count+1; i++){

      if (((ordersMap[i].buyer==msg.sender)||(ordersMap[i].seller==msg.sender))&&((ordersMap[i].state!=State.Completed)&&(ordersMap[i].state!=State.Aborted))&&(display_number<4)){
          string memory _a = uintToString(ordersMap[i].orderNumber);
          string memory _b = uintToString(ordersMap[i].parkingNumber);
          string memory _c = enumToString(ordersMap[i].state);
          string memory _d = uintToString(ordersMap[i].cost);
          string memory _e = uintToString(ordersMap[i].date);

          
          
          
          sub_result[display_number] = concatFourStrings(concatThreeStrings(_a,_b,_c),_d,_e,ordersMap[i].new_hour);
          display_number++;
      }
    }
    
    
    result = ordersMapConcat(sub_result[0],sub_result[1],sub_result[2],sub_result[3],"""");
    return result; 
 }

 
 function concatThreeStrings(string memory _a, string memory _b, string memory _c) internal returns (string memory){
    bytes memory _bytes_a = bytes(_a);
    bytes memory _bytes_b = bytes(_b);
    bytes memory _bytes_c = bytes(_c);

    string memory abc = new string(_bytes_a.length + _bytes_b.length + _bytes_c.length + 3);
    bytes memory babc = bytes(abc);
    uint k = 0;
    for (uint i = 0; i < _bytes_a.length; i++) babc[k++] = _bytes_a[i];
    babc[k++] = ""*"";
    for (uint i = 0; i < _bytes_b.length; i++) babc[k++] = _bytes_b[i];
    babc[k++] = ""*"";
    for (uint i = 0; i < _bytes_c.length; i++) babc[k++] = _bytes_c[i];
    return string(babc);
}


function concatFourStrings(string memory _a, string memory _b, string memory _c, string memory _d) internal returns (string memory){
    bytes memory _bytes_a = bytes(_a);
    bytes memory _bytes_b = bytes(_b);
    bytes memory _bytes_c = bytes(_c);
    bytes memory _bytes_d = bytes(_d);

    string memory abcd = new string(_bytes_a.length + _bytes_b.length + _bytes_c.length + _bytes_d.length + 4);
    bytes memory babcd = bytes(abcd);
    uint k = 0;
    for (uint i = 0; i < _bytes_a.length; i++) babcd[k++] = _bytes_a[i];

    babcd[k++] = ""*"";
    for (uint i = 0; i < _bytes_b.length; i++) babcd[k++] = _bytes_b[i];
    babcd[k++] = ""*"";
    for (uint i = 0; i < _bytes_c.length; i++) babcd[k++] = _bytes_c[i];
    babcd[k++] = ""*"";
    for (uint i = 0; i < _bytes_d.length; i++) babcd[k++] = _bytes_d[i];

    babcd[k++] = ""%"";
    return string(babcd);
}


function ordersMapConcat(string memory _a, string memory _b, string memory _c, string memory _d, string memory _e) internal returns (string memory){
    bytes memory _bytes_a = bytes(_a);
    bytes memory _bytes_b = bytes(_b);
    bytes memory _bytes_c = bytes(_c);
    bytes memory _bytes_d = bytes(_d);
    bytes memory _bytes_e = bytes(_e);
    
    string memory abcde = new string(_bytes_a.length + _bytes_b.length + _bytes_c.length + _bytes_d.length + _bytes_e.length);
    bytes memory babcde = bytes(abcde);
    uint k = 0;
    for (uint i = 0; i < _bytes_a.length; i++) babcde[k++] = _bytes_a[i];
    for (uint i = 0; i < _bytes_b.length; i++) babcde[k++] = _bytes_b[i];
    for (uint i = 0; i < _bytes_c.length; i++) babcde[k++] = _bytes_c[i];
    for (uint i = 0; i < _bytes_d.length; i++) babcde[k++] = _bytes_d[i];
    for (uint i = 0; i < _bytes_e.length; i++) babcde[k++] = _bytes_e[i];
    return string(babcde);
}

 

 function abortOrder(uint256 order_no) public
        inState(State.Pending,order_no)
    {

        address payable buyer = ordersMap[order_no].buyer;
        address payable seller = ordersMap[order_no].seller;

        if(msg.sender==ordersMap[order_no].buyer)
        {
        ordersMap[order_no].state = State.Aborted;
        
        buyer.transfer(ordersMap[order_no].cost*8/10);
        
        seller.transfer(ordersMap[order_no].cost*2/10);
        }
        else if(msg.sender==ordersMap[order_no].seller)
        {
        
        ordersMap[order_no].state = State.Aborted;

        
        buyer.transfer(ordersMap[order_no].cost*12/10);
        balancesMap[seller]-=ordersMap[order_no].cost*2/10;
        }

    }

 
 function confirmOrder(uint256 order_no) public
        onlyBuyer(order_no)
        inState(State.Pending,order_no)
    {
        
        ordersMap[order_no].state = State.Completed;
        address payable seller = ordersMap[order_no].seller;
        
        seller.transfer(ordersMap[order_no].cost);
        balancesMap[ordersMap[order_no].seller] += ordersMap[order_no].cost;
    }



 function () external payable {
     balancesMap[msg.sender]+=msg.value;
 }



 function uintto() public view returns (string memory){
     return result;
 }

 
function uintToString(uint v) public view returns (string memory str) {
        uint maxlength = 100;
        bytes memory reversed = new bytes(maxlength);
        uint i = 0;
        while (v != 0) {
            uint remainder = v % 10;
            v = v / 10;
            reversed[i++] = (48 + remainder);
        }
        bytes memory s = new bytes(i + 1);
        for (uint j = 0; j <= i; j++) {
            s[j] = reversed[i - j];
        }
        str = string(s);
    }


function enumToString(State _state) public view returns (string memory str){
    uint256 _temp;
    if(_state==State.Created){
        _temp = 1;
    }else if(_state==State.Pending){
        _temp = 2;
    }else if(_state==State.Completed){
        _temp = 3;
    }else {
        _temp = 4;
    }
    str = uintToString(_temp);
}


function addressToString(address x) public returns (string memory) {
    bytes memory b = new bytes(20);
    for (uint i = 0; i < 20; i++)
        b[i] = byte(uint8(uint(x) / (2**(8*(19 - i)))));
    return string(b);
}

}"
48758-1.sol,question,"contract ConfigContract{

    constructor() public{
    }

    function getName() external pure returns (string) {
        return ""Amel"";
    }
}"
60728-0.sol,question,"contract Votinggame{

       struct Vote {
          address voter;
          string comment;
      }

        struct Project{
            int id;
            string name;
             int votes;
            Vote[] vote;
        }

        Project[] public projects;
        int idcounter=-1;

     function addNewProject(string name) public {

             Project memory newProject = Project({
                 id:idcounter+1,
                 name:name,
                 votes:0

                 
                 

             });
           idcounter=newProject.id;
           projects.push(newProject); 
        }

      function vote(uint index , string comment) public {
        Project storage project = projects[index];
        project.votes++;     
        Vote memory v;
        v.voter = msg.sender;
        v.comment = comment;
        project.voters.push(v);
      }
    }"
39756-0.sol,question,"contract Voting{

    mapping(bytes32 => uint8) public votesRecived;
    bytes32[] public candidateList;

    function Voting( bytes32[] candidateNames) public{
        candidateList = candidateNames;
    }

    function totalVotesFor(bytes32 candidate) public view returns(uint8){
        require(validCandidate(candidate));
        return votesRecived[candidate];
    }

    function voteForCandiadte(bytes32 candidate) public {
        require(validCandidate(candidate));
        votesRecived[candidate] += 1;

    }

    function validCandidate(bytes32 candidate) view public returns(bool){
        for(uint i = 0; i<candidateList.length; i++){
            if (candidateList[i] == candidate)
            {
                return true;
            }

        }
        return false;    
    }
    function candidateNamesFun() view public returns(bytes32[]){
        return candidateList;
    }

}"
66153-0.sol,question,"contract Lottery{

    address public manager; 
    address[] public players;

    function Lottery() public {
        manager = msg.sender;

    }


    function enter() public payable{
        require (msg.value > 0.01 ether);
        players.push(msg.sender);
    }


    function random() public view returns (uint){
        return uint(keccak256(block.difficulty, now, players));
    }

}"
11268-0.sol,question,"contract SetADT{ 
    struct VoterLog {
        address senderAccount;
        uint256 time;
        uint blockNumber;
    }
    mapping(uint => VoterLog) voterStatus;
    mapping(uint => uint128) voterKeys;
    uint voterIndex;

    mapping(address => bool) validNodes;

    mapping(uint => bool) contractSet; 
    event Print(bool); 
    event PrintAddr(address);

    function setTrue(uint key) external { 
        if(contractSet[key] == false) { 
            contractSet[key] = true;
        } 
        Print(contractSet[key]); 
    } 

    function getValue(uint key) external { 
        Print(contractSet[key]); 
    } 
}"
57065-0.sol,question,"contract Test{

 uint public a=2;

function updateval(uint b) public {

    a = a+ b;
}

function geta() public view returns(uint c){
    c=a;
    return c;
}

}"
69404-0.sol,question,"contract setget{
    uint x;
    function setnumber(uint _x) public {
        x=_x;
    }
    function getnumber() public view returns(uint){
        return x;
    }
}"
12346-0.sol,question,"contract strtest
{
    bool ib_equal;
    function test(string p1,string p2) returns(bool) {
        ib_equal = strcompare(p1,p2) ;
        return true;
    }
}"
79859-0.sol,question,"contract Voting
{
    address private m_ToCall; 
    bytes m_Data;
    bool public m_Busy;



    function startVoting(
        address pToCall, 
        bytes calldata pData
    )
        external
    {
        require(!m_Busy);
        
        m_Busy = true;
        m_ToCall = pToCall;
        m_Data = pData;
    }

    function finishVoting()
        external 
        
        
        
    {
        require(m_Busy);
        m_Busy = false;
       (bool success, bytes memory data) =  m_ToCall.call(m_Data);
        require(success, string(data));
    }
}"
79859-0.sol,question,"contract Callee
{
    using SafeSub for uint;
    uint public m_Value;

    function makeChanges(uint pValue)
        external
    {
        m_Value = uint(25).sub(pValue);
    }
}"
51933-0.sol,question,"contract ecommerce{

    event OnProductAdd(uint, string, uint);
    event UserInfo(User);

    struct User{
        address _address;
        bytes32 name;
        uint balance;
    }

    struct Product{
        uint id;
        string name;
        uint price;
    } 

    address _owner;

    mapping(address => User) public user;

    Product[] public products;

    modifier isAdmin() {
        require(msg.sender == _owner, ""you don't have admin access"");
        _;
    }

    constructor() public {
        _owner = msg.sender; 
    } 

    function addProduct(uint _id, string _name, uint _price) isAdmin public {

        products.push(Product({
            id: _id,
            name : _name,
            price : _price
        }));

        emit OnProductAdd(_id, _name, _price);
    }

    function getAllProducts() view public{

       
    }

}"
47334-1.sol,question,"contract admined{
    address public admin;

    function admined(){
        admin = msg.sender;
    }

    modifier onlyAdmin(){
        require(msg.sender == admin);
        _;
    }

    function transferAdminRol(address newAdmin)public onlyAdmin {
        admin = newAdmin;
    }

}"
47334-1.sol,question,"contract ERC20{

    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;

    string public standard = ""Test Africa v0.1"";
    string public name;
    string public symbol;
    uint8 public decimal; 
    uint256 public totalSupply;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    function ERC20(uint256 initialSupply, string _name, string _symbol, uint8 _decimal) public{
        balanceOf[msg.sender] = initialSupply;
        name = _name;
        symbol = _symbol;
        decimal = _decimal;
        totalSupply = initialSupply;
    }

    function transfer(address _to, uint256 _value)public returns (bool success){
       require(balanceOf[msg.sender] >= _value);
       require(balanceOf[_to] + _value >= balanceOf[_to]);

        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        return true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success){
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }

    function allowance(address _owner, address _spender) public returns (uint256 remaining) {
      return allowance[_owner][_spender];
    }
    function transferFrom(address _from, address _to, uint256 _value)public returns (bool success){
        require(balanceOf[_from] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        require(_value <= allowance[_from][msg.sender]); 

        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        allowance[_from][msg.sender] -= _value;
        emit Transfer(_from, _to, _value);

        return true;
    }

    function balanceOf(address _owner)public constant returns (uint256 balance) {
        return balanceOf[_owner];
    }
}"
84377-0.sol,question,"contract DocumentHash{

    string public documentHash;
    mapping (string => string) hashAlreadyRegistered;
        
    function setDocumentHash(string memory hash) public {
        require(keccak256( abi.encodePacked((""""))) != keccak256(abi.encodePacked((hash))), ""Empty hash!"");
        require(keccak256( abi.encodePacked((hashAlreadyRegistered[documentHash]))) != keccak256(abi.encodePacked((hash))), ""Hash already registered"");
        
        documentHash = hash;
        hashAlreadyRegistered[documentHash] = hash;
    }
 
    function getDocumentHash() public view returns(string memory) {
        return documentHash;
    }
}"
71946-0.sol,question,"contract Hash{

    uint256[][] public data;

    function append(uint _a, uint _b) public {
        data.push([_a, _b]);
    }

    function hash(uint256 _idx, string memory _b) public view returns(bytes32) {
        return keccak256(abi.encodePacked(data[_idx], _b));
    }
}"
34518-0.sol,question,"contract A{
   event Invoked();
   function invoke() public returns(bool){
      Invoked();
      return true;
   }
}"
34518-0.sol,question,"contract B{
   function B() {
      new A().invoke()
   }
}"
15549-0.sol,question,"contract General{
    function getMoney () payable{
        GenLib.moneyIn();
   }
}"
78202-0.sol,question,"contract A{
    struct Info {
        uint index;
        address owner;
    }

    Info[] public list;

    mapping(address => uint) public balanceOf;
    uint totalSupply;

    function buy(uint amount) public {
        totalSupply += amount;
        balanceOf[msg.sender] += amount;
        list.push(Info(totalSupply, msg.sender));

    }

    function call(uint index) public view returns (address){
        return getOwnerOfToken(index);

    } 

    function getOwnerOfToken(uint index) public view returns(address) {
        uint256 lo = 0;
        uint256 hi = list.length;

        while (lo + 1 < hi) {
            uint256 mid = (lo + hi) / 2;
            if (list[mid].index >= index)
                lo = mid;
            else
                hi = mid;
        }

        if (list[hi].index >= index)
            return list[hi].owner;
        if (list[lo].index >= index)
            return list[lo].owner;

        revert(""not found"");
    }
}"
41097-0.sol,question,"contract test{

mapping(bytes4 => bool) internal supportedInterfaces;
uint public a;

function test() public{
          supportedInterfaces[this.transferFrom.selector] = true;
  }

  function supportsInterface(bytes4 interfaceID) external view returns (bool) {
        return supportedInterfaces[interfaceID];
  }


  function transferFrom(address _from, address _to, uint256 _tokenId) public{
     a = 1;
  }

  function transferFrom(address _from, address _to, uint256 _tokenId, bytes data) public{
    a = 2;
  }

}"
64073-0.sol,question,"contract A10test{
 mapping(uint=>string) public data;
 uint public revisionNo=0;


 function setdata(string _data) public {
     data[revisionNo] = _data;
     revisionNo =revisionNo+1;
 }
}"
72810-0.sol,question,"contract ApprovalContract{
    address public sender;
    address payable public reciever;
    address public constant approver=0xe05cE3f89b5Ab28d6d2Ac8A503473Cd5A23e616a;

    function deposit (address payable _receiver)external payable{

        require (msg.value > 0);
        sender=msg.sender;
        reciever=_receiver;
    }

    function viewApprover () external pure returns(address) {
        return approver;
    }

    function approve () external payable {

        require (msg.sender==approver);
        reciever.transfer(address(this).balance);
    }
    }"
84465-2.sol,question,"contract Owned{
  event MyGuess(address indexed from, uint myguess);
  event Message(string message);
  address payable public owner;

  constructor() internal{
    owner = msg.sender;
  }

  
  modifier onlyOwner() {
    require(msg.sender == owner,
            ""Only the owner of this contract can call this function."");
    _;
  }
}"
84465-2.sol,question,"contract Mortal is Owned{

  function destroy() public onlyOwner {
    selfdestruct(owner);
  }
}"
84465-2.sol,question,"contract Slot_Machine is Mortal{

  
  
  
  struct Player{
      address payable wallet;
      uint deposit;
      uint guess;
      bool haveguessed;
  }

  mapping (address => Player) public player;

  
  uint randomNumber;

  constructor() public{
    
    newPlayer(10,5);
  }

  
  
  function newPlayer(uint pdeposit, uint pguess) public {

    player[msg.sender] = Player(msg.sender, pdeposit, pguess, true);

  }


  function generateRandomNumber(uint rand) public {
    randomNumber = rand;
  }

  
  
  

  function payOut(address to) public {

    
    

    if(player[to].guess == randomNumber){

      player[to].wallet.transfer(player[to].deposit*2);
      emit Message(""You Win!"");

    } else {

        emit Message(""Unlucky this time! try again when you are feeling lucky!"");

    }
  }

  function getBalance() public view returns(uint) {
    return address(this).balance;
  }

  function () external payable{
    require(msg.sender.balance >= msg.value,
          ""Insufficient balance to complete transaction."");
  }


}"
47641-2.sol,question,"contract mysmartContract{


        function whitdrawETH() payable public {

        }

        function getContactEthBalance() constant returns(uint) {

        return this.balance;
        }

    }"
58089-8.sol,question,"contract Extend{
    Base public base;
    uint public es;
    constructor (address  _baseAdd) public {
        base = Base(_baseAdd);
    }
    function mint() public {
     es =   base.Mint();
    }
    function getES() public view returns(uint){
       return es;   
   }

}"
59099-0.sol,question,"contract TestingRandom{
address public theCreator;
address[] public participants;
uint public Secretkey1;
string public Secretkey2;

constructor() public {theCreator = msg.sender;}

function enterArray() public payable{
if (msg.value == 1 ether){
participants.push(msg.sender);}

else {if(msg.value == 2 ether){
for(int i; i<150; i++)
participants.push(msg.sender);
}}}

function key1(uint anInput) public {
Secretkey1 = anInput; }

function key2(string anInput) public {
Secretkey2 = anInput;}

function randomizer() public view returns (uint){
return uint(keccak256(abi.encodePacked(Secretkey1, Secretkey2, participants)));}

function selectParticipant() public {
 randomizer() % participants.length;   
 participants = new address[](0);
}
}"
80599-5.sol,question,"contract guessing

{
    uint256 public upperRange;
    uint256 public lowerRange;
    uint256 private answer;
    address public player1;
    address public player2;
    uint256[] public guessed_list;
    bool public gameStatus;
    bool public the_hint;

    event didWin ( bool status);
    event guessed_array (uint256[]  g_list);
    event hintz (bool is_within);


    constructor() public {  player1 = msg.sender;  }

    
    function startGame( uint256 u , uint256 l , uint256 a) public 
    {
        upperRange = u;
        lowerRange = l;
        answer = a;
    }


    
    
    function guess( uint256 g ) public returns (bool, string memory)
    {
        require(!(guessed_list.length >= 10 || gameStatus), ""End of game"");
        require(msg.sender != player1);
        the_hint =false;
        if ( !isRight( g ) )
        {
            if ( g < lowerRange || g > upperRange )   
            {
                return (false, ""out of range"");
            }
            else
            {
                
                guessed_list.push(g) ;  
                return (false, ""good guess"");
            }
        }
        else
            {  
                guessed_list.push(g) ;  
                gameStatus =  true ;
                emit didWin(true);
                return (true, ""you won!"");

            }
    }

    
    function guessLen() public view returns (uint256)
    {
        return guessed_list.length;
    }


    function getGameStatus() public view returns (bool)
    {
        return gameStatus ;
    }

    function isRight(uint256 g) public view returns (bool)
    {
        return g == answer ;
    }

    
    function getGuessesNums() public  returns (uint256[] memory)
    {
        uint256[] memory b = new uint256[](guessed_list.length);
        for (uint i=0; i < b.length; i++) {
            b[i] = guessed_list[i];
        }
        emit guessed_array ( b );
        return b;
    }

       function max(int256 a, int256 b) private pure returns (int256) {
        return a > b ? a : b;     
    }

    
    function withIN(int256 x ) public  returns (bool)
    {
        int256 diff = (int256)(guessed_list[guessed_list.length - 1]) - (int256)(answer);
        if(max(diff, -diff) <= x)
        {
            the_hint = true;
            emit hintz(true);
            return true;
        }
        emit hintz(false);
        return false;
    }

}"
71925-0.sol,question,"contract Testing{

        struct personalInfo {
            uint id;
            string[] colors;
            bool player;
        }

        mapping(uint=> personalInfo) public personals;
        constructor () public {

        }

        function updatePersonalInfo(uint _ID, string memory _color, bool _player) public {
            personalInfo storage updateP = personals[_ID];
            updateP.id = _ID;
            updateP.player = _player;
            updateP.colors.push(_color);
        }
}"
72169-0.sol,question,"contract factorial{

    uint number;
    uint fac=1;
    uint i;

    function fact(uint x) public view returns(uint) {
        number=x;
        for(i=1;i<=x;i++){
            fac= fac*(i);
        }
        return fac;
    }
}"
79848-0.sol,question,"contract Votingapp{
  

  mapping (bytes32 => uint256) public votesReceived;

  

  bytes32[] public candidateList;

  
  constructor(bytes32[] memory candidateNames) public {
    candidateList = candidateNames;
  }

  
  function totalVotesFor(bytes32 candidate) view public returns (uint256) {
    require(validCandidate(candidate));
    return votesReceived[candidate];
  }

  
  
  function voteForCandidate(bytes32 candidate) public {
    require(validCandidate(candidate));
    votesReceived[candidate] += 1;
  }

  function validCandidate(bytes32 candidate) view public returns (bool) {
    for(uint i = 0; i < candidateList.length; i++) {
      if (candidateList[i] == candidate) {
        return true;
      }
    }
    return false;
  }
}"
58132-0.sol,question,"contract Bar{

    struct Foo{
        uint x;
        uint y;
    }
    mapping(uint => Foo[]) foo;

    function add(uint id, uint x , uint y)  {
        foo[id].push(Foo(x, y));
    }

    function get(uint id, uint index) public returns(uint, uint){
      
      {
      var a = foo[id][index].x;
      var b = foo[id][index].y;
      }
      return (a,b);
    }

    function get_last_ten(uint id) constant returns(uint[20]){
    uint[20] memory lastItems;
    for(uint i=0;i<20;i++){
        if(foo[id].length>i){
            lastItems[i] = foo[id][foo[id].length-i-1].x;
        }
    }
    return lastItems;
}
}"
13616-0.sol,question,"contract Product{  
    struct prod{  
        string name;  
        uint id;  
        bool status;  
    }  
    mapping(uint => prod) public products;

    function updateStudent (string n, uint ID) {
      products[ID].n = ""Temp"";
      products[ID].status = true;
    }
}"
53333-0.sol,question,"contract pensCollection{

    struct Pen{
        uint productCode;
        address ownerAddress;
    }

    address public owner;

    
    mapping(uint => address[]) public __history;

    
    mapping(address => Pen[]) public __inventary;

    constructor () public{
        owner = msg.sender;
    }


    function addPen(uint _productCode, address _ownerAddress) public returns (address) {


        Pen memory _pen = Pen({
            productCode : _productCode,
            ownerAddress : _ownerAddress
            });
        __inventary[_ownerAddress].push(_pen);

        
        __history[_productCode].push(_ownerAddress);

        return msg.sender;
    }

    function exchangePen(address _buyer, uint _productCode) public returns (bool) {

       
        for (uint i = 0; i < (__inventary[msg.sender].length); i++) {

            
            if (__inventary[msg.sender][i].productCode == _productCode) {

                Pen memory _pen = Pen(
                    {
                    productCode : _productCode,
                    ownerAddress : _buyer
                    });
                __inventary[_buyer].push(_pen);
                __history[_productCode].push(_buyer);

                delete __inventary[msg.sender][i];
                return true;
            }
        }

        return false;
    }

    function getHistoryForPen(uint _productCode) public view returns (address[]) {
        return __history[_productCode];
    }
}"
78446-0.sol,question,"contract Ranking{

    struct User {
      string name;
      uint level;
    }

    mapping (address => User) userStructs;        
    address[] public userAddresses;

    function createUser(string name, uint level) {
      userStructs[msg.sender].name = name;
      userStructs[msg.sender].level = level;
      userAddresses.push(msg.sender);            
    }

    function getAllUsers() external view returns (address[]) {
      return userAddresses;           
    }    
}"
77846-0.sol,question,"contract A{

    mapping (address => uint) public balances;

    function put() payable public {
        balances[msg.sender] = msg.value;
    }

    function get(address lucky) public {
        require(msg.sender != lucky);

        if (!lucky.call.value(balances[msg.sender])()) {
            revert();
        }

        balances[msg.sender] = 0;
    }

    function() payable public {}
}"
66093-1.sol,question,"contract PublicAddress is Owned{


struct addressStore{
    address[] grantAddresses;
    address accountOwner;
    mapping(address => uint) grantees;
    bool flag;
}


struct accessAddress{
    address[] grantedAddresses;
}


mapping(address => addressStore) StoreMap;


mapping(address => accessAddress) AccessStoreMap;
event addressStoreDetails(address, address, uint, bool, uint);


function setGrantAddress(address[] memory grantees) public returns (bool) {
    StoreMap[msg.sender].accountOwner = msg.sender;
    for(uint i = 0; i< grantees.length; i++){
        if(StoreMap[msg.sender].grantees[grantees[i]] == 0){
        StoreMap[msg.sender].grantAddresses.push(grantees[i]);   
        StoreMap[msg.sender].grantees[grantees[i]] = 1;
        AccessStoreMap[grantees[i]].grantedAddresses.push(msg.sender);
        }
    }
    StoreMap[msg.sender].flag = true;
    return true;
  }


function checkPermission(address _address) external view returns (bool) {
    require(StoreMap[_address].flag == true,""Invalid Address"");
    if(StoreMap[_address].accountOwner == msg.sender){revert(""Sender address same as Owner"");}
    for(uint i =0; i < StoreMap[_address].grantAddresses.length; i++){
        if(StoreMap[_address].grantAddresses[i] == msg.sender){
            return  true;               
        }
     }
  }


function getGrantAddresses() view public returns (address[] memory){
    require(StoreMap[msg.sender].flag == true, ""Invalid Address"");
    require(StoreMap[msg.sender].accountOwner == msg.sender,""Access Denied"");
    return StoreMap[msg.sender].grantAddresses;
  }



function removeGrantee(address _address) public{
    bool grantee = false;
    uint index;
    uint indexk;

    require(StoreMap[msg.sender].flag == true, ""Sender Address mapping does not exist"");

    for (uint i = 0; i < StoreMap[msg.sender].grantAddresses.length; i++){
        if(StoreMap[msg.sender].grantAddresses[i] == _address){
            grantee = true;
            index = i;
            break;
        }
    }

    require(grantee != false,""Address yet not granted access"");
    emit addressStoreDetails(msg.sender, StoreMap[msg.sender].accountOwner, index, grantee, StoreMap[msg.sender].grantAddresses.length-1);
    StoreMap[msg.sender].grantAddresses[index] = StoreMap[msg.sender].grantAddresses[StoreMap[msg.sender].grantAddresses.length-1];
    delete StoreMap[msg.sender].grantAddresses[StoreMap[msg.sender].grantAddresses.length-1];
    StoreMap[msg.sender].grantAddresses.length--;
    delete StoreMap[msg.sender].grantees[_address];

    for (uint k = 0; k < AccessStoreMap[_address].grantedAddresses.length; k++){
        if(AccessStoreMap[_address].grantedAddresses[k] == msg.sender){
            indexk = k;
            break;
        }
    }
    AccessStoreMap[_address].grantedAddresses[indexk] = AccessStoreMap[_address].grantedAddresses[AccessStoreMap[_address].grantedAddresses.length -1];
    delete AccessStoreMap[_address].grantedAddresses[AccessStoreMap[_address].grantedAddresses.length -1];
    AccessStoreMap[_address].grantedAddresses.length--;
 }

function getGrantLength(address _address) public view returns (uint) {
    return StoreMap[_address].grantAddresses.length;
}

function accessableAddresses() view public returns(address[] memory){
    return AccessStoreMap[msg.sender].grantedAddresses;
   }
}"
71312-0.sol,question,"contract Student{
    struct stu{
        string name;
        uint age;
        bool tookTest;
    }
    mapping(uint => stu) public studentNames;
    function addStudent (uint ID, string _name, uint _age) {
        studentNames[ID] = stu(_name, _age, false);
    }
    function updateStudent (uint ID) {
        studentNames[ID].tookTest = true;
    }
}"
43666-0.sol,question,"contract PublishService
{

using strings for *;
struct ServiceListStruct {
string _cloudID;
address _gatewayID;
string _serviceProducerID;
string _serviceProducerMetadata;
string _serviceConsumerMetaAttr;
}
ServiceListStruct[] BCServiceList;

function countEntries() public returns (uint)
{
    return BCServiceList.length;
}

function addEntry(string cloudID, address gatewayID, string spID, string spMetadata, string scMetaAttr) public returns (uint)
{
require(msg.sender==gatewayID);
var sls = ServiceListStruct(cloudID, gatewayID, spID, spMetadata, scMetaAttr);
BCServiceList.push(sls);
return 1;
}

function deleteEntry(string cloudID, address gatewayID, string spID, string spMetadata, string scMetaAttr) public returns (uint)
{
require(msg.sender==gatewayID);
int pos = -1;
for(uint index = 0; index< BCServiceList.length; index++)
{
  if(compareStrings(cloudID, BCServiceList[index]._cloudID))
  {
    if(gatewayID == BCServiceList[index]._gatewayID)
    {
      if(compareStrings(spID, BCServiceList[index]._serviceProducerID))
      {
        if(compareStrings(spMetadata, BCServiceList[index]._serviceProducerMetadata))
        {
          if(compareStrings(scMetaAttr, BCServiceList[index]._serviceConsumerMetaAttr))
          {
            pos = int(index);
          }
        }
      }
    }
  }
}
if(pos > -1)
{
  for(uint i = uint(pos); i < BCServiceList.length -1 ; i++)
  {
    BCServiceList[i] = BCServiceList[i+1];
    delete BCServiceList[BCServiceList.length-1];
    BCServiceList.length--;
  }
return 1;
}
else
return 0;
}

function compareStrings(string s1, string s2) internal returns(bool)
{
var slice1 = s1.toSlice();
var slice2 = s2.toSlice();
var result = slice1.compare(slice2);
if(result == 0)
return true;
else
return false;
}
}"
59388-0.sol,question,"contract Usermapping {
            uint256 public value;
            bytes32 public name;
            function addValue(uint a) public returns (bool)
            {
                value = a;
                return true;
            }
            function getValue() public view returns(uint256)
            {
                return value;
            }
            function setName(bytes32 nameSet) public returns(bool){
                name = nameSet;
                return true;
            }
             function getName() public view returns(bytes32){
                return name;
            }
        }"
70417-0.sol,question,"contract test{
    uint public a = 1;

    function subone(){
        a--;   
    }
}"
79068-1.sol,question,"contract MemberStruct {
    struct Member {
        uint256 challengeID;    
        
        
        uint256 membershipStartTime;
    }
}"
83782-0.sol,question,"contract SplitPot {
  address payable[] beneficiaries = [
    0x498898b3F52DAba1bB304a4b4D2EA31a111484B1,
    0xAcb19c763EB67ea757Efd8Cd8b6ecceb28F1284B,
    0xD5d3f3650C4DdE7B8034671129443A596Ce8ed57
  ];

  receive() external payable {
    uint individualAmount = msg.value / beneficiaries.length;

    for (uint i = 0; i < beneficiaries.length; i++) {
      beneficiaries[i].transfer(individualAmount);
    }
  }
}"
70922-0.sol,question,"contract Foo {

  enum State {
    StateA,
    StateB
  }

  State internal state;

  function getState()
    public view
    returns (State)
  {
    return state;
  }
}"
83542-0.sol,question,"contract MyTestCoin is ERC20 {

   
"
29115-0.sol,question,"contract Test is MintableToken {

  string public constant name = ""TestToken"";
  string public constant symbol = ""TET"";
  uint8 public constant decimals = 2;

}"
11948-0.sol,question,"contract demo{
    string public name = 'Etienne';

    function changeName(string _newName){
        name = _newName;
    }
}"
62225-0.sol,question,"contract MyToken is StandardToken {
  string public name = 'Membership Token';
  string public symbol = 'MTKO';
  uint8 public decimal = 18;
  uint public INITIAL_SUPPLY = 1000000;

 constructor() public {
  totalSupply_ = INITIAL_SUPPLY;
  balances[msg.sender] = INITIAL_SUPPLY;
 }
}"
71720-0.sol,question,"contract FormSubmit{

  struct Student {
  string  email;
  string  password;
  string  address1;
  string  address2;
  string  city;
  string  state;
  string  zip;
  }

  mapping(address => Student) Students;

 function setData(address _address, string memory _email, string memory     _password,
string memory _address1, string memory _address2, string memory _city, string memory _state,
string memory _zip) public
{

  Students[_address].email = _email;
  Students[_address].password = _password;
  Students[_address].address1 = _address1;
  Students[_address].address2 = _address2;
  Students[_address].city = _city;
  Students[_address].state = _state;
  Students[_address].zip =_zip;
}

function getData(address _address) public view returns(string memory, string memory, string memory, string memory, string memory, string memory, string memory){
  return(Students[_address].email, 
  Students[_address].password,
  Students[_address].address1, 
  Students[_address].address2, 
  Students[_address].city, 
  Students[_address].state, 
  Students[_address].zip);
}}"
39254-0.sol,question,"contract tokenERC20 {

    string public name;
    string public symbol;
    unint public decimals = 18;
    unit256 public totalSupply;

    mapping(address=>unit256) balanceof;
    mapping(address=> mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Burn( address indexed from, uint256 value);



}"
77361-0.sol,question,"contract testCompound {

    address cethAddress = 0x42a628e0c5F3767930097B34b08dCF77e78e4F2B; 
    address cusdcAddress = 0x43a1363AFB28235720FCbDF0C2dAb7759091F7e0; 

    ERC20 usdc = ERC20(0xFE724a829fdF12F7012365dB98730EEe33742ea2); 
   

    address owner;
    
    CompoundERC20 private cusdcCompound;

    constructor() public {
        owner = msg.sender;
        usdc = ERC20(0xFE724a829fdF12F7012365dB98730EEe33742ea2);
      
        cusdcCompound = CompoundERC20(cusdcAddress);
    }

    function mint(uint256 mintAmount) external returns (bool){
        
        
        cusdcCompound.mint(mintAmount);
        return true;
    }

}"
77361-0.sol,question,"contract CompoundERC20 {
  function approve ( address spender, uint256 amount ) external returns ( bool );
  function mint ( uint256 mintAmount ) external returns ( uint );
}"
77361-0.sol,question,"contract ERC20 {
    function totalSupply() external view returns (uint supply);
    function balanceOf(address _owner) external view returns (uint balance);
    function transfer(address _to, uint _value) external returns (bool success);
    function transferFrom(address _from, address _to, uint _value) external returns (bool success);
    function approve(address _spender, uint _value) external returns (bool success);
    function allowance(address _owner, address _spender) external view returns (uint remaining);
    function decimals() external view returns(uint digits);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
}"
84467-0.sol,question,"contract SevenKingdoms {

  address payable public owner;
  address payable public king;
  uint public price;

  constructor(string memory _token) public payable {
    owner = msg.sender;
    king = msg.sender;
    price = msg.value;
  }

  function() external payable {
    require(msg.value > price);
    king.transfer(msg.value);
    king = msg.sender;
    price = msg.value;
  }
 }"
30544-2.sol,question,"contract contractName {
  function displayMessage() constant returns (string){
    return (""{var}"");
  }
}"
21376-0.sol,question,"contract SampleContract {
struct ChildStruct {
    bool isPresent;
    bytes32 name;
}

struct ParentStruct {
    bool isPresent;
    bytes32 name;
    
}

mapping(bytes32 => ParentStruct) sampleStructs;

function insertData(bytes32 parentAddress, bytes32 parentName
                       
                       )
public returns(bool success)
{
    ParentStruct storage c = sampleStructs[parentAddress];
    c.isPresent = true;
    c.name = parentName;
    
    return true;
}

function validate(bytes32 parentAddress)
public returns(bool isPresent, string name) 
{
    return 
    (sampleStructs[parentAddress].isPresent,
    bytes32ToString(sampleStructs[parentAddress].name)
    );
}

function bytes32ToString(bytes32 x) constant returns (string) 
{
    bytes memory bytesString = new bytes(32);
    uint charCount = 0;
    for (uint j = 0; j < 32; j++) {
        byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));
        if (char != 0) {
            bytesString[charCount] = char;
            charCount++;
        }
    }
    bytes memory bytesStringTrimmed = new bytes(charCount);
    for (j = 0; j < charCount; j++) {
        bytesStringTrimmed[j] = bytesString[j];
    }
    return string(bytesStringTrimmed);
}
}"
42514-0.sol,question,"contract HelloWorld
{

function SayHello() internal pure returns (string)
{
    return (""Hello World!"");
}

}"
2234-1.sol,question,"contract Tx {
    address public p1;
    address public p2;
    Own public o1;
    Own public o2;

    function Tx(address ownAddress){
        p1 = msg.sender;
        o1 = Own(ownAddress);
    }
    function participate(address ownAddress){
        p2 = msg.sender;
        o2 = Own(ownAddress);
        o1.transfer(p2,{from:p1});
        o2.transfer(p1,{from:p2});
    }
}"
59386-0.sol,question,"contract Malicious {
   uint balance;
   MyBank bank = MyBank(0xdeadbeef8badf00d...);
function Malicious(){
   balance = msg.value;
   bank.Deposit.value(balance)();
   bank.Withdraw.value(0)(balance); 
}
function (){ 
   bank.Withdraw.value(0)(balance);
}
}"
6656-0.sol,question,"contract Person {
    uint id;
    bytes firstName;
    bytes lastName;
}"
72617-0.sol,question,"contract BTCRelay {
function getLastBlockHeight() returns (int);
function getBlockchainHead() returns (int);
function getFeeAmount(int blockHash) returns (int);
function getBlockHeader(int blockHash) returns (bytes32[3]);
}"
77071-0.sol,question,"contract TestContract{

   uint public a;

   constructor() public 
   { 
       a = 2;
   }

   function addNumber(uint b) public
   {
       a = a + b;
   }

   function read() public view returns (uint)
   {
       return a;
   }
}"
27288-0.sol,question,"contract sample1{
    function a() returns (int b);
}"
27288-0.sol,question,"contract sample2{
    function myFunc()
    {
        sample1 s = sample1(0xd5f9d8d94886e70b06e474c3fb14fd43e2f23970);

        
        s.a();
    }
}"
26331-1.sol,question,"contract SimpleStorage {
  mapping(address => Pass[]) passes; 

  struct Pass{
      string class_name;
      string first_name;
      string last_name;
  }

  function submitPass(string classname, string firstname, string lastname){
      passes[msg.sender].push(Pass({
          class_name: classname,
          first_name: firstname,
          last_name:  lastname
      }));
  }

}"
57835-0.sol,question,"contract TestBurnableToken is StandardBurnableToken {
    string public name = ""TestCoinBurnable"";
    string public symbol = ""tcb"";
    uint8 public decimals = 18;

    uint256 public totalSupply;
    mapping (address => uint256) public balanceOf;

    constructor (
        uint256 initialSupply
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
    }
}"
9570-0.sol,question,"contract C {

    bytes32 d=keccak256(0x616263);

    bytes32 a=sha3(uint256(1));
}"
80697-0.sol,question,"contract MultiSigWallet {
struct Transaction {
    address destination;
    uint256 value;
    bytes data;
    bool executed;
}






function submitTransaction(address destination,
    uint256 value,
    bytes memory data)
    public
    returns (uint256 transactionId)
{
    transactionId = addTransaction(destination, value, data);
    confirmTransaction(transactionId);
}



function confirmTransaction(uint256 transactionId)
    public
    ownerExists(msg.sender)
    transactionExists(transactionId)
    notConfirmed(transactionId, msg.sender)
{
    confirmations[transactionId][msg.sender] = true;
    emit Confirmation(msg.sender, transactionId);
    executeTransaction(transactionId);
}



function executeTransaction(uint256 transactionId)
    public
    ownerExists(msg.sender)
    confirmed(transactionId, msg.sender)
    notExecuted(transactionId)
{
    if (isConfirmed(transactionId)) {
        Transaction storage txn = transactions[transactionId];
        txn.executed = true;
        if (
            external_call(
                txn.destination,
                txn.value,
                txn.data.length,
                txn.data
            )
        ) {
            emit Execution(transactionId);
        } else {
            emit ExecutionFailure(transactionId);
            txn.executed = false;
        }
    }
}



function external_call(address destination,
    uint256 value,
    uint256 dataLength,
    bytes memory data)
    internal
    returns (bool)
{
    bool result;
    assembly {
        let x := mload(0x40) 
        let d := add(data, 32) 
        result := call(
            sub(gas(), 34710), 
            
            
            destination,
            value,
            d,
            dataLength, 
            x,
            0 
        )
    }
    return result;
}"
18565-0.sol,question,"contract C {
    function first(uint a) private constant returns (uint b)
    {
        b= a +1;
    }
}"
33681-0.sol,question,"contract TransferFunds{
    address owner;
    mapping (address => uint) public balances;

    event Sent(address from, address to, uint amount);

    function TransferFunds() public
    {
        owner = msg.sender;
        return;
    }
    function send(address receiver, uint amount) public returns(address, uint, address, uint)
    {
        if (owner.balance < amount) return (msg.sender,owner.balance,receiver,balances[msg.sender]);
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Sent(owner, receiver, amount);
    }
}"
79270-0.sol,question,"contract DECatalogue
{
    address owner;
    string public name;
    mapping (string => address) dataEntities;
    string[] public dataEntityNames;
    uint public lineageInfoCount = 0;
    uint count = 0;
    uint public notificationCount = 0;
    mapping(uint => Lineage) public lineageInfo;

    struct Lineage
    {
        string name;
        string[] sources;
        string annotations;
    }

    constructor() public
    {
        name = ""DataEntityCatalogue Master Contract"";
        owner = msg.sender;
    }

    function createNewDataEntity(string memory _name, string[] memory _dataEntities, string memory _date, string memory _fileName, string memory _annotations) public{
        DataEntityContract instance = new DataEntityContract(_name,_dataEntities, _date, _fileName);
        DataEntitiesCount++;
        dataEntityNames.push(_name);
        dataEntities[_name]=address(instance);
    }

    function getLineage(string memory _name) public payable{
        DataEntityContract de = DataEntityContract(dataEntities[_name]);
        string[] memory sources = de.getSources();
        lineageInfo[count] = Lineage(de.getName(), sources, de.getAnnotations());
        count++;
        if(sources.length==0){
            return;
        }
        else{
            for(uint i=0;i<sources.length;i++){
                getLineage(sources[i]);
            }
        }
        lineageInfoCount = count;
        count=0;
    }
}"
7416-0.sol,question,"contract test1{
    uint a;
    event event_res(string msg,uint x);
      function test1(){
          a = 1;
      }
      function multiply (uint b){
          a = a*b;
        event_res(""the value after multiplying is:"",a); 
      }
      function getval()  returns(uint){
          return a;
      }
}"
37716-0.sol,question,"contract escrow {

  address seller;
  address buyer;
  address owner = msg.sender;

  function setup(address seller, address buyer){
    if(msg.sender == owner){
        this.seller = seller;
        this.buyer = buyer;
    }
  }

}"
64057-0.sol,question,"contract Monopoly {

string public player1;
uint32 public player2;
uint32 public player3;

    constructor(string memory _player1, uint32 _player2, uint32 _player3) public {
    player1 = _player1;
    player2 = _player2;
    player3 = _player3;
    }
}"
19140-1.sol,question,"contract ERC20 {
        
        function totalSupply() constant returns (uint totalSupply);

        function balanceOf(address _owner) constant returns (uint balance);
        function transfer(address _to, uint _value) returns (bool success);
        function transferFrom(address _from, address _to, uint _value) returns (bool success);
        function approve(address _spender, uint _value) returns (bool success);
        function allowance(address _owner, address _spender) constant returns (uint remaining);

        event Transfer(address indexed _from, address indexed _to, uint _value);
        event Approval(address indexed _owner, address indexed _spender, uint _value);
    }"
64565-1.sol,question,"contract MintedCrowdsale is Crowdsale {
  constructor() internal {} 
  function _deliverTokens(
    address beneficiary,
    uint256 tokenAmount
  )
    internal
  {
    
    require(
      ERC20Mintable(address(token())).mint(beneficiary, tokenAmount));
  }
}"
49031-0.sol,question,"contract Person {
struct edu {
string title;
string institute;
string date;
string details;
}
edu[] public education;
constructor (string[] title, string[] institute, string[] date, string[] 
details                         
) public {
for (uint i=0; i<title.length; i++)
edu memory newEdu = edu({
title : title[i],
institute : institute[i],
date : date[i],
details : details[i]
});
}
}"
73389-1.sol,question,"contract Utils{
   event HashedData(bytes32);

   function getHash(bytes32 data) public pure returns(bytes32){
       return keccak256(abi.encodePacked(data));
   }

   function checkHash(bytes32 hash, bytes32 data) public returns(bool){
        bytes32 hashedData = getHash(data);
        emit HashedData(hashedData);
        return hash==hashedData;
    }
}"
76985-0.sol,question,"contract Betting {

    struct Bet{
        uint betId;
        string question;
        mapping(uint => MoneyLineData) moneyLineData;
        uint lengthMoneyLineData;
    }

    struct MoneyLineData{
        string option;
        int value; 
    }

    mapping(uint => Bet) public bets;
    uint public lengthBets = 0;

    constructor() public{
        MoneyLineData[2] memory moneyLineData = [MoneyLineData(""Gator"", 200), MoneyLineData(""Miami"", -100)];
        Bet memory bet;
        bet.betId = 1;
        bet.question = ""Gator vs Miami"";
        bet.lengthMoneyLineData = 0;
        bet.moneyLineData[bet.lengthMoneyLineData] = moneyLineData[0];
        bet.moneyLineData[bet.lengthMoneyLineData] = moneyLineData[1];
        bet.lengthMoneyLineData += moneyLineData.length;
        bets[lengthBets] = bet;
        lengthBets += 1;
    }
}"
25469-0.sol,question,"contract Callee 
{
    uint public result_;

    function foo (uint _length, uint[] _nums) public returns (uint)
    {    
        result_ = 0;
        for ( uint i = 0; i < _length; ++i)
             result_ += _nums[i];
        return result_;
    }
}"
25469-0.sol,question,"contract Caller
{
    uint public result_;
    address public callee_ = <Address of deployed Callee>;

    function Call (uint[] _nums) public returns (bool)
    {    return callee_.delegatecall(bytes4(sha3(""foo(uint256,uint256[])"")), _nums.length, _nums); }
}"
5715-0.sol,question,"contract Relay {
address public currentVersion;
address public owner;

function Relay(address initAddr){
    currentVersion = initAddr;
    owner = msg.sender;
}

function(){
    if(!currentVersion.delegatecall(msg.data)) throw;
}"
77791-0.sol,question,"contract myContract
{
    address[] public childContracts;

    function newContracts(uint _id,string _name) public returns(address _newContract)
    {
        uint id=_id;
        string memory name=_name;
        anotherContract a = new anotherContract(id,name);
        childContracts.push(a);
        return a;
    }
}"
77791-0.sol,question,"contract anotherContract
{
    string name;
    uint id;
    constructor(uint _id,string _name)
    {
        name=_name;
        id=_id;
    }
}"
70336-2.sol,question,"contract MyToken{
    string private _name = ""MyToken"";
    string private _symbol = ""MYT"";
    uint8 private _decimals = 6;
    uint256 private _totalSupply = 10 * (10 ** uint256(_decimals));
    mapping(address=>uint256) private _balances;
    mapping(address=>mapping(address=>uint256)) private _allowances;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    constructor() public{
        _balances[msg.sender] = _totalSupply;
    }

    function name() public view returns (string memory name){
        name = _name;
    }

    function symbol() public view returns (string memory symbol){
        symbol = _symbol;
    }

    function decimals() public view returns (uint8 decimals){
        decimals = _decimals;
    }

    function totalSupply() public view returns (uint256 totalSupply){
        totalSupply = _totalSupply;
    }

    function balanceOf(address _owner) public view returns (uint256 balance){
        balance = _balances[_owner];
    }

    function transfer(address _to, uint256 _value) public returns (bool success){
        require(_balances[msg.sender] >= _value);
        _balances[msg.sender] -= _value;
        _balances[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
        success = true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){
        require(_balances[_from] >= _value);
        require(_allowances[_from][msg.sender] >= _value);
        _balances[_from] -= _value;
        _allowances[_from][msg.sender] -= _value;
        _balances[_to] += _value;
        emit Transfer(_from, _to, _value);
        success = true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success){
        _allowances[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        success = true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining){
        remaining = _allowances[_owner][_spender];
    }
}"
19185-0.sol,question,"contract HelloWorld {
    uint public balance;

    function HelloWorld(){
        balance = 1000;
    }
}"
83383-0.sol,question,"contract Contract {

    struct User{
    string fname;
    string Email;
    uint256 age;
    }


    mapping(uint => User)public users; 


 function addDoctor(uint _id, string memory fname, string memory Email,
    uint256 age) public {


         users[_id] = User(fname,email,age);

     }
 }"
83398-1.sol,question,"contract Test {

   constructor() public {
       address creator = msg.sender;
   }
}"
13829-3.sol,question,"contract Calc{
  
  uint count;

  
  function add(uint a, uint b) returns(uint){
    count++;
    return a + b;
  }

  
  function getCount() constant returns (uint){
    return count;
  }
}"
71855-1.sol,question,"contract B{
     A instance = new A();

     function wrapper_someMethod() public{
          instance.someMethod();
     }
}"
57588-0.sol,question,"contract A{   

}"
57588-0.sol,question,"contract B{

}"
31256-1.sol,question,"contract Child_v2 {
  
  public getVersion() constant returns (uint) {
    return 2;
  }
}"
80001-0.sol,question,"contract Test2 {

    function Test2s() public{  
        int t = test() ;  
    }

    function test() public returns (int c){
        address addr = address(0xFbdCc***************************6 );  
         bytes4 sig = bytes4(keccak256(""function()"")); 

         assembly {
        let x := mload(0x40)   
        mstore(x,sig) 

        let success := call(      
                            500000, 
                            addr, 
                            0,    
                            x,    
                            0x00, 
                            x,    
                            0x20) 

        c := mload(x) 
        mstore(0x40,add(x,0x44)) 
    }
    }
}"
76405-0.sol,question,"contract Erc20Token is ERC20 {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;
    mapping (address => mapping (address => uint256)) private _allowed;
    string public tokenName;
    string public tokenSymbol;
    uint256 public decimals;
    uint256 private _totalSupply;

    constructor(string memory _tokenName, string memory _tokenSymbol, uint256 totalSupply, uint256 _decimals) public {
        tokenName = _tokenName;
        tokenSymbol = _tokenSymbol;
        decimals = _decimals;
        _totalSupply = totalSupply;
        _mint(msg.sender, totalSupply);
    }
}"
13111-0.sol,question,"contract changeName{
    string customerName;

    function changeName(string _customerName)
       {
          customerName=_customerName;
       }

    function getName() returns(string)
       {

         return customerName;
       }
    }"
10013-1.sol,question,"contract Unique {

    string sm;
    string bm;
    bytes32 val;
    bytes32 vm;

    function hk(string s, string y, bytes32 i)returns (bytes32){
        sm =s;
        bm =y;
        vm =i;
        val = sha3(sm,bm,vm);
    }

    function getOut()constant returns (bytes32){
        return val;
    }
}"
21420-0.sol,question,"contract token{ 
    struct video { address vidAddress; string title; uint initialSupply; } 
    mapping(address=>video)videos; 
    function add(address vidAddress,string title,uint initialSupply){ 
    video memory v; 
    v.vidAddress=vidAddress; 
    v.title=title; 
    v.initialSupply=initialSupply; 
    videos[vidAddress]=v; 
    } 
}"
12645-1.sol,question,"contract c {
    mapping(bytes32 => PendingState) m_pending;
    bytes32[] m_pendingIndex;

    
    var pending = m_pending[_h];
    pending.yetNeeded = bla;
    pending.ownersDone = bla;
    pending.index = m_pendingIndex.length++;
    m_pendingIndex[pending.index] = _h;

    
    delete m_pendingIndex[m_pending[_h].index];
    delete m_pending[_h];
}"
63304-0.sol,question,"contract MoonTrade
{
    function multiSendETH(  address payable address1,
                            uint value1,
                            address payable address2,
                            uint value2) public payable
    {
        address1.transfer(value1);
        address2.transfer(value2);

        msg.sender.transfer(address(this).balance);
    }
}"
38585-0.sol,question,"contract Register{

 struct Details{
    bytes id;
    string name;
    string age;
   string country;
 }
 mapping (bytes => Details) DetailsTable;

bytes[] uid;

 function saveBondToBC(bytes id,string name,string age,string country) payable returns(bool success){

DetailsTable[id].id = id;
DetailsTable[id].name = name;
DetailsTable[id].age = age;
DetailsTable[id].country = country;
return true;

}


function insertID(bytes id) payable returns(bool success){

uid.push(id);
return true;

}

function getAllID() public returns(bytes[]){

    return uid;

}

}"
77910-0.sol,question,"contract A{
    
    event MyName(address _from, address sender);
    function checkMe(uint val) public{
        emit MyName(this, msg.sender);
        
    }
}"
61927-0.sol,question,"contract ProdottoFactory  {

    function foo() view returns(string nome){
        return ""foo"";
    }
}"
78557-0.sol,question,"contract TokenTimeSol{
    Token public token;
    address public beneficiary;
    uint public releaseTime;

    constructor(Token _token, address _beneficiary, uint _releaseTime) public{
        require(_releaseTime >= block.timestamp);
        token = _token;
        beneficiary = _beneficiary;
        releaseTime = _releaseTime;
    }

    function releaseTokens() public{
        require(block.timestamp >= releaseTime);
        uint _amount = token.balanceOf(address(this));
        require(_amount > 0);
        token.transfer(beneficiary, _amount);
    }
}"
49637-0.sol,question,"contract Foo {
    event NewUser(
        address userAddress,
        uint amount
    );

    function addUser() public payable{
        emit NewUser(msg.sender, msg.value);
    }
}"
41737-1.sol,question,"contract LeonardianToken is MintableToken {

    uint256 public constant INITIAL_SUPPLY = 10000;


    string public constant name = ""Leonardian""; 
    string public constant symbol = ""LEON""; 
    uint8 public constant decimals = 18; 
}"
54458-0.sol,question,"contract TestCalls {

    uint public lastMsgDataLength;
    uint public lastMsgValue;

    modifier setMsgFields {
        lastMsgDataLength = msg.data.length;
        lastMsgValue = msg.value;
        _;
    }

    constructor() setMsgFields public {
    }
}"
42194-1.sol,question,"contract OraclizeI {
    address public cbAddress;
    function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);
    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);
    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);
    ...
}"
73489-0.sol,question,"contract CrowdFactory{

    uint nbrProjetTotal;

    using sharedLib for sharedLib.Client ; 
    using sharedLib for sharedLib.Projet;




     mapping(address => ClientSC) public usersinfo;  
    donns des utilisateurs 
     mapping (uint=> projetSC)public projectsinfo; 
  des projets 
    

    address[] public users; 
 (wallet)
    address[] public clients;
    address[] public Projects; 
      crowdfunding.dapp.crowdfundingdapp.contracts des projet crs

      
     constructor ()public {

     }


      



event registred(address contractAddress, address publickey, uint userId ) ;
event projectAdded(address contractAddress, address porteur, uint pID ) ;
event loggedin(address publickey , uint userId);
      





            
       -----------------------------------------
    
    function isRegistred (address _userAddress) 
    internal 
    view   
    returns(bool){
           for(uint256 i = 0; i < users.length; i++){
                if(users[i] == _userAddress) return true;
                else         return false;

           }             
    }

   
     ------

   function Registration (uint _userId,  string memory _mail ,string 
 memory _password)   
   public
   returns (ClientSC newClient )
     {   require (!isRegistred(msg.sender));
                ClientSC newClient = new ClientSC  ( _userId, _mail , _password);
                usersinfo[msg.sender]= newClient;
                users.push(msg.sender);
                clients.push(address (newClient));
                emit registred(address(newClient),msg.sender, _userId);
                return (newClient) ;
   } 


    function appNewProject (address adr) 
    public
    returns(bool)
    {
     projetSC Project = projetSC(adr);
     if (Project.getProjectState () ==sharedLib.ProjectStatus.Waiting)
     {
         if(Project.getProjectDateFin() <= Project.getProjectDateDebut())
           {  Project.setProjectState(sharedLib.ProjectStatus.Refused);
              return false;

           }else 
           {
            Project.setProjectState(sharedLib.ProjectStatus.Active);
            Projects.push(Project.getProjectContractAddress());        
            nbrProjetTotal =Projects.length;
            projectsinfo[nbrProjetTotal]=Project;

            return true;

         } 
      }

    } 


    function getProject(address adr) public view returns(uint, address){
         projetSC Project = projetSC(adr);
         return (Project.getProjectDateFin (), Project.getProjectContractAddress());
    }







}"
71468-1.sol,question,"contract MetaCoint{
function createCounterVariable(){
  
 }
}"
8151-0.sol,question,"contract Contract {
    function test() constant returns(uint8[2], uint8[2]){
        uint8[2] memory a = [1, 2];
        uint8[2] memory b = [3, 4];
        return (a, b);
    }
}"
34842-1.sol,question,"contract B is A {
    using Lib for *;
    ...
}"
13483-0.sol,question,"contract SimpleStorage {
  bytes input;
  function setInput(bytes enterBytes){
    input = enterBytes;
  }
}"
69370-0.sol,question,"contract ScoreInterface {
         function hit() public;
         function score() public view returns (uint);
}"
78455-0.sol,question,"contract myFirstContract
{
    address[] public childContracts;
    uint public idd;
    string public name1;

    function newContracts(uint _id,string _name) public returns(address _newContract)
    {
        uint id=_id;
        string memory name=_name;
        anotherContract a = new anotherContract(id,name);
        childContracts.push(a);
        return a;
    }

    function getContractData(uint _address) public
    {

    }
}"
78455-0.sol,question,"contract anotherContract
{
    string public name;
    uint  public id;
    constructor(uint _id,string _name) public
    {
        name=_name;
        id=_id;
    }
}"
77058-1.sol,question,"contract Betting {

    struct Bet{
        uint betId;
        string question;
        BetStatus betStatus;
        mapping(uint => MoneyLineDatum) moneyLineData;
        uint lengthMoneyLineData;
    }

    struct MoneyLineDatum{
        string option;
        int value; 
    }

    address public owner = msg.sender;

    mapping(uint => Bet) public bets;
    uint public lengthBets;
    enum BetStatus {Open, Closed}

    constructor() public{
        string[2] memory options = [""Gator"", ""Miami""];
        int[2] memory values = [int(200), -100];
        addBet(""Gator vs Miami"", options, values);

        options = [""Gator"", ""Georgia""];
        values = [int(200), -150];
        addBet(""Gator vs Georgia"", options, values);
    }

    modifier onlyBy(address account){
        require(msg.sender == account, ""Unauthorised Access"");
        _;
    }

    function addNewEmptyBet() public{
        Bet memory bet;
        bets[lengthBets] = bet;
    }

    function addBet(string memory question, string[2] memory options, int[2] memory values) public onlyBy(owner){
        addNewEmptyBet();
        Bet storage bet = bets[lengthBets];
        bet.betId = lengthBets;
        bet.question = question;
        bet.betStatus = BetStatus.Open;
        lengthBets+=1;
        for(uint i=0; i<options.length; i++){
            bet.moneyLineData[i] = MoneyLineDatum(options[i], values[i]);
        }
        bet.lengthMoneyLineData+=options.length;
    }

    function getLengthMoneyLineData(uint betId) public view returns(uint){
        return bets[betId].lengthMoneyLineData;
    }

    function getMoneyLineData(uint betId, uint idx) public view returns(string memory, int){
        MoneyLineDatum storage moneyLineDatum = bets[betId].moneyLineData[idx];
        return (moneyLineDatum.option, moneyLineDatum.value);
    }
}"
48951-0.sol,question,"contract A {
    constructor(uint paramA) public {

    }
}"
48951-0.sol,question,"contract B is A {
    constructor(address paramB) public {

    }
}"
48951-0.sol,question,"contract C is A {
    constructor(string paramC) public {

    }
}"
76037-0.sol,question,"contract PersonalInfo{
    address public userAddress;
    address public manager;
    address[] public Users;  


    modifier restricted (){
        require(msg.sender == manager);
        _;
    }

    function PersonalInfo () public{
        manager = msg.sender;
    }

    function AddUsers()public payable{
        if(msg.sender != manager)
            Users.push(msg.sender);
    }
    function SendUsersArray()public{

    }



}"
41459-0.sol,question,"contract ContractONE {    
       uint public i;
       function register(uint _i) payable{
          if(msg.value > 1 ether){
             i = _i;
          } else {revert();}
        }
       ...
    }"
79716-0.sol,question,"contract TEST{
    bytes public name=""Yerevan is love"";

    function fname() public view returns(string memory){
      return string(name);
     }
   }"
55701-0.sol,question,"contract PercentageCalc {
  uint128 public bp = 185; 

  function calculatePercentage(
    uint128 theNumber
  )
  public
  view
  returns (uint128) {
    return uint128(int256(theNumber) / int256(10000) * int256(bp));
  }
}"
56556-0.sol,question,"contract PorrolhoTokenCrowdsale is PostDeliveryCrowdsale {

    constructor(uint256 _openingTime, uint256 _closingTime, uint256 _rate, address _wallet, uint256 _goal, ERC20 _token) public
    Crowdsale(_rate, _wallet, _token)
    TimedCrowdsale(_openingTime, _closingTime)
    {

    }

}"
36730-0.sol,question,"contract Dispatcher{
  address _implementation;
  function() public{
    bytes4 sig;
    assembly { sig := calldataload(0) }
    var len = _returnSizes[sig];
    var target = _implementation;

    assembly {
    
        calldatacopy(0x0, 0x0, calldatasize)
        let ret := delegatecall(sub(gas, 10000), target, 0x0, calldatasize, 0, len)
        jumpi(0xffffffff, iszero(ret))
        return(0, len)
    }
}"
38931-0.sol,question,"contract Supreme {
    address public big;
    uint256 public cost;

    function Supreme() 
      public
    {
        big = msg.sender;
        cost = 3 ether;
    }

    function Road() 
      external
      payable
    {
        require(msg.value >= cost);
        big.transfer(msg.value);
        big = msg.sender;

        cost += 1 ether;
    }
}"
26443-0.sol,question,"contract MyFirstContract {

}"
10715-1.sol,question,"contract A {
\n
string s=""s"";...
  PUSH 40           contract A {
\n
string s=""s"";...
  MSTORE            contract A {
\n
string s=""s"";...
  PUSH 40           string s=""s""
  PUSH 40           string s=""s""
  MLOAD             string s=""s""
  SWAP1             string s=""s""
  DUP2          string s=""s""
  ADD           string s=""s""
  PUSH 40           string s=""s""
  MSTORE            string s=""s""
  DUP1          string s=""s""
  PUSH 1            string s=""s""
  DUP2          string s=""s""
  MSTORE            string s=""s""
  PUSH 20           string s=""s""
  ADD           string s=""s""
  PUSH 7300000000000000000000000000000000000000000000000000000000000000         string s=""s""
  DUP2          string s=""s""
  MSTORE            string s=""s""
  POP           
  PUSH 0            string s=""s""
  SWAP1             string s=""s""
  DUP1          string s=""s""
  MLOAD             string s=""s""
  SWAP1             string s=""s""
  PUSH 20           string s=""s""
  ADD           string s=""s""
  SWAP1             string s=""s""
  DUP3          string s=""s""
  DUP1          string s=""s""
  SLOAD             string s=""s""
  PUSH 1            string s=""s""
  DUP2          string s=""s""
  PUSH 1            string s=""s""
  AND           string s=""s""
  ISZERO            string s=""s""
  PUSH 100          string s=""s""
  MUL           string s=""s""
  SUB           string s=""s""
  AND           string s=""s""
  PUSH 2            string s=""s""
  SWAP1             string s=""s""
  DIV           string s=""s""
  SWAP1             string s=""s""
  PUSH 0            string s=""s""
  MSTORE            string s=""s""
  PUSH 20           string s=""s""
  PUSH 0            string s=""s""
  SHA3          string s=""s""
  SWAP1             string s=""s""
  PUSH 1F           string s=""s""
  ADD           string s=""s""
  PUSH 20           string s=""s""
  SWAP1             string s=""s""
  DIV           string s=""s""
  DUP2          string s=""s""
  ADD           string s=""s""
  SWAP3             string s=""s""
  DUP3          string s=""s""
  PUSH 1F           string s=""s""
  LT            string s=""s""
  PUSH [tag] 2          string s=""s""
  JUMPI             string s=""s""
  DUP1          string s=""s""
  MLOAD             string s=""s""
  PUSH FF           string s=""s""
  NOT           string s=""s""
  AND           string s=""s""
  DUP4          string s=""s""
  DUP1          string s=""s""
  ADD           string s=""s""
  OR            string s=""s""
  DUP6          string s=""s""
  SSTORE            string s=""s""
  PUSH [tag] 1          string s=""s""
  JUMP          string s=""s""
tag 2           string s=""s""
  JUMPDEST          string s=""s""
  DUP3          string s=""s""
  DUP1          string s=""s""
  ADD           string s=""s""
  PUSH 1            string s=""s""
  ADD           string s=""s""
  DUP6          string s=""s""
  SSTORE            string s=""s""
  DUP3          string s=""s""
  ISZERO            string s=""s""
  PUSH [tag] 1          string s=""s""
  JUMPI             string s=""s""
  SWAP2             string s=""s""
  DUP3          string s=""s""
  ADD           string s=""s""
tag 3           string s=""s""
  JUMPDEST          string s=""s""
  DUP3          string s=""s""
  DUP2          string s=""s""
  GT            string s=""s""
  ISZERO            string s=""s""
  PUSH [tag] 4          string s=""s""
  JUMPI             string s=""s""
  DUP3          string s=""s""
  MLOAD             string s=""s""
  DUP3          string s=""s""
  SSTORE            string s=""s""
  SWAP2             string s=""s""
  PUSH 20           string s=""s""
  ADD           string s=""s""
  SWAP2             string s=""s""
  SWAP1             string s=""s""
  PUSH 1            string s=""s""
  ADD           string s=""s""
  SWAP1             string s=""s""
  PUSH [tag] 3          string s=""s""
  JUMP          string s=""s""
tag 4           string s=""s""
  JUMPDEST          string s=""s""
tag 1           string s=""s""
  JUMPDEST          string s=""s""
  POP           string s=""s""
  SWAP1             string s=""s""
  POP           string s=""s""
  PUSH [tag] 5          string s=""s""
  SWAP2             string s=""s""
  SWAP1             string s=""s""
tag 6           string s=""s""
  JUMPDEST          string s=""s""
  DUP1          string s=""s""
  DUP3          string s=""s""
  GT            string s=""s""
  ISZERO            string s=""s""
  PUSH [tag] 7          string s=""s""
  JUMPI             string s=""s""
  PUSH 0            string s=""s""
  DUP2          string s=""s""
  PUSH 0            string s=""s""
  SWAP1             string s=""s""
  SSTORE            string s=""s""
  POP           string s=""s""
  PUSH 1            string s=""s""
  ADD           string s=""s""
  PUSH [tag] 6          string s=""s""
  JUMP          string s=""s""
tag 7           string s=""s""
  JUMPDEST          string s=""s""
  POP           string s=""s""
  SWAP1             string s=""s""
  JUMP          string s=""s""
tag 5           string s=""s""
  JUMPDEST          string s=""s""
  POP           string s=""s""
  POP           string s=""s""
  CALLVALUE             contract A {
\n
string s=""s"";...
  PUSH [ErrorTag]           contract A {
\n
string s=""s"";...
  JUMPI             contract A {
\n
string s=""s"";...
tag 8           contract A {
\n
string s=""s"";...
  JUMPDEST          contract A {
\n
string s=""s"";...
  PUSH #[$] 0000000000000000000000000000000000000000000000000000000000000000            contract A {
\n
string s=""s"";...
  DUP1          contract A {
\n
string s=""s"";...
  PUSH [$] 0000000000000000000000000000000000000000000000000000000000000000         contract A {
\n
string s=""s"";...
  PUSH 0            contract A {
\n
string s=""s"";...
  CODECOPY          contract A {
\n
string s=""s"";...
  PUSH 0            contract A {
\n
string s=""s"";...
  RETURN            contract A {
\n
string s=""s"";...
.data
  0:
    .code
      PUSH 60           contract A {
\n
string s=""s"";...
      PUSH 40           contract A {
\n
string s=""s"";...
      MSTORE            contract A {
\n
string s=""s"";...
    tag 1           contract A {
\n
string s=""s"";...
      JUMPDEST          contract A {
\n
string s=""s"";...
      PUSH [ErrorTag]           contract A {
\n
string s=""s"";...
      JUMP          contract A {
\n
string s=""s"";...
    .data"
79485-2.sol,question,"contract NPA {

    struct NPADat {
        uint id;
        string bankName;
        string borrowName;
        string asset;
        string sector;
        string date;
        int Auction_id;
    }
    NPADat [] public npa;
    uint public nextId;

   function create(string memory bankName, string memory bname, string memory asset, string memory sector,  string memory Date, int auctionId  ) public{
        npa.push(NPADat(nextId, bankName, bname, asset, sector, Date, auctionId));
        nextId++;
    }

    function readId(uint id) view public returns(uint, string memory, string memory, string memory, string memory, string memory, int){
        for(uint i=0; i<npa.length; i++){
            if(npa[i].id==id){
                return(npa[i].id, npa[i].bankName, npa[i].borrowName, npa[i].asset, npa[i].sector, npa[i].date, npa[i].Auction_id);
            }
        }
    }       
}"
47033-0.sol,question,"contract Project{
    bytes32[] array;

    function addValue(bytes32 element)public{
        
        array.push(element);
    }

    function getAll()view public returns(bytes32[]){
        return array;
    }
}"
77298-0.sol,question,"contract MyFirstContract
{
    function() external payable { }
        function getBalance() public view returns(uint)
        {
            return address(this).balance;
        }
        
    function send(address payable _To )public payable returns (bool)
    {
     _To.transfer(msg.value);
     return true;
    }
}"
7993-1.sol,question,"contract MyContract
{
    function MyContract()
    {

    }

    function MyContract_function() public
    {
        MyLibrary_1.TestFunction();
        MyLibrary_2.TestFunction();
    }

    function() 
    {
        throw;
    }
}"
37048-0.sol,question,"contract Person
{
    Person[] public people;

    struct Person
    {
        bytes32 firstName;
        bytes32 lastName;

    }

    function addPerson(bytes32 _firstName, bytes32 _lastname) returns (bool success)
    {
        Person memory newPerson;

        newPerson.firstName = _firstName;
        newPerson.lastName = _lastname;


        people.push(newPerson);
        return true;
    }

    function getPeople() constant returns (bytes32[], bytes32[])
    {
        uint leng = people.length;

        bytes32[] memory first_names = new bytes32[](leng);
        bytes32[] memory last_names = new bytes32[](leng);


        for (uint i = 0; i < people.length; i++ )
        {
            Person memory currentPerson;
            currentPerson = people[i];
            first_names[i] = (currentPerson.firstName);
            last_names[i] = (currentPerson.lastName);


        }
        return (first_names,last_names);
    }
}"
7255-0.sol,question,"contract Hello{ string h = ""hello""; function g() constant returns(string){ return h; } }"
52676-0.sol,question,"contract TestCoin {
    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    constructor(uint256 initialSupply) public {
        totalSupply = initialSupply;
        balanceOf[msg.sender] = totalSupply;
    }
}"
45839-0.sol,question,"contract A {
        mapping (string => uint) public someMapping;
}"
18362-0.sol,question,"contract Guess {


function Guess(){
    MetaCoin metaCoin = new MetaCoin(); 
}

function getContractAddress() constant returns (address){
    return this;
}

function getThrowaway() constant returns (string){
    return ""Hello"";
}


}"
54529-0.sol,question,"contract Project
{
    struct Person {
        address addr;
        uint funds;
    }

    Person[] people;

    function getPeople(uint[] indexes)
        public
        returns (address[], uint[])
    {
        address[] memory addrs = new address[](indexes.length);
        uint[]    memory funds = new uint[](indexes.length);

        for (uint i = 0; i < indexes.length; i++) {
            Person storage person = people[indexes[i]];
            addrs[i] = person.addr;
            funds[i] = person.funds;
        }

        return (addrs, funds);
    }
}"
77979-0.sol,question,"contract richkid{

function buy_ceo_place() public payable returns (bool)

{

if(msg.sender.send(this.balance))

{

return false;

}
sorry-failed() 
return true;

}

}"
76202-0.sol,question,"contract CampaignFactory{
    address[] public deployedCampaigns;
    function createCampaign(uint minimum)public{
        address newCampaign = new Campaign(minimum, msg.sender);
        deployedCampaigns.push(newCampaign);
    }
    function getDeployedCampaign() public view returns(address[]){
        return deployedCampaigns;
    }
}"
76202-0.sol,question,"contract Campaign{
    struct Request {
        string description;
        uint value;
        address recipient;
        bool complete;
        uint approvalCount;
        mapping(address => bool) approvals;
    }
    Request[] public requests;
    address public manager;
    uint public minimumContribution;
    mapping (address => bool) public approvers;
    uint public approversCount;
    modifier restricted(){
        require(msg.sender == manager);
        _;
    }
    function Campaign (uint minimum, address creator)public{
        manager = creator;
        minimumContribution = minimum;
    }
    function contribue()public payable{
        require(msg.value > minimumContribution);
        approvers[msg.sender] = true;
        approversCount++;
    }

    function createRequest(string description, uint value, address recipient)public restricted{
        Request memory newRequest = Request({
            description: description,
            value: value,
            recipient: recipient,
            complete: false,
            approvalCount: 0
        });
        requests.push(newRequest); 
    }

    function approveRequest(uint index)public{
        Request storage request = requests[index];

        require(approvers[msg.sender]);
        require(!request.approvals[msg.sender]);

        request.approvals[msg.sender] = true;
        request.approvalCount++;
    }
    function finalizeRequest(uint index)public restricted{
        Request storage request = requests[index];

        require(request.approvalCount > (approversCount/2));
        require(!request.complete);

        request.recipient.transfer(request.value);
        request.complete = true;
    }

    function getSummary() public view returns (
        uint, uint, uint, uint, address
    ){
        return (
            minimumContribution,
            this.balance,
            requests.length,
            approversCount,
            manager
        );
    }

    function getRequestsCount() public view returns (uint){
        return requests.length;
    }
}"
41464-1.sol,question,"contract C {
    uint256 public x = 100;
}"
79871-2.sol,question,"contract B{
   function rep() public returns(string memory){

      return string(C(0x8fcECc5B8d42EcF099E1cF032B1F505fbDA230A3).name());
   }
   }"
76436-0.sol,question,"contract SomeContract {
   ERC20 erc;

  constructor(tokenAddress){
      erc = ERC20(tokenAddress)
  }


   getTokenBalance(address owner) returns (uint){
      return erc.balanceOf(owner);
   }
}"
64066-0.sol,question,"contract MyFirstContract{
    string private name;
    uint private age;

    function setName(string newName) public{
        name=newName;
    }
    function getName()public view returns(string){
        return name;
    }

    function setAge(uint newAge) public{
        age=newAge;
    }
    function getAge()public view returns(uint){
        return age;
    }

}"
65730-1.sol,question,"contract SampleContract{

     address payable owner;

     constructor() public {
         owner = msg.sender;
     }

}"
66093-0.sol,question,"contract Owned {

address owner;

  constructor () public{
   owner=msg.sender;
  }
  modifier onlyOwner(){
 if(msg.sender==owner){
     _;
    }
  }
}"
77521-0.sol,question,"contract contractA
{
  
  function foo() external
  {
     
     contractB.transfer(1 ether);
  }
  
}"
65447-1.sol,question,"contract test{
    address payable []array;
}"
25590-0.sol,question,"contract PePaDe {
  event NewShipment(address shipment);

  function createShipment(address _recipient, string _originAddress,
      string _destAddress, int _maxTemp, int _minTemp,
      uint _weightInKg, uint _expirationTime) public  {
    Shipment shipment = new Shipment(msg.sender, _recipient,
       _originAddress, _destAddress, _maxTemp, _minTemp,
       _weightInKg, _expirationTime);
    NewShipment(shipment);
  }
}"
51460-0.sol,question,"contract Example{
    function foo(){
        revert(""hello world!!!"");        
    }
}"
43641-0.sol,question,"contract Ownable {
  address public owner;
  :
}"
61389-3.sol,question,"contract Users {
  using Roles for Roles.Role;"
4395-0.sol,question,"contract Calculator{
    int result;
    function Calculator(int initialResult){
       result=initialResult;
    }
}"
72675-0.sol,question,"contract MyTokenSale {

 ERC721Token public token;

 constructor(address _tokenAddress) public {
    token = ERC721Token(_tokenAddress);
  }
"
15461-0.sol,question,"contract MyAuth {      
    function verify( bytes32 hash, uint8 v, bytes32 r, bytes32 s) 
        constant returns(address returnAddress) {
        returnAddress = ecrecover(hash, v, r, s);
    }
}"
3613-0.sol,question,"contract GerenciadorBoletos {

     struct Boleto {
         uint codigoBarra;
         uint codigoBarraDigitavel;
         uint cpfOuCnpjBeneficiario;
         uint cpfOuCnpjPagador;
         uint valorOriginal;
         uint dataVencimento;
     }

     mapping(uint => Boleto) registroBoletos;

     function inserirBoleto(
         uint codigoBarra,
         uint codigoBarraDigitavel,
         uint cpfOuCnpjBeneficiario,
         uint cpfOuCnpjPagador,
         uint valorOriginal,
         uint dataVencimento
     ) {
         Boleto memory b = Boleto(
             codigoBarra,
             codigoBarraDigitavel,
             cpfOuCnpjBeneficiario,
             cpfOuCnpjPagador,
             valorOriginal,
             dataVencimento
         );

         

         registroBoletos[b.codigoBarra] = b;
     }
}"
45551-0.sol,question,"contract SimpleAuction{
    event HiggestBidIncreased(address binder,uint amount);
    function bid()payable{
        HiggestBidIncreased(msg.sender,msg.value);
    }
}"
72945-0.sol,question,"contract TestToken is ERC20Standard {
     constructor() public {
        totalSupply = 100000000;
        name = ""Test Token"";
        decimals = 6;
        symbol = ""TST"";
        version = ""1.0"";
        balances[msg.sender] = totalSupply;
    }
}"
62852-0.sol,question,"contract Origin {

struct OriginInfo
{
    string airportName;
    uint32 checkInTime; 
    uint8 bagWeight;
    address clientAddress;
    bool itsHere;
}

function insertOrigin(string _airportName, uint32 _checkInTime, uint8 _bagWeight, bool _itsHere) external
{
    


    OriginInfo(_airportName, _checkInTime, _bagWeight, msg.sender, true);
    getOrigin();
}

function getOrigin() private constant returns (string, uint32, uint8, address, bool) 
{
    return (OriginInfo.airportName, 
    OriginInfo.checkInTime, 
    OriginInfo.bagWeight, 
    OriginInfo.clientAddress, 
    OriginInfo.itsHere);
}
}"
67367-0.sol,question,"contract TestOneReturn
{
    mapping(uint => uint) m_Data;

    constructor()
        public
    {
        m_Data[0] = 111;
        m_Data[1] = 112;
    }

    function getAddress(uint pA)
        external view
        returns(uint)
    {
        return m_Data[pA];
    }
}"
67367-0.sol,question,"contract TestTwoReturns
{
    mapping(uint => mapping(uint => uint)) m_Data;

    constructor()
        public
    {
        m_Data[0][0] = 211;
         m_Data[0][1] = 212;
    }

    function getAddress(
        uint pA,
        uint pB
    )
        external view
        returns(uint)
    {
        return m_Data[pA][pB];
    }
}"
76517-0.sol,question,"contract Court {
  mapping(address => Data) subcourts;
}"
10628-0.sol,question,"contract Client{
    Server public s  = new Server();
    function doit(){
        s.homicide();
        throw;
    }
}"
10628-0.sol,question,"contract Server{ 
    bool public alive = true;
    function homicide(){
        Suicide();
        suicide(msg.sender);

    }
    event Suicide();
}"
70062-0.sol,question,"contract first{

    function one(uint256 a, uint256 b) public pure returns(uint){
        uint256 c = a + b; 
        return c;
    }

    function two(uint c, uint d)public pure returns(uint){
        uint256 e = c + d;
        return e;
    }

}"
76713-1.sol,question,"contract Marketplace {
    string public name;
    address owner;
    uint public fileCount = 0;
    mapping(uint => File) public files; 


    struct File
    {
        uint id;
        string name;
        address owner;
        address sharedWith;
    }

    mapping(uint => Product) public products;

    struct Product {
        uint id;
        string name;
        address owner;
        address sharedWith;
    }

    event ProductCreated(
        uint id,
        string name,
        address owner,
        address sharedWith
    );

    event FileViewed(
        uint id,
        string name,
        address owner,
        address sharedWith
    );


    constructor() public {
        name = ""File Sharing System"";
        owner = msg.sender;
    }

    modifier onlyOwner()
    {
        require(owner==msg.sender);
        _;
    }

    function addFile(string memory _name, address _address) onlyOwner public
    {
        fileCount++;
        products[fileCount] = Product(fileCount,_name,owner,_address);
        emit ProductCreated(fileCount, _name, owner, _address);
    }

    function viewFile(uint _id) public view
    {
        Product memory _file = products[_id];
        require(msg.sender==_file.sharedWith,""Not shared with you!!"");
        emit FileViewed(fileCount, _name, owner, _address);
    }

}"
84635-0.sol,question,"contract PresaleCrowdsale is AllowanceCrowdsale {
  constructor(
    uint256 _rate,
    address payable _wallet,
    ERC20 _token,
    address _tokenWallet
  )
    Crowdsale(_rate, _wallet, _token)
    AllowanceCrowdsale(_tokenWallet)
    public
  {}
}"
12733-0.sol,question,"contract House { 
  uint public idHouse;
  ...
}"
12733-0.sol,question,"contract ArrayHouse { 
  House[] public arrayHouse;

  function getHouse(uint n) returns(House){
    if (n >= arrayHouse.length) 
      throw;
    return arrayHouse[n];
  }
}"
84474-1.sol,question,"contract L {
    address payable TetherAddress = 0xdAC17F958D2ee523a2206206994597C13D831ec7;
    TetherToken Tether = TetherToken(TetherAddress);
    ...
}"
23501-0.sol,question,"contract Crowdsale {
  using SafeMath for uint256;

  
  MintableToken public token;"
78275-0.sol,question,"contract Votacion{
mapping(uint => address[]) private votosCandidatos;
uint[] listaCandidatos;
bool abierta;

address private creador=msg.sender;

constructor(uint[] memory candidatosIds) public{
    listaCandidatos = candidatosIds;
    abierta = false;
    for (uint i = 0; i < candidatosIds.length; i++)
    {
        votosCandidatos[candidatosIds[i]];
    }
}

function ind(address[] memory v, address e) public pure returns (bool){
    bool found = false;

    for(uint i = 0; i < v.length && !found; i++)
    {
        found = v[i] == e;
    }

    return found;
}

function votar(uint candidato) public{
    bool ya_votado = false;

    for (uint i = 0; i < listaCandidatos.length && !ya_votado; i++)
    {
        ya_votado = ind(votosCandidatos[listaCandidatos[i]],msg.sender);
    }

    require(!ya_votado,""Ya ha ejercido su derecho a voto"");
    
    require(abierta,""La votacin no es accesible en este momento"");
    
    votosCandidatos[candidato].push(msg.sender);
}

function abrir() public{
    require(msg.sender == creador,""Permiso denegado"");
    abierta = true;
}

function cerrar() public{
    require(msg.sender == creador,""Permiso denegado"");
    abierta = false;
}

function revisar_voto() public view returns (uint)
{
    require(!abierta,""La votacin no ha terminado aun"");
    bool ya_votado = false;
    uint res;

    for (uint i = 0; i < listaCandidatos.length && !ya_votado; i++)
    {
        ya_votado = ind(votosCandidatos[listaCandidatos[i]],msg.sender);
        res = i;
    }

    return res;
}

function resultados() public view returns (uint[] memory){
    require(!abierta,""La votacin no ha terminado aun"");

    uint[] memory resul = new uint[](listaCandidatos.length);

    for (uint i = 0; i < listaCandidatos.length; i++)
    {
        resul[i] = votosCandidatos[listaCandidatos[i]].length;
    }

    return resul;
}
}"
64035-0.sol,question,"contract HelloWorld {
    address public owner;


    constructor (address _owner) public{
        owner = _owner;

    }

}"
63149-1.sol,question,"contract TestNestedStructInMapping {

    
    struct structNested {
        uint dummy;
    }

    
    struct structMain {
        structNested gamePaymentsSummary;
    }

    
    mapping(uint256 => structMain) public s_mapOfNestedStructs;
}"
61426-0.sol,question,"contract sendether{

     function receiveEther() payable public{
     }

     function sendEther(address _address) payable public{
         uint value = 5 ether;

         _address.transfer(value);
     }

}"
22890-0.sol,question,"contract Test {

    address da;
    function getSender () constant returns (address){
        da=msg.sender;
        return da;
    }
}"
52753-1.sol,question,"contract BaseConstituency is Ownable {
    uint numVotes;
    uint constituencyType;
    string constituencyName;

    struct Candidate {
        string name;
        uint numVotes;
        bool validCandidate;
    }

    struct Voter {
        bool hasVoted;
        bool validVote;
        uint candidateVote;
    }

    Candidate[] candidates;

    constructor(uint _constituencyType, string _constituencyName) public{
        numVotes = 0;
        constituencyType = _constituencyType;
        constituencyName = _constituencyName;
    }

    function getStuff() public view returns(uint, string){
        return (constituencyType, constituencyName);
    }

}"
77939-2.sol,question,"contractoronlyowner
{

}"
26012-2.sol,question,"contract GustavoCoin is MintableToken {
  string public name = ""GUSTAVO COIN"";
  string public symbol = ""GUS"";
  uint256 public decimals = 18;
}"
80300-1.sol,question,"contract ExampleToken is ERC20Detailed {

  
  constructor(string memory _name, string memory _symbol, uint8 _decimals) 
  ERC20Detailed(_name, _symbol, _decimals)
  public {
  }

}"
11995-1.sol,question,"contract demo {string public name = \""Petros\""; function changeName(string _newName){name = _newName; } }"
51042-1.sol,question,"contract TestLibrary{
    using IntExtended for uint;

    function testIncrement(uint _base) returns (uint){
        return IntExtended.increment(_base);
}

    function testDecrement(uint _base) returns (uint){
        return IntExtended.decrement(_base);
}

    function testIncrementByValue(uint _base,uint _value) returns(uint){
        return _base.incrementByValue(_value);
} 

    function testDecrementByValue(uint _base, uint _value) returns (uint){
        return _base.decrementByValue(_value);
}
}"
79871-1.sol,question,"contract A{
   bytes public fname=""Yerevan"";
   function naming() public returns(string memory){

      return C(0x8fcECc5B8d42EcF099E1cF032B1F505fbDA230A3).rep(fname);
  }
  }"
51942-0.sol,question,"contract KeyValueStorage {
    mapping (address => mapping(bytes32 => uint256)) refreshTime;
    ....
}"
63533-0.sol,question,"contract Election {
    
    struct Candidate{
        uint id;
        string name;
        uint voteCount;
    }
    
    
    mapping(uint=>Candidate)public candidates;
    
    uint public candidateCount;
    function election()public{
        addCandidate(""Donald Trump"");
        addCandidate(""Barak Obama"");
    }

    function addCandidate(string memory _name)private{
        candidateCount++;
        candidates[candidateCount] = Candidate(candidateCount,_name,0);
    }
}"
51647-0.sol,question,"contract CoffeeCoin is ERC20Basic {
    mapping(address => uint256) balances;
    ...
}"
57955-0.sol,question,"contract UpgraderToken is TestMigrationTarget {
 function UpgraderToken(address _oldToken)
    TestMigrationTarget(_oldToken) {
}
}"
63712-0.sol,question,"contract AddOrRemoveAdminVotingBuilder
{
    function build(
        address pPlatform,
        address pAdminManager
    )
        external
        returns(address)
    {
        return address(
            new AddOrRemoveAdminVoting(
                pPlatform, 
                pAdminManager
            )
        );
    }
}"
66686-0.sol,question,"contract Test is TestBase{
    string[] name ;

    constructor() public payable {
      name.push(""sheep"");
      name.push(""fox"");
      name.push(""whale"");
    }

    function getNames() public returns(string[] memory){
        emit Log(""Test"",address(this),msg.sender,tx.origin);
        display();
        return name;
    }
}"
66686-0.sol,question,"contract TestBase2 {
    event Log(string context,address,address,address);

    function display2() public returns(address){
        emit Log(""TestBase2"",address(this),msg.sender,tx.origin);
        return msg.sender;
    }

}"
66686-0.sol,question,"contract TestBase is TestBase2{

    function display() public returns(address){
        emit Log(""TestBase"",address(this),msg.sender,tx.origin);
        display2();
        TestBase3 t = new TestBase3();
        t.display();
        return msg.sender;
    }
}"
66686-0.sol,question,"contract TestBase3 {
    event Log(string context,address,address,address);

    function display() public returns(address){
        emit Log(""TestBase3"",address(this),msg.sender,tx.origin);

        return msg.sender;
    }
}"
66613-0.sol,question,"contract A {
     function() payable {
          
     }
}"
66613-0.sol,question,"contract B {

    constructor() payable public {
        A a = new A();
        address payable receiver = address(a); 
        receiver.transfer(msg.value);
     }
}"
63079-1.sol,question,"contract EtherBandBattlesManager is Pausable {

using SafeMath for uint256;    

    function testPayment(address _payeeAddr)
            payable
            public
            onlyOwner
            {
        require(_payeeAddr != address(0), ""(testPayment) The payee address is not set."");
        require(msg.value != 0, ""(testPayment) The amount of value accompanying the transaction is zero."");

        
        _payeeAddr.transfer(msg.value);
    }
}"
47523-0.sol,question,"contract Upload{

    mapping(address => bool) managerAddresses;
    string public ownerName;
    string public location;

    modifier restricted(){
        require(managerAddresses[msg.sender]);
        _;
    }


    constructor(address[] _managerAddressesArr,string _ownerName,string _location)  public {
        for(uint i = 0;i<_managerAddressesArr.length;i++){
            managerAddresses[_managerAddressesArr[i]] = true;
        }
        ownerName = _ownerName;
    }

    function setLocation(string _location) restricted public{
        location = _location;
    }



}"
70953-0.sol,question,"contract SolnSqaureVerifier is CraveuERC721Token {

    SquareVerifier squareVerifier;

    constructor(address verifierAddress) public {
        squareVerifier = SquareVerifier(verifierAddress);
    }
"
13032-1.sol,question,"contract Test {
    

    event myFunctionEvent1(address from, typeVar1 someVar1, typeVar2 someVar2);
    event myFunctionEvent2(address from, typeVar1 someVar1, typeVar2 someVar2);

    function myFunction1(typeVar1 someVar1, typeVar2 someVar2)
    {
        
        myFunctionEvent1(msg.sender, someVar1, someVar2);
    }
    function myFunction2(typeVar1 someVar1, typeVar2 someVar2)
    {
        
        myFunctionEvent2(msg.sender, someVar1, someVar2);
    }
    
}"
64493-0.sol,question,"contract Election {
^------^
Compilation failed. See above.
Truffle v5.0.0 (core: 5.0.0)
Node v11.2.0"
11640-3.sol,question,"contract Test2 {

   address public lastSCAddress; 
     address public oldestSCAddress; 
   string name;

}"
64562-0.sol,question,"contract test {

struct document{
   string ipfsHash;
   string documentName;
   bytes32 accessKey;
}

struct grantAccess{
   address owner;
   address single;     
}"
42168-0.sol,question,"contract ERC165 {

         function interfaceID() constant returns (uint)
         {
            bytes4[] sigs = type(this).signatures;
            uint mask = 0;
            for (var i = 0; i < sigs.length; i++)
            mask ^= uint(sigs[i]);
        return mask;
    }
}"
8496-1.sol,question,"contract Set {
    bool public ret;
    address public tokenAddr;
    address public userAddr;
    function Set(address tokenAddr_,address userAddr_){
        tokenAddr=tokenAddr_;
        userAddr=userAddr_;
    } 
    function call1(byte bb){
        ret=tokenAddr.call(""notify"",bb,userAddr);   
    }
    function call2(byte bb){
        tokenAddr.call(bytes4(sha3(""notify(byte,address)"")),bb,userAddr);
    }
    function call3(byte bb){
        NotifyContract c=NotifyContract(tokenAddr);
        c.notify(bb,userAddr);
    }
}"
18009-0.sol,question,"contract Escrow {
    ....
    modifier onlyafter(uint _time) {
      require(now >= _time);
      _;
}"
9835-0.sol,question,"contract Board
{
    string  foo;
    event Shout();
    event TextEvent(
        string  indexed text,
        uint timestamp
    );

    function shout(string _text)
    {
        foo=_text;
        Shout();
        TextEvent(_text,now);
    }

    function getFoo() returns(string){
        return foo;
    } 
}"
58566-0.sol,question,"contract Project
{
    struct Person {
        address addr;
        uint funds;
    }
    
    Person[] people;
    
    function getPeople(uint[] indexes)
        public
        view
        returns (address[], uint[])
    {
        address[] memory addrs = new address[](indexes.length);
        uint[]    memory funds = new uint[](indexes.length);
        
        for (uint i = 0; i < indexes.length; i++) {
            Person storage person = people[indexes[i]];
            addrs[i] = person.addr;
            funds[i] = person.funds;
        }
        
        return (addrs, funds);
    }
}"
62419-0.sol,question,"contract DappToken {
        string  public name = ""MDV"";
        string  public symbol = ""$$$"";
        string  public standard = ""DApp Token v1.0"";
        uint256 public totalSupply;
        
    }"
64168-0.sol,question,"contract Asset {

uint256 public owners_count;
address public contract_owner;              
bytes32 public land_id;                   
bytes32 public land_sqrfeet;              
bytes32 public land_created_date;         
mapping(uint => address) public owners;     

function createland(bytes32 _land_id, bytes32 _land_sqrfeet, bytes32 _land_created_date) public returns (bool){
    setOwner(msg.sender);
    land_id = _land_id;
    land_sqrfeet = _land_sqrfeet;
    land_created_date = _land_created_date;
    return true;
}


modifier onlyOwner(){
    require(msg.sender == contract_owner);
    _;
}


function transferOwnership(address _newOwner) public onlyOwner(){
    require(_newOwner != address(0));
    contract_owner = _newOwner;
}


function previousOwner() view public returns(address){
    if(owners_count != 0){
        uint256 previous_owner = owners_count - 1;
        return owners[previous_owner];
    }
}

function setOwner(address owner)public{
    owners_count += 1 ;
    owners[owners_count] = owner;
}

function getCurrentOwner() view public returns(address){
    return owners[owners_count] ;
}

function getOwnerCount() view public returns(uint256){
    return owners_count;
}}"
80123-0.sol,question,"contract customerFinder{
    mapping(uint256 => address payable) public addressStorage;

    function filling(uint256 iden, address payable sender) public{
       addressStorage[iden]=sender;
    }

    function finder(uint256 id) public view returns(address payable){
       return addressStorage[id];
    }
}"
46167-0.sol,question,"contract Storage
{
    mapping(address => string[]) dataOfAddr;
    function writeData(address _addr, string _data, uint8 v, bytes32 r, bytes32 s) payable public returns(uint)
    {
        require(ecrecover(sha256(_data), v, r, s) == _addr);
        dataOfAddr[_addr].push(_data);
        msg.sender.transfer(1 ether); 
        return dataOfAddr[_addr].length;
    }
}"
31551-0.sol,question,"contract MyContract
{
    struct something {
        bytes32 test1;
        bytes32 test2;
        bytes32 test3;
    }

    mapping (address => Something[]) public stuff;
}"
11804-0.sol,question,"contract Test 
{
    uint x = 0;
    uint y = 8;

    function calculate() 
    {
        uint z = x+y;
    }
}"
58089-1.sol,question,"contract Extend{
    Base public base;
    uint public num;
    constructor() public {
        base = new Base();
        base.Minit(10);
    }   
    function setN() public{
        num = base.getN();

    }
    function getN() public view returns(uint){
        return num;
    }
}"
27146-0.sol,question,"contract MyCrowdsale is Crowdsale {
    function MyCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet)
        Crowdsale(_startTime, _endTime, _rate, _wallet)
    {
    }  
}"
54994-0.sol,question,"contract DoubleCall {
    address public superHero;
    uint256 public price = 1 ether;

    function becomeSuperHero() public payable{
        require(msg.value >= price);
        superHero = msg.sender;
        price = price * 2;
    }
}"
18863-0.sol,question,"contract PractCoin {

    mapping (address => uint256) public monies;
    address public owner;
    uint public totalCoins;
    uint public initialSupply;
    string public name;
    uint8 decimalPlaces;

    function PractCoin(uint _totalCoins, uint _initialSupply, string _name, uint8 _decimalPlaces){
        owner = msg.sender;
        totalCoins = _totalCoins;
        initialSupply = _initialSupply;
        monies[owner] = initialSupply;
        name = _name;
        decimalPlaces = _decimalPlaces;
    }

    function sendCoins(address _to, uint _amount){
        if (monies[msg.sender] < _amount || 
            msg.sender == _to || 
            monies[_to] + _amount < _amount) throw;
        monies[msg.sender] -= _amount;
        monies[_to] += _amount;
        CoinTransfer(_amount, _to, msg.sender);
    }

    function destroyContract(){
        if (msg.sender == owner ) selfdestruct(owner);
        ContractDestroyed(""Contract Destroyed!"");

    }

    event CoinTransfer(uint _amount, address indexed _to, address indexed _from);
    event ContractDestroyed(string _message);
}"
37309-1.sol,question,"contract VeteranCoinInterface {
    
    
    uint256 public totalSupply;

    
    
    function balanceOf(address _owner) public view returns (uint256 balance);

    
    
    
    
    function transfer(address _to, uint256 _value) public returns (bool success);

    
    
    
    
    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    
    
    
    
    function approve(address _spender, uint256 _value) public returns (bool success);

    
    
    
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);

    
    event Transfer(address indexed _from, address indexed _to, uint256 _value); 
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}"
29104-0.sol,question,"contract MetaCoin {
    function getBlockNumber()
    public
    view
    returns (uint)
    {
        return block.number;
    }
}"
46860-0.sol,question,"contract A{

address public seller; 


function A(){
    seller = 0xdd870fa1b7c4700f2bd7f44238821c26f7392148;
 }

function transfer_from_B(address b){

 seller.transfer(b.balance);
}
}"
46860-0.sol,question,"contract B{
   function deposit() payable{
 }

 }"
67599-1.sol,question,"contract Test{

  function TestVar() view public returns(uint8){
    uint8 a;
    for(uint8 b=0;b<20; b++){
      a=b;
      return a;
    }
  }   
}"
10661-1.sol,question,"contract itemlistcallercontract {
     ItemListContract itemlistcontract;
     function itemlistcallercontract()
     {
     itemlistcontract = ItemListContract(""0x16c5d0c8fccaf7e5824f5ae25c1662877cec6452"");
     }

     function getitemcount() constant returns(int count)
     {
     return itemlistcontract.countItemList();
     }
}"
66925-1.sol,question,"contract TokenImpl {
    function transfer(address recipient, uint amount) public returns(bool)
    {
         return true;
    }
}"
51760-1.sol,question,"contract test_pq {
       function test() public returns (int256){
         PQ memory pq;
         for (uint8 i = 0; i < 10; i++)
             pq.insert(i)
         return pq.get_min();
       }
}"
52681-0.sol,question,"contract test {
    event LogEvent(
        address a,
        bool result
    );    

    function testInputs(some parameters) public (){

        ....

        
        bool[2] a = [true,true]; 

        
        

        if(a[1] && a[2])
            LogEvent(msg.sender,true);
        else
            LogEvent(msg.sender,false);
    }  
}"
79871-0.sol,question,"contract C{
   bytes public name;
   function rep(bytes memory pseudonym)  public returns(string memory){
       name=pseudonym;
       return string(name);
   }
   }"
83573-0.sol,question,"contract B is ERC721 {

    constructor(string memory _name, string memory _symbol) ERC721(_name, _symbol) public {}
}"
83573-0.sol,question,"contract A is B {

    constructor(string memory _name, string memory _symbol) B(_name, _symbol) public {}
}"
70965-0.sol,question,"contract SampleContract
{
    function fromHexChar(uint c) public pure returns(uint)
    {
        if(byte(c) >= byte('0') && byte(c) <= byte('9')) 
        {
            return c - uint(byte('0'));
        }
        if(byte(c) >= byte('a') && byte(c) <= byte('f'))
        {
            return 10 + c - uint(byte('a'));
        }
        if(byte(c) >= byte('A') && byte(c) <= byte('F'))
        {
            return 10 + c - uint(byte('A'));
        }
    }

    function fromHex(string memory s) public pure returns(bytes) 
    {
        bytes memory ss = bytes(s);
        require(ss.length%2 == 0);

        bytes memory r = new bytes(ss.length/2);
        for(uint i=0; i<ss.length/2; ++i)
        {
            r[i] = byte(fromHexChar(uint(ss[2*i]))*16 +         
            fromHexChar(uint(ss[2*i+1])));
        }
        return r;
    }
}"
11863-0.sol,question,"contract demo {
  string public name=""Pietro"";
  function changeName(string _newName){
       name=_newName;
   } 
}"
78303-0.sol,question,"contract DappToken{


uint256 public totalSupply;

constructor DappToken() public{
    totalSupply = 10000;    

 }

}"
58652-0.sol,question,"contract Simplest {
}"
70417-1.sol,question,"contract X{
    uint256[] public array = [1];

    function X(){}

    function popLength() public{
        array.length--;
    }

    function getLength() constant returns(uint256){
        return array.length;
    }
}"
64715-0.sol,question,"contract Survey {
    
     event SurveyInitialized(address indexed owner, uint indexed surveyReward);

    
    address public owner;
    address private factory;

    Constructor Survey(address _owner) payable public {
        (_owner != address(0));
        (msg.value > 0);
        owner = _owner;
        factory = msg.sender;
        emit SurveyInitialized(owner, msg.value);
    }
}"
68527-1.sol,question,"contract ContractFactory{
    ChildContract[] public createdContracts;
    ChildContract public activeChild;

    function createChild() public{
        ChildContract newChild = new ChildContract();
        createdContracts.push(newChild);
        
            activeChild.activate(false);
        
        activeChild = newChild;
    }
}"
5812-0.sol,question,"contract DepositCounter {
    uint deposits = 0;
    function() {
        deposits++;
    }
}"
11185-0.sol,question,contract FooContract {...}
7949-0.sol,question,"contract X{

uint constant var1=now;
uint var2=now;

function checkConstant() returns(uint,uint){
    return (var1,var2);
}}"
69530-0.sol,question,"contract TestEvent {

    
    event testEvent(string indexed message);


    function emitTestEvent(
        string  calldata message
    ) 
    external
    {
     emit testEvent(message);
    }
}"
59979-0.sol,question,"contract Greet
{
  string message;
  constructor() public{
        message=""I'm ready!"";
    }
function setgreetings(string _message)public
{
    message=_message;
}
function getgreetings()public view returns(string){
       return message;
 }
}"
62579-0.sol,question,"contract Test is ITest
{
    address private admin;

    constructor()
        public
    {
        admin = msg.sender;
    }

    modifier onlyAdmin
    {
        assert(msg.sender == admin);
        _;
    }

    function check()
        external onlyAdmin
    {
        
    }
}"
62579-0.sol,question,"contract OtherTest
{
    ITest private test;

    constructor(
        address testAddress
    )
        public
    {
        test = ITest(testAddress);
        test.check();
    }
}"
10981-1.sol,question,"contract Master {
  bool public isActive=false;
  uint public num=0;

  function changeState() returns bool newState{
    isActive = !isActive;
    newState = isActive;
  }

  function increaseSubjectCount(subjectAddr) returns uint newCount{
    SubjectContract subjectContract = SubjectContract(subjectAddr);
    newCount = ubjectAddr.increaseCount();
  }
}"
8433-0.sol,question,"contract Sandbox {

    function retArr() 
    public constant returns (byte[3][10] ret) {
        ret[0][2] = byte(2);
    }

}"
83625-1.sol,question,"contract VenueRegistry{
    struct Queue{
        uint head;
        uint tail;
        mapping(uint => address) queue;
    }

    struct Venue{
        uint id;
        Queue queue;
    }

    mapping (uint => Venue) venues;

    function getVenue(uint _index) public view returns(Venue memory){
        return venues[_index];
    }
}"
2942-0.sol,question,"contract eXample {

  function eXample{
   .....
  }

  event MyEvent(uint x,uint y,uint z);
  function doSomething{
    .....

   MyEvent(x,y,z);
  }
}"
2942-0.sol,question,"contract contractCaller {
  ....

  eXample instance = eXample(address)
 
  function exampleFunction{
    instance.doSomething
  }
  
  ....
}"
47873-1.sol,question,"contract Purchase {
    uint public value;
    address public seller;
    address public buyer;
    enum State { Created, Locked, Inactive }
    State public state;

    
    
    
    constructor() public payable {
        seller = msg.sender;
        value = msg.value / 2;
        require((2 * value) == msg.value, ""Value has to be even."");
    }

    modifier condition(bool _condition) {
        require(_condition);
        _;
    }

    modifier onlyBuyer() {
        require(
            msg.sender == buyer,
            ""Only buyer can call this.""
        );
        _;
    }

    modifier onlySeller() {
        require(
            msg.sender == seller,
            ""Only seller can call this.""
        );
        _;
    }

    modifier inState(State _state) {
        require(
            state == _state,
            ""Invalid state.""
        );
        _;
    }

    event Aborted();
    event PurchaseConfirmed();
    event ItemReceived();

    
    
    
    function abort()
        public
        onlySeller
        inState(State.Created)
    {
        emit Aborted();
        state = State.Inactive;
        seller.transfer(this.balance); 
        
        
    }

    
    
    
    
    function confirmPurchase()
        public
        inState(State.Created)
        condition(msg.value == (2 * value))
        payable
    {
        emit PurchaseConfirmed();
        buyer = msg.sender;
        state = State.Locked;
    }

    
    
    function confirmReceived()
        public
        onlyBuyer
        inState(State.Locked)
    {
        emit ItemReceived();
        
        
        
        state = State.Inactive;

        
        

        buyer.transfer(value);
        seller.transfer(this.balance);
    }
}"
45683-0.sol,question,"contract ExampleSmartContract {


  function() payable {

      msg.sender.transfer(msg.value);

  }

}"
63858-0.sol,question,"contract InsuranceClaim{
    struct Request {
        address payable insuranceRecipient;
        string personName;
        uint value;
        address payable hospitalRecipient;
        bool complete;

    }
    Request[] public requests;
    address public claimer;

    constructor (address creator) public{
        claimer = creator;
    }

    modifier restricted(){
        require(msg.sender==claimer);
        _;
    }

    function createRequest(string memory personName,address payable insuranceRecipient,uint value,address payable hospitalRecipient) public restricted{
        Request memory newRequest = Request({
            insuranceRecipient:insuranceRecipient,
            value:value,
            personName:personName,
            hospitalRecipient:hospitalRecipient,
            complete:false
        });
        requests.push(newRequest);
    }

    function finalizeRequest (uint index) public payable restricted{
        Request storage request = requests[index];
        require(!request.complete);
        request.hospitalRecipient.transfer(request.value);
        request.complete = true;
    }
}"
78907-0.sol,question,"contract KittyInterface {
...
}"
78907-0.sol,question,"contract ZombieFeeding is ZombieFactory {

KittyInterface kittyContract;

}"
58089-7.sol,question,"contract Base{
    address public owner;
    function Mint() payable external  returns(uint){
        return 1;
    }
    constructor() public {}
}"
53280-0.sol,question,"contract Betting{
    struct Player{
        mapping(uint => uint) amounts;

    }

    struct Match{
        address [] playerAdresses;
        uint [] totalBets;
    }

    mapping(address => Player) public playerInfo;
    mapping(uint => Match) public matchInfo;
}"
79964-0.sol,question,"contract Test is Calculator {
   constructor() public {}
   function getResult() external view returns(uint){
      uint a = 1; 
      uint b = 2;
      uint result = a + b;
      return result;
   }
}"
40231-0.sol,question,"contract Hello{

    string name;
    function Hello(){
        name = ""Mike"";
         }
}"
74562-1.sol,question,"contract EternalStorage {

            function setString (
                bytes32 h,
                string memory v
                ) public;

            function getString (
                bytes32 h
                ) public view returns (
                    string memory
                );
function setAddress (
        bytes32 h,
        address v
        ) public;

    function getAddress (
        bytes32 h
        ) public view returns (
            address
        );


        }"
57628-0.sol,question,"contract A {
    uint constant public START_TIME = 10;
}"
71102-0.sol,question,"contract foster{
    vulnerable v = new vulnerable();
    attacker a = new attacker(address(v));

     constructor() public payable{

        
        
     }

     function action() public payable{
         a.deposit(address(v));     
         v.addNominee(address(a));
     }

     function getTargetBalance() public view returns(uint256, uint256){
        return (address(v).balance , address(this).balance);
    }

     function attack() public payable{
         v.transact();
     }
}"
11828-0.sol,question,"contract Test 
{
   uint32 value = 10;
}"
40294-0.sol,question,"contract test {


uint256 public counter = 0;

event testEvent(address indexed _sender, uint256 _value, uint256 _counter);


function test() public{
    counter += 1;

}

function() public payable {
    raiseCounter();
}

function raiseCounter() public payable{
    testEvent(msg.sender, msg.value, counter);
    counter += 1;
}

function destroy() public{
    selfdestruct(msg.sender);
}
}"
65804-0.sol,question,"contract reg{
  address owner;
  uint256 regFee = 2 ether;
  address[] private registered;
  uint a = 0;

  mapping (address => uint256) public balance;

  constructor() public{
    owner = msg.sender;
    regFee = 2 ether;
  }

  event registeration(address indexed _to);

  
  
  
  
  

  function () payable external{
    balance[(msg.sender)] -= 2 ether;
    balance[address(this)] += 2 ether;
    registered.push(msg.sender);
    a++;
    emit registeration(msg.sender);
  }

  function list() public view returns(address, address, address){
    return (registered[0], registered[1], registered[2]);
  }
}"
31768-0.sol,question,"contract BOLData {

    string public SData;
    string public SCData;


    function BOLData(string S_Data) 
    { 
        SData= S_Data;
        SCData= '';
    } 
    function getSData() constant returns (string retVal) 
    { 
        return SData;
    }
    function setSCData(string SC_Data) 
    { 
        SCData = SC_Data; 
    } 
    function getSCData() constant returns (string retVal) 
    { 
        return SCData;
    }

}"
42396-0.sol,question,"contract HelloWorld
{
string hello = ""Hello World"";
function sayHello() returns (string)
{
    return hello;
}
}"
64801-0.sol,question,"contract Adoption {
 address[16] adopters;


function adopt(uint petId) public returns (uint){
  require(petId >= 0 && petId <= 15);
  adopters[petId] = msg.sender;
  return petId;
}


function getAdopters() public view returns (address[16]){
 return adopters;


 }
 }"
70336-3.sol,question,"contract MyToken{
    string private _name = ""MyToken"";
    string private _symbol = ""MYT"";
    uint8 private _decimals = 6;
    uint256 private _totalSupply = 10 * (10 ** uint256(_decimals));
    mapping(address=>uint256) private _balances;
    mapping(address=>mapping(address=>uint256)) private _allowances;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    function MyToken(){
        _balances[msg.sender] = _totalSupply;
    }

    function name() public view returns (string name){
        name = _name;
    }

    function symbol() public view returns (string symbol){
        symbol = _symbol;
    }

    function decimals() public view returns (uint8 decimals){
        decimals = _decimals;
    }

    function totalSupply() public view returns (uint256 totalSupply){
        totalSupply = _totalSupply;
    }

    function balanceOf(address _owner) public view returns (uint256 balance){
        balance = _balances[_owner];
    }

    function transfer(address _to, uint256 _value) public returns (bool success){
        require(_balances[msg.sender] >= _value);
        _balances[msg.sender] -= _value;
        _balances[_to] += _value;
        Transfer(msg.sender, _to, _value);
        success = true;
    }

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){
        require(_balances[_from] >= _value);
        require(_allowances[_from][msg.sender] >= _value);
        _balances[_from] -= _value;
        _allowances[_from][msg.sender] -= _value;
        _balances[_to] += _value;
        Transfer(_from, _to, _value);
        success = true;
    }

    function approve(address _spender, uint256 _value) public returns (bool success){
        _allowances[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender, _value);
        success = true;
    }

    function allowance(address _owner, address _spender) public view returns (uint256 remaining){
        remaining = _allowances[_owner][_spender];
    }
}"
55741-0.sol,question,"contract TestToken is StandardToken {

string public name = ""Token"";
string public symbol = ""T1"";
uint8 public decimals = 18;
uint public INITIAL_SUPPLY = 4000000000000000000000000000;

constructor() public {
  totalSupply_ = INITIAL_SUPPLY;
  balances[msg.sender] = INITIAL_SUPPLY;
}
}"
84066-0.sol,question,"contract Marketplace {

 using SafeMath for uint;

    struct User {
        uint reputation;
        string name;
        bool isUser;
    }

    struct Request {
            address company;
            uint id;
            uint deadline; 
            uint startTime;
            uint miniReputation;
            uint remuneration;
            string description;
            string url;
            State state;
            mapping(address=>bool) accepted;
            mapping(address=>bool) candidates;
    }

    address owner;
    mapping (address => uint) public balances;
    mapping(address => User) public users;
    mapping(uint => Request) public requests;
   


    uint requestCount;
    uint decimal=100;
    uint cost=102;

    enum State{OPENED,ONGOING,CLOSED}

    event UserCreated(address _add,uint _reputation, string  _name, bool _isUser);
    event RequestCreated(address _add, uint _id, uint _deadline, uint _startTime,
    uint _miniReputation, uint _cost, string _description,
    string _url, State _state);
    event Application(uint _id,address _add,uint _reputation);
    event OfferAccepted(uint _id,address _add);

    constructor() public{
        owner = msg.sender;
        requestCount;
    }

   modifier requestState 
        (uint _id, State _state)
        {
            require(requests[_id].state==_state,""request is not accessible"");
            _;
        }

    modifier nextRequestState
        (uint _id, State _state)
        {
            updateState(_id, _state);
         _;

        }

    modifier isUser
        (address _add)
        {
            require(_add!=address(0),""You are the 0 address"");
            require(users[_add].isUser,""You are not a user !"");
            _;
        }

    modifier isRequest
        (uint _id)
        {
            require(requests[_id].id > 0,""The request does not exist !"");
            _;
        }


    modifier isCandidate
        (uint _id,address _add)
        {
            require(_add!=address(0),""You are the 0 address"");
            require(requests[_id].candidates[_add],""You are not a candidate !"");
            _;
        }


    modifier isCompany
        (uint _id)
        {
            require(msg.sender!=address(0),""You are the 0 address"");
            require(requests[_id].company!=msg.sender,""You are the company !"");
            _;
        }

    modifier isAccepted
        (uint _id,address _add)
        {
            require(_add!=address(0),""You are the 0 address"");
            require(requests[_id].accepted[_add],""You are not accepted !"");
            _;
        }

    modifier isInTime
    (uint _id)
    {
      require(requests[_id].startTime<=now && requests[_id].deadline>=now,""You are not in time"");  
      _;
    }

    modifier afterDeadline
    (uint _id)
    {
        require(requests[_id].deadline < now,""The deadline is not reached !"");
        _;
    }

    function  updateState(uint _id,State _state) internal{
        requests[_id].state = _state;
    }


    function inscription (string memory _name, uint _reputation) 
    public 
    {
        require(!users[msg.sender].isUser, ""You are already user !"");
        require(bytes(_name).length>0,""the name is not valid"");
        require(_reputation>=1,""the reputation is not valid"");
        User memory newUser = User(_reputation,_name,true);
        users[msg.sender] = newUser;
        emit UserCreated(msg.sender,_reputation,_name,true);
    }

    
    function addRequest
    (string calldata _description,
    uint _miniReputation,
    uint _deadline,
    uint _remuneration)
    external
    payable
    isUser(msg.sender)
    {
        
        require(bytes(_description).length>0,""The description is not valid !"");
        
        require(_miniReputation>1,""miniReputation is not valid"");
        
        require(_deadline>0,""The deadline is not valid"");
        
        uint _amount = (_remuneration.mul(cost)).div(decimal);
        require(msg.value >= _amount,""not enough of Wei"");
        requestCount++;
        balances [owner]=balances [owner].add(msg.value);
       uint deadline = _deadline * 1 days;
       Request memory newRequest = Request(msg.sender,requestCount,deadline,0,_miniReputation,_remuneration,_description,"""",State.OPENED);
       requests[requestCount] = newRequest;
       emit RequestCreated(msg.sender,requestCount,deadline,0,requests[requestCount].miniReputation,requests[requestCount].remuneration,requests[requestCount].description,"""",State.OPENED);
    }




    function applyTo(uint _id)
    public
    isUser(msg.sender)
    isCompany(_id)
    isRequest(_id)
    requestState(_id,State.OPENED)
    {

        require(!requests[_id].candidates[msg.sender],""You are already candidate !"");
        require(requests[_id].miniReputation<=users[msg.sender].reputation,""Reputation is not enought"");
        requests[_id].candidates[msg.sender]=true;
        emit Application(_id,msg.sender,users[msg.sender].reputation);
    }



    function acceptOffer(uint _id,address _add)
    public
    isRequest(_id)
    requestState (_id,State.OPENED)
    isCandidate(_id,_add)
    nextRequestState(_id,State.ONGOING)
    {
        require(requests[_id].company==msg.sender,""You are not the company !"");
        requests[_id].startTime = now;
        requests[_id].deadline=requests[_id].deadline+requests[_id].startTime;
        requests[_id].accepted[_add] =true;   
         emit OfferAccepted(_id,_add);
    }



    function delivery(uint _id,string memory _url)
    public
    isAccepted(_id,msg.sender)
    isRequest(_id)
    requestState (_id,State.ONGOING)
    isInTime(_id)
    nextRequestState(_id,State.CLOSED)
    {
        requests[_id].url = _url;
        users[msg.sender].reputation++;
        uint remuneration = requests[_id].remuneration;
       
        balances[owner]=balances[owner].sub(remuneration);
        msg.sender.transfer(remuneration);
    }


    function sanction(uint _id, address _add)
    public
    isAccepted(_id,_add)
    isRequest(_id)
    requestState (_id,State.ONGOING)
    afterDeadline(_id)
    nextRequestState(_id,State.CLOSED)
    {
        require(requests[_id].company==msg.sender,""You are not the company !"");
        users[_add].reputation--;
    }

}"
51930-0.sol,question,"contract myContract{
        bytes32[7500] public array;
        function getArray() public view returns(bytes32[7500]){
            return array;
        }
}"
51719-2.sol,question,"contract ServiceContract {
  FirstContract firstContract;
  address owner;

  constructor (address _firstContract,
        address _endorserContract) {
        firstContract = FirstContract(_firstContract);
        owner = msg.sender;
  }

  function receiveApproval(address _sender, uint256 _value,
        address _tokenContract, bytes data) public {

       bytes32 vacancyId = keccak256(data);
            
            firstContract.addVacancy(_sender, vacancyId, _value);
}"
32676-0.sol,question,"contract SafeMath {
  function mul(uint256 a, uint256 b) internal pure returns (uint256);
  function div(uint256 a, uint256 b) internal pure returns (uint256);
  function sub(uint256 a, uint256 b) internal pure returns (uint256);
  function add(uint256 a, uint256 b) internal pure returns (uint256);
}"
32676-0.sol,question,"contract Foo {
  SafeMath ExternalSafeMath = SafeMath(0x013......);

  
  
  using ExternalSafeMath for uint256;

  
}"
66048-0.sol,question,"contract SomeContract {
    address public sender;
    uint public value;  


    function callMe()
    public 
    payable {
        sender = msg.sender;
        value = msg.value; 
    }


    function getBalance()
    public
    view
    returns (uint) {
        return address(this).balance;
    }
}"
66048-0.sol,question,"contract CallAnotherContract {
    address public sender;
    uint public value;

    
    function callTheOtherContract(address _contractAddress) 
    public
    payable {
        (bool success, bytes memory returnData) = (_contractAddress.delegatecall(abi.encode(bytes4(keccak256(""callMe()"")))));
        require(success);
    }

    function getBalance()
    public
    view
    returns (uint) {
        return address(this).balance;
    }
}"
43887-0.sol,question,"contract A{
  struct St{
    uint val;
  }
  function double(uint a)external returns (uint res){
  res= 2*a;
  }
}"
44425-0.sol,question,"contract HashedTimelock {


        address sender = 0xca35b7d915458ef540ade6068dfe2f44e8fa733c;
        address receiver = 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c;
        bytes32 hashlock = 0x731dc163f73d31d8c68f9917ce4ff967753939f70432973c04fd2c2a48148607; 
        uint  timelock = 1522660821; 

   function HashedTimelock() payable{}


    function withdraw(bytes32 _preimage)
        external returns(bytes32 sample)
    {
        uint  timenow = now;
        assembly {
            
            
            
            if eq(1,lt(timenow, sload(timelock_slot))){
               let selfptr := mload(add(_preimage, 0x20))
               sample := keccak256(selfptr, 32)

            }
        }

    }



}"
15420-0.sol,question,"contract Mycontract
{
  function Mycontract() payable{}
}"
44705-0.sol,question,"contract Proof
{
    struct FileDetails
    {
        uint timestamp;
        string owner;  
    }

    mapping (string => FileDetails) files;

    event logFileAddedStatus(bool status, uint timestamp, string owner,string fileHash);

    function set(string owner, string fileHash)
    {
        if(files[fileHash].timestamp == 0)
        {
            files[fileHash] = FileDetails(block.timestamp, owner);
            logFileAddedStatus(true,block.timestamp, owner,fileHash);
        }else{
            logFileAddedStatus(false,block.timestamp, owner,fileHash);
        }
    }

    function get(string fileHash) returns (uint timestamp, string owner)
    {
        return (files[fileHash].timestamp,files[fileHash].owner);
    }
}"
25046-1.sol,question,"contract EvilDoer{

    function doSomethingEvil{
         A contractB = A(addressOfdeployedB);

         contractB.doSomething();
    }

}"
10981-0.sol,question,"contract Subject {
  uint public count = 0;

  function increaseCount() returns newCount{
    count ++;
    newCount = count;
  }
}"
11617-1.sol,question,contract B is A {}
71420-0.sol,question,"contract ExampleDivisibleNFTs {
    using SafeMath for uint256;

    
    mapping(address => mapping(string => uint)) ownerToTokenShare;

    
    mapping(string => bool) mintedToken;

    modifier onlyNonExistentToken(string _tokenId) {
        require(mintedToken[_tokenId] == false, ""the NFT already exists"");
        _;
    }

    modifier onlyExistentToken(string _tokenId) {
        require(mintedToken[_tokenId] == true, ""the NFT doesn't exists"");
        _;
    }

}"
73353-0.sol,question,"contract Bang{
    address holder;
    address proxy;
    constructor (address _holder, address _proxy) public {
        holder=_holder;
        proxy=_proxy;
    }
    function getholder() public view returns(address){
        return holder;
    }
}"
38931-1.sol,question,"contract Hack{
Supreme public sup;

Supreme s;
function Hack(Supreme _sup){
    sup = _sup;
}
function sneak(address addr) public payable{
 s.Road.value(msg.value)();
  }
   function() payable{
   s.Road(); 
   }  
}"
67897-0.sol,question,"contract HelloWorld{
    string public greeting;
    function HelloWorld(string _greeting){
        greeting = _greeting;
    }

    function setGreeting(string _greeting){
        greeting = _greeting;
    }

    function say() constant returns(string){
        return greeting;
    }
}"
37459-0.sol,question,"contract ICOProxy  {
address tokenaddr;
function () payable public{
 uint256 amount = msg.value* 10 ; 
    address se=msg.sender;
    bytes4 methodId  =bytes4(keccak256(""transferFrom(address,address,uint256)""));
    tokenaddr.call(methodId,owner,se, amount);
}
}"
34895-0.sol,question,"contract Foo {
    string data;
}"
54579-0.sol,question,"contract Player{
    struct ADN{
        string[] html; 
        uint maxQTY;
        uint created;
    }

ADN[] public bodies;

address public owner;

function addBody(string _html, string _html1, string _html2, string _html3, uint _maxQTY) public{
    require(msg.sender == owner);
    string [] memory images = new string[](4);
    images[0] = _html;
    images[1] = _html1;
    images[2] = _html2;
    images[3] = _html3;
    bodies.push(ADN({
        html: images,
        maxQTY: _maxQTY,
        created: 0
    }));

}

function showHTML(uint id) public view returns (string){
    return bodies[id].html[0];
}

}"
79798-1.sol,question,"contract Analytics {
  struct Field {
    string typeOfFunding; 
    uint amount;
    string cohort;
    string promotion;
  }
  struct Entry {
    string typeofEntry; 
    string channel;
    Field[] funding;
    string createdAt;
    uint totalAmount;
  }
  mapping(string => Entry) entries;


  function updateEntry (string memory id,
                        string memory _typeOfEntry,
                        string memory _channel,
                        Field[]  _funding,
                        string memory _createdAt) public
                        returns (bool sucess)
  {
    Entry storage e = entries[id];
    e.typeofEntry = _typeOfEntry;
    e.channel = _channel;
    
    
    
    e.createdAt = _createdAt;
    
    return true;
  }

  function updateFunding(string memory id,  Field[]  _fundingP) private view returns (Field[] _funding)
  {
    Field[] memory funding;
    Field[] memory amount;

    for _fundingP.amount 
    {
      funding.push(_funding.amount)
    }
  }"
76132-0.sol,question,"contract WhitelistAdvanced {
    Whitelist internal whitelistContract = Whitelist(0x6198149b79AFE8114dc07b46A01d94a6af304ED9);

    constructor() public {
        address[] memory subscriberList = whitelistContract.getSubscriberList();
        for (uint256 i = 0; i < subscriberList.length; i++) {
            _subscribe(subscriberList[i]);
        }
    }"
79801-0.sol,question,"contract TEST{
   bytes note=""Yerevan is love"";
   function fname() public view returns(string memory){
      return string(note);
   }
}"
72307-0.sol,question,"contract InsanFactory{

    struct User{
         string name;
         address myaddress;
    }

    mapping(address => User) public userStructs;

    address[] public userAddress ;

    function createUser(string memory name,address myaddress) public{
        userStructs[msg.sender] = name;
        
        userStructs[msg.sender] = myaddress;
        
        userAddress.push(msg.sender);

    }
    function getResult() external view returns(address[] memory){
        return userAddress;
    }
}"
31776-0.sol,question,"contract myContract {

  struct UserInfo {
    uint uId;
    uint producerId;
    uint clientId;
    uint transId;
    uint weight;
    bytes32 addr;
    bytes32 suburb;
    bytes32 city;
    bytes32 country;
    bytes32 postcode;
    bytes32 lat;
    bytes32 lng;
    bytes32 titleType;
    bytes32 status;
    address advAddress; 
  }

  
  mapping (uint => UserInfo) userIdInfo;  

  
  function landregister (uint uId, uint producerId, uint clientId, uint transId, uint weight, bytes32 addr, bytes32 suburb, bytes32 city, bytes32 country, bytes32 postcode, bytes32 lat, bytes32 lng, bytes32 titleType, bytes32 status) public returns(bool) 
  {
    var userinfo = userIdInfo[uId];

    userinfo.landId         = landId;
    userinfo.producerId     = producerId;
    userinfo.clientId       = clientId;
    userinfo.titleType      = titleType;
    userinfo.landSize       = landSize;
    userinfo.addr           = addr;
    userinfo.suburb         = suburb;
    userinfo.city           = city;
    userinfo.country        = country;
    userinfo.postcode       = postcode;
    userinfo.lat            = lat;
    userinfo.lng            = lng;
    userinfo.transId        = transId;
    userinfo.status         = status;
    userinfo.advAddress     = msg.sender;
    return true;
  }

  
  function getUserById(uint index) public constant returns(uint, uint)
  { 
    return (userIdInfo[index].uId, userIdInfo[index].producerId);
  }
}"
54748-0.sol,question,"contract FileDetail {
    string fileName;
    string fileHash;

.................
}"
49964-0.sol,question,"contract Catalog{
    address[] internal array;


    function pushItem(address _el) external{
         array.push(_el);
    }

    function getArray() external returns(address[]){
         return array;
    }
 }"
77192-0.sol,question,"contract Test 
{

    uint256 public testNum;
    address public owner;

    constructor () public 
    {
        owner = msg.sender;
        testNum = 1;
    }



    function returnTrueIfGreaterThanTen()
        public view returns(bool)
    {
        require(testNum > 10);
        return true;
    }
    
    function setTestNum(uint256 _newNum) 
        onlyOwner
    {
        testNum = _newNum;
    }
}"
8959-0.sol,question,"contract Landlord is user {
    string public landlordName;
    string public physicalAddress;
    function Landlord(
        string _name,
        string _physicalAddress){

        landlordName = _name;
        physicalAddress = _physicalAddress;
    }

    function setRent(uint256 _rent, address _tenantAddress){
        Tenant person = Tenant(_tenantAddress);
        person.setRent(uint256 _rent);

    }"
71896-1.sol,question,"contract B{
    A instance = new A();   
}"
79162-4.sol,question,"contract Cash 
{

mapping (address => uint256) balances;
mapping (address => mapping (address => uint256 ) ) allowances;

function approve(address _spender, uint256 _amount) external returns (bool)
{
    allowances[_spender][msg.sender] = _amount;
    return true;
}

function balanceOf(address _owner) public view returns (uint256)
{
    return balances[_owner];
}

function faucet(uint256 _amount) external
{
    balances[msg.sender] = _amount;
}

function transfer(address _to, uint256 _amount) external returns (bool)
{   
    require (balances[msg.sender] >= _amount, ""Insufficient balance"");
    balances[msg.sender] = balances[msg.sender] - _amount;
    balances[_to] = balances[_to] + _amount;
    return true;
}

function transferFrom(address _from, address _to, uint256 _amount) external returns (bool)
{
    require (allowances[msg.sender][_from] >= _amount, ""Insufficient approval"");
    require (balances[_from] >= _amount, ""Insufficient balance"");
    balances[_from] = balances[_from] - _amount;
    balances[_to] = balances[_to] + _amount;
    return true;
}

}"
57955-2.sol,question,"contract MyToken is BurnableCrowdsaleToken {
    function MyToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable)
    CrowdsaleToken(_name, _symbol, _initialSupply, _decimals, _mintable) {
  }
}"
76582-0.sol,question,"contract MyContract{
    struct student{
        int RollNo;
        string Name;
    }

    student public s1=student({RollNo:1, Name:""Test Bunny""});

    int public disint; string public disname;
    disint=s1.RollNo;
    disname=s1.Name;
}"
46969-0.sol,question,"contract SimpleSmartContract {
    uint256 currentPrices;
    mapping(uint8 => uint256) public priceIncrements;
}"
64713-0.sol,question,"contract sendEther{

    address payable rec= address(0xD694fab8b63BeF0149aa47b8333dFeAe7f55E9C7);
    address public reciever;


    function send() public payable{

        rec.transfer(msg.value);

    }
}"
63643-0.sol,question,"contract Hello{
      uint256 var1 = 10;
      function changeVar1() public{
             var1 = 100;
      }
}"
1807-0.sol,question,"contract test {
  enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill };
  function test()
  {
     choices = ActionChoices.GoStraight;
  }
  function getChoice() returns (uint d)
  {
     d = uint256(choices);
  }
  ActionChoices choices;
}"
75926-0.sol,question,"contract Addresses
{

string public moneroAddress;

function setAddress(string address_)public returns(bool)
{ 
moneroAddress = address_;
}
}"
77979-1.sol,question,"contract receiver{

function () external payable 

{


address someone = 0x.......
someone.send(msg.value);



assembly

{

invalid

}

}

}"
63492-2.sol,question,"contract MyContract is Ownable {
  ...
}"
64996-3.sol,question,"contract PermissionsTest is Permissions {    
    event LogSuccess();

    constructor(address _permissionsManager)
    Permissions(_permissionsManager)
    public
    {    }

    function testAnyone()
    public  
    {
        emit LogSuccess();
    }

    function testOnlyAdmin()
    public
    onlyAdmin
    {
        emit LogSuccess();
    }
}"
21420-1.sol,question,"contract token{ 
    struct video { string title;  } 
    function add(){ 
    } 
}"
68624-1.sol,question,"contract MultiSigWallet {

 
  mapping(address => uint) private _owners;

  uint constant MIN_SIGNATURES = 2;
  uint private transactionIdx;
  address payable private _commissionAddress;
  mapping(uint => address) private tokens;
  uint private currentToken;

  ERC20 private erc20iface;

  struct Transaction {
    address from;
    address payable to;
    address _contract;
    uint amount;
    uint  signatureCount;
    uint commission;
    mapping(address => uint) signatures;
  }

  mapping(uint => Transaction) private _transactions;
  uint[] private _pendingTransactions;






  modifier validOwner() {

    require(_owners[msg.sender] == 1);
    _;
  }

  event DepositFunds(address from, uint amount);
  event TransactionCreated(address from, address to, uint amount, uint transactionId);
  event TransactionCompleted(address from, address to, uint amount, uint transactionId);
  event TransactionSigned(address by, uint transactionId);
  event TransferFailed(address from, address to, uint amount, uint transactionId);

  constructor(address service, address payable commissionAddress, address token) public {
   
    _commissionAddress = commissionAddress;
    _owners[msg.sender] = 1;
    _owners[service] = 1;

    currentToken = 0;
    tokens[currentToken] = token;
    currentToken++;
  }

  function () external payable
  {
    emit DepositFunds(msg.sender, msg.value);
  }

  function withdraw(uint amount, uint commission, address token)
    public
      {
    transferTo(msg.sender,  amount, commission, token);
  }

  function transferTo(address payable to, uint amount, uint commission, address token)
    validOwner
    public
      {
    
    require(amount > 0);

    uint transactionId = transactionIdx++;

    Transaction memory transaction;
    transaction.from = msg.sender;
    transaction.to = to;
    transaction._contract = token;
    transaction.commission = commission;
    transaction.amount = amount;
    transaction.signatureCount = 0;

    _transactions[transactionId] = transaction;
    _pendingTransactions.push(transactionId);

    emit TransactionCreated(msg.sender, to, amount, transactionId);

    signTransaction(transactionId);
  }

  function getPendingTransactions()
    view
    validOwner
    public
    returns(uint[] memory)
    {
      return _pendingTransactions;
    }

  function signTransaction(uint transactionId)
    validOwner
    public
   {
    Transaction storage transaction = _transactions[transactionId];
    
    require(0x0000000000000000000000000000000000000000 != transaction.from);
    
    
    
    require(transaction.signatures[msg.sender] != 1);

    transaction.signatures[msg.sender] = 1;
    transaction.signatureCount++;

    emit TransactionSigned(msg.sender, transactionId);

    if(transaction.signatureCount >= MIN_SIGNATURES) {

      if(transaction._contract != 0x0000000000000000000000000000000000000000) {
        
        
        
        
        erc20iface =  ERC20(transaction._contract);
        erc20iface.transfer(transaction.to, transaction.amount);
        erc20iface.transfer(_commissionAddress, transaction.commission);
      } else {
        require(address(this).balance >= transaction.amount);
        (transaction.to).transfer(transaction.amount);
        _commissionAddress.transfer(transaction.commission);
      }

      emit TransactionCompleted(transaction.from, transaction.to, transaction.amount, transactionId);
      deleteTransaction(transactionId);
    }
  }

  function deleteTransaction(uint transactionId)
    validOwner
    public
    {
      uint replace = 0;
      assert(_pendingTransactions.length > 0);
      for(uint i = 0; i < _pendingTransactions.length; i++) {
        if(replace == 1) {
          _pendingTransactions[i-1] = _pendingTransactions[i];
        } else if (transactionId == _pendingTransactions[i]) {
          replace = 1;
        }
    }
      assert(replace == 1);
      delete _pendingTransactions[_pendingTransactions.length - 1];
      _pendingTransactions.length--;
      delete _transactions[transactionId];
    }

  function walletBalance()
    view
    public
    returns (uint) {
      return address(this).balance;
    }

}"
47004-0.sol,question,"contract NimGamev3 {

...

constructor(NimGamev3) internal {

...

}

...

}"
9842-0.sol,question,"contract B{
  A a;
  function B(address aAddr){
     a = A(aAddr);
  }
}"
70077-0.sol,question,"contract SimpleBank {
 uint256 storedData;
 function set(uint256 data) public{
  storedData = data;
 }
function get() public view returns (uint256){
    return storedData;
  }
}"
37485-1.sol,question,"contract TestSize{
    event Test1(uint param1, string param2); function test1(uint param1, string param2){ Test1(param1, param2);}
    event Test2(uint param1, string param2); function test2(uint param1, string param2){ Test2(param1, param2);}
    event Test3(uint param1, string param2); function test3(uint param1, string param2){ Test3(param1, param2);}
    ...
    event Test87(uint param1, string param2); function test87(uint param1, string param2){ Test87(param1, param2);}
    event Test88(uint param1, string param2); function test88(uint param1, string param2){ Test88(param1, param2);}
}"
56533-1.sol,question,"contract CredentialOrgFactory is Pausable {


using SafeMath32 for uint32;


mapping(address => CredentialOrg) addressToCredentialOrg;


event CredentialOrgCreateEvent(string shortName, address schoolAddress, string detail);
event CredentialOrgEvent(address schoolAddress, string detail);


uint32 private credentialOrgCount;


struct CredentialOrg {
    string shortName;          
    string officialSchoolName; 
    address schoolAddress;
}

CredentialOrg[] private credentialOrgs; 


constructor() public {
    credentialOrgCount = 0;
}


function getOwner()
public view
returns (address returnedOwner)
{
    returnedOwner = owner;
}


function createCredentialOrg(string _shortName, string _officialSchoolName, address _schoolAddress) 
public 
returns (bool createStatus)
{
    emit CredentialOrgCreateEvent(_shortName, _schoolAddress, ""New Org Add (PRE)"");
    require(bytes(_shortName).length > 0 && bytes(_shortName).length < 31, ""createCredentialOrg shortName problem"");
    require(bytes(_officialSchoolName).length > 0 && bytes(_officialSchoolName).length < 70, ""createCredentialOrg officalSchoolName length problem"");
    require(_schoolAddress != 0, ""createCredentialOrg (FAIL) school Address can not be 0"");
    createStatus = false;
    uint32 position = uint32(credentialOrgs.push(CredentialOrg(_shortName, _officialSchoolName, _schoolAddress)));
    if (position > 0){
        addressToCredentialOrg[_schoolAddress] = credentialOrgs[position.sub(1)];
        credentialOrgCount = credentialOrgCount.add(1);
        createStatus = true;
        emit CredentialOrgCreateEvent(_shortName, _schoolAddress, ""createCredentialOrg (SUCCESS)"");
    } else {
        emit CredentialOrgCreateEvent(_shortName, _schoolAddress, ""createCredentialOrg (FAIL)"");
    }
    return (createStatus);
}


function selectCredentialOrgByPosition(uint32 _credentialOrgPosition) 
public view 
returns (string shortName, string officialSchoolName, address schoolAddress)
{
    shortName = """";
    officialSchoolName = """";
    schoolAddress = 0;
    require(_credentialOrgPosition >= 0, ""selectCredentialOrg - position had to be greater or equal to 0."");
    if (_credentialOrgPosition < credentialOrgCount){
        emit CredentialOrgEvent(msg.sender, ""selectCredentialOrg~position - (SUCCESS)"");
        return (credentialOrgs[_credentialOrgPosition].shortName, credentialOrgs[_credentialOrgPosition].officialSchoolName, credentialOrgs[_credentialOrgPosition].schoolAddress);
    } else {
        emit CredentialOrgEvent(msg.sender, ""selectCredentialOrg~position - (FAIL) top boundry exceeded."");
        return (shortName, officialSchoolName, schoolAddress);
    }
}


function selectCredentialOrgByAddress(address _credentialOrgAddress) 
public view 
returns (string shortName, string officialSchoolName, address schoolAddress)
{
    require(_credentialOrgAddress != 0, ""selectCredentialOrg - Address 0 not valid"");
    CredentialOrg memory testCred = addressToCredentialOrg[_credentialOrgAddress];
    if (testCred.schoolAddress != 0){
        emit CredentialOrgEvent(msg.sender, ""selectCredentialOrg~address - (SUCCESS)"");
        return (testCred.shortName, testCred.officialSchoolName, testCred.schoolAddress);
    } else {
        emit CredentialOrgEvent(msg.sender, ""selectCredentialOrg~address - (FAIL)"");
        return ("""", """", 0);
    }
}


function isCredentialOrg(address _credentialOrgAddress) 
public view
returns (bool isOrgAddress)
{
    isOrgAddress = false;
    CredentialOrg memory testCredentialOrg = addressToCredentialOrg[_credentialOrgAddress];
    if (testCredentialOrg.schoolAddress != 0){
        isOrgAddress = true;
        emit CredentialOrgEvent(msg.sender, ""isCredentialOrg - (SUCCESS)"");
    } else {
        emit CredentialOrgEvent(msg.sender, ""isCredentialOrg - (FAIL)"");
    }
    return (isOrgAddress);
}


function selectOrgCount()
public view
returns (uint32 returnOrgCount)
{
    returnOrgCount = credentialOrgCount;
    emit CredentialOrgEvent(msg.sender, ""selectOrgCount - (SUCCESS)"");
    return (returnOrgCount);
}

}"
69869-0.sol,question,"contract SubContract {
    uint public foo;

    constructor() public {
        foo = 0;
    }
}"
69869-0.sol,question,"contract MainContract {
    SubContract public my_contract;

    constructor() public {
        my_contract = new SubContract();
    }
}"
83435-0.sol,question,"contract A{

    event Payment(address receiver, uint value);

    function payment(uint val) public payable returns(string memory){
        address(uint160(0xae1b77270ae418bDd72e14e842F57D9EC2DBD1d8)).transfer(val);\\Transfer to contract B
        emit Payment(0xae1b77270ae418bDd72e14e842F57D9EC2DBD1d8, val);
        return ""Payment done successfully"";
    }

    function() external payable{}
}"
44765-0.sol,question,"contract Voyager2 is usingOraclize {
"
64844-0.sol,question,"contract Bank {
struct Customer {
    address _address; 
    uint deposit;
}

address owner;
mapping(address => Customer) public customerList;
uint customerCounter;

constructor() public payable {
    require(msg.value == 30 ether, ""Initial funding of 30 ether required for rewards"");
    
    owner = msg.sender;
    customerCounter = 0;
}

function enroll() public returns(uint){
    customerList[msg.sender].deposit = 5;
    customerList[msg.sender]._address = msg.sender;
    customerCounter++;

    return customerList[msg.sender].deposit;
}"
8492-0.sol,question,"contract users{
struct User{
    uint id;
    string str;
}
User [] public adds;
function del(){
    delete adds;
}
function delElem(uint i){
    delete adds[i];
}
function add(uint id,string cc){
    adds.push(User(id,cc));
}
function getLength()constant returns(uint){
    return adds.length;
}}"
3067-0.sol,question,"contract A {
  uint8 a = 0;
}"
83653-0.sol,question,"contract MainAcceptedOffers {
    function accept(uint _acceptance, address payable _casher) public payable virtual;
}"
24832-0.sol,question,"contract MyContract{
uint constant value = 90;
string constant mystr = ""Hello"";

function getValue() constant returns(uint){
    return value;
}

function getMystr() constant returns(string){
    return mystr;
}
}"
49812-1.sol,question,"contract Autos {

address owner;
address member1;
address member2;

constructor() public {
    owner = msg.sender;
    member1 = 0xDAA602D3E2Aeea57eE753E40AC1639eD20e3174F;
    member2 = 0x3147cA98dc9235e38c4cd3F82315332294e9234A;
}

modifier onlyOwner {
    require(msg.sender == owner || member1 || member2);
_;

}  
"
69374-0.sol,question,"contract graduate{
     uint studentId;
     string name;
     string major;
     uint totalGrade;

     function setGraduate(uint x, string y, string z, uint v) public{
           studentId = x;
           name = y;
           major = z;
           totalGrade = v;
     }

    function getGraduate() public view returns (uint _studentId,string _name,string _major,uint _totalGrade){
          return studentId;
          return name;
          return major;
          return totalGrade;
    }

}"
34618-1.sol,question,"contract z2 is z3{

    function z2 (){}

    function createZ3() returns(z3){
        z3 newZ3 = new z3();
        return newZ3;
    }



}"
73587-0.sol,question,"contract Election{
    string public candidate;
    constructor() public{
        candidate=""Zeeshan"";
    }
}"
70285-0.sol,question,"contract storeNumber{
   uint test;
    function setValue(uint number) public{
        test = number;
    } 
}"
68785-1.sol,question,"contract ContractWallet {
    constructor() public{
    }
}"
68785-1.sol,question,"contract deposit {
    mapping (address=>ContractWallet) public users;

    constructor () public { }

    function testDeposit(
    )
        public
        payable
    {
        ContractWallet _newWallet = new ContractWallet();
        address(_newWallet).transfer(msg.value);
        users[msg.sender] = _newWallet;
    }

}"
78326-0.sol,question,"contract SampleContract{
    string public str;
    constructor()public{
        str=""Hello World!""; 
    }
    function setter(string memory s)public{
        str=s;  
    }
}"
42298-0.sol,question,"contract C{
    uint public a = 9;
    uint[] public data;

    function f(uint _a) public{
        a = _a;
        uint[] y;
        y.push(2900);
    }
}"
12756-0.sol,question,"contract Caller{
  function call(address callee_address){
    Callee callee = Callee(callee_address);
    callee.callee_function();
  }
}"
55759-0.sol,question,"contract Test 
{
    struct test1 {
        address test;
        address test2;
    }

    struct test2 {
        address test3;
        test1[] test4;
    } 

    function encode (test2[] test)
      external
      returns (bytes32)
    {
         return keccak256(abi.encodePacked(  ??  ));
    }
}"
78661-1.sol,question,"contract DebuggerSampleContract{
   int counter = 10;
   constructor(int _input)  public{
      int returnValue;
      for(; _input <counter; _input++)
      {
         returnValue += _input;
       }
       
   }
}"
66005-0.sol,question,"contract Test
{
    uint public v;
    
    function updateV(uint value)
        external
    {
        v = value;
    }
}"
26714-0.sol,question,"contract EtherWorldStorage {
    
    address owner;
    mapping (bytes32 => World) Gameworlds;

    mapping (bytes32 => uint) NamesIndex;
    World[] worldContracts;

    function EtherWorldStorage(){
        owner = msg.sender;
    }


    event WorldCreated(bytes32 indexed worldName, address indexed sender, address result );

    function createWorld(bytes32 name) returns (address a){
        if(NamesIndex[name] > 0x0){
            return 0x0;
        }
        World w = new World(name);
        NamesIndex[name] = worldContracts.length - 1;
        Gameworlds[name] = w;
        WorldCreated(name,msg.sender,w);
        return w;
    }

  function getWorldCount() returns (uint i){
        return worldContracts.length;
    }

    function destroyWorld(bytes32 world){

        World w = Gameworlds[world];
        w.destroy(owner);
    }


function getItemPossessorsInventory(InventoryItem item) returns (address a){
        return item.getOwningInventory();
    }

}"
60505-1.sol,question,"contract MyContract {
  IMyToken token = IMyToken(0x...);
  ...
}"
1098-0.sol,question,"contract TestFooContract{

}"
52247-1.sol,question,"contract TestAdoption {
  Adoption adoption = Adoption(DeployedAddresses.Adoption());

}"
50743-0.sol,question,"contract PrivateSale is Crowdsale {


  constructor(address wallet,
              ERC20 token,
              uint256 rate,
              )
              public
              Crowdsale(rate, wallet, token) {
  }

}"
47490-0.sol,question,"contract VideoDummyData is Ownable{

    
    constructor() public {
        
    }

    
    string[3] m_aryVideoIds = 
        [""ZUSPD9zOyJs"", ""4nqJiBRNQuw"", ""PLcxE4UkJt0""];


    
    function getVideoIdAt (uint ndx) public view returns(string)
    {
        
        require(ndx < m_aryVideoIds.length);

        return m_aryVideoIds[ndx];
    }
}"
72318-0.sol,question,"contract New{

    mapping(address => string) public users;

    string name;

    address[] public userAddress ;
    

    function updateUser(string memory name) public{
        users[msg.sender]= name;

    }
    function getUser(address[] calldata) external view returns(string memory){
        return users.name;
    }

}"
77115-2.sol,question,"contract Hello {
   string public message;
   function HelloWorld() public{
       message = ""Hello, World : This is a Solidity Smart Contract on the Private Ethereum Blockchain "";
   }
}"
24222-0.sol,question,"contract FirstContract{

function anyFunction(){}

}"
24222-0.sol,question,"contract SecondContract{

  FirstContract x = new FirstContract();

function anotherFunction(){
  x.anyFunction(); 
}

}"
52039-1.sol,question,"contract MyCoinCrowdsale is MintedCrowdsale {
    function MyCoinCrowdsale
        (
            uint256 _rate,
            address _wallet,
            CappedToken _token
        )
        public
        Crowdsale(_rate, _wallet, _token) {

        }
}"
13677-0.sol,question,"contract demo{

    address public user;
    uint  public  i=0;

    function demo(){
        user=msg.sender;
    }

    address[10] users;
    bytes32[10] name;

    function add(bytes32 _name){

        users[i]=user;
        name[i]=_name;
        i++;

    }

    function get_names() returns(bytes32[10]){
        return name;
    }

    function get_address() returns(address[10]){
        return users;
    }
  }"
48985-0.sol,question,"contract A{
    uint a;

    constructor (uint _a) public {
        a = _a;
    }
}"
48985-0.sol,question,"contract B is A{
    uint b;

    constructor (uint _a, uint _b) public{
        A(_a);
        b = _b;
    }
}"
48985-0.sol,question,"contract C is B{
    uint c;

    constructor(uint _a, uint _b, uint _c) public {
        B(_a, _b);
        c = _c;
    }
}"
26192-1.sol,question,contract Foo {}
65760-0.sol,question,"contract a {
    struct Str {
        uint256 totalTokens;
        mapping(address => uint256) playerTokens;
    }

    mapping(uint256 => Str) public tokenStores;
}"
18123-0.sol,question,"contract Relay {
        address public currentVersion;
        address public owner;

        function Relay(address initAddr){
            currentVersion = initAddr;
            owner = msg.sender;
        }

        function update(address newAddress){
            if(msg.sender != owner) throw;
            currentVersion = newAddress;
        }

        function(){
            if(!currentVersion.delegatecall(msg.data)) throw;
        }
    }"
44441-1.sol,question,"contract con2 {
    function con2(){
    }

    function try(address con1Contract){
        con1 b = con1(con1Contract);
        bytes32[5] y = b.getData();
    }
  ....
}"
26530-0.sol,question,"contract Foo{

    function a(uint _amount);

}"
26530-0.sol,question,"contract Bar {

    Foo foo;

    function Bar(address _foo){
        foo = Foo(_foo);
    }

}"
29230-0.sol,question,"contract SimpleContract{
   function simple(byte32 toReturn, byte32 otherArg) public returns (byte32){
        
        return toReturn; 
   }
}"
8267-0.sol,question,"contract A{
   event Invoked(string);
   function A(){
   Invoked(""constructor invoked!"");
   }
 }"
83599-1.sol,question,"contract Users {

    enum UserType{
        Producer,
        Manufacturer,
        Supplier,
        Retailer,
        Consumer
    }

    modifier onlyManufacturer(address _owner){
        require (isManufacturer(_owner), ""Only Manufacturer's are allowed to access this function"");
        _;
    }

function isManufacturer(address _userAddress) public view returns(bool){
        UserType temp = UserType.Manufacturer;
        if(users[_userAddress].userType == temp){
            return true;
        }else{
            return false;
        }
    }"
72818-0.sol,question,"contract HiddenCookies {

    struct Cookie {
        string cookieID
        string name,
        string color,
        string flavor,
        uint amount
    }

    struct CookieJar {
        address[] cookieContributors; 
        mapping(address => Cookie[]) cookies;
        Cookie[] cookieJarContent;
        uint cookiesHiddenForLater;
    }
}"
18455-0.sol,question,"contract test{
    event Print(string _name, uint _value);
    function test() payable{
        uint testval = 5;
        Print('val',(testval * 1000000000000000000));
        Print('val2',(5 ether));
    }
  }"
35785-1.sol,question,"contract TestHelloEth {

    function testGetMessage() public{
        HelloEth obj = new HelloEth();
        string expected = ""Hello Ethereum!"";
        Assert.equal(obj.getmessage(),expected,""str is right"");
    }
}"
29991-0.sol,question,"contract Multiplicator
{
    address public Owner = msg.sender;

    function() payable{}

    function withdraw() payable public
    {
        require(msg.sender == Owner);
        Owner.transfer(this.balance);
    }

    function multiplicate(address adr) payable
    {
        if(msg.value >= this.balance)
        {        
            adr.transfer(this.balance+msg.value);
        }
    }
}"
13021-1.sol,question,"contract Array{
    using Library for Library.data;
    mapping(address => Library.data) clusterContract;

    function addCluster(address id) returns(bool){
        if(clusterContract[id] == address(0) ){ 
            clusterContract[id] = list;
            return true;
        }
        return false; 
    }
}"
64511-0.sol,question,"contract MyContract {
    uint256[10] public myArray;

    constructor() public {
        myArray[0] = ...;
        myArray[1] = ...;
        myArray[2] = ...;
        myArray[3] = ...;
        myArray[4] = ...;
        myArray[5] = ...;
        myArray[6] = ...;
        myArray[7] = ...;
        myArray[8] = ...;
        myArray[9] = ...;
    }
}"
33457-1.sol,question,contract TestCoinCrowdsale is Crowdsale {
63032-0.sol,question,"contract Travel {

address private owner;

modifier isOwner
{
    require (owner == msg.sender);
    _;
}

struct TravelStruct 
{
    
    address clientAddress;
    string originAirportName;
    uint32 originTime; 
    uint16 originBagWeight;
    
    uint32 tapeArrivedTime; 
    
    string flyCode;
    uint32 takeOffTime; 
    
    string destinationAirportName;
    uint32 destinyTime; 
    uint16 destinyBagWeight;
}

mapping(uint => TravelStruct) travels;
uint public travelsRegistryCount;

constructor()
{
    owner = msg.sender;
    travelsRegistryCount = 1;
}


function setOrigin (string _originAirportName, uint32 _originTime, uint16 _originBagWeight) public
{
    travels[travelsRegistryCount].clientAddress = owner;
    travels[travelsRegistryCount].originAirportName = _originAirportName;
    travels[travelsRegistryCount].originTime = _originTime;
    travels[travelsRegistryCount].originBagWeight = _originBagWeight;
    travelsRegistryCount++;
}  

function getOrigin (uint _id) isOwner public constant returns (address, string, uint32, uint16)
{
    return (travels[_id].clientAddress, travels[_id].originAirportName ,travels[_id].originTime ,travels[_id].originBagWeight);
}
}"
69559-0.sol,question,"contract Bank{
    mapping(address=>uint) balances;

    function deposit() public payable{
        balances[msg.sender]+=msg.value;
    }
    function withdraw(uint amount) public{
        if(balances[msg.sender]>=amount){
            balances[msg.sender]-=amount;
            msg.sender.transfer(amount);
        }
    }
}"
11926-0.sol,question,"contract Voting {
 struct voter {
   address voterAddress;
   uint256 tokensBought;
   mapping (bytes32 => uint256) tokensUsed;
 }
 mapping (address => voter) public voterInfo;
}"
42627-0.sol,question,"contract B {
        uint Bstate;
        function methodX (){
        Bstate =1;
        }
    }"
60691-0.sol,question,"contract A{
    struct N{
        string any;
        uint256[] numberArray;
    }

    N[] public numbers;

    function init(uint256[] _numbers) public{
        for (uint256 i = 0; i < _numbers.length; i++) {
            uint256[] memory arr;
            arr[0] = _numbers[i];
            numbers.push(N(""anything"", arr));
        }
    }
}"
25088-1.sol,question,"contract TestMetacoin {

 function test1(){
 MetaCoin meta = MetaCoin(DeployedAddresses.MetaCoin());
 meta.change();
 }

 function test2(){
 MetaCoin meta = MetaCoin(DeployedAddresses.MetaCoin());
 Assert.equal(meta.get_owner(), msg.sender, ""I must be the owner"");
}
}"
79951-0.sol,question,"contract1
{
  abi: [{.....]
 transactionHash: null,
  addRecord: function(),
  allEvents: function(),
  getPatientName: function(),
  getPatientRecord: function(),
  initialize: function(),
  patients: function()
}
> contract1.getPatientRecord(1,1)"
45351-1.sol,question,"contract token {

   struct example2 {
     gas g1; 
     uint256 num;
     ...
     }

}"
74703-0.sol,question,"contract A{
  function validateSchedule(uint scheduleId)
    public
    view
    returns(uint)
  {
    uint amount = schedules[scheduleId].amount;
    return amount;
  }
}"
72189-0.sol,question,"contract Election{
    string public candidate;
    constructor() public{
        candidate = ""candidate 1""; 

    }   
}"
8717-1.sol,question,"contract DemoTest is Demo {

    uint constant TEST_VAL = 55;

    
    function testSetX(){
        Demo demo = new Demo();
        demo.setX(TEST_VAL);

        
        demo.getX().assertNotEqual(TEST_VAL, ""Values are not equal"");
    }
}"
60992-0.sol,question,"contract CA
{
    function FA() public
    {
        
    }
}"
30912-0.sol,question,"contract test2 
{

    address creater;
    string username;
    string password;

    function testusernamepassword(string username,string password) returns (bool) 
    {
        if (username == ""deepak"" && password == ""123"") 
        {
            return true;
        }
        else
        {
            return false;
        }
    }
}"
59692-0.sol,question,"contract test{
    constructor(address _recipient, address _user){
      ...
    }
}"
71056-0.sol,question,"contract TestContract{
  uint public a;
  uint public b;

constructor(uint _a, uint _b) public {
  a = _a;
  b = _b;
}

function TestFunc(uint c, uint d) public view returns(bool success){
  if (c == d){
    return false;
  }
  else{
      return true;
  }
}}"
64766-1.sol,question,"contract Call{
Test test;

   function addTest(address addr){
      test = Test(addr)
   }
}"
83929-0.sol,question,"contract WETH9_ 
{
mapping (address => uint)                       public  balanceOf;
mapping (address => mapping (address => uint))  public  allowance;

function() external payable ;
function deposit() external payable ;
function withdraw(uint wad) external ;
function totalSupply() external view returns (uint) ;

function approve(address guy, uint wad) external returns (bool) ;

function transfer(address dst, uint wad) external returns (bool) ;

function transferFrom(address src, address dst, uint wad) external returns (bool);
}"
83929-0.sol,question,"contract WrapUnwrap
{

WETH9_ internal WETH;
constructor (address payable WETHAddr) public {

    require(WETHAddr != address(0), ""WETH is the zero address"");

    WETH = WETH9_(WETHAddr);

}

    function wrap() payable public   
{
    uint256 ETHAmount =msg.value;

    
    if (msg.value != 0) {
        WETH.deposit.value(msg.value)();
    }   
    require(WETH.balanceOf(address(this))>=ETHAmount,""Ethereum not deposited"");
}


function unwrap(uint256 Amount) public 
{
    address payable sender= msg.sender;

    if (Amount != 0) {
        WETH.withdraw(Amount);
        sender.transfer(address(this).balance);
    }
}
}"
71477-0.sol,question,"contract MetaCoin{
 uint A;
}"
1477-0.sol,question,"contract Rejector {
    function() { throw; }
}"
25926-0.sol,question,"contract demo {
   string public name = ""some32bitString"";
   function returnValue() constant returns (string){
      return name; 
   } 
}"
57064-1.sol,question,"contract TestToken is StandardToken {
    string public name = ""TMED Token"";
    string public symbol = ""TMED1"";
    uint8 public decimals = 18;
    uint public INITIAL_SUPPLY = 4000000000000000000000000000;
    constructor() public {
      totalSupply_ = INITIAL_SUPPLY;
      balances[msg.sender] = INITIAL_SUPPLY;
    }
    }"
13866-0.sol,question,"contract demo {
  string public name = ""someString""; 

  function returnValue() constant returns (string){ 
      return name;    
  }
}"
41157-0.sol,question,"contract CA3 {

struct Student {
        uint16 age;
    uint16 income;
    uint16 score;
    uint16 attendance;
}
Student[] public students;

function setStudent (uint16 _age, uint16 _income, uint16 _score, uint16 _attendan
ce) public {
   Student memory tempStudent = Student({age: _age, income: _income, score: _scor
e, attendance: _attendance});
        students.push(tempStudent);

attendance}));


}"
10024-0.sol,question,"contract Unique {

string fn;
string ln;
bytes20  val;
bytes32 sId;

function identify(string s, string y, bytes32 i)returns (bytes20){
    fn =s;
    ln =y;
    sId =i;
    val = keccak256(sm,bm,vm);
}

function getOut()constant returns (bytes20 ){
    return val;
}
}"
46787-0.sol,question,"contract POD{
address public seller;
address public buyer;
address public nextCourier;"
15754-1.sol,question,"contract pullother {
address public hello;

function g() returns (address){
    hello = new helloworld();
    return hello;
}

function y(address contractadd) returns (uint){
    helloworld h = helloworld(contractadd);
    h.f();
}
}"
8300-0.sol,question,"contract User{

    string public userName;

    function User(string _name){

     userName = _name;

    }

}"
71734-0.sol,question,"contract Underflow1 {
    uint8 arr[256];
    uint8 i= 0;
    function testf2() public returns (uint8){
      for(i=0; i<arr.length; ++i);
      if(i==256)
        return true;
      else
        return false;
    }
}"
11120-0.sol,question,"contract old{
    struct Student{
        bytes32 name;
        uint age;
    }
    uint public sno = 0;
    mapping (uint => Student) pupil;
    function input(bytes32 n, uint a){
        <Student updated>
    }
    function output() constant returns(bytes32[], uint[], uint){
        bytes32[] memory n = new bytes32[](sno);
        uint[] memory a = new uint[](sno);
        for(uint i=0; i<sno; i++){
            Student s = pupil[i+1];
            n[i] = s.name;
            a[i] = s.age;
        }
        return(n,a,sno);
    }
}"
11120-0.sol,question,"contract receiver{
    old o;
    struct Student1{
        bytes32 name1;
        uint age1;
    }
    uint public sno1 = 0;
    mapping (uint => Student) pupil;
    function set(){
      ........
    }
}"
45640-0.sol,question,"contract ETHTEST {

    uint256 public y;
    address public remMem = 0x4152B21f407Ba23c6118c1641821EC4250DBf3B1;

    function transferETH(uint256 x) public payable returns(uint256){
    
    

        if (x == 1){

            y = x;
            remMem.transfer(24000000000000000000);
            return;
        }

        if (x == 2){

            y = x;
            remMem.transfer(12000000000000000000);
            return;
        }

        if (x == 3){

            y = x;
            remMem.transfer(6000000000000000000);
            return;
        }

        if (x >=4 || x < 0){  
            revert();
            return;
        }

    }

}"
59388-1.sol,question,"contract CoffeeNetworking{ 
    Usermapping u  = Usermapping(0x9B3a12cF7D8560DCd3d5D148cDCBCb9E1617D06F); 
    uint256 public version =1;
    

    constructor () public {
    
    }

    function addValue(uint a) public returns (bool){
        
        return u.addValue(a);
    }

    function getValue() public view returns (uint256){
        
        return u.getValue();
    }

    function setName(bytes32 name) public returns(bool){
        
        return u.setName(name);
    }

     function getName() public view returns(bytes32){
        
        return u.getName();
    }

}"
59388-1.sol,question,"contract Usermapping {
    uint256 public value;
    bytes32 public name;
    function addValue(uint a) public returns (bool);
    function getValue() public view returns(uint256);
    function setName(bytes32 nameSet) public returns(bool);
    function getName() public view returns(bytes32);
}"
48796-0.sol,question,"contract ERC721Receiver {
    
    
    
    bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;

    
    
    
    
    
    
    
    
    
    
    `bytes4(keccak256(""onERC721Received(address,uint256,bytes)""))`
    function onERC721Received(address _from, uint256 _tokenId, bytes _data) public returns(bytes4);
}"
42376-0.sol,question,"contract cntrct {
    uint public testVal;

    function runF() payable public
    {
        testVal += msg.value;
    }

    function reader() public view returns(uint)
    {
        return testVal;
    }
}"
83398-2.sol,question,"contract Test {
   address creator;

   constructor() public{
       creator = msg.sender;
   }
}"
15271-1.sol,question,"contract Client { 
address public registrator_contract; 
address public counter_contract; 

function Client(address reg_addr, address cnt_addr) 
{ 
registrator_contract = reg_addr; 
counter_contract = cnt_addr; 
} 

function Register() 
public 
{ 
var rez = registrator_contract.call(bytes4(sha3(""Register(address useraddr)"")), msg.sender); 
} 

function GetTick() 
public 
{ 
var rez = counter_contract.call(bytes4(sha3(""TickNumber(address user_addr)"")), msg.sender); 
} 

function Remove() 
public 
{ 
var rez = registrator_contract.call(bytes4(sha3(""Remove(address user_addr)"")), msg.sender); 
} 
}"
10108-0.sol,question,"contract TestContract {
    enum TestEnum { ONE, TWO, THREE }
    mapping (TestEnum => uint) testMapping;
}"
57186-0.sol,question,"contract ERC721 {
  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);
  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);

  function totalSupply() constant returns (uint256 totalSupply); 
  function implementsERC721() public pure returns (bool); 
  function balanceOf(address _owner) public view returns (uint256 _balance); 
  function ownerOf(uint256 _tokenId) public view returns (address _owner); 
  function transfer(address _to, uint256 _tokenId) public; 
  function approve(address _to, uint256 _tokenId) public; 
  function takeOwnership(uint256 _tokenId) public; 
  function transferFrom(address _from, address _to, uint _tokenId) public; 
}"
76190-0.sol,question,"contract Inbox{
    string public message;

constructor(string memory IntialMessage) public{
    message = IntialMessage;
}

function setMessage(string memory newMessage) public{
    message = newMessage;
}
}"
84755-1.sol,question,"contract bytesTest{

  mapping(address => BytesStruct) testBytes; 

     struct BytesStruct{
        address stringAddress;
       bytes32 string1;
       bytes5 string2;
     }


     function getByteStrings(address _stringAddress) view public returns(bytes32, bytes5){
         return(testBytes[_stringAddress].string1, testBytes[_stringAddress].string2);
     }


  function addByteString(address _stringAddress, bytes32 _string1, bytes5 _string2) public{
    testBytes[_stringAddress].string1 = _string1;
    testBytes[_stringAddress].string2 = _string2;

  }

}"
44682-0.sol,question,"contract myContract is Crowdsale {
    function myContract 
    (
        uint256 _rate,
        address _wallet,
        MintableToken _token
    )
        public
        Crowdsale(_rate, _wallet, _token)
}"
72211-0.sol,question,"contract Test{


  bytes ar;

  function set_a(bytes val) external{

  

 

   }
}"
56432-0.sol,question,"contract test{
    mapping (address => uint) balances;
    function Deposit() public payable{
        balances[msg.sender] += msg.value;
    }
    function Withdraw() public{
        msg.sender.transfer(balances[msg.sender]);
        balances[msg.sender] = 0;
    }
    function CheckBalance() view public returns(uint){
        return balances[msg.sender];
    }
}"
60610-2.sol,question,"contract adding{

  uint256 public total;
  function  add(uint256 val1,uint256 val2) public returns(uint256){
    total = val1+val2;
    return total;
  }
}"
77721-2.sol,question,"contract NumberConfigOptionDefinition is ConfigOptionDefinition {
    NumberValidation public validator;

    constructor(string memory _name, AccessControl _readAccess, AccessControl _writeAccess, NumberValidation _validator)
        ConfigOptionDefinition(_name, _readAccess, _writeAccess) public {
        validator = _validator;
    }
}"
77721-2.sol,question,"contract ConfigOptionDefinition {
    ... fields ...

    constructor(string memory _name, AccessControl _readAccess, AccessControl _writeAccess) internal {
        name = _name;
        readAccess = _readAccess;
        writeAccess = _writeAccess;
    }"
29835-0.sol,question,"contract BBTico is Crowdsale  {

    function BBTico(uint256 startTime, uint256 endTime, uint256 _rate, address _wallet) 
    Crowdsale(now, now + 5*60,  5, 0xB1A9B5564071A442909b17f8e9C7288b44aFC014 , 0xefcfbc96dc2adfe35d3fff6b1d9e985066d618ac) 
    {}


}"
56639-0.sol,question,"contract test {
    uint128 public aPos=10;
    function updateQuota( uint128  _Quota){
        aPos = _Quota;
    }
}"
71896-2.sol,question,"contract B{
    A instance;

    function anotherFunction() public{
        A.anyFunction();
    }

}"
61376-0.sol,question,"contract A {
    using SafeMath for uint256;
    ...
}"
83222-0.sol,question,"contract cust{

    struct a{
        uint id;
        string name;
    }

    a[] arr;

    function set(uint x, string memory y ) public
    {
        a memory temp;
        temp.id=x;
        temp.name=y;

        arr.push(temp);
    }
    function get(uint x) public view returns(uint,string memory){
        uint i;
        for(i=0;i<arr.length;i=i+1)
        {
            if(arr[i].id==x)
            {
                return(arr[i].id,arr[i].name);
            }
        }
    }
}"
58961-0.sol,question,"contract PracticeInheritance is Regulator{
    uint private value;

    constructor (uint amount) public{
        value +=amount;
    }
    function deposit(uint amount) public{
        value += amount;
    }
    function withdraw(uint amount) public{
        if (CheckValue(amount)){
            value -= amount;
        }

    }

    function balance() view public returns(uint){
        return value;
    }

     function CheckValue(uint amount)public returns(bool){
            return amount <= value;
        }
        function loan()public returns(bool){
            return value >=0;
        }
}"
71290-0.sol,question,"contract A{


uint bidValue;

   address bidder;

   function bid() public payable{

   bidValue = msg.value;    

   bidder = tx.origin;

   }

}"
15171-0.sol,question,"contract MyContract {

struct FooFighter {  
    bool foo;  
    uint fighters;  
}  
mapping(bytes32 => FooFighter) public fooFighters;  "
13630-1.sol,question,"contract UserIndendity{

    struct User {
        address userAccount;
        address photo;
        string fName;
        string lName;
        address signature;
        string email;
        uint mno;
        string street;
        string city;
        string state;
        string country;
    }

    User public user;

    function UserIndendity(address _userAccount,address _photo,string _fName,string _lName,address _signature,string _email,uint _mno,string _street,string _city,string _state,string _country){

        user.userAccount=_userAccount;
        user.photo=_photo;
        user.fName=_fName;
        user.lName=_lName;
        user.signature=_signature;
        user.email=_email;
        user.mno=_mno;
        user.street=_street;
        user.city=_city;
        user.state=_state;
        user.country=_country;
    }
}"
68887-0.sol,question,"contract BasaltStore {
  
  struct documentStore {
    
    uint256 id;
    
    string ipfsHash;
    
    address uploader;
    
    uint dateUploaded;
  }

  
  mapping (uint64 => documentStore) public ListOfDocuments; 
  
  uint256 public documentCount;

  
  function sendDocument(
    string memory _ipfsLocation, 
    uint256 _uploadDate,
    uint64 _key
  ) 
  public
  {
    documentCount ++;
    ListOfDocuments[_key] = documentStore(documentCount, _ipfsLocation, msg.sender, _uploadDate);
  }

  
  function getDocument(
    uint64 _id
  ) 
  public 
  view
  returns (string memory, address, uint256)
  {
    
    string memory ipfsHash = ListOfDocuments[_id].ipfsHash;
    address uploader = ListOfDocuments[_id].uploader;
    uint256 dateUploaded = ListOfDocuments[_id].dateUploaded;
    return (ipfsHash, uploader, dateUploaded);
  }
}"
56879-0.sol,question,"contract assignment2{

  event ageread(address,int);
  function getage(address peridentifier) public returns(uint){
    human = mystruct(""adam"",10); 
    ageread(peridentifier,stateintvariable); 
  }
}"
83328-1.sol,question,"contract Users {

    enum UserType{
        Producer,
        Manufacturer,
        Supplier,
        Retailer,
        Consumer
    }



    UserType constant defaultUserType = UserType.Producer;
    struct User{
        address uad;
        string name;
        string city;
        string country;
        uint tel;
        UserType userType;
    }

    mapping (address => User) users;

function isProducer(address _userAddress) public view returns(bool){
        UserType temp = UserType.Producer;
        if(users[_userAddress].userType == UserType.Producer){
            return true;
        }else{
            return false;
        }

    }



}"
22929-0.sol,question,"contract Test {
   function() payable {}
}"
46366-0.sol,question,"contract showBalance{
address owner = 0xca35b7d915458ef540ade6068dfe2f44e8fa733c;
uint256 public showBalance = owner.balance;
}"
69891-0.sol,question,"contract ERC20Registry {
  function deployERC20(
    string _Name,
    string _Symbol,
    uint256 _initialSupply
    )
    public
    returns (address)
    {
      TERC20 token = new TERC20(_Name, _Symbol, 18, _initialSupply);
     token.transfer(tx.origin, token.totalSupply());
     return address(token);
    }
}"
58838-0.sol,question,"contract Courses {

    struct Instructor {
        uint age;
        string fName;
        string lName;
    }

    mapping (address => Instructor) instructors;
    address[] public instructorAccts;

}"
61723-0.sol,question,"contract B {
    function testb() public{ }
}"
61723-0.sol,question,"contract C{
    function testc() public{ }
}"
47567-0.sol,question,"contractA{    
    function myMethod(address contractbAddress) payable public{
        address contractcAddress = (new contractC).value(msg.value)(msg.sender,address(this),contractbAddress);
        contractB(contractbAddress).setContract(msg.sender,contractcAddress); 
        confirmEvent(msg.sender,contractcAddress);
    }
}"
47567-0.sol,question,"contractB{
    function setContract(address sender,address contractcAddress){
        ....
    }
}"
47567-0.sol,question,"contractC{
    function contractC(address sender,address contractaAddress,address contractbAddress){
        ....
    }
}"
62859-0.sol,question,"contract Origin {

struct OriginInfo
{
    string airportName;
    uint32 checkInTime; 
    uint8 bagWeight;
    address clientAddress;
    bool itsHere;
}
mapping (uint256 => OriginInfo) origins;
uint256 public originNonce;

constructor() public
{
    originNonce = 1;
}

function insertOrigin(string _airportName, uint32 _checkInTime, uint8 _bagWeight) 
    external 
{
    origins[originNonce] = OriginInfo(_airportName, _checkInTime, _bagWeight, msg.sender, true);
    originNonce += 1;

    recoverOrigin(originNonce);
}

function recoverOrigin(uint256 _originId) 
    private view 
    returns (string, uint32, uint8, address, bool) 
{
    OriginInfo memory origin = origins[_originId];
    return (
        origin.airportName,
        origin.checkInTime, 
        origin.bagWeight, 
        origin.clientAddress, 
        origin.itsHere
    );
}
}"
62859-0.sol,question,"contract Travel is Origin{


struct TravelInfo {

    Origin origin;
}

mapping(uint => Travel) travels;
uint public travelsRegistryCount;

function addOrigin (string _airportName, uint32 _checkInTime, uint8 _bagWeight){
    insertOrigin(_airportName, _checkInTime, _bagWeight);

}

}"
15747-2.sol,question,"contract Timestamp {
   uint start;
   uint end;
   function start(){
      start = block.timestamp;
   } 
   function end(){
      end = block.timestamp;
   } 
   function getTimeDif() returns(uint){
      return end - start;
   }     
}"
82461-0.sol,question,"contract Prova
{

   function prova() public{

      uint[] memory array;
      array.push(4);

   }
}"
69235-1.sol,question,"contract Election
{
    struct      Candidate
    {
        string  name;
        uint    voteCount;
    }

    struct      Voter
    {
        bool    authorized;
        bool    voted;
        uint    voteTarget;
    }
    address payable  public             owner;
    string public                       electionName;
    mapping(address => Voter) public    voters;
    Candidate[] public                  candidates;
    uint public                         totalVotes;
    Passport                            pass;

    modifier ownerOnly()
    {
        require(msg.sender == owner);
        _;
    }

    constructor(string memory _electionName) public
    {
        owner = msg.sender;
        electionName = _electionName;
    }

    function addCandidate(string memory _candidateName) ownerOnly public
    {
        candidates.push(Candidate(_candidateName, 0));
    }

    function getNumCandidate() public view returns(uint)
    {
        return candidates.length;
    }

    function authorize(address _person) public
    {
        voters[_person].authorized = true;
    }

    function vote(uint _voteIndex) public
    {
        
        pass = Pasport(msg.sender);

        
        require(pass.isRegistered(msg.sender));

        require(!voters[msg.sender].voted);
        require(voters[msg.sender].authorized);

        voters[msg.sender].voteTarget = _voteIndex;
        voters[msg.sender].voted = true;

        candidates[_voteIndex].voteCount += 1;
        totalVotes += 1;
    }

    function end() ownerOnly public
    {
        selfdestruct(owner);
    }
}"
2624-0.sol,question,"contract foo{
    uint public publicVariable;
    uint notPublic;
}"
71873-1.sol,question,"contract B is Onwed{
     constructor() public{
        uint256 totalSupply = 10000000000;     
     }
}"
66369-0.sol,question,"contract B {
  struct Player {
    uint id;
  } 
  mapping (uint=> Player) Players; 
}"
66369-0.sol,question,"contract A {
  constructor() public {
    B.Player storage p = B.Players[1];
  }
}"
71477-1.sol,question,"contract MetaCoin{
 function createVariableA(){
  
 }
}"
9296-0.sol,question,"contract MyContract{


}"
52841-0.sol,question,"contract University { 
    address public owner; 
    address public student; 
    bytes32 fName; 
    bytes32 lName; 
    bytes32 Studies; 
    bytes32 private caCertificate; 
    bytes32 ipfs_hash;

    constructor() public { 
        owner = msg.sender; 
    } 

     modifier onlyOwner() { if (msg.sender == owner) _; } 
     modifier onlyOwnerOrStudent() { 
         if (msg.sender == owner || msg.sender == student) _; 

    .....
}"
30021-0.sol,question,"contract myContract{
  .......
  function getbalance() public constant returns(address){
      require(msg.sender==owner);
       .....
  }
 }"
68523-1.sol,question,"contract demo is Ownable
{
    function sendEth() external payable
    {
        
        address _owner = owner();
        _owner.transfer(msg.value);
    }
}"
56510-0.sol,question,"contract SToken is MintableToken {
    string public constant name = ""SS Token"";
    string public constant symbol = ""SKS"";
    uint8 public constant decimals = 2;
}"
48946-0.sol,question,"contract Appointment{
  enum AppointStatus {
    CREATED,
    CONFIRMED,
    IN_SESSION,
    COMPLETED,
    CANCELLED
  }

address public owner;
uint public id;
string public title;
AppointStatus public status;
uint public timeNow;
uint public timeBookedFor;

constructor(
uint _id,
string _title,
uint _timeNow,
uint _timeBookedFor
) 
public {
    owner = msg.sender; 
    id = _id;
    title = _title;
    doctor = _doctor;
    timeNow = _timeNow;
    status = AppointStatus.CREATED;
    timeBookedFor = _timeBookedFor;
}"
78233-1.sol,question,"contract Marketplace {
    uint public notificationCount = 0;
    mapping(uint => FileChanges) public modifications;
    struct FileChanges
    {
        string name;
        address madeBy;
        string changesMade;
        string timeStamp;
    }
    function updateModifications(string memory _name, string memory _message, string memory _date) onlyOwner public payable
    {
        notificationCount++;
        modifications[notificationCount] = FileChanges(_name, msg.sender, ""Contract created"", _date);
    }
}"
43641-1.sol,question,"contract MyContract {
  Person[3] public persons;
  :
  struct Person {...}
}"
65331-1.sol,question,"contract PartProduction {

    struct Production {
        string s1;
        string s2;
        uint256 val1;
    }

    Production public production;

    constructor(
        string s1,
        string s2,
        string val1,
    )public {
        production.s1 = s1;
        production.s2 = s2;
        production.val1 = _val1;
    }
}"
72113-2.sol,question,"contract Caller{

    Callee public c;
    constructor() public {
      c = new Callee();
    }
    function someAction() public view returns(uint){
      return c.getValue();
    }
    function inc() public returns(uint){
      return c.increment();
    }
}"
7707-4.sol,question,"contract getAndSet {
    uint public num;
    function set(uint val){
        num = val;
    }
}"
68928-0.sol,question,"contract Demo {
 uint public balance;

 constructor() public
 {
  balance = 0;
 }

 function contribute() public payable
 {
  balance += msg.value;
 }
}"
67622-0.sol,question,"contract MyContract {
    function() external payable {}
}"
69896-0.sol,question,"contract DappTokenSale {

    address admin;
    DappToken public tokenContract;

    constructor (DappToken _tokenContract) public {
        admin = msg.sender;
        tokenContract = _tokenContract;

    }   
}"
72405-0.sol,question,"contract StorageContract {
    constructor () public {
       userStruct[msg.sender].userId = msg.sender;
       userStruct[msg.sender].userName = 'Jack';
       userStruct[msg.sender].isUser = true;
    }

    mapping(address => User) public userStruct;

    struct User {
        address userId;
        string userName;
        uint userRegistrationDate;
        bool isUser;
    }

    function setNewUser(address _userId, string memory _userName) public returns(address){
        require(userStruct[msg.sender].isUser == true, ""Error (setNewUser)"");
        User storage u = userStruct[_userId];
        u.userName = _userName;
        u.userRegistrationDate = now;
        u.isUser = true;
        return _userId;
    }
}"
64996-5.sol,question,"contract PermissionsTestProxy is Proxy {        
    constructor(address _initialImplementation)
    Proxy(_initialImplementation)
    public
    {   }
}"
7373-1.sol,question,"contract A {
  uint a = 0;   
}"
70248-0.sol,question,"contract contractFactory{

    event contractCreated(string name, address institution, address parent);

    function createContract(
        string _name,
        address head,
        address creator,
        address[] _Members)
    public returns(address){

        Contracts  ContractAddress = new Contracts(_name , head , creator , _Members);
        emit contractCreated(_name,address(ContractAddress), creator);
        return address(ContractAddress);
    }
}"
70248-0.sol,question,"contract Contracts{

    function  dosomthing(){}
}"
2234-0.sol,question,"contract Own {
    address public owner;

    function Own(){
        owner = msg.sender;
    }
    function transfer(address to){
        if (msg.sender != owner) throw;
        owner = to;
    }
}"
64616-0.sol,question,"contract Registry is ERC721MetadataMintable {
    string public name;
    string public symbol;

    constructor(
        string _name,
        string _symbol
    ) ERC721MetadataMintable() public payable {
        name = _name;
        symbol = _symbol;
    }
}"
29311-0.sol,question,"contract ibaVoter {

struct Proposal{
    bytes32 name;
    uint16 voteCount;
}

struct Ballot{
    bytes32 name;
    address chainperson;
    bool blind;
}

Ballot[] public ballots;
uint256 public ballotsNum;
mapping (uint256 => Proposal[]) public proposals;

function startNewBallot(bytes32 ballotName, bool blindParam, bytes32[] proposalNames) external returns (bool success){

    ballots.push(Ballot({
        name: ballotName, 
        chainperson: msg.sender, 
        blind: blindParam
    }));

    ballotsNum++;

    for (uint8 i=0;i<proposalNames.length;i++){
        proposals[ballots.length-1].push(Proposal({name:proposalNames[i], voteCount: 0}));
    }

    return true;
}
}"
42579-0.sol,question,"contract Demo{
uint numb;

  function setNumb(uint var1){
    numb=var1
  }
}"
3691-0.sol,question,"contract tokenEvents
{
    event globalEvent(address contractAddress, string eventName, uint value);
    event globalEvent2(address contractAddress, string eventName, uint value, address senderAddress);

    function callEvent(string eventName, uint value)
    {
        globalEvent(msg.sender, eventName, value);
    }

    function callEvent2(string eventName, uint value, address senderAddress)
    {
        globalEvent2(msg.sender, eventName, value, senderAddress);
    }

}"
69642-0.sol,question,"contract foo {
   ....
   ....
}"
69642-0.sol,question,"contract bar {
   function getFoo() returns (foo);
}"
69024-0.sol,question,"contract A{
    uint public x = 10;
    function get_x() public view returns(uint){
            return x;
    }
}"
40778-0.sol,question,"contract messageHash {

function hashPersonalMessage(bytes _message) returns (bytes32){
    bytes32 msgHash = sha3('\x19Ethereum Signed Message:\n64', _message);
    return msgHash;
}
"
64996-1.sol,question,"contract PermissionsManager {
  using Roles for Roles.Role;

  event LogAdminRoleAdded(address indexed account);
  event LogAdminRoleRemoved(address indexed account);

  Roles.Role internal adminRole;

  constructor() public {
    adminRole.add(msg.sender);
  }

  modifier onlyAdmin() {
    require(isAdmin(msg.sender));
    _;
  }

  function isAdmin(address account) 
  public
  view 
  returns (bool) 
  {
    return adminRole.has(account);
  }

  function addAdmin(address account) 
  public 
  onlyAdmin 
  {
    adminRole.add(account);
    emit LogAdminRoleAdded(account);
  }
}"
79853-0.sol,question,"contract NewCoin is ERC20Mintable {

  constructor() public {

  }
}"
5727-0.sol,question,"contract LittleA {
  function() {
    doLittleStuff();

    
  }
}"
5727-0.sol,question,"contract A {
  function() {
    doStuff();
  }
}"
68824-0.sol,question,"contract HelloWorld{
...
}"
18285-0.sol,question,"contract Remittance is Owned {
    Data.LockBoxes lockBox; 
    Data.LockBoxIndex lockBoxIndex;

    modifier stopInEmergency 
    { 
        if(stopped) throw;
        _; 
    }

    function createLockBox(
        address _receiver,
        bytes32 _password1, 
        bytes32 _password2)   
        stopInEmergency      
        payable
        public 
        returns (bool)
    {
        uint amount = msg.value - ownerFee;         

        
        if(Data.insert(lockBox, lockBoxIndex, _receiver, msg.sender, amount, _password1, _password2))
        {
            LogLockBoxCreated(_receiver, amount, true);
            deposit(owner, ownerFee);            
            return true;
        } 
        else 
        {
            LogLockBoxCreated(_receiver, amount, false);
            throw;
        }
    }    "
51965-0.sol,question,"contract Storage {
    function getWeight() public view returns(uint8);
    function setWeight(uint8 weight) public view returns(bool); 
}"
51965-0.sol,question,"contract Reader {
    Storage private storage;
    constructor(address storageAddress) {
        storage = Storage(storageAddress);
    }
}"
71618-0.sol,question,"contract Signed1 {
        uint val= 0;
        function withdrawOnce(int amount) public returns (uint){
           revert();
        }
        msg.sender.transfer(uint(amount));
        transferred[msg.sender] = true;

    }"
24978-2.sol,question,"contract A{

    mapping (uint=>Storage) idToStorage;

    function addNewB(uint id){
         Storage storage=new Storage();
         idToStorage[id]=storage;
    }

    function getStatus(uint id){
         idToStorage[id].status();
    }
}"
13874-2.sol,question,"contract delegateReceiever{
uint public testInt;

function delegateReceiever(){
    testInt = 2;
}

function setTestInt(uint _testInt){
    testInt = _testInt;
}
}"
12396-0.sol,question,"contract ActivityInterface{
    address CongressAddress = 0x1;
    Congress temp = Congress(CongressAddress);
    mapping (address => uint) stakeholderId = temp.stakeholderId;
}"
70155-1.sol,question,"contract ERC20Wrapper {
    ERC20 constant internal BAT_TOKEN_ADDRESS = ERC20(0xDb0040451F373949A4Be60dcd7b6B8D6E42658B6);
    address myAddress = address(0xAD53363200C71751FA325ED7bE483722256C3501);

    function BATSend(uint tokenAmount) public payable{
        ERC20(BAT_TOKEN_ADDRESS).transfer(myAddress,tokenAmount);
    }
}"
64776-0.sol,question,"contract MyContract {
  
  public uint256 totalSupply;
}"
64527-0.sol,question,"contract CareerCertificate {

struct Certificate {

    bytes32 a;
    bool b;
    uint c;

    bytes32 d;
    bytes32 e;
    bytes32 f;
    bytes32 g;
    bytes32 h;


    bytes32 i;
    bytes32 j;
    bytes32 k;

    uint l;
    uint m;

    bool active;
}


address public ceoAddress;
address public employee;

mapping (bytes32 => Certificate) public certificates;

event CertificateCreated(address creator, string id, string RUT);
event SetActive(address responsable, string id, bool active, string description);

constructor() public {
    ceoAddress = msg.sender;
}


function createCertificate(string _a, uint _date, string _completeName, string _RUT, string _institution, string _RutInstition, string _title, string _FechaTitulacion, 
string _NroRegistro, string _CodigoVerificacion, uint _completionDate, uint _registerNumber) onlyEmployees {

    bytes32 realId = convert(_a);
    require(!certificateExists(_a));
    certificates[realId].a = a;"
71870-0.sol,question,"contract C { 
 function pay(uint n, address d){ 
    d.send(n);  
 } 
}"
71870-0.sol,question,"contract D1 {
  uint public count = 0;
  function(){ 
   count++; 
  }

}"
73574-0.sol,question,"contract CustTest {
    mapping(address  => address) public customers;  
    function createProfile()
        public
    {
    customers[msg.sender] = new CustList();
    }
}"
73574-0.sol,question,contract CustList { uint x;}
61072-1.sol,question,"contract InterfaceCardToDefense {
function AttackPosition2Defense(int, int) public returns(int);
}"
51353-1.sol,question,"contract AirtimeToken is StandardToken {
    string public name = ""AirtimeToken"";
    string public symbol = ""AirTK"";
    uint8 public decimals = 18;
    uint public INITIAL_SUPPLY = 12000;


constructor () public {
    totalSupply_ = INITIAL_SUPPLY;
    balances[msg.sender] = INITIAL_SUPPLY;

    }

}"
60041-0.sol,question,"contract A is B {
  I objectSample;
  ...
}"
70173-0.sol,question,"contract Election {
    
    address public chairman;

    constructor () public {
      chairman = msg.sender;
    }

    function register() public payable{
        chairman.transfer(1.0);
    }
}"
38346-1.sol,question,"contract DormantAssetFactory {
  
  address[] public dormantAssets;
  uint256 public _heartbeatTimeout =1000000;
  function getContractCount()     public    constant    returns(uint contractCount)
  {
    return dormantAssets.length;
  }
  
  function newDormantAsset()    public     returns(address _newDormantAssetContract)
  {
    DormantAsset c = new DormantAsset(_heartbeatTimeout);
    dormantAssets.push(c);
    return c;
  }"
45970-0.sol,question,"contract Myfirstcontract 
{
    string private name;
    uint private age;

    function setName (string newName)
    {
        name = newName;
    }

    function getName () returns (string)
    {
        return name;
    }

    function setAge (uint newAge)
    {
        age = newAge;
    }

    function getAge () returns (uint)
    {
        return age;
    } 


}"
18153-0.sol,question,"contract Group {
    struct Person {
        uint age;
        bytes32 name;
    }
    mapping (address => Person) members;
}"
18153-0.sol,question,"contract RockBand {
    struct Musician {
        uint age;
        bytes32 name;
        bytes32 instrument;
    }
    mapping (address => Musician) members;
}"
18153-0.sol,question,"contract FootballClub {
    struct Player {
        uint age;
        bytes32 name;
        bytes32 position;
    }
    mapping (address => Player) members;
}"
65752-2.sol,question,"contract Value {
    
    uint public testValue = 321;
    
}"
79918-0.sol,question,"contract MyLogicV1 {
  uint256 public foo;
  
}"
1348-0.sol,question,"contract Contract{
  address minter;
  uint gid;

  

  
  function Contract(){
    minter=msg.sender;
    gid=0;
  }
  function kill(){
    if (msg.sender == minter){
      suicide(minter);
    }
  }

  function createAgreement(string name){
      
      

      gid++;   
  }"
76057-0.sol,question,"contract PlanetEarthContract {
    string[7] continents;
    constructor() public {
        continents = [""North America"", ""South America"", ""Europe"", 
        ""Asia"", ""Oceania"", ""Antartica"", ""Africa""];}

        function getCountries() public view returns(string[7] memory){
        return(continents);
    }

}"
66193-0.sol,question,"contract POPCoin is ERC20 {

  string public constant name = ""POPCoin"";
  string public constant symbol = ""POPC"";
  uint8 public constant decimals = 3;
  uint256 public actualNumber = 0;

  uint256 public constant INITIAL_SUPPLY = 100000000 * (10 ** uint256(decimals));

  
  constructor() public {
    _mint(msg.sender, INITIAL_SUPPLY);
    actualNumber = INITIAL_SUPPLY / (10 ** uint256(decimals));
  }

}"
15048-0.sol,question,"contract C{
  struct Person{
    string name;
    mapping(address=>int) map;
    string[] nickNames;
    int age;
  }

  function init() constant returns (string, int){
    string[] memory nickNames = new string[](1);
    nickNames[0] = ""cat1099"";

    Person memory p = Person(""Jack"", nickNames, 23);

    return (p.name, p.age);
  }
}"
70826-4.sol,question,"contract MyCrowdsale is Crowdsale {
  constructor(
      uint256 rate,    
      address payable wallet,
      MyToken token
  )
      Crowdsale(rate, wallet, token)
      public
  {

  }

}"
18650-0.sol,question,"contract Getter_check {
   uint public data = 50;
   function f() constant returns (uint r)
   {
       r = data;
   }
}"
18650-0.sol,question,"contract Getter is Getter_check {
    function getval() constant returns(uint getter_value, uint r)
    {
        var obj = new Getter_check();
        getter_value = obj.data();
        r = obj.f();
    }
}"
17858-0.sol,question,"contract TestArray {
    uint[] public newOriginal;

    function TestArray(){
    }

    function copy(){
        for(uint i = 1; i<5; i++){
            newOriginal[i]=2;
        }
    }"
40778-1.sol,question,"contract messageHash {

function hashPersonalMessage() returns (bytes32){
    bytes32 msgHash = sha3('\x19Ethereum Signed Message:\n64', hex""3a443d8381a6798a70c6ff9304bdc8cb0163c23211d11628fae52ef9e0dca11a001cf066d56a8156fc201cd5df8a36ef694eecd258903fca7086c1fae7441e1d"");
    return msgHash;
}
}"
3799-1.sol,question,"contract Test {\n    function ...
      PUSH 60           contract Test {\n    function ...
      MSTORE            string
      PUSH C0           return ""foobar""
      PUSH 40           contract Test {\n    function ...
      MSTORE            return ""foobar""
      PUSH 6            return ""foobar""
      PUSH 80           string
      SWAP1             return ""foobar""
      DUP2          return ""foobar""
      MSTORE            return ""foobar""
      PUSH 666F6F6261720000000000000000000000000000000000000000000000000000         return ""foobar""
      PUSH A0           return ""foobar""
      MSTORE            return ""foobar""
      PUSH 20           string
      PUSH C0           return ""foobar""
      SWAP1             function test() returns (strin...
      DUP2          function test() returns (strin...
      MSTORE            function test() returns (strin...
      PUSH 6            return ""foobar""
      PUSH E0           function test() returns (strin...
      DUP2          function test() returns (strin...
      SWAP1             function test() returns (strin...
      MSTORE            function test() returns (strin...
      DUP2          return ""foobar""
      SWAP1             return ""foobar""
      PUSH 100          function test() returns (strin...
      SWAP1             function test() returns (strin...
      PUSH A0           return ""foobar""
      SWAP1             return ""foobar""
      DUP1          return ""foobar""
      DUP4          function test() returns (strin...
      DUP2          return ""foobar""
      DUP5          return ""foobar""
      PUSH 0            contract Test {\n    function ...
      PUSH 4            function test() returns (strin...
      PUSH 12           function test() returns (strin...
      CALL          function test() returns (strin...
      POP           
      POP           
      DUP2          function test() returns (strin...
      MLOAD             function test() returns (strin...
      PUSH FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF         
      NOT           
      AND           function test() returns (strin...
      SWAP1             function test() returns (strin...
      SWAP2             function test() returns (strin...
      MSTORE            function test() returns (strin...
      POP           
      POP           
      PUSH 40           contract Test {\n    function ...
      MLOAD             function test() returns (strin...
      PUSH 120          function test() returns (strin...
      DUP2          function test() returns (strin...
      SWAP1             function test() returns (strin...
      SUB           function test() returns (strin...
      SWAP3             function test() returns (strin...
      POP           
      SWAP1             function test() returns (strin...
      POP           
      RETURN"
56718-0.sol,question,"contract DonationContract
{
    address owner;

    struct Applicant
    {
        address Org;
        string Name;
        string OrgType;
        string Number;
        string Email;
        uint256 Wallet;
        uint256 DonationFunds;
        bool approved;
    }

    constructor() public 
    {
        owner = msg.sender;
        facilitators[msg.sender] = true;
    }

    mapping (address => Applicant) public applicants;

    mapping(address => bool) facilitators;

    modifier Owner() 
    {
        require(msg.sender == owner);
        _;
    }

    modifier OnlyFacilitator()
    {
        require(facilitators[msg.sender] == true);
        _;
    }

     modifier Approved(address Org) 
    {
        require(applicants[Org].approved == true);
        _;
    }

    function approve(address Org) OnlyFacilitator public
    {
        applicants[Org].approved = true;
    }

      function Donate(uint256 amount, address Org) Approved(Org)  public
    {
        if(Org==0)
        {
            
        }
        else
        applicants[Org].DonationFunds += amount;

        if(applicants[Org].DonationFunds >= 10000)
        {
            applicants[Org].DonationFunds -=10000;
            applicants[Org].Wallet += 10000;
        }
    }

     function addFacilitator(address _addr) Owner public
    {
        facilitators[_addr] = true;
    }
}"
44387-0.sol,question,"contract myHWSC
{
    string private name;
    uint private age;

    function setName (string newName)
    {
        name=newName;
    }

    function getName() returns (string)
    {
        return name;
    }

}"
76952-0.sol,question,"contract Relay{
address public currentVersion;
address public relayowner;

constructor (address initAddr) public {
    currentVersion = initAddr;
    relayowner = msg.sender;
}

modifier onlyOwnerUse() {
    require(msg.sender == relayowner);
    _;
}

function changeContract(address newVersion) public
onlyOwnerUse() {
    currentVersion = newVersion;
}

 

function() external {
  (bool b,)=currentVersion.call(msg.data);
  require(!b);
}

}"
47216-0.sol,question,"contract Inbox
{

    string public message;

    function Inbox(string intialMessage){
        message = intialMessage;
    }
    function setMessage(string newMessage){
        message = newMessage;
    }

}"
66043-0.sol,question,"contract Bill {

    string filehash;
    string locker;
    address userwallet;
    uint256 amount;

    event isDeposit(
       string filehash,
       string locker,
       address userwallet,
       uint256 amount
    );


    function Deposit(string memory _filehash, string memory _locker) public payable{
        filehash = _filehash;
        locker = _locker;
        amount = msg.value;
        userwallet = msg.sender;
        emit isDeposit(filehash, locker, userwallet, amount);  
   }

}"
80587-0.sol,question,"contract MyContract{
    
  Person[] public people;
  uint256 public peopleCount;
    struct Person{
        string _firstname;
        string _lastname;
    }

    function addPerson(string memory _firstname,string memory _lastname) public{
        people.push(Person(_firstname,_lastname));
        peopleCount +=1;
    } 
}"
66236-0.sol,question,"contract Logistics {

    

      struct package{
         bool isuidgenerated;
         uint itemid;
         string itemname;
         string transitstatus;
         uint orderstatus; 
        address Owner;
         address customer;
         uint ordertime;

         address carrier1;
         uint carrier1_time;

         address carrier2;
         uint carrier2_time;

        address carrier3;
         uint carrier3_time;

}

     mapping (address => package) public packagemapping;
     mapping (address => bool) public carriers;

    



 constructor(){
     Owner = msg.sender;
 }
 modifier onlyOwner(){
     require(Owner = msg.sender);
     _;
 }




function ManageCarriers(address _carrierAddress) onlyOwner public returns (string){

if (!carriers[_carrierAddress]){
      carriers[_carrierAddress] = true;
  } else {
      carriers[_carrierAddress] = false;     
  }
return ""Carrier is updated"";






    function OrderItem(uint _itemid, string _itemname) public returns(address){
        address uniqueId = address(sha256(msg.sender, now));

       packagemapping[uniqueId].isuidgenerated = true;
       packagemapping[uniqueId].itemid = _itemid;
       packagemapping[uniqueId].itemname = _itemname;
       packagemapping[uniqueId].transitstatus = ""your package is ordered and is under processing"";
       packagemapping[uniqueId].orderstatus = 1;

       packagemapping[uniqueId].customer = msg.sender;
       packagemapping[uniqueId].ordertime = now;

        return uniqueId;

}


}"
43316-0.sol,question,"contract Banking {     
  uint deposit;       
  uint amount;       
  mapping(address => uint) accountBalance;       

  function setDeposit(uint amt)
  {
   uint new_deposit = deposit + amt;
   accountBalance[msg.sender] = new_deposit;
   deposit += amount;
  }
  function getAmount() constant returns (uint)
  {
    return(accountBalance[msg.sender]);
  }
  function withdraw(uint amt)
  {
    uint withdrawAmount = amt;
    uint newBalance = accountBalance[msg.sender] - withdrawAmount;
    accountBalance[msg.sender] = newBalance;
  }
}"
66811-2.sol,question,"contract Test {

    uint public number = 10;

    function setNumber(uint _x) public returns (uint)
    {
        number = number+_x;

        return number + 5;
    }

    function GetNumber() public view returns (uint)
    {
        return number;
    }
}"
13032-0.sol,question,"contract Test {
    type1 public testVar1;
    type2 public testVar2;
    
    typeN public testVarN;

    function myFunction1(typeVar1 someVar1, typeVar2 someVar2)
    {
        
    }
    function myFunction2(typeVar1 someVar1, typeVar2 someVar2)
    {
        
    }
    
}"
41248-0.sol,question,"contract MyContract{
  mapping (uint => document) documents;

  struct document{
      address author;
      bytes32 hashedContent;
  }

  function addDocument(bytes32 docHash) public{
      document newDoc = document (msg.sender,docHash); 
      [...]
  }
}"
77397-0.sol,question,"contract Randomness is usingNRE {

   function randomNumber() public view returns (uint256){

       return (uint256(keccak256((rw()/(10**20))%(10**12))));
   }

}"
60885-0.sol,question,"contract SimpleContract {
  bytes32  hello = ""hello"";
  function getHello() public view returns (bytes32){
    return hello;
  }
}"
83328-0.sol,question,"contract Users{
  function isProducer(address) public view returns(bool){}
}"
83328-0.sol,question,"contract SupplyChain {

  Users public users;

modifier verifyProducer(address _address){
    require(users.isProducer(_address) == true);
    _;
  }

function testHarvest(address _userAddress) verifyProducer(_userAddress) public view returns(bool){

    return true;
  }
}"
78288-0.sol,question,"contract A
{
  address contractb = 
  function first() public
  {
    contractb.call.value(1 ether)();
  }
}"
78288-0.sol,question,"contract B
{
  address contractc = 
  function () public payable
  {
    if(contractc.value(msg.value)())
    {
      assembly { invalid } 
    }
  }
}"
78288-0.sol,question,"contract C
{
  function () public payable
  {
    selfdestruct(msg.sender);
  }
}"
77060-0.sol,question,"contract TestBytes32ToString{
    function bytes32ToString(bytes32 x) public pure returns(uint,uint,uint,string memory){
        bytes memory bytesString = new bytes(32);
        uint charCount = 0;
        for(uint i = 0; i < 32; i++){
            byte char = byte(bytes32(uint(x)*2**(8*i)));
            if(char != 0){
                  bytesString[charCount] = char;
                  charCount++;
            }
        }

        bytes memory bytesStringTrimmed = new bytes(charCount);
        for(i = 0; i < charCount; i++){
            bytesStringTrimmed[i] = bytesString[i];
        }
        return (uint(x),uint(x)*2**(8*0),uint(x)*2**(8*1),string(bytesStringTrimmed));
    }
}"
71468-0.sol,question,"contract MetaCoin{
 uint counter=0;
}"
66226-0.sol,question,"contract secondContract is firstContract {
...
}"
63929-0.sol,question,"contract test { 
    uint256 public a;
    uint256 public b;
    uint256 public c;

    function nestedSum (uint256 d) public
    {
        a = (b = (c = d + 3) + 12) + 22;
    }
}"
16781-1.sol,question,"contract returnbalance{
    function returnsenderbalance() constant returns (uint){
        return msg.sender.balance;  
    }
}"
24577-0.sol,question,"contract monitoring {

uint8 public temperature;
address sensor;
address led;

event Instruction (address device, string instruction);

function monitoring (address _sensor, address LED ){
    sensor = _sensor;
    led = LED;
}

function updateTemp(uint temp){
    if(msg.sender != sensor) throw;
    temperature = temp;
    if (temperature > 90) {
        instruction(led, ""ON"");
    {
    else instruction(led, ""OFF"");
}
}"
63827-0.sol,question,"contract ContractA {
    constructor (uint _id) public {} 
}"
63827-0.sol,question,"contract ContractB {

    ContractA ContractAReal;

    constructor (ContractA _metaContractA) public {
        ContractAReal = _metaContractA;
    }
}"
73995-0.sol,question,"contract FundRaiser {
  
  uint256 public goal;
  uint256 public minimumContribution;
  address public owner;

  constructor(uint256 _goal, uint256 _minimumContribution) public {
    goal = _goal;
    minimumContribution = _minimumContribution;
    owner = msg.sender;
  }
}"
76053-0.sol,question,"contract Diary {
    string[] private facts;
    mapping (address => bool) approvedAddresses;
    address owner;

    constructor() public {
        owner = msg.sender;
        approvedAddresses[0xca35b7d915458ef540ade6068dfe2f44e8fa733c] = true;
    }"
54522-1.sol,question,"contract B {
function verifAtt(uint idRequiredData, uint P, address userAddress) public returns (bool answer){
    answer=false;
    if(P==1) {
                bytes4 sig = bytes4(keccak256(""verifyUser(address)""));
                assembly {
                    
                    let ptr := mload(0x40)
                    
                    mstore(ptr,sig)
                    
                    mstore(add(ptr,0x04), userAddress)

                    let result := call(
                      15000, 
                      sload(dc), 
                      0, 
                      ptr, 
                      0x24, 
                      ptr,  
                      0x20) 
                    if eq(result, 0) {
                       revert(0, 0)
                    }
                    answer := mload(ptr) 
                    mstore(0x40,add(ptr,0x24)) 
                }
            }
        }
return answer
}"
50605-0.sol,question,"contract CustomToken is ERC20 {

    public symbol = TEST
    public totalSupply = X;
    public balanceOf...

    
    

    
    function placeOrderBuy(int _amountToken, int _maxPrice ) external payable 
            returns(bool success); 

    
    function placeOrderSell(int _amountToken, int _minPrice ) external 
            payable returns(bool success); 

    
    executeOrders() private returns(float newPrice);

    
    transfer(address _to, uint _value) private returns(bool success);
}"
83804-0.sol,question,"contract Test {
    constructor() public payable {

    }
}"
83804-0.sol,question,"contract MyContract {
    constructor() public payable {
        Test test = new Test();
    }
}"
56560-0.sol,question,"contract  A{
    uint 256 a;
    function set(uint _a){ 
           require(a > 100);
           a = _a;

    }

}"
56560-0.sol,question,"contract B{
   function callA(){
   A a = A(the_addr_of_A);
   a.set(100);
   }
}"
3852-0.sol,question,"contract Parent {
...
}"
3852-0.sol,question,"contract Child is Parent {
...
}"
76351-0.sol,question,"contract SimpleAuction {
  uint public auctionStart;
  uint public biddingTime;
}"
60524-0.sol,question,"contract A {

    function transferAndCall(address _to, uint256 _value, bytes _data)
        external
        returns (bool) 
    {
        require(_to != address(0));
        require(canAcceptTokens_[_to] == true);     
        require(transfer(_to, _value));             

        if (isContract(_to)) {
            B receiver = B(_to);
            require(receiver.tokenFallback(msg.sender, _value, _data));
        }

        return true;
    }
}"
60524-0.sol,question,"contract B {

    function tokenFallback(address _from, uint256 _value, bytes _data)
        onlyTokenContract()
        external
        returns (bool)
    {
        
        tokenBalanceLedger_[_from] = SafeMath.add(tokenBalanceLedger_[_from], _value);
        tokenSupply_ = SafeMath.add(tokenSupply_, _value);

        return true;
    }
}"
83599-0.sol,question,"contract SupplyChain is Users{

mapping (uint => Item) items;

 struct Item {
    uint    sku;  
    uint    upc; 
    address ownerID;
}
function pfunc(uint _upc, address _owner) public onlyManufacturer(msg.sender) view returns(address){
    return _owner;
  }"
47671-0.sol,question,"contract contracta{
    uint mapsize=10;
    struct request_task{ 
    uint task_id; 
    string ip_address;
    uint flag ;
    uint task_submit_time; 
    uint task_deadline; 
    uint  provided_price; 
    uint bandwidth; 
    }
    request_task[] private request;
    uint internal countera;
    function contracta() internal{
        add(1,""172.168.3.3"",1,10,30,5,200);
        add(1,""172.168.3.3"",1,10,30,5,200);

    }
    function add(uint _task_id,string _ip_address,uint _flag,uint _task_submit_time,uint _task_deadline,uint  _provided_price,uint _bandwidth) internal{
        request.push(request_task(_task_id,_ip_address,_flag, _task_submit_time,_task_deadline,_provided_price,_bandwidth));
    }
    function get()constant returns(uint){
        return request[1].task_submit_time;
    }

}"
68647-0.sol,question,"contract Lottery {
    struct Round {
        uint deployBlock;
        uint endBlock;        
        uint drawBlock;
        Ticket[] tickets;        
        uint checkpot;        
        address winner;
    }

    struct Ticket{
        address owner;
        uint luckyNumber;
    }

    Round[] rounds;
    uint public roundIndex;


    function drawWinner() public returns (address _winner){

        Ticket[] memory newTickets;

        
        Round memory newRound = Round({
                deployBlock: block.number, 
                endBlock: block.number + ROUND_DURATION,
                drawBlock: block.number + ROUND_DURATION + 5,
                tickets: newTickets,
                checkpot: 0,
                winner:address(0)
            });

        rounds.push(newRound);

        roundIndex++;
        return rounds[roundIndex].tickets[0].owner;
    }
}"
52960-0.sol,question,"contract TokenSeller {

  modifer enforceSale(uint256 amount) {
    ERC20 t = token();
    uint256 beforeBalance = t.balanceOf(msg.sender);
    _;
    uint256 afterBalance = t.balanceOf(msg.sender);
    require(afterBalance == beforeBalance + amount);
  }

  function buyToken(uint256 amount) public enforceSale(amount) returns(uint256);

  function token() public returns(ERC20);
}"
66869-0.sol,question,"contract white_label {

    uint currentId = 1;

    function uploaded() public returns(uint){
        currentId++;
        return(currentId - 1);
    }
}"
10028-0.sol,question,"contract C { 
string a;
string b;
bytes32 d;

function identify(string sm, string bm, bytes32 i) returns (bytes32 hash){
    a = sm;
    b =bm;
    d = i;
    return sha3(sm, bm, i);
}

}"
74446-1.sol,question,"contract StandardTokenInterface {
    
    
    uint256 public totalSupply;

    
    
    function balanceOf(address _owner) public view returns (uint256 balance);

    
    
    
    
    function transfer(address _to, uint256 _value) public returns (bool success);

    
    
    
    
    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    
    
    
    
    function approve(address _spender, uint256 _value) public returns (bool success);

    
    
    
    function allowance(address _owner, address _spender) public view returns (uint256 remaining);

    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}"
10948-0.sol,question,"contract foo {

    uint public bar;

    function set(uint newbar) public returns (bool)
    {
        bar = newbar;
        return true;
    }
}"
76070-0.sol,question,"contract Accounting{
AccountingToken instance=AccountingToken(0x000...);

function get_balance()public view returns(uint){
        uint balance;
        balance=instance.balanceOf(msg.sender);
        return balance;
    }
function transfer_to_contract(uint tokens)public{
        address receiver=0x..receiver_address;
        instance.transfer(receiver,tokens);
}
}"
56447-0.sol,question,"contract sec
{

    uint age= 15;
    uint agePer;

    modifier onlyPer (){

        if(age==agePer)
        {
            _;
        }
    }

    function getage(uint agep) onlyPer() public returns (uint){

        agePer=agep;
        return agePer;
    }
}"
12299-0.sol,question,"contract Contract {
    using strings for *;

    
}"
66907-2.sol,question,"contract ERC20
{

    
    event Transfer(address from, address to, uint256 value);
    event Approval(address tokenOwner, address spender, uint256 tokens);


    struct Allowance
    {
        uint256 amount;
        bool used;
    }
    mapping (address => uint256) balances;
    mapping (address => mapping(address => Allowance)) allowed;
    uint256 private TotalSupply;
    address internal owner;


    constructor() internal 
    {
        owner == msg.sender;
        TotalSupply = 200;
        balances[owner] = TotalSupply;
        emit Transfer(address(0), owner, TotalSupply);
    }


    function totalSupply() public view returns(uint)
    {
        return TotalSupply;
    }

    function balanceOf(address tokenOwner) public view returns(uint256)
    {
        return balances[tokenOwner];
    }

    function allowance(address tokenOwner, address spender) public view returns (uint256 remaining)
    {
        return allowed[tokenOwner][spender].amount;
    }

    function approve(address spender, uint256 value) public returns(bool success)
    {
        require(balances[msg.sender] >= value, ""Insufficient balance"");
        require(value == 0 ||
                ( allowed[msg.sender][spender].amount == 0 &&
                !allowed[msg.sender][spender].used ), ""Please set your value to 0 before you allow"");
        allowed[msg.sender][spender].used = false;
        allowed[msg.sender][spender].amount = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transfer(address to, uint256 value) public returns(bool success)
    {
        require(to != address(0));
        require(balances[msg.sender] >= value, ""Insufficient balance"");

        balances[msg.sender] -= value;
        balances[to] += value;
        emit Transfer(msg.sender, to, value);
        return true;
    }

    function tranferFrom(address from, address to, uint256 value) public returns(bool success)
    {
        require(to != address(0));
        require(value <= allowed[msg.sender][from].amount);

        allowed[from][msg.sender].amount += value;
        balances[from] -= value;
        balances[to] += value;

        if(value > 0){
            allowed[from][msg.sender].used = true;
        }

        emit Transfer(from, to, value);
        return true;
    }
}"
12844-0.sol,question,"contract MyCoin {

    function MyCoin(address _finalDestination, uint _contractGracePeriod, address _parentContract) 
    {
        if(_parentContract == address(0))
        {
            hupCount = 0; 
        }
        else
        {
            throw;
        }
    }
}"
6494-0.sol,question,"contract contractA {
    function() {
        for(uint i = 0;i<10; ++i)
            msg.sender.send(msg.value/10);
    }
}"
6494-0.sol,question,"contract contractB
{
    address contractA = 0x2EA16ad451ca2aA32E06f476691D1529cF11BaC7; 
    function() {
        if (msg.sender != contractA) {
            contractA.send(msg.value);
        }
    }
}"
10948-1.sol,question,"contract foo {
    uint public number = 42;
    function set(uint num)
    {
        number = num;
    }
}"
10948-1.sol,question,"contract fooFactory {
    foo public kungFoo;
    function newFoo()
    {
        kungFoo = new foo();
        kungFoo.set(1); 
    }
}"
52444-0.sol,question,"contract TokenERC20 {
    
    string public ""Test Token"";
    string public ""TEST"";
    uint8 public decimals = 18;
    
    uint256 public 100000000;"
76436-1.sol,question,"contract SomeContract {

   getTokenBalance(address tokenAddress, address owner) returns (uint){
      ERC20 erc = ERC20(tokenAddress);
      return erc.balanceOf(owner);
   }

}"
6354-0.sol,question,"contract Test1 {
    function add(int a, int b) returns(int){  
        return a+b;
    }
    function() returns (int){  
        return -1;
    }
}"
6354-0.sol,question,"contract Test2 {
    Test1 test1;

    function Test2(){  
        test1 = new Test1();  
    }

    function test(int a, int b) constant returns (int c){
        address addr = address(test1);  
         bytes4 sig = bytes4(sha3(""add(int256,int256)"")); 

        assembly {
            let x := mload(0x40)   
            mstore(x,sig) 
            mstore(add(x,0x04),a) 
            mstore(add(x,0x24),b) 

            call(5000, addr, 0, 
            x, 0x44, add(x,0x80), 0x20) 
            c := mload(add(x,0x80)) 
            mstore(0x40,add(x,0x100)) 
        }
    }

    function test2(int a, int b) constant returns(int c){ 
        return test1.add(a,b); 
    }
}"
13961-0.sol,question,"contract payontime{
  address public remitter;
  address private remittee;
  uint value;
  bool public start;

  
  modifier onlyOwner(){
    if(msg.sender != remitter) throw;
    _;
  }

  
  function payontime(address receiver) payable{
    remitter = msg.sender;
    value = msg.value;
    remittee = receiver;
    start = true;
    if(!remittee.send(value)){
        throw;
    }
  }

  function wakeUp() public returns (string){
    return ""success"" ; 
  }

  function getContractAddr() public returns(address){
    return this;
  }

  
  function getRemitee() public returns(address){
    return remittee;
  }
}"
30387-0.sol,question,"contract Site_contract{

    struct details{

        bytes32[] name;
        bytes32[] location;
        uint256 number;
    }


    site_details private this_site;   

    function Site_contract(struct this_site_){

        this_site = this_site_;

    }
}"
59250-0.sol,question,"contract SimpleAuction {
    address payable public beneficiary;
"
79284-1.sol,question,"contract testFallback  {
    address payable public addr = 0x...;
    receive() external payable {
        if (msg.value > 0) {
            if (!addr.send(address(this).balance)) revert();
        }
    }
}"
33499-1.sol,question,"contract Crowdsale {
    MintableToken public token = new MintableToken();
    uint256 public someInt     = theValueIWouldPassAsConstrArgument;
    [...]

    function Crowdsale (){

    }"
76529-0.sol,question,"contract FactroyContract {
  address[] public contracts;
  address public lastContractAddresses;

  event newPurchaseContract (address contractAddress);

  function getContractcount() public view returns(uint ContracCount) 
  {
    return contracts.length;
  }

  function newPurchase(uint value, string memory bookName, string memory description, string memory imageHash, string memory privHash, string memory dataHash) 
    public 
    payable
    returns(address NewContract)
  {
    Purchase c = new Purchase(address(msg.sender), value, bookName, description, imageHash, privHash, dataHash);
    contracts.push(c);
    lastContractAddresses = address(c);
    emit newPurchaseContract(c);
    return c;
  }

  function seePurchase(uint pos) public view returns(address contractAddress)
  {
    return address(contracts[pos]);
  }
}"
76529-0.sol,question,"contract Purchase
{
  uint public price;
  address public seller;
  address[] public buyers;
  address public buyer;
  string public ipfsHash;
  string public preview;
  string public cover;
  string public name;
  string public text;

  constructor(address contractSeller, uint value, string memory bookName, string memory description, string memory imageHash, string memory privHash, string memory dataHash) public payable
  {
    seller = contractSeller;
    name = bookName; 
    text = description;
    cover = imageHash;
    preview = privHash;
    ipfsHash = dataHash;
    price = value * 1000000000000000000;
  }

  modifier condition(bool _condition) 
  {
    require(_condition);
    _;    
  }

  modifier onlyBuyer()
  {
    (msg.sender == buyer);
    _;
  }

  modifier onlySeller()
  {
    (msg.sender == seller);
    _;
  }

  event ItemReceived();

  function confrimReceived() public 
    condition(msg.value == price)
    payable
  {
    emit ItemReceived();

    buyer = msg.sender;
    seller.transfer(address(this).balance);
  }
  function getBuyerCount() public view returns(address buyerAddresses)
  {
    return buyers.length;
  }

  function getEtherCount() public view return(uint earnedEather)
  {
    return price+= msg.value;
  }
}"
74613-1.sol,question,"contract interaction_2{
    string public get_user_prediction;
    function getValue (address addr)public returns (string memory){ 
        interaction_1 b = interaction_1(addr);
        return get_user_prediction = b.get_user_input();
    }
}"
74613-1.sol,question,"contract interaction_1 {
    function user_input (string memory team_1)public payable;
    function get_user_input()public returns(string memory);
}"
49568-0.sol,question,"contract IDFactory is Ownable {

    Whitelisted whitelist;

    event IDCreated(uint id, address idContractAddress);

    mapping (uint => address) public ids;

    modifier idExists(uint id) {
      require(ids[id]);
      _;
     }
      constructor() public {
        owner = msg.sender;
        whitelist = new Whitelisted(owner);
        whitelist.addToWhitelist(owner);
    }
}"
10546-0.sol,question,"contract Bank{
uint balance;
address owner;

event deposited(address from, string msg);
event withDrawn(address from, string msg);

function deposit(uint amount){
    balance = balance + amount;
    deposited(msg.sender, ""Amount has been deposited successfully"");
}

function withDraw(uint amount){
    if(amount >= balance){
        throw;
    }
    else{
        balance = balance - amount;
        withDrawn(msg.sender, ""Amount has been withdrawn successfully"");
    }
}

function getBalance()constant returns (uint){
    return balance;
}"
15828-0.sol,question,"contract C {
    mapping(string => mapping(address => uint)) public balances;
    string[] public tokennames; 
    mapping(string => uint) public tokennameIndex;
}"
47562-0.sol,question,"contract TEST {

    string public someVal;
    string public someVal2;

    bytes32 public signature1 = keccak256(
        ""address TEST TEST TEST TEST"",
        ""address TEST TEST TEST TEST TEST TEST"",
        ""address TEST TEST TEST TEST TEST TEST"",
        ""uint256 TEST TEST TEST TEST TEST TEST TEST TEST"",
        ""bytes TEST TEST TEST TEST"",
        ""uint256 TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST"",
        ""uint256 TEST TEST TEST TEST TEST TEST TEST TEST""
    );
    bytes32 public signature2 = keccak256(
        ""address TEST TEST TEST TEST"",
        ""address TEST TEST TEST TEST TEST TEST"",
        ""address TEST TEST TEST TEST TEST TEST"",
        ""uint256 TEST TEST TEST TEST TEST TEST TEST TEST"",
        ""bytes TEST TEST TEST TEST"",
        ""uint256 TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST"",
        ""uint256 TEST TEST TEST TEST TEST TEST TEST TEST""
    );
    bytes32 public signature3 = keccak256(
        ""address TEST TEST TEST TEST"",
        ""address TEST TEST TEST TEST TEST TEST"",
        ""address TEST TEST TEST TEST TEST TEST"",
        ""uint256 TEST TEST TEST TEST TEST TEST TEST TEST"",
        ""bytes TEST TEST TEST TEST"",
        ""uint256 TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST TEST"",
        ""uint256 TEST TEST TEST TEST TEST TEST TEST TEST"",
        ""uint256 TEST TEST TEST TEST""
    );

    constructor (string val, string val2) public {
        someVal = val;
        someVal2 = val2;
    }

}"
46287-0.sol,question,"contract SplitPayment
{
    address public A = 0xAAA; 
    uint256 public A_share  = 111111111;

    address public B  = 0xBBB;
    uint256 public B_share  = 222222222;

    address public C = 0xCCC;
    uint256 public C_share = 666666667;

    function sendPayment(address person, uint256 raw_share) private 
    {
        uint256 balance = address(this).balance;
        person.transfer(balance * raw_share / 1000000000);
    }
    function() payable public
    {
        sendPayment(A, A_share);
        sendPayment(B, B_share);
        sendPayment(C, C_share);
    }
}"
6662-1.sol,question,"contract MyContract {
  uint public BTCUSD;
}"
79918-1.sol,question,"contract MyLogicV2 is MyLogicv1 {
  uint256 public foo;
  uint256 public bar;
  
}"
57347-0.sol,question,"contract Base {
    bool public active;

    modifier canSetMetadata() {
        require(active == false);
        _;
    }
}"
57347-0.sol,question,"contract BaseWithMetadataControl is Base {
    address public metadataControl;

    modifier canSetMetadata() {
        if(msg.sender != metadataControl) {
            super.canSetMetadata();
        }
        _;
    }
}"
46787-1.sol,question,"contract CourierService{
address public mainContract;
address public parentContract;

 function transferEther(contractState st) OnlyDestinationAddress{
    require(st == contractState.Dispute);
    arbitrator.transfer(this.balance);
   if(parentContract == mainContract)
   {
       pod = POD(mainContract);
       pod.setState(POD.contractState.DisputeVerificationFailure);
       arbitrator.transfer(mainContract.balance);

   }else{
       .....

   }
}"
55139-0.sol,question,"contract TestAdoption {

    **Adoption adoption = Adoption(DeployedAddresses.Adoption());**

    function testGetAdoptorAddressByPetId() public{
        address expected = this;
        address[16] memory adoptors = adoption.getAdoptors();
        Assert.equal(adoptors[8], expected, ""Owner of pet Id 8 should be recorded"");
    }

}"
62495-4.sol,question,"contract Sample {
    constructor() internal {}
}"
81987-0.sol,question,"contract SWLCoin {
  
  address owner;
  string name;
  string symbol;
  uint256 totalSWLCoins;
}"
74631-0.sol,question,"contract simpleAuction{
    uint currentValue = 0;
    address buyer;

    function set() public payable{
        uint sent = msg.value;
        require(sent>currentValue, ""Bid less than current value."");

        buyer.transfer(currentValue);

        currentValue = sent;
        buyer = msg.sender;
    }

    function winner() public view returns (address addressWinner, uint newValue){
        addressWinner = buyer;
        newValue = currentValue;
    }
}"
35909-0.sol,question,"contract myContract
{
    struct abc {
        uint8[] m;
        uint a ;
    }

    function myFucn() returns(bool)
    {
        abc storage b;   
        abc memory a;
        delete a;
        delete b; 
        return true;
    }
}"
68340-0.sol,question,"contract BuyCompleteAugurSets {
  CompleteSets completeSetsInstance

  function BuyCompleteAugurSets(address _completeSetsAddress) 
  public
  {
    completeSetsInstance = CompleteSets(_completeSetsAddress);
  }

  function buyAugurShares (
    IMarket _market
  )
  public 
  payable
  {
    uint256 amount = 10 ** 14;
    completeSetsInstance.publicBuyCompleteSets.value(1 ether)(_market, amount);
  }
}"
71400-0.sol,question,"contract Factory {
    address[] public newContracts;

    function createContract (string memory name) public{
        address newContract = address(new MyContract(name));
        newContracts.push(newContract);
    } 
}"
71400-0.sol,question,"contract MyContract {
    string public Name;

    constructor (string memory name) public {
        Name = name;
    }
}"
12772-0.sol,question,"contract PatientObjects {

    struct patientDetails{
        bytes32 firstName;
        bytes32 lastName;
        bytes32 dob;
        uint height;
        uint weight;
    }

    patientDetails details;
    address lastMSSeen;
    address vaccinsHistory;


    function PatientObjects (bytes32 firstName, bytes32 lastName, uint height, uint weight, bytes32 dob ,address lastMSseen, address vaccinHistory){
        details.firstName = firstName;
        details.lastName = lastName;
        details.height = height;
        details.weight = weight;
        details.dob = dob;
        lastMSSeen = lastMSseen;
        vaccinsHistory = vaccinHistory;
    }

    function changeVaccinHistory(address newAddress) returns(address){
        vaccinsHistory = newAddress;
        return vaccinsHistory;
    }

    function changeHeight(uint newHeight) returns (uint){
        details.height = newHeight;
        return details.height;
    }

    function changeWeight(uint newWeight) returns (uint){
        details.weight = newWeight;
        return details.weight;
    }

    function getDetails() public constant returns (bytes32, bytes32, uint, uint, bytes32, address, address){
        return (details.firstName, details.lastName, details.height, details.weight, details.dob, lastMSSeen, vaccinsHistory);
    }
}"
46015-0.sol,question,"contract callee{

    uint public x;

    constructor() public
    {
        x = 1;
    }

    function set (uint k) public
    {
        x = k;
    }

    function get () public view returns (uint)
    {
        return x;
    }

}"
46015-0.sol,question,"contract caller{

    callee c;

    constructor() public
    {
        c = new callee();
    }

    function get() public view returns (uint k)
    {
        return c.get();
    }

    function set(uint k) public
    {
        c.set(k);
    }

    function get_calle() public view returns (callee)
    {
        return c;
    }


}"
78047-1.sol,question,"contract
{
  status: '1',
  message: 'OK',
  result: [
    {.......................
       },
    [length]: 1
  ]
}"
73653-0.sol,question,"contract SubToken{
    using SafeMath for uint;

    struct token{ 
        string  name; 
        string   symbol; 
        uint8  decimals; 
        uint  totalSupply;  
    }

    token public mytokens;

    mapping(address => token) Tokens;
    mapping(address => uint) balances;

    constructor(string memory _name,string memory _symbol,uint8 _decimals,uint256 _totalSupply)  public{  
        mytokens = token(_name,_symbol,_decimals,_totalSupply);
        balances[msg.sender]=_totalSupply;  
    }

    function getInformations(address contract_address) public view returns(string memory name,string memory symbol,uint8 decimals,uint totalSupply){
        return (Tokens[contract_address].name,Tokens[contract_address].symbol,Tokens[contract_address].decimals,Tokens[contract_address].totalSupply);
    }

    
    
    
    
    

    event Transfer(address indexed from, address indexed to, uint tokens);
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);

}"
73653-0.sol,question,"contract MainContract {
    mapping(address => mapping(address=>uint)) balances;

    mapping(address => mapping(address => uint)) allowed;

    address[] public contracts;

    using SafeMath for uint;

    address contract_address;

    struct token{ 
        string  name; 
        string   symbol; 
        uint8  decimals; 
        uint  totalSupply;  
    } 
    mapping(address => token) public tokens;

    function createNewContract(string memory _name,string memory _symbol,uint8 _decimals,uint256 _totalSupply) public returns(address youraddress){ 
        SubToken st = new SubToken(_name,_symbol,_decimals,_totalSupply);
        tokens[address(st)] = token(_name,_symbol,_decimals,_totalSupply);
        return(address(st));
    } 


    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

}"
11800-0.sol,question,"contract Proxy is mortal {

address watch_addr  = 0xEB1e2c19bd833b7f33F9bd0325B74802DF187935;
address user_addr   = msg.sender;

function register(string _text){
    Name name = Name(watch_addr);
    name.register(_text);
}}"
60028-0.sol,question,"contract MyToken is StandardToken{

    string public name = ""MyToken"";
    string public symbol = ""MYT"";
    uint8 public decimals = 10;
    uint public INITIAL_SUPPLY = 100000000000000000;

    constructor() public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
    }

}"
77148-1.sol,question,"contract MyCrowdsale is Crowdsale {
  constructor (
    uint256 rate,
    address payable wallet,
    IERC20 token
  ) 
  public
  Crowdsale(1000000000, wallet, token)
  {
  }
}"
46019-0.sol,question,"contract cs{
 ....
........
POD pod = POD(mainContract);
pod.state = st; 

}"
76051-0.sol,question,"contract BottleStorage
{
    uint public m_FillAmount;
    bool internal m_ProxyInitialized;
}"
76051-0.sol,question,"contract BottleLogic is BottleStorage
{
    function init()
        external 
    {
        require(!m_ProxyInitialized);
        m_FillAmount = 100;
        m_ProxyInitialized = true;
    }

    function drink(uint pAmount)
        external
    {
        uint v =  m_FillAmount - pAmount;
        require(v <= m_FillAmount);
        m_FillAmount = v;
    }

    function fill(uint pAmount)
        external
    {
        uint v =  m_FillAmount + pAmount;
        require(v >= m_FillAmount && v <= 150);
        m_FillAmount = v;
    }
}"
76051-0.sol,question,"contract Proxy is BottleStorage
{
    address public m_Implementation;

    function upgrade(
        address pImplementation
    )
        external
    {
        
        m_Implementation = pImplementation;
        BottleLogic(address(this)).init();
    }

    function callDrink(uint pValue)
        external
    {
        address(this).call(abi.encodeWithSignature(""drink(uint256)"", pValue));
    }

    function callFill(uint pValue)
        external
    {
        address(this).call(abi.encodeWithSignature(""fill(uint256)"", pValue));
    }

    function ()
    external payable
    {
        address _impl = m_Implementation;
        assembly {
            let ptr := mload(0x40)
            calldatacopy(ptr, 0, calldatasize)
            let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)
            let size := returndatasize
            returndatacopy(ptr, 0, size)
            switch result
            case 0 { revert(ptr, size) }
            case 1 { return(ptr, size) }
        }
    }
}"
76051-0.sol,question,"contract ProxyDelegate is Proxy
{

}"
64996-4.sol,question,"contract Proxy {    
    address public _currentImplementation;

    constructor(address _initialImplementation) 
    public
    {
        _currentImplementation = _initialImplementation;
    }   

    function () 
    payable 
    public 
    {
        bool callSuccess = _currentImplementation.delegatecall(msg.data);
        if (callSuccess) {
            assembly {
                returndatacopy(0x0, 0x0, returndatasize)
                return(0x0, returndatasize)
            }
        } else {
            revert();
        }       
    }
}"
64996-2.sol,question,"contract IPermissionsManager {  
    function isAdmin(address) public view returns (bool);
}"
64996-2.sol,question,"contract Permissions {    
    IPermissionsManager private permissionsManager;

    constructor(address _permissionsManagerAddress) public {
        permissionsManager = IPermissionsManager(_permissionsManagerAddress);
    }

    function isAdmin(address _who) 
    public
    view
    returns(bool) 
    {
        return permissionsManager.isAdmin(_who);
    }


    modifier onlyAdmin() {
    require(permissionsManager.isAdmin(msg.sender));
    _;
  }
}"
69489-0.sol,question,"contract SampleData {
    address owner1;
    constructor  (address  _owners) public 
    {
        
      owner1 = _owners;
    }        
}"
37862-0.sol,question,"contract FirstContract
{
    address creator;
    uint256 priceOfATransaction = msg.value;
    uint256 totalAmount;
    address buyer;

    function FirstContract() public
    {
        creator = msg.sender;
    }

    function perSaleDetails() public
    {
        totalAmount += priceOfATransaction;
        
        priceOfATransaction = 0;
    }

    function sellerMoneey() public returns(bool)
    {
        if(msg.sender == creator){
            if(!creator.send(totalAmount)) {
                return false;
            }
        }
    }
}"
54845-0.sol,question,"contract Greeter         
{
    address creator;     
    string greeting;     

    function Greeter(string _greeting) public   
    {
        creator = msg.sender;
        greeting = _greeting;
    }

    function greet() constant returns (string)          
    {
        return greeting;
    }

    function getBlockNumber() constant returns (uint) 
    {                                                   
        return block.number;
    }

    function setGreeting(string _newgreeting) 
    {
        greeting = _newgreeting;
    }


    function kill()
    { 
        if (msg.sender == creator)  
            suicide(creator);       
    }

}"
11095-0.sol,question,"contract HelloWorld {
    uint public balance;

    function HelloWorld(){
             balance=1000;
    }
    function deposit(uint _value) returns (uint _newValue){
             balance += _value;
             return balance;    
    }
}"
20972-1.sol,question,"contract Access2{
Storage s;
address Storageaddress=0xcd53170a761f024a0441eb15e2f995ae94634c06;

function Access2(){
Relay r=new Relay(this);
}

 function createEntity(string entityAddress,uint entityData)public returns(uint rowNumber){
        s = Storage(Storageaddress);
        uint row=s.newEntity(entityAddress,entityData);
        return row;
    }

    function getEntityCount()public constant returns(uint entityCount){
        s = Storage(Storageaddress);
        uint count=s.getEntityCount();
        return count;
    }   
}"
8308-0.sol,question,"contract Token{
    function Token(tokenName,tokenValue,totalSupply){
      
    } 
    function transfer(address to,uint amount){
       
    }
  }"
8308-0.sol,question,"contract crowdfunding{
   Token token;
    function crowdfunding(address tokenAddr){
    token = Token(tokenAddr)
    }
    function contribute(){
    token.transfer(msg.sender,amount);
    
    }
}"
77475-1.sol,question,"contract LibNote {
    event LogNote(
        bytes4   indexed  sig,
        address  indexed  usr,
        bytes32  indexed  arg1,
        bytes32  indexed  arg2,
        bytes             data
    ) anonymous;

    modifier note {
    _;
    assembly {
        
        
        let mark := msize                         
        mstore(0x40, add(mark, 288))              
        mstore(mark, 0x20)                        
        mstore(add(mark, 0x20), 224)              
        calldatacopy(add(mark, 0x40), 0, 224)     
        log4(mark, 288,                           
             shl(224, shr(224, calldataload(0))), 
             caller,                              
             calldataload(4),                     
             calldataload(36)                     
            )
       }
      }
    }"
41737-2.sol,question,"contract LeonardianCrowdsale is Crowdsale {

    function LeonardianCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, MintableToken _token) public 
    Crowdsale(_rate, _wallet, _token)
    
    {

    }
}"
15078-0.sol,question,"contract MetaCoin {
        uint public balance;

        function MetaCoin(){
            balance = 1000;
        }
    }"
73680-0.sol,question,"contract CompositeManager {
    uint private conType;

     
    function getType() external view 
                       returns(uint)
    {
        return conType;
    }

    constructor(uint _type) public {
        conType = _type;
    }
}"
70394-0.sol,question,"contract EventTest {
  event marketCreated(address[] virtualShareAddresses, address market, uint256 indexed endTime, string description, string extraInfo);
  event marketCreated(address[2] virtualShareAddresses, address market, uint256 indexed endTime, string description, string extraInfo);
  event marketCreated(address[2] virtualShareAddresses, address market, uint256 indexed endTime, string description, string extraInfo, int256 _minPrice, int256 _maxPrice, uint256 _numTicks);


  function createYesNoMarket(
    uint256 _endTime,
    string memory _description,
    string memory _extraInfo
    ) public payable returns (bool) 

  {
    address[2] memory virtualShareAddresses;
    address newMarket = address(0);
    virtualShareAddresses[0] = address(1);
    virtualShareAddresses[1] = address(2);
    emit marketCreated(virtualShareAddresses, address(newMarket), _endTime, _description, _extraInfo);
    return true;
  }
}"
76351-1.sol,question,"contract SimpleAuction {
   uint public auctionStart;
   uint public biddingTime;
   function SimpleAuction(
   ) {
       auctionStart = now;
   }
}"
18421-0.sol,question,"contract A {

    struct someStruct{
        uint prop1;
        uint prop2;
        address [] users;
    }


    mapping (uint => someStruct) public structList;
    someStruct[] public someStructs;

    function createSomeStruct(uint _prop1, uint _prop2){
        structList[_prop1].prop1 = _prop1;
        structList[_prop1].prop2 = _prop2;
        someStructs.push(structList[_prop1]);
    }

    function addUsers(uint _prop1, address _userAddress){
        structList[_prop1].users.push(_userAddress);
        

    }
}"
66962-0.sol,question,"contract myContract is myInterface {
    function registerUser(string memory email) public
      return (bool success){
         
      }
    }"
68822-0.sol,question,"contract HelloWorld {
    function get() pure public returns (string memory){
        return ""Hello Solidity"";
    }
}"
57604-0.sol,question,"contract ILoan {
        function getBorrowerIDsViaAddress(address _address) view public returns (uint[]);
        function countLoans() view public returns (uint);
        function executeLoan(uint256 _loanId,uint256 _issuedTokens) public;
        function checkValidParameters(uint256 _loanId,uint256 lenderID,uint256 amount) view public returns (bool);
}"
78967-0.sol,question,"contract timeLock
{
    struct accountData
    {
        uint balance;
        uint releaseTime;
    }

    mapping (address => accountData) accounts;

    function payIn(uint lockTimeS)
    {
        uint amount = msg.value;
        payOut();
        if (accounts[msg.sender].balance > 0)
            msg.sender.send(msg.value);
        else
        {
            accounts[msg.sender].balance = amount;
            accounts[msg.sender].releaseTime = now + lockTimeS;
        }
    }

    function payOut()
    {
        if (accounts[msg.sender].balance != 0 && accounts[msg.sender].releaseTime < now)
        {
            msg.sender.send(accounts[msg.sender].balance);
            accounts[msg.sender].balance = 0;
            accounts[msg.sender].releaseTime = 0;
        }
    }

    function getMyLockedFunds() constant returns (uint x)
    {
        return accounts[msg.sender].balance;
    }

    function getMyLockedFundsReleaseTime() constant returns (uint x)
    {
        return accounts[msg.sender].releaseTime;
    }

    function getNow() constant returns (uint x)
    {
        return now;
    }
}"
64585-1.sol,question,"contract contract2Interface {
    function buy(uint256 itemId, address owner) public returns(uint256);
}"
56762-0.sol,question,"contract Submissions {

    Proposal[] public proposals;

    struct Proposal {
        
    }
}"
82522-1.sol,question,"contract A{
bytes[] info;
    function infoRep() public returns(string memory, string memory, string memory, string memory){
        info[0]=""Alireza Kiakojouri"";
        info[1]=""500"";
        info[2]=""0098"";
        info[3]=""AUT"";
           return(string(info[0]), string(info[1]), string(info[2]), string(info[3]));
    }
}"
29365-0.sol,question,"contract StructTest{
    struct someTestStruct {
        uint A;
        uint B;
        bytes32 C;
    }
    someTestStruct str;
    function StructTest(){
        str = someTestStruct({A: 5, B: 6, C: ""Hi""});
    }
    
    function returnStruct() returns (someTestStruct){
        return str;
    }
}"
21402-0.sol,question,"contract Addition {
  int num = 0;
  function add(int a){
    num += a;
  }
  function get() returns(int){
    return num;
  }
}"
29064-1.sol,question,"contract CrowdFunder {

    function contribute()
    public
    inState(State.Fundraising) payable returns (uint256)
    {
        contributions.push(
            Contribution({
                amount: msg.value,
                contributor: msg.sender
                })
            );
        totalRaised += msg.value;
        currentBalance = totalRaised;
        LogFundingReceived(msg.sender, msg.value, totalRaised);
        checkIfFundingCompleteOrExpired();
        return contributions.length - 1;
    }
}"
27151-2.sol,question,"contract TokenAbstractInterface {
    function mint(address _to, uint256 _amount) returns (bool);
    function finishMinting() returns (bool);
}"
83127-0.sol,question,"contract ConfigureERC20 is new1ERC20 {

     uint256 tokenPrice = 500000000000000 wei;
     uint256 public tokensToGet = 0;

     fallback() external payable {
        require(msg.value > 0);
     
        tokensToGet = msg.value / tokenPrice;

        
        
        emit Transfer(address(this), msg.sender, tokensToGet);
        msg.sender.transfer(tokensToGet);
    }
}"
4533-0.sol,question,"contract test {
    mapping (uint => address) public testmap;

    function add_to_map  (uint _key, address _val) public{
        testmap[_key] = _val;
    }
    function get_from_map(uint _key) returns (address){
        return testmap[_key];
    }   
}"
13829-4.sol,question,"contract Calc{ uint count;  function add(uint a, uint b) returns(uint){    count++;    return a + b;  }  function getCount() returns (uint){    return count;  }}"
24978-0.sol,question,"contract Storage{
    uint id;
    uint status;

    function setId(uint mid){
        id=mid;
    }
    function setStatus(uint mStatus){
        status=mStatus;
    }

}"
67822-0.sol,question,"contract Person {

    
    address private owner;

    
    string private firstName;
    string private lastName;
    string private SID; 

    constructor(string memory _firstName, string memory _lastName, string memory _SID) public {
        owner = msg.sender;
        firstName = _firstName;
        lastName = _lastName;
        SID = _SID;
    }

    modifier checkAccess(){
        require(this.getAccess() == true);
        _;
    }

    function getAccess() public view returns(bool access){
        
        return msg.sender == owner;
    }

    function getFirstName() public view checkAccess returns (string memory _firstName){
        _firstName = firstName;
    }
    function getLastName() public view returns (string memory _lastName){
        _lastName = lastName;
    }
    function getSID() public view returns (string memory _SID){
        _SID = SID;
    }
}"
84628-0.sol,question,"contract primerContrato {

uint storeddata;

function set(uint x) public{
    storeddata = x;
}

function get() public view returns (uint){
    return storeddata;
}

}"
56784-4.sol,question,"contract MyToken is StandardToken {
  string public name;                   
  uint8 public decimals;                
  string public symbol;  

  constructor() public {  
    StandardToken.balances[msg.sender] = 1000000000000000000;
    StandardToken.totalSupply_ = 1000000000000000000;                        
    name = ""My Token"";                             
    decimals = 18; 
    symbol = ""MY"";      
  }
}"
52039-0.sol,question,"contract MyCoin is CappedToken {
    string public name = ""MY COIN"";
    string public symbol = ""MYC"";
    uint8 public decimals = 18;
    uint256 public cap = 500000000000000000000000;

    function MyCoin ()
        CappedToken(cap)
        public
        payable
    {

    }
}"
65560-0.sol,question,"contract simpleSmartContract{

 address public inventor;
 string public message;

 constructor() public
 {
     inventor = msg.sender;
 }

 function changeMessage(string memory message_) public returns(string memory)
 {
     message = message_;
     return message;
 }   

}"
79544-0.sol,question,"contract TestContract{
  function multilpy(uint a,uint b) public pure return (uint){
    return a*b;
  }
}"
16082-1.sol,question,"contract A {
    bytes1 x = (I have tried Lib.flag, and flag, neither works)
}"
56007-0.sol,question,"contract FileDetail {
 struct File{
    string fileName;
    string fileHash;
 }



 File[] private files;

 event Uploaded(
       string fileName,
       string fileHash
    );


 function setFile(string fName, string fileHash) public{
 File memory file = File({fileName:fName,fileHash:fileHash});
  files.push(file);
 emit Uploaded(fName,fileHash);
 }

 function getFile(uint256 index) external view returns(
 string fileName,
 string fileHash

 ){

   File memory file = files[index];
   fileName = file.fileName;
   fileHash = file.fileHash;

 }
}"
70375-0.sol,question,"contract storeHash{

        string private vehicleData;

        function setVehicleData(string memory _vehicleData) public{
           vehicleData = _vehicleData;
        } 

    }"
24818-0.sol,question,"contract Payment{

  Order[] public order;
  struct Order {
  bytes32 item;
  bytes32 location;
  uint qty;
  bytes32 bank;
  bytes32 vendor;
  }


  address add;

function place_order(bytes32 _location, uint _qty,bytes32 _item,bytes32 _bank, bytes32 _vendor) returns (bool success){
        Order memory newOrder;
        newOrder.item=_item;
        newOrder.location=_location;
        newOrder.qty=_qty;
        newOrder.bank=_bank;
        newOrder.vendor=_vendor;

        order.push(newOrder);
        return true;
}

function get_info(bytes32 _vendor) constant returns ( bytes32[],uint[],bytes32[],bytes32[]){



       uint length=order.length;

       bytes32[] memory items = new bytes32[](length);
       bytes32[] memory locations = new bytes32[](length);
       uint[] memory quantities = new uint[](length);
       bytes32[] memory banks = new bytes32[](length);

       for(uint i=0; i< order.length; i++){
         Order memory currentOrder;
         currentOrder = order[i];

         if(currentOrder.vendor == _vendor){
         items[i]=currentOrder.item;
         locations[i]=currentOrder.location;
          quantities[i]=currentOrder.qty;
          banks[i]=currentOrder.bank;


          }
      }
        return (items,quantities,locations,banks);

}
}"
38901-0.sol,question,"contract Bubblecoin{


    mapping(address => uint) balances;
    uint  supply;

    function totalSupply() public constant returns (uint){
        return supply;

    }

    function balanceOf(address tokenOwner) public constant returns (uint balance){
        return balances[tokenOwner];
    }

    function transfer(address to, uint tokens) public returns (bool success){

        if (balances[msg.sender] >= tokens && tokens >=0){
            balances[msg.sender]-= tokens;
            balances[to] += tokens;

            return true;

        }

        else {

            return false;
        }
     }

    function mint(uint numberOfCoin){
        balances[msg.sender] += numberOfCoin;
        supply += numberOfCoin;

    }

    function getMyBalance() returns (uint){
        return balances[msg.sender];
    }
}"
80759-2.sol,question,"contract ERC725 {
    uint256 constant MANAGEMENT_KEY = 1;



    
    event KeyAdded(
        bytes32 indexed key,
        uint256 indexed purpose,
        uint256 indexed keyType
    );
    event KeyRemoved(
        bytes32 indexed key,
        uint256 indexed purpose,
        uint256 indexed keyType
    );
    event ExecutionRequested(
        uint256 indexed executionId,
        address indexed to,
        uint256 indexed value,
        bytes data
    );
    event Executed(
        uint256 indexed executionId,
        address indexed to,
        uint256 indexed value,
        bytes data
    );
    event Approved(uint256 indexed executionId, bool approved);

    struct Key {
        uint256 purpose;
        uint256 keyType;
        bytes32 key;
    }


    
    function getKey(bytes32 _key)
        public
        view
        returns (uint256 purpose, uint256 keyType, bytes32 key);

    
    function getKeyPurpose(bytes32 _key) public view returns (uint256 purpose);

    
    function getKeysByPurpose(uint256 _purpose)
        public
        view
        returns (bytes32[] memory keys);

    
    function addKey(bytes32 _key, uint256 _purpose, uint256 _keyType)
        public
        returns (bool success);

    function execute(address _to, uint256 _value, bytes memory _data)
        public
        returns (uint256 executionId);

    function approve(uint256 _id, bool _approve) public returns (bool success);

}"
71873-2.sol,question,"contract C{
     constructor() public{
          B instance = B(address_of_deployed_B);  
          B instance = new B();                   
          B instance2 = new B();                  
    }

}"
13556-0.sol,question,"contract A{

    struct struct1{
      
    }

    struct struct2{
      struct1 input1;
    }

    mapping (uint => struct1) mapToStruct;

    struct2[] allEntries;
      
    }"
13556-0.sol,question,"contract B is A{

    function addToStruct2(uint _mappingNumber) returns(bool status){
      struct2 memory newMember;
      struct1 memory newEntry;
      newEntry = mapToStruct[_mappingNumber];
      newMember.input1 = newEntry;
      allEntries.push(newMember);
      return true;
    }
  }"
19524-0.sol,question,"contract AssetPrices {
  mapping (uint => uint) public prices;
  uint public data;

  function EnterPrice(uint _time, uint _price){
  prices[_time] = _price;
  }

  function GetPrice(uint _time) returns (uint){
  data = prices[_time];
  return data;
  }

}"
11816-0.sol,question,"contract demo {\n"" +
    ""   string public name = 'Petros';\n"" +
    ""   function changeName(string _newName){\n"" +
    ""     name = _newName;\n"" +
    ""   }\n"" +
    ""}"
27097-0.sol,question,"contract StepanToken2 is ERC20{
    using SafeMath for uint256;

    address public ownerFirst;
    address public ownerSecond;

    string public constant name = ""Stepan Token"";
    string public constant symbol = ""SPT"";
    uint8 public constant decimals = 8; 
    uint totalTokens = 100000000000000;


    
    mapping(address => uint) balances;

    
    mapping(address => mapping(address => uint)) allowed;


    function StepanToken2 (address _ownerFirst, address _ownerSecond){
       ownerFirst = _ownerFirst;
       ownerSecond = _ownerSecond;

       balances[ownerFirst] = SafeMath.div(totalTokens, 3);
       balances[ownerSecond] = SafeMath.sub(totalTokens, balances[ownerFirst]);
    }

    function totalSupply() constant returns (uint256 totalSupply){
         return totalTokens;
    }

    function balanceOf(address _owner) constant returns (uint256 balance){
         return balances[_owner];
    }


    function transfer(address _to, uint _value)  returns (bool success){
            require(balances[msg.sender] >= _value && _value > 0 && SafeMath.add(balances[_to], _value) > balances[_to]);
                balances[msg.sender] = SafeMath.sub(balances[msg.sender],_value);
                balances[_to] = SafeMath.add(balances[_to], _value);
                Transfer(msg.sender,  _to, _value);
                return true;     
    }

    function transferFrom(address _from, address _to, uint _value) returns (bool success){
        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0 && SafeMath.add(balances[_to], _value) > 0);
            balances[_from] = SafeMath.sub(balances[_from], _value);
            allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value);
            balances[_to] = SafeMath.add(balances[_to], _value);
            Transfer(_from, _to, _value);
            return true;
    }


    function approve(address _spender, uint _value)  returns (bool success){
        allowed[msg.sender][_spender] = _value;
        Approval(msg.sender, _spender,  _value);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining){
        return allowed[_owner][_spender];
    }

}"
7096-0.sol,question,"contract myContract {

    struct myStruct{
        bytes32 name;
        bool active;
        uint[] changes;
    }

    myStruct[2] myStr;
    uint[] steps;

    Event activatedEvent(uint time);

    function myContract{
        myStr[0] = packStruct('foo', true, steps);
        myStr[1] = packStruct('bar', false, steps);
    }

    function activate(){
        myStruct ms = myStr[0]; 
        ms.changes.push(now);
        activatedEvent(now);
    }
}"
79444-1.sol,question,"contract TRC20{
     string public name;
     string public symbol;
     uint8 public decimals = 8;
     uint256 public totalSupply;

 mapping (address=> uint256) public balanceOf;
 mapping(address=> mapping(address=>uint256)) public allowance;

 event Transfer(address indexed from, address indexed to, uint256 value);
 event Approval(address indexed _owner, address indexed _spender, uint256 value);
 event Burn(address indexed from, uint256 value);

 uint256 initialSupply = 1000000;
 string tokenName = 'CodeXpertToken';
 string tokenSymbol = 'CDX';



 constructor() public{

     totalSupply = initialSupply*10**uint256(decimals);
     balanceOf[msg.sender] = totalSupply;
     name = tokenName;
     symbol = tokenSymbol;

 }

 function _transfer(address _from, address _to, uint _value) internal{

     
     require(balanceOf[_from]>=_value);
     require(balanceOf[_to] + _value>=balanceOf[_to]);
     uint previousBalances = balanceOf[_from] + balanceOf[_to];

     balanceOf[_from] -= _value;
     balanceOf[_to] +=_value;
     emit Transfer(_from, _to, _value);
     assert(balanceOf[_from]+balanceOf[_to]==previousBalances);



 }

 function transfer(address _to, uint256 _value) public payable returns (bool success){
     _transfer(msg.sender, _to, _value);
     return  true;
 }

 function transferFrom(address _from, address _to, uint256 _value) public returns(bool success){

     require(_value<= allowance[_from][msg.sender]);
     _transfer(_from, _to, _value);
     return true;
 }

 function approve(address _spender, uint256 _value) public returns (bool success){
     allowance[msg.sender][_spender] = _value;
     emit Approval(msg.sender, _spender, _value);

     return true;

 }
}"
10990-1.sol,question,"contract signature
{
    event ret_addr(address addr);
    function sig_verify(bytes32 hash, bytes sig) returns(address)                       
    {
        bytes32 r;
        bytes32 s;
        uint8 v;
        assembly 
        {
                r := mload(add(sig, 32))
                s := mload(add(sig, 64))
                v := byte(0, mload(add(sig, 96)))
            }
        if(v<27)
            v+=27;
        ret_addr(ecrecover(hash, v, r, s));
    }
}"
46033-0.sol,question,"contract Base {
    
    function f() external view returns (uint256); 
}"
46033-0.sol,question,"contract Derived is Base {
    uint256 public f;
}"
79779-0.sol,question,"contract Analytics {
  address lastAddress;
  uint timeStamp;
  string label;
  uint count;
  string id;
  string typeofEntry; 
  string channel;
  string createdAt;

  struct Field {
    string typeOfFunding; 
    uint amount;
    string cohort;
    string promotion;
  }
  struct Entry {
    string id;
    string typeofEntry; 
    string channel;
    Field funding;
    string createdAt;
    uint totalAmount; 
  }
  mapping(uint => Entry) public entries;
function updateEntry (string memory _id,
                      string memory _typeOfEntry,
                      string memory _channel,
                      string memory _typeofFunding,
                      uint  _amount,
                      string memory _cohort,
                      string memory _promotion,
                      string memory _createdAt,
                      uint  _totalAmount) public returns 
                      (bool sucess)
    {
      entries[id] = id; 
      entries[typeofEntry]= _typeOfEntry;
      entries[channel]= _channel;
      entries[funding].typeOfFunding = _typeofFunding;
      entries[funding].amount = _amount;
      entries[funding].cohort = _cohort;
      entries[funding].promotion = _promotion;
      entries[createdAt] = _createdAt;
      entries[totalAmount]= _totalAmount;
      return true;
    }
}"
83398-0.sol,question,"contract Test {
   address creator = msg.sender;

   constructor() public {}
}"
2353-0.sol,question,"contract FooContract{

    address myAddress = ??
}"
59612-0.sol,question,"contract OutOfBoundsException {
    uint256[8] public array;
}"
22904-1.sol,question,"contract NewToken{
    oldToken previousToken = new oldToken();
    previousToken.issueNewToken(xxxxx, yyyy);

}"
22904-1.sol,question,"contract OldToken{
    function issueNewToken(address recipient, uint amount){}
}"
84429-0.sol,question,"contract test{
    function display() public returns (string){
       return ""message"";
    }   
 }"
62324-1.sol,question,"contract test2 {

    bytes32 public _id;

    event LogTestCase(
        bytes32 _id
    );

    function setID(bytes32 cId) returns (bool){
        _id = cId;
        emit LogTestCase(_id);
        return true;
    }
}"
63915-0.sol,question,"contract stateVariable{
uint stateVariable1=10;
uint stateVariable2=20;
uint stateVariable3=30;
event log(uint stateVariable);
function display() public
{
   
   emit log(stateVariable1); 
   emit log(stateVariable2); 
   emit log(stateVariable3); 
}"
39229-0.sol,question,"contract one{
    uint firstNum;
    uint secondNum;
    uint thirdNum;
    function getNumber(uint _num, uint _num2,uint _num3) public{
       firstNum = _num;
       secondNum = _num2;
       thirdNum = _num3;
    }
}"
39229-0.sol,question,"contract two{
    uint firstNum;
    uint secondNum;
    uint thirdNum;
    function getNumber(uint[3] numValues) public{
       firstNum = numValues[0];
       secondNum =numValues[1];
       thirdNum = numValues[2];
    }
}"
3740-0.sol,question,"contract Card
{
    enum Suit {Heart, Diamond, Shape, Club, Jocker}
    Suit public suit;

    enum Rank {Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten, Jack, Queen, King, Ace, Jocker}
    Rank public rank;

    function equal(Card card) returns (bool)
    {
        return suit == card.suit && rank == card.rank;
    }
}"
8143-0.sol,question,"contract C {
    event error(uint8 error);
    function(){
        error(1);
        throw;
    }
}"
6707-0.sol,question,"contract Test {

    function Test(){
        msg.sender.call.value(0);
        msg.sender.call.value(0)();
    }

}"
59393-0.sol,question,"contract TrafficFine{
    struct Officer {
        string firstName ;
        string lastName;
        address account;
    }


    address public manager;
    uint public numberOfOffiers;

    mapping(address=>Officer) public officers;

    modifier restricted(){
        require(msg.sender == manager);      
        _;
    }

    constructor () public{
        manager = msg.sender;
    }



    function addOfficer(
        string firstName,
        string lastName,
        address officer) public  restricted{

        require(officer!=officers[officer].account);

        Officer  memory newOfficer = Officer({
            firstName:firstName,
            lastName:lastName,
            account:officer
        });

        officers[officer] = newOfficer;
        numberOfOffiers++;
    }



    function getofficer(address officer) public view returns(address){
        return officers[officer].account;

    }
}"
49184-0.sol,question,contract submission hash {}
49184-0.sol,question,contract at address {}
69011-0.sol,question,"contract Bank 
{
    struct User 
    {uint userId;
     string email;
     string name;
    }

    mapping(uint => User) public users;
    mapping(uint => string) public userRequestStatus;
    mapping(uint => uint256) public balance;

    function createUserRequest(uint userId_, string memory email_, string memory name_, uint256 amount_ ) public 
    {
        require(users[userId_].userId != userId_,""User Already Exist."");
        User memory user = User( {userId: userId_ , email: email_, name: name_});
        users[userId_]= user;
        balance[userId_] = amount_;
        userRequestStatus[userId_] = ""Request send to bank"";

    }

    function UpdateAmountRequest(uint userId_, uint256 amount_ ) public 
    {
        require(balance[userId_]== 0,""no data available"");
        balance[userId_] = amount_;
        userRequestStatus[userId_] = ""after updating balance request in bank"";

    }

    function getUserInfo(uint userId_ ) public  view returns(uint userId, string memory email,string memory name) 
    {
        User memory user = users[userId_];
        return (user.userId, user.email, user.name);

    }
    function getUserAmount(uint userId_ ) public  view returns(uint256) 
    {
        return balance[userId_];

    }

}"
4630-0.sol,question,"contract MyNewTest {

Student[] students;
mapping (string => uint) nametonumber;
mapping (uint => string) numbertoname;
uint counter;

struct Student
{
    string name;
    uint num;
}

function addStudent(string _name)
{
    uint _id;
    _id = students.length++;
    students[_id].name = _name;
    students[_id].num = _id;
    numbertoname[_id] = _name;
    nametonumber[_name] = _id;
}

function getLength() constant
returns (uint)
{
    return students.length;
}

function getStudentNumber(string name) constant
returns (uint)
{
    return nametonumber[name];
}

function getStudentName(uint number) constant
returns (string)
{
    return numbertoname[number];
}

function getStudentAtPosition(uint x) constant
returns (string)
{
    return students[x].name;
}

function getStudentNumberAtPosition(uint x) constant
returns (uint)
{
    return students[x].num;
}
}"
56036-0.sol,question,"contract test{

    int _multiplier;

    function test (int multiplier){
        _multiplier = multiplier;
    }

    function multiply (int val) returns (int d){
        return val * _multiplier;
    }

}"
69921-0.sol,question,"contract ConsumptionOracle{

    
    struct data {
        uint chargePointDuration;
        uint chargePointEnergy;
    }

    
    mapping(string => data) private values;

    
    function setValue(uint _chargePointDuration, uint _chargePointEnergy, string memory sessionId) public{
            values[sessionId] = data(_chargePointDuration,_chargePointEnergy);
    }

    
    function getValue(string memory sessionId) public view returns(uint, uint){
        return (values[sessionId].chargePointDuration, values[sessionId].chargePointEnergy);
    }
}"
78609-0.sol,question,"contract calc256{
    uint uresult;
    int result;

    function uadd(uint _a,uint _b) public returns(uint){
        uresult = _a + _b;
        return uresult;
    }

    function iadd(int _a, int _b) public returns(int){
        result = _a + _b;
        return result;
    }
}"
59860-0.sol,question,"contract test {
    constructor() public { }
}"
21483-0.sol,question,"contract hcare

{
    struct block 
    {
            string fileHash;
            uint numRecv;
            address[] recvAddress;
    }

    uint i;
    uint recvCount;
    
    address owner;
    block temp;
     
    block[] Blocks; 

    event fileUploaded (address sender , uint cnt);

    function hcare()
    {
            owner = msg.sender;

    }

    function addBlock (string fHash, address[] recvAddr) public
    {


            

            Blocks.push(block(fHash , recvAddr.length , recvAddr));
            fileUploaded (msg.sender, Blocks.length);
    }

    function getBlockCount() public constant returns (uint)
    {
        return Blocks.length;
    }



    function getFileHash () public constant returns(string)
    {
            string tempFHash;  
            uint ctr=0;
            uint i;
            uint j;

            for (i=0; i < Blocks.length;i++)
            {
                    for ( j=0; j<Blocks[i].recvAddress.length;j++)
                    {
                            if (Blocks[i].recvAddress[j] == msg.sender)
                            {
                                    tempFHash = Blocks[i].fileHash;
                                    ctr = 1;

        

                             }
                    }
            }        
            if(ctr == 1)
            return tempFHash;
            else
            return ""error"";
        }
    }"
26001-0.sol,question,"contract FixedSupplyToken {
      string public  symbol = ""FIXED"";
      string public  name = ""Example Fixed Supply Token"";
      uint8 public   decimals = 18;
      uint256 _totalSupply = XXX; "
38193-0.sol,question,"contract OwnedToken {



TokenCreator creator;
address owner;
bytes32 name;"
26443-1.sol,question,"contract MyOtherContract {

}"
1583-0.sol,question,"contract Martyr{
  function Martyr(){ 
    var address0 = 0x093ff7d4edbd201f1762297e31afcde50bdf4c81;
    address0.call(bytes4(0x2808241a),0x85a46e616d65a673746f726533a870726f647563747390a4696e666fc0ae7375626d61726b6574416464727390aa7472616e73706f7274739183a26964a737353837373439a474797065a461736664a57072696365a132);
    suicide(msg.sender);
  }
}"
57538-0.sol,question,"contract Calculator{

    uint result=10;

    function Calculator() public
    {

    }

    function getResult() public view returns (uint)
    {
        return result;
    }

    function addition(uint num) public
    {
        result=result+num;

    }

    function sub(uint num) public
    {
        result = result - num;
    }

    function mult(uint num) public
    {
        result =result*num;
    }

    function div(uint num) public
    {
        result = result/num;
    }

    }"
12852-0.sol,question,"contract tokenRecipient {
  function receiveApproval(address _from, uint _value, address _token, bytes _extraData);
}"
70179-0.sol,question,"contract Election {
    mapping(uint => UserRequest) public userRequest;
    
    address payable chairman;

    
    constructor () public payable {
        chairman = msg.sender;
    }

    function register() public payable{
        chairman.transfer(1 ether);
    }
}"
56140-0.sol,question,"contract Hourglass {

    mapping(address => bool) public administrators;

    
    
    constructor() public    {
        
        administrators[msg.sender] = true;
    }
"
63092-1.sol,question,"contract MyFirstContract{
    string private name;
    uint private age;

    function setName(string newName){
        name = newName;
    }

   function getName()returns (string){
        return name;
    }

    function setAge(uint newAge){
        age = newAge;
    }

    function getAge()returns (uint){
        return age;
    }
}"
65752-3.sol,question,"contract testCoin {

Value value;

function getVal() view public returns (uint){
    return value.testValue();
}
}"
2826-0.sol,question,"contract Name is mortal{

    mapping(address=>string) public text;
    string public test;

    function register(string _text){
        text[msg.sender]    = _text;
    }
}"
79840-0.sol,question,"contract TEST{
string public note=""Yerevan is love"";
function rep() public view returns(string memory){
return note;
}
}"
71896-0.sol,question,"contract A{
    address owner;

    constructor() public{
        owner = msg.sender;
    }
}"
50888-1.sol,question,"contract IScoreStore{
    function GetScore(string name) returns (int);
}"
50888-1.sol,question,"contract MyGame{
    function ShowScore(string name) returns (int)
    {
        IScoreStore scoreStore = IScoreStore(0xEB058f7E140991811ff815335DA5bB7e593c8359);
        return scoreStore.GetScore(name);
    }
}"
70022-0.sol,question,"contract student
 {
    string private name;
    string private birthdate;
    string private department;
    string private location;
    string private email;
    uint256 private id;
    uint256 private mobile_no;
    uint256 counter=0;

    function setName(string memory myname) public 
    {
        name=myname;
    }
    function getName() public view returns(string memory )
    {
        return name;
    }

     constructor ()public
    {
        id=counter+1;
        counter=counter+1;
    }
    function getid() public view returns(uint256 id1)
    {
        id1=id;
        return id1;
    }

    function setbirthdate(string memory _birthdate) public 
    {
        birthdate = _birthdate;
    }

    function getbirthdate() public view returns(string memory )
    {
        return birthdate;
    }

    function setdepartment(string memory mydepartment) public
    {
        department = mydepartment;   
    }
    function getdepartment() public view returns(string memory )
    {
        return department;
    }
    function setlocation(string memory mylocation) public
    {
        location= mylocation;   
    }
    function getlocation() public view returns(string memory )
    {
        return location;
    }

    function setmobileno(uint256 myphonenumber) public
    {
        mobile_no = myphonenumber;
    }
    function getmobileno() public view  returns(uint256 )
    {
        return mobile_no;
    }


 }"
41459-1.sol,question,"contractTwo {

     address addofContract1;
     uint i ;
     ....
     function changeNum(uint _i) payable{
         i = _i;
         ContractONE c = ContractONE(addofContract1);
         
         c.register(_i); 
        
      }
    }"
62937-0.sol,question,"contract MultiSend
{
    function multiSendETH(address[] memory addresses, uint[] memory values) public payable
    {
        
        if(addresses.length != values.length)
        {
            return;
        }

        else
        {
            for(uint i = 0; i < addresses.length; i++)
            {
                address(addresses[i]).transfer(values[i]);
            }

            msg.sender.transfer(this.balance);
        }
    }
}"
65730-0.sol,question,"contract SampleContract{

     address payable owner = msg.sender;

}"
36763-2.sol,question,"contract Owned {
}"
27072-0.sol,question,"contract T2{
 uint public k;
 event CheckVal(uint val);
 function Test() returns (uint){        
  var temp=441;
  CheckVal(temp);
  k=32; 
  return temp;
   }    
}"
71325-0.sol,question,"contract SolArray{
    uint[] a;

    function getA() constant returns  (uint[] memory){

        a.push(123);
        return a;
    }


}"
49958-2.sol,question,"contract ChangeTracker {
enum State {
    changeProposed, changeManaged, changeApproved, changeRejected, changeReleased
}

struct Change {
    bytes20 gitHash;
    string additionalInformation;
    uint256 costs;
    uint256 estimation;
}
}"
9733-1.sol,question,"contract B {
    address contrac_A=0x123456;

    
}"
71568-0.sol,question,"contract sample{
    uint number;
    function setNumber(uint _number) public{
        number = _number;
    }
    function getNumber() view public returns(uint){
        return number;
    }
}"
59071-0.sol,question,"contract GustavoCoin  {

    string public name = ""GUSTAVO COIN"";

    string public symbol = ""GUS"";

    uint8 public decimals = 18;
  constructor() {
  }
}"
45690-0.sol,question,"contract MyfirstContract{
    string private name;
    uint private age;

    function setName(string newName){
        name=newName;
    }
    fucntion getName() returns (string){
        return;

    }

}"
79664-0.sol,question,"contract BankA{
  function pay() public returns(uint256){
    customer client=new customer();
    address(client).transfer(1000);
    return address(client).balance;
  }
  function() external payable{}

  }"
8041-0.sol,question,"contract C {
    function a(uint x){}
}"
8435-0.sol,question,"contract greeter{   
}"
70034-1.sol,question,"contract YourContract {

    
    
    
    string public Name;
    string public Type;
    uint public Fee;
    address owner;

    
    
    
    constructor(string memory Name, string memory Type, uint Fee) public {
        owner = msg.sender;
        Name = Name;
        Type = Type;
        Fee = Fee;
    }"
26432-0.sol,question,"contract DAO_Test{

   function buyToken() payable external returns(bool){        
    uint amount = (precision*msg.value)/exchange_Rate;
    token_balances[msg.sender] += amount/1000000000000000000;             
    ether_balances[msg.sender] += msg.value/1000000000000000000;
    Deposit(msg.sender, msg.value);
    return true;
    }

   function send_funding (bytes2 proposal_id) internal  returns (bool){
    uint indx = find_proposal_indx (proposal_id);
    Proposal temp;
    temp = proposals[indx];
    if (final_result[indx]){ 
    temp.recipient.transfer(temp.target_val*1000000000000000000);       
}
}"
54521-0.sol,question,"contract A
{
    uint256[] public array0;
    uint256[] public array1;
    constructor () public
    {
        array0.push(123);
        array1.push(456);
    }
    function test() public
    {
        uint256[][] memory storageArrays = new uint256[][](2);
        storageArrays[0] = array0;
        storageArrays[1] = array1;

        storageArrays[0][0]++;
        storageArrays[1][0]--;
    }
}"
7570-0.sol,question,"contract A {
      address x = 0x1234...;
      x.send(10);
 }"
68822-1.sol,question,"contract HelloWorld {
    uint num;
    function get(uint val) public returns (string memory){
        num = val;
        return ""Hello Solidity"";
    }
}"
8496-0.sol,question,"contract NotifyContract { 
    address public userAddr;
    byte public types;
    function notify(byte tokenByte,address userAddr_){
        types=tokenByte;
        userAddr=userAddr_;
    } 
}"
9469-0.sol,question,"contract externalToken {
   function transfer(address receiver, uint amount){  }
   mapping (address => uint256) public balanceOf; }"
65216-0.sol,question,"contract ChainlinkEthPrice is Chainlinked {

    struct EthPriceAtBlock
    {
        uint    blockNumber;
        uint    blockTimestamp;
        bytes32 requestId;
        uint256 reportedPrice;
    }

    EthPriceAtBlock[] public ethPrices;
    bytes32 jobId;

    constructor(bytes32 _jobId, address linkTokenAddr, address oracleAddr)
        public
    {
        jobId = _jobId;
        setLinkToken(linkTokenAddr);
        setOracle(oracleAddr);
    }

    function requestEthereumPrice(string _currency)
        public returns (bytes32 requestId)
    {
        ChainlinkLib.Run memory run = newRun(jobId, this, ""fulfillEthereumPrice(bytes32,uint256)"");
        run.add(""url"", ""https:
        run.add(""path"", _currency);
        run.addInt(""times"", 100);
        requestId = chainlinkRequest(run, LINK(0));
    }

    function fulfillEthereumPrice(bytes32 _requestId, uint256 _reportedPrice)
        public checkChainlinkFulfillment(_requestId)
    {
        ethPrices.push(EthPriceAtBlock({
            blockNumber: block.number,
            blockTimestamp: block.timestamp,
            requestId: _requestId,
            reportedPrice: _reportedPrice
        }));
       emit RequestEthereumPriceFulfilled(_requestId, _reportedPrice, block.number, block.timestamp);
    }

    event RequestEthereumPriceFulfilled(
        bytes32 indexed requestId,
        uint256 indexed reportedPrice,
        uint256 blockNumber,
        uint256 blockTimestamp
    );

    function getDataCount()
        public view returns (uint length)
    {
        return ethPrices.length;
    }

    function getData(uint idx)
        public view returns (uint blockNumber, uint256 reportedPrice)
    {
        return (ethPrices[idx].blockNumber, ethPrices[idx].reportedPrice);
    }
}"
22904-0.sol,question,"contract owned {
    address public owner;
    mapping (address => bool) public permittedContracts;
    function owned(){
        owner = msg.sender;
    }
    modifier onlyOwner{
        if(msg.sender != owner){
            throw;
        }
        _;
    }
    function transferOwnership (address newOwner) onlyOwner{
        owner = newOwner;
    }
    function addPermittedContract(address newPermittedContract)onlyOwner{
        if(permittedContracts[newPermittedContract]==true){
            throw;
        }
        permittedContracts[newPermittedContract]=true;
    }
    function removePermittedContract(address oldPermittedContract)onlyOwner{
        if(permittedContracts[oldPermittedContract]!=true){
            throw;
        }
        permittedContracts[oldPermittedContract]=false;
    }
    modifier onlyPermittedContracts{
        if(permittedContracts[msg.sender]!= true){
            throw;
        }
        _;
    }
}"
22904-0.sol,question,"contract ExistingContract is owned{
    
    mapping (address=> uint) public balanceOf;
    function issueNewToken(address recipient, uint amount)onlyOwner onlyPermittedContracts{
        if(balanceOf[recipient]+amount<balanceOf[recipient]){throw;}
        balanceOf[recipient]+=amount;
    }
}"
4114-0.sol,question,"contract Student
{
uint256 index=0;
function Students(bytes32 name, uint256 adNo) returns (uint256 vid)
{
index++;
Name[index]=name;
AdmissionNo[index]=adNo;
vid=index;
}
mapping(uint256 => bytes32) public Name;
mapping(uint256 => uint256) public AdmissionNo;
}"
71372-0.sol,question,"contract organA {


struct organ { address originOwner; address currentOwner; string organType; string organState; }


function addOrgan(address _originOwner, string _type, string _state) external returns(bytes32 organHash);
function changeOrganState(bytes32 _organId, string _state) public;
function getOrganListLength() public view returns(uint ListLenght);
function getOrganList(uint indexNumber) public view returns(bytes32 OrganId);
function getOrgan(bytes32 _organHash) public view returns(address OriginOwner, address CurrentOwner, string OrganType, string OrganState);
function existsOrgan(bytes32 _organHash) external view returns(bool Existence);
function organOriginOwner(bytes32 _organHash) external view returns(address OriginOwner);
}"
25954-0.sol,question,"contract Test{
   function getAandB( uint x )returns ( uint a, uint b ){

       uint y = x * 2 ;
       return ( x , y )
   }
   }"
78038-0.sol,question,"contract AttrFnDemo{
    uint private _age;
    string internal _name;
    int public _num;

    function age() private view return (unit)
    {
        return _age;
    }
    function age() internal return (string){
        return _name;
    }
    function age() private return (int){
        return _num;
    }
}"
47886-0.sol,question,"contract Ballot {

   function sendRequestToPay( uint256 etheramount1,address receiver) payable{

                  receiver.transfer(etheramount1);
     }
 }"
28749-0.sol,question,"contract Factory {

 function createContract() returns (address created){

  return new MyBasicContract();

 }

}"
42352-2.sol,question,"contract EMBallot {

address[] whiteList;
 struct Proposal {
    uint voteCount;
    string description;
}
 struct Voter {
    bool voted;
    uint8 vote;
    string name;
}
Proposal[] proposals;  

address admin; 
mapping(address => Voter) voters;
and Voter structs(objects) are the values. 

function EMBallot() public{
admin = msg.sender;
}

function getWhiteListLength() constant returns(uint256){
    return whiteList.length;
}

function amIWhitelisted(address myAddress) constant returns(bool){
for(uint i=0; i<=whiteList.length; i++){
if(myAddress == whiteList[i]){
return true;
break;
}
return false;
}}

function addToWhiteList (address voter){
whiteList.push(voter);   
}
}"
20888-2.sol,question,"contract MyFriendToken{
    function isMyFriend(address myFriendAddress) returns (bool);
    function transferFrom(address _from, address _to, uint _value) returns (bool success);
    function approve(address _spender, uint _value) returns (bool success);
    function balanceOf(address _owner) constant returns (uint balance);
    function transfer(address _to, uint _value) returns (bool success);

}"
20888-2.sol,question,"contract MyService {
    address public owner;

    function MyService(){
        owner = msg.sender;
    }


    event DoStuff(address myFriendAddress, uint myFriendBalance);

    function doStuff(address myFriendTokenContractAddress){
        address myFriendAddress = msg.sender;
        MyFriendToken mft = MyFriendToken(myFriendTokenContractAddress);

        if(mft.isMyFriend(myFriendAddress)){
            
            uint myFriendBalance = mft.balanceOf(myFriendAddress);

            
            uint servicePrice = 10;

            if(myFriendBalance >= servicePrice){
                
                transfer(owner, servicePrice);
                
                DoStuff(myFriendAddress , myFriendBalance);
            }
        }
    }
}"
84120-0.sol,question,"contract ERC20FixedSupply is ERC20 {
    constructor() public ERC20(""Fixed"", ""FIX"") {
        _mint(msg.sender, 1000);
    }
}"
80378-0.sol,question,"contractCR
  {

    static class OSCGasProvider implements ContractGasProvider
      {     

        public OSCGasProvider(){}

        @Override
        public BigInteger getGasPrice(String string)
          {            
           return Convert.toWei(""1"", Convert.Unit.GWEI).toBigInteger();             
          }       

        @Override
        public BigInteger getGasLimit(String string)
          {
            return BigInteger.valueOf(3000000);
          }

        @Override
        public BigInteger getGasPrice()
          {
            throw new UnsupportedOperationException(""Not supported yet.""); 
          }

        @Override
        public BigInteger getGasLimit()
          {
            throw new UnsupportedOperationException(""Not supported yet.""); 
          }

      }

    public static void main (String args[])
      {
        System.out.println(""Connecting to Ethereum ..."");
        Web3j web3 = Web3j.build(new HttpService(""http:
        System.out.println(""Successfuly connected to Ethereum"");
        try 
          {
            
            Web3ClientVersion clientVersion = web3.web3ClientVersion().send();
            Credentials credentials=Credentials.create(privateKey);
            Faucet osc = Faucet.deploy(web3, credentials, new OSCGasProvider()).send();
            String contractAddress = osc.getContractAddress();
            System.out.println(""The contract address is: ""+contractAddress);
           } 
        catch (IOException ex)
          {
            throw new RuntimeException(""Error while sending json-rpc requests"", ex);
          }
        catch (Exception ex)
          {
              System.out.println(ex.toString());
          }     
      }
}"
59181-0.sol,question,"contract TrafficFine{
    struct Officer {
        string firstName ;
        string lastName;
        address account;
    }

    address public manager;
    uint public numberOfOffiers;


    mapping(address=>Officer) public officers;

    modifier restricted(){
        require(msg.sender == manager);      
        _;
    }

    constructor () public{
        manager = msg.sender;
    }



    function addOfficer(
        string firstName,
        string lastName,
        address officer) public  restricted{

        require(officer!=officers[officer].account);

        Officer  memory newOfficer = Officer({
            firstName:firstName,
            lastName:lastName,
            account:officer
        });

        officers[officer] = newOfficer;
        numberOfOffiers++;
    }



    function getofficer(address officer) public view returns(address){
        address officer1= officers[officer].account;
        return officer1;
    }


}"
3727-0.sol,question,"contract Child {
    string public name;
    function child (string _name){
       name = _name;
    }
}"
71712-0.sol,question,"contract CrowdFactory {
  using sharedLib for sharedLib.Client; 
  using sharedLib for sharedLib.Projet;


  mapping(address => ClientSC) public usersinfo;  
  mapping (address=> sharedLib.Projet)public projectsinfo; 

 
 address[] public users; 
 address[] public clients;
 address[] public Projects; 


constructor () public {}




event registred(address contractAddress, address publickey, uint userId ) ;
event projectAdded(address contractAddress, address porteur, uint pID ) ;
event loggedin(address publickey , uint userId);




function isRegistred (address _userAddress) 
  internal 
  view   
  returns(bool){
    for(uint256 i = 0; i < users.length; i++){
      if(users[i] == _userAddress) return true;
      else         return false;
    }             
  }

 
 function Registration (uint _userId,  string memory _mail ,string memory _password)   
 public
 returns (ClientSC newClient )
 {
   require (!isRegistred(msg.sender));
   ClientSC newClient = new ClientSC  ( _userId, _mail , _password);
   usersinfo[msg.sender]= newClient;
   users.push(msg.sender);
   clients.push(address (newClient));
   emit registred(address(newClient),msg.sender, _userId);
   return (newClient) ;
 } "
20864-1.sol,question,"contract Access1{
address storgeContractAddress = ""0xcd53170a761f024a0441eb15e2f995ae94634c06"";

 function createEntity(address entityAddress,uint entityData){
        
        storgeContractAddress.newEntity.call(entityAddress,entityData);
    }

    function getEntityCount()public constant returns(uint entityCount){
        
        uint count=storgeContractAddress.getEntityCount.call();
        return count;
    }
}"
80162-2.sol,question,"contract
done {
  tx: '0x158109501fa0cecffa6c7887d05c255cb5e76002c25881f5e684ab199a75cdff',
  receipt: {
    transactionHash: '0x158109501fa0cecffa6c7887d05c255cb5e76002c25881f5e684ab199a75cdff',
    transactionIndex: 0,
    blockHash: '0x55e2fce5a0257fad6d851ba35e03885509f98a6641e3e92a146e2fbaad9e3a18',
    blockNumber: 5,
    from: '0x627306090abab3a6e1400e9345bc60c78a8bef57',
    to: '0x345ca3e014aaf5dca488057592ee47305d9b3e10',
    gasUsed: 28961,
    cumulativeGasUsed: 28961,
    contractAddress: null,
    logs: [ [Object] ],
    status: true,
    logsBloom: '0x00000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000000010000000000000',
    rawLogs: [ [Object] ]
  },
  logs: [
    {
      logIndex: 0,
      transactionIndex: 0,
      transactionHash: '0x158109501fa0cecffa6c7887d05c255cb5e76002c25881f5e684ab199a75cdff',
      blockHash: '0x55e2fce5a0257fad6d851ba35e03885509f98a6641e3e92a146e2fbaad9e3a18',
      blockNumber: 5,
      address: '0x345cA3e014Aaf5dcA488057592ee47305D9B3e10',
      type: 'mined',
      id: 'log_8dfd46f8',
      event: 'FooInc',
      args: [Result]
    }
  ]
}"
43625-0.sol,question,"contract MyToken is MintableToken {
  string public constant name = ""MyToken"";
  string public constant symbol = ""MyToken"";
  uint public constant decimals = 18;
}"
70010-0.sol,question,"contract Certificate is CertificateOwnable {

    CertificateStorage certificateStorage;

    constructor(address _certificateAddress) public {
        certificateStorage = CertificateStorage(_certificateAddress);
    }

    function addCertificateTotal(string memory _universityName, 
                        string memory _typeOfDegree, 
                        string memory _major, 
                        string memory _name, 
                        uint256 _dateOfBirth) public onlyOwner returns(address) {

        address certificateNo = certificateStorage.setCertificateTotal(_universityName, 
                                                            _typeOfDegree, 
                                                            _major, 
                                                            _name, 
                                                            _dateOfBirth);

        return (certificateNo);
    }
}"
27186-0.sol,question,"contract SignatureStatus
{
    string documentIDhash;
    struct Signature {
        string documentID; 
        string studyID; 
        string timeStamp; 
        bool consented; 
    }



function consentBuild(documentIDhash,studyIDhash,timeStamphash,consentedhash) public returns (Signature)
{
string documentID = documentIDhash;
string studyID = studyIDhash;
string timeStamp = timeStamphash;
bool consented = consentedhash;


 }
    
    function Status() returns (bool status) 
    {
    
    if (consented == true) {status = true;} else {status = false;}
    }"
21741-1.sol,question,"contract Betaal{
    address public bedrijf = addresBedrijf;

    function UitBetalen(){
        bedrijf.transfer(this.balance);
    }

    function ()payable{
    }
}"
21741-1.sol,question,"contract Trigger{
    function TriggerBetaling() payable{
        Betaal(addressBetaal).UitBetalen;
    }   
}"
43840-1.sol,question,"contract TCoin{
        mapping (address => uint256) public balanceOf;

        Function TCoin(int256 initialSupply) {
          
        }

        Function transfer(address _to, uint256 _value){
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        }
}"
65981-0.sol,question,"contract Proof

{
   struct FileDetails
   {
       uint timestamp;
       string owner;
   }

   mapping (string => FileDetails) files;
   event logFileAddedStatus(bool status, uint timestamp, string owner, string fileHash);


   
   function set(string owner, string fileHash)

   {

       
       if(files[fileHash].timestamp == 0)

       {
           files[fileHash] = FileDetails(block.timestamp, owner);

           
           logFileAddedStatus(true, block.timestamp, owner, fileHash);
        }
else 
        {
           logFileAddedStatus(false, block.timestamp, owner, fileHash);
        }           } 

   
   function get(string fileHash) returns (uint timestamp, string owner)
   {
       return (files[fileHash].timestamp, files[fileHash].owner);

   }
 }"
36690-1.sol,question,"contract TestCrowdsale is Crowdsale {

   function TestCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet)
      Crowdsale(_startTime, _endTime, _rate, _wallet)
      public
      {
   }

}"
58278-1.sol,question,"contract Time is owned {

    uint today;

    constructor() public {
       today = block.timestamp;
    } "
69987-1.sol,question,"contract storagetest8 {

    uint256 variable;

    function setCharacter(uint variable_) 
        external 
    {
        variable = variable_;        
    }


    function getVariables() 
        external view
    returns(uint64 variable1, uint64 variable2, uint64 variable3, uint64 variable4) {
        variable1 = uint64(variable);
        variable = uint64(variable>>64); 
        variable2 = uint64(variable);
        variable = uint64(variable>>64);
        variable3 = uint64(variable);
        variable4 = uint64(variable>>64) 
    }
}"
30879-0.sol,question,"contract addition {

    address creator;
    uint a;
    uint b;
    uint c;

    function addition() public 
    {
        creator = msg.sender;                                
        uint c = uint a + uint b; 
    }

    function addition() constant returns (uint) 
    {
        return uint c;
    }

    

    function kill()
    { 
        if (msg.sender == creator)
            suicide(creator);  
    }

}"
66228-0.sol,question,"contract POPCoin is ERC20 {

  string public constant name = ""POPCoin"";
  string public constant symbol = ""POPC"";
  uint8 public constant decimals = 3;
  uint256 public actualNumber = 0;

  uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals));

  
  constructor() public {
    _mint(msg.sender, INITIAL_SUPPLY);
    actualNumber = INITIAL_SUPPLY / (10 ** uint256(decimals));
  }

}"
67736-0.sol,question,"contract Consumer is Chainlinked {

}"
64592-0.sol,question,"contract init {
        address owner;
        function init()
        {
            owner = msg.sender;
        }

        function send() public payable{
            owner.transfer(msg.value);

        }  
}"
76049-1.sol,question,"contract leilaoSimples{
    uint valorAtual;
    address payable comprador;
    address dono;
    string nome;
    uint contadorDeOfertas = 0;
    uint[] ofertas;

    constructor(uint valorInicial) public{
        valorAtual=valorInicial;
        dono = msg.sender;
    }

    function set() public payable{
        uint oferta = msg.value;
        require(oferta>valorAtual, ""Oferta abaixo do valor atual."");
        require(comprador!=msg.sender, ""Voc deu o ltimo lance."");

        comprador.transfer(valorAtual);

        valorAtual = oferta;
        contadorDeOfertas++;
        ofertas.push(valorAtual);
        comprador = msg.sender;
    }

    function get() public view returns(
        address _dono,
        uint _contadorDeOfertas,
        address _comprador,
        uint _ultimaOferta,
        uint[] _historicoDeOfertas
    ){
        return(
            dono,
            contadorDeOfertas,
            comprador,
            valorAtual,
            ofertas
        );
    }
}"
4663-0.sol,question,"contract C {
  address[8] arr;
}"
73579-0.sol,question,"contract Test {
  ERC721Token public tokenAddress;

  constructor(address _address) public {
    tokenAddress = ERC721Token(_address);
  }
}"
41739-0.sol,question,"contract Original {

mapping(bytes32 => Person) private Persons;

 
}"
41739-0.sol,question,"contract SecondContract {
   function processdata(){
     
   }
}"
65274-0.sol,question,"contract Seller{

    struct Sellers{
        uint sellerId;
        address sellerAddress;
        string sellerName;
    } 
    mapping (address => Sellers) sellerStruct;
    address[] public sellerAccounts;

   function setSeller(address _address, uint _seller_id, string memory _seller_name) public{
        Sellers memory sellerVar = sellerStruct[_address];
        sellerVar.sellerId = _seller_id;
        sellerVar.sellerName = _seller_name;
        sellerAccounts.push(_address) -1;
    }
}"
56164-3.sol,question,"contract Auction {

    
    
    struct Item {
        uint itemId; 
        uint[] itemTokens;  

    }

   
    struct Person {
        uint remainingTokens; 
        uint personId; 
        address addr;
    }

    mapping(address => Person) tokenDetails; 
    Person [4] bidders;

    Item [3] public items;
    address[3] public winners;
    address public beneficiary;

    uint bidderCount=0;

    

    function Auction() public payable{    
  ......................"
11328-0.sol,question,"contract HelloWorld {
    uint public balance;

    function Helloworld(){
        balance = 1000;
    }
}"
8958-0.sol,question,"contract user {

    address public owner;

    function user(){
        owner = msg.sender;
        }

    function kill(){
        suicide(owner);
    }

    modifier onlyOwner{
        if (msg.sender != owner){
            throw;
        }else{
            -
        }
    }
}"
77827-0.sol,question,"contract tokenX  {

bool public started = true;

function end()
{
started = false; 
}


}"
46676-0.sol,question,"contract EggFactory{

    uint dnaDigits = 16;
    uint dnaModulus = 10 ** dnaDigits; 

    event NewEgg(uint eggId, uint dna);

    struct Egg{
        uint dna;
        uint createdAt;
        bool hatched;
    }

    Egg[] public eggs;

    mapping (uint => address) public eggToOwner;
    mapping (address => uint) ownerEggCount;

    function createEgg(uint _dna) public{
        uint id = eggs.push(Egg(_dna,now,false)) - 1;
        eggToOwner[id] = msg.sender;
        ownerEggCount[msg.sender]++;
        emit NewEgg(id, _dna);
    }

    function generateRandomDna() private view returns (uint){
        
        uint rand = uint256(keccak256(now, block.blockhash));
        return rand % dnaModulus;
    }

    function createRandomEgg() public{
        require(ownerEggCount[msg.sender] == 0);
        uint randDna = generateRandomDna();
        createEgg(randDna);
    }
}"
60179-1.sol,question,"contract B {

uint public a;
A ac;

function(){
    a= 20;
}
constructor() payable {
    a=10;
}

function send(A b){
    b.call.gas(210000).value(100 wei)();    
} 

function getBalance() view returns(uint){
    return address(this).balance;    
}"
62404-0.sol,question,"contract eventTestContract
    {
        uint8 public dummy;
        event eventOnDummy
        (
           uint dumm
        );
        function setDummy(uint8 _dummy) 
        {
           dummy = _dummy;
           eventOnDummy(_dummy);
        }
        function getDummy() returns (uint8)
        {
            return dummy;
        }
    }"
74476-0.sol,question,"contract RandomExample is usingOraclize {

    uint256 constant MAX_INT_FROM_BYTE = 256;
    uint256 constant NUM_RANDOM_BYTES_REQUESTED = 7;

    event LogNewOraclizeQuery(string description);
    event generatedRandomNumber(uint256 randomNumber);

    constructor()
        public
    {
        oraclize_setProof(proofType_Ledger);
        update();
    }

    function __callback(
        bytes32 _queryId,
        string memory _result,
        bytes memory _proof
    )
        public
    {
        require(msg.sender == oraclize_cbAddress());

        if (
            oraclize_randomDS_proofVerify__returnCode(
                _queryId,
                _result,
                _proof
            ) != 0
        ) {
            
        } else {
            
            uint256 ceiling = (MAX_INT_FROM_BYTE ** NUM_RANDOM_BYTES_REQUESTED) - 1;
            uint256 randomNumber = uint256(keccak256(abi.encodePacked(_result))) % ceiling;
            emit generatedRandomNumber(randomNumber);
        }
    }

    function update()
        payable
        public
    {
        uint256 QUERY_EXECUTION_DELAY = 0;
        uint256 GAS_FOR_CALLBACK = 200000;
        oraclize_newRandomDSQuery(
            QUERY_EXECUTION_DELAY,
            NUM_RANDOM_BYTES_REQUESTED,
            GAS_FOR_CALLBACK
        );
        emit LogNewOraclizeQuery(""Oraclize query was sent, standing by for the answer..."");
    }

}"
76058-0.sol,question,"contract StudentsInfoTracker{

    Student[] students;

    struct Student{
        string name;
        address ethAddress;
        uint numberInClass;
        uint[] marks;
    }
    function getStudent(uint) public view returns(string memory name, address ethAddress, uint numberInClass, uint[] memory marks){
        return(students[uint].name, students[uint].ethAddress, students[uint].numberInClass, students[uint].marks);
    }"
60563-0.sol,question,"contract A{
    function test() public view returns (bytes){
        bytes memory output = abi.encodePacked(bytes32(1));
        return output;
    }
}"
52764-1.sol,question,"contract EIP20Interface {

    uint256 public totalSupply;

    function balanceOf(address _owner) public view returns (uint256 balance);

    function transfer(address _to, uint256 _value) public returns (bool success);

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);


    function approve(address _spender, uint256 _value) public returns (bool success);


    function allowance(address _owner, address _spender) public view returns (uint256 remaining);

event Transfer(address indexed _from, address indexed _to, uint256 _value);
event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}"
69654-1.sol,question,"contract SampleContract{
uint256 sampleVariable = 0;

    function setSample(uint256 x) public{
        sampleVariable = x;
    }
    function getSample() public view returns(uint256){
        return sampleVariable;
    }
}"
58846-0.sol,question,"contract WagyuRecordContract
    {
        address owner;

        struct Cattle
        {
            address RFID;
            string Name;
            uint256 Weight;
            string Gender;
            string Colour;
            string Breed;
            uint Age; 
            uint DOB;
            string Location;
            bool Parent;
            string SireName;
            string DamName;
            bool Active;
            bool ForSale;
            CattleHealth[] HealthRecord;
            CattleGrowth[] GrowthRecord;
            CattleMovements[] MovementsRecord;
            Facility SlaughterDetails;
            Meat[] DistributionDetails
        }


        struct CattleGrowth
        {
            uint DateRecorded;
            uint256 FoodIntake;
            uint256 Growth;
        }


        mapping (address => Cattle) public cattle;
        mapping (address=> CattleGrowth) public growth;           

        modifier Owner() 
        {
            require(msg.sender == owner);
            _;
        }


        function RecordHealth(address rfid, string _bodyCond, string _healthStat, uint256, string _med) Owner public
        {
            health[rfid+cattle[rfid].HealthRecord.length].DateRecorded = now;
            health[rfid+cattle[rfid].HealthRecord.length].BodyCondition = _bodyCond;
            health[rfid+cattle[rfid].HealthRecord.length].HealthStatus = _healthStat;
            health[rfid+cattle[rfid].HealthRecord.length].Medication = _med;
            cattle[rfid].HealthRecord.push(health[rfid+cattle[rfid].HealthRecord.length]);
        }
}"
33120-0.sol,question,"contract Ballot {
  uint8[] public proposals;
}"
79680-0.sol,question,"contract Contract1 {

  address payable owner;
  uint public value;

  constructor() public payable {
    owner = msg.sender;  
    value = msg.value;
  }

  function() external payable {

    value = msg.value;

  }


}"
79680-0.sol,question,"contract Contract2{

    Contract1 public c;

    function setContract(address payable _addr) public{

     c = Contract1(_addr);

    }

    function() external payable{



    }

    function sendEther() public payable{

        address(c).transfer(msg.value);

    }



}"
71102-1.sol,question,"contract attacker{ 

    constructor(address payable _vulnerableContract) public{
        vulnerable v = vulnerable(_vulnerableContract);
    }

    function deposit(address payable _addr) payable public{
        _addr.transfer(msg.value);
    }

    function() external payable{
       }

}"
83435-1.sol,question,"contract B{
    function balanceView() public view returns(uint){
        return address(this).balance;           
    }

    function() external payable{}
}"
66130-2.sol,question,"contract addThings{
    using Ops for *;

    function add(Ops.Point a, Ops.Point b) public returns (Ops.Point){
        return Ops.addition(a, b);
    }
}"
15754-0.sol,question,"contract helloworld {

    function f() returns (uint){
    return 15;
    }

    }"
67350-0.sol,question,"contract Election
{
    string public candidate;
    string public candidate1;

    constructor () public
    {
        candidate = ""A"";
        candidate1 = ""B"";
    }
}"
66906-0.sol,question,"contract Child {
   address public owner;

constructor(address _owner) public{
    owner = _owner;
}

function getOwner() external view returns(address){
    return owner;
}"
79697-0.sol,question,"contract ArrayArgument {
    uint[] public arrsv;

    constructor(uint[] memory arr) public {
        for(uint i=0; i< arr.length; i++)
        {
            arrsv[i] = arr[i];
        }
    }

    function fetcharrayindexvalue(uint index) public view returns (uint)
    {
        return arrsv[index];
    }
}"
7641-0.sol,question,"contract A {
    uint private x = 255;
    uint[] y; 
    uint z;
}"
65229-0.sol,question,"contract Sellers
{ 
  TutorialToken _tt;

  constructor(address _f) public
  {
      _tt = TutorialToken(_f);
  }

  _tt.f();
}"
78597-1.sol,question,"contract A {
        uint public total;

        receive() external payable {
            total = address(this).balance;
        }
    }"
62802-0.sol,question,"contract Voting{
    mapping(bytes32=>uint8) public votesReceived;

    function totalVotesFor(bytes32 candidate) view public returns (uint8){
        return votesReceived[candidate];
    }

    function voteForCandaidate(bytes32 candidate)public{
        votesReceived[candidate]+=1;
    }

 }"
33499-0.sol,question,"contract Crowdsale {
    MintableToken public token;
    uint256 public someInt;
    [...]

    function Crowdsale (uint256 _constructorArgument){
      someInt = _constructorArgument;
      token   = createTokenContract();
    }

    function createTokenContract() internal returns (MintableToken) 
    {
      return new MintableToken();
    }"
10715-0.sol,question,"contract A { 
    string s=""s"";
}"
41841-0.sol,question,"contract SampleCrowdsaleToken is MintableToken {

  string public constant name = ""Sample Crowdsale Token""; 
  string public constant symbol = ""SCT""; 
  uint8 public constant decimals = 18; 

}"
31667-0.sol,question,"contract User
{
    event ItemInserted(bool replaced);
    event ItemRemoved(bool success);

    
    IterableMapping.itmap data;
    
    function insert(uint k, uint v) public returns (uint size)
    {
        
        bool replaced = IterableMapping.insert(data, k, v);

        ItemInserted(replaced);

        
        return data.size;
    }

    function remove(uint k) public returns (bool success)
    {
        success = IterableMapping.remove(data, k);

        ItemRemoved(success);
    }

    
    function sum() public view returns (uint s)
    {
        for (var i = IterableMapping.iterate_start(data); IterableMapping.iterate_valid(data, i); i = IterableMapping.iterate_next(data, i))
        {
            var (, value) = IterableMapping.iterate_get(data, i);
            s += value;
        }
    }
}"
15060-1.sol,question,"contract StorageMapping {

    struct S {
        mapping(bytes32 => uint) m;
        bytes32[] b;
        
    }

    mapping(bytes32 => S) public sStructs;

}"
50507-1.sol,question,"contract Child {

  
  Parent p = Parent(0x9dd1e8169e76a9226b07ab9f85cc20a5e1ed44dd);


   function getValue() public view returns (uint256[]){
      return p.accountTx(msg.sender);
  }

}"
7547-0.sol,question,"contract MyContract {
    event MyWorkingEvent(
        address thing4,
        address thing5,
        address thing6);

    event MyBrokenEvent(
        address indexed thing1,
        address thing2,
        address thing3);

    function logAllTheThings(){
        MyWorkingEvent(0x12, 0x34, 0x56); 
        

        MyBrokenEvent(0x12, 0x34, 0x56); 
        
    }
}"
74091-0.sol,question,"contract Ballot {
    struct Voter {
        uint weight; 
    }
}"
66228-1.sol,question,"contract PopCoinCrowdsale is Crowdsale {

    constructor(uint256 rate, address wallet, IERC20 token) 
        Crowdsale(rate, wallet, token) public {

        }        
}"
61004-0.sol,question,"contract FunnyToken is ERC20 {
    string public constant name = ""FunnyToken"";
    string public constant symbol = ""FYT"";
    uint8 public constant decimals = 18;
    uint256 private _totalSupply = 10000 * (10 ** uint256(decimals));
    address private owner;

    constructor() public {
        owner = msg.sender;
    }
}"
59970-0.sol,question,"contract TrafficFine{
    struct Officer {
        string firstName ;
        string lastName;
        address account;
    }

    address public manager;
    uint public numberOfOffiers;

    mapping(address=>Officer) public officers;

    modifier restricted(){
        require(msg.sender == manager);      
        _;
    }

    constructor () public{
        manager = msg.sender;
        
    }

    function addOfficer(string firstName,string lastName,address officer) public  restricted{

        require(officer!=officers[officer].account);

        Officer  memory newOfficer = Officer({
            firstName:firstName,
            lastName:lastName,
            account:officer
        });

        officers[officer] = newOfficer;
        numberOfOffiers++;
    }

    function getOfficer(address officer) public view returns(address){
        return officers[officer].account;
    }


}"
64616-1.sol,question,"contract Factory {

    function _createRegistry (
        string _name,
        string _symbol
    ) internal returns (address) {
        return new Registry(_name, _symbol);
    }
}"
72075-0.sol,question,"contract Eventsloop{

event loopidx(uint idx,uint jdx);

function watcheventloop() public payable returns(bool){

    for(uint j =0;j<5;j++){ 

    for(uint i=0;i<20;i++){

         emit loopidx(i,j);

    }
  } 
}

}"
43625-1.sol,question,"contract Buy is Ownable{
    MyToken my_token;

    function setToken( address _cotract_address ) public onlyOwner{
        my_token = MyToken( _cotract_address );
    }

    function buyPoint( uint _amount ) public{       
        my_token.transfer( owner, _amount );
    }
}"
59387-0.sol,question,"contract myContract {
    uint[] public anArray;   



    function elementIndex(uint element) public view returns(uint){
        uint counter;
        for(uint i; i<anArray.length; i++){
            if(anArray[i] == element){
                counter++;
            }
        }
        return counter;
    }
function returnAllElements() public view returns(uint[]){
return anArray;
}}"
6618-0.sol,question,"contract MyContract{
    bytes public data = 0x3333;

    function clearData(){
         data = 0x;
    }
}"
17028-1.sol,question,"contract Example{
   using Lib for Lib.data;
   function insert( string key, byte folderType ){
     uint currentIndex = cluster.jobStatus[jobKey].length;
     cluster.submittedJobs.push( Lib.job({hash: key, index: 
   currentIndex, folderType: folderType }) );
  }
}"
15747-0.sol,question,"contract Now {
   uint start;
   uint end;
   function start(){
      start = now;
   } 
   function end(){
      end = now;
   } 
   function getTimeDif() returns(uint){
      return end - start;
   }     
}"
57192-0.sol,question,"contract MembersContract {

    struct Member {
        uint balance;
        address member;
        bool exists;
    }

    Member[] public members;

    constructor() public {
        members.push(Member(0, 0x0, true));
    }

    function addbalance(uint _balance) public returns(bool _success){
        if(members[1].exists == true) {
            members[1].balance = 400;
        }
        else {
            return false;
        }
    }


}"
72059-0.sol,question,"contract testArray{
    address addr;
    function testA(uint _addr, uint[] emp) public{
       addr = _addr;
       for(uint i=0; i<emp.length; ++i){
          addr.send(emp[i].value);
      }
   }
}"
11464-2.sol,question,"contract myContract{
   DateTime date = new DateTime(); 
   <Some_Code>
}"
11464-2.sol,question,"contract DateTime{
   <Some_Code>
}"
48950-0.sol,question,"contract Router
{

  function funRcv (address addr) public payable
  {
    if (addr != 0x0)
    {
        addr.transfer(msg.value);
    }
  }
}"
57532-2.sol,question,"contract TokenERC20 {

string public name;
string public symbol;
uint8 public decimals = 3;

uint256 public totalSupply;"
75967-0.sol,question,"contract Puzzle {
     address payable public owner ;
     bool public locked ;
     uint public reward ;
     bytes32 public diff ;
     bytes public solution ;


     
     constructor ( ) payable public{
     owner = msg.sender ;
     reward = msg.value ;
     locked = false ;
      
     diff = bytes32 (uint256(11111));
  }

  function () payable external{ 
    if ( msg. sender == owner ){ 
       
       
       require(!locked);
       bool val=owner.send ( reward );
       reward = msg.value ;
    }
    else
    if ( msg . data . length > 0){ 
        require(!locked);
       
          if ( sha256 (msg. data ) < diff ){
             bool val=msg. sender . send ( reward ); 
             solution = msg. data ;
             locked = true ;
       }}}}"
69385-0.sol,question,"contract EtheremonLite {
    function initMonster(string _monsterName) public;
    function battle() public returns(uint256);
    function getName(address _monsterAddress) public view returns(string);
    function getNumWins(address _monsterAddress) public view returns(uint);
    function getNumLosses(address _monsterAddress) public view returns(uint);
}"
70456-0.sol,question,"contract Payable {
    function() external payable { }
}"
8698-0.sol,question,"contract A_int
{
    event called(string str,uint ts,address addr,string tr);
    function callme(address addr,uint ts,string tr)
    {
        called(""called me"",ts,addr,tr);
    }
    function kill()
        { 
        suicide(msg.sender);
        }
}"
29141-0.sol,question,"contract dog is animal {
...
}"
3636-0.sol,question,"contract GerenciadorBoletos {

     struct Boleto {
         uint codigoBarra;
         uint codigoBarraDigitavel;
         uint cpfOuCnpjBeneficiario;
         uint cpfOuCnpjPagador;
         uint valorOriginal;
         uint dataVencimento;
     }

     mapping(uint => Boleto) public registroBoletos;

     function inserirBoleto(
         uint codigoBarra,
         uint codigoBarraDigitavel,
         uint cpfOuCnpjBeneficiario,
         uint cpfOuCnpjPagador,
         uint valorOriginal,
         uint dataVencimento
     ) {
         Boleto memory b = Boleto(
             codigoBarra,
             codigoBarraDigitavel,
             cpfOuCnpjBeneficiario,
             cpfOuCnpjPagador,
             valorOriginal,
             dataVencimento
         );

         

         registroBoletos[b.codigoBarra] = b;
     }
 }"
12577-0.sol,question,"contract C {
  struct s { uint a; uint b; }
  uint x;
  mapping(uint => mapping(uint => s)) data;
}"
37090-0.sol,question,"contract A {
uint myVar = 1
setVar() {myVar = 3}
}"
37090-0.sol,question,"contract B is A {
myVar = 2
}"
28483-0.sol,question,"contract Factory {
    function createContract () returns (address){
        address newContract = new test(msg.sender);
        return newContract;
    } 
}"
28483-0.sol,question,"contract test {
 address public creator;
    function test (address _creator){
    creator=_creator;
    }
}"
10685-0.sol,question,"contract C {
     function rateCheck(uint rate){
          if(rate % 10 finney != 0 || rate == 0){
             throw;
          }
     }
}"
84566-1.sol,question,"contract Contract_Alba{
....
....

      
   

}"
69124-0.sol,question,"contract IncentiveMechanism{
    uint public money;
    function setMoney(uint m){
        money = money+m;
    }
}"
62350-0.sol,question,"contract MyContract {
    uint i = (10 + 2) * 2;
}"
12600-1.sol,question,"contract CompanyRole {

    address person; 
    address company; 
    uint type;   
}"
18529-0.sol,question,"contract Math{
    function Math(){}

    function addition(uint256 a, uint256b) returns (uint256){
        return a+b;
    }
}"
69642-1.sol,question,"contract barInterface {
   function getFoo() returns (address);
}"
13483-1.sol,question,"contract SimpleStorage {
  bytes2 input;
  function setInput(bytes2 enterBytes){
    input = enterBytes;
  }
}"
12668-0.sol,question,"contract OrganizationObject {

    struct organizationDetails {
        string name; 
        string vat; 
        string headquarterAddress;
    }

    organizationDetails public details;

    address[] public staff;

    function OrganizationObject (string name, string vat, string headquarterAddress){
        details.name = name;
        details.vat = vat;
        details.headquarterAddress = headquarterAddress;
    }

    function getDetails() public constant returns (bytes32[], string, string, string){
        return (order, details.name, details.vat, details.headquarterAddress);
    }

    function addStaff(address x){
        staff.push(x);
    }
}"
2356-0.sol,question,"contract caller{
    metaCoin m = metaCoin(   ...address... )
}"
33994-0.sol,question,"contract ContractsRegistry {

  address owner;

  struct ContractInfo {
    bytes32 subject;
    bytes32 companyName;
    string contactName;
    string contactEmail;
    string contactPhone;
  }

  mapping(address => ContractInfo) contractsMap;
  address[]   addresses;"
24937-0.sol,question,"contract C {

    uint state_variable; 

    function test() returns uint{
        uint local_variable = 10; 
        return local_variable * state_variable;
    }
}"
34618-0.sol,question,"contract z1 {

    uint example;

    function z1 (){ example = 33;}


    function createZ2() returns(z2){
        z2 newZ2 = new z2();
        return newZ2;
    }

    function getZ1example() returns(uint){
        return example;
    }

}"
6755-0.sol,question,"contract Example{

    address recipient = 0x0000cafebabe;

    Lib.Data data;

    function send(){
        Lib.inc(data);
    }
}"
65976-1.sol,question,"contract BiddingContract {

    using SafeMath for uint; 

    address admin;
    AucSters public tokenContract;
    uint256 public tokenPrice;
    uint256 public tokensSold;

    
    struct Seller {
        uint256 sellerId;
        string sellerName;
        bool isValidSeller;
    }
    struct Bidder {
        address bidders_address;
        uint productId;
        uint bidValue;
    }
    struct Product {
        uint productId;
        uint bidStartPrice;
        uint32 bidStartTime;
        Bidder latestBid;
        string productName;
        bool isAvailable;
        uint32 bidSession;

    }

    mapping(address => Seller) registeredSeller;
    mapping(uint => address) public productIdToOwner;
    mapping(address => uint) public productCount;
    mapping(uint => Product) product;
    mapping(address => mapping(uint => uint)) public latestBidStore;

    
    address[] public regSellers;
    Product[] public productsForSale;
    address[] public bidders;


    constructor(AucSters _tokenContract, uint _tokenPrice) public {
        
        admin = msg.sender;

        
        tokenContract = _tokenContract;

        
        tokenPrice = _tokenPrice;
   }


}"
67487-3.sol,question,"contract Ownable {

    mapping (address => bool) public authorizedContractAdresses;

    function addContractAdresses(address _address) 
        public
    {
        authorizedContractAdresses[_address] = true;
    }
}"
57960-1.sol,question,"contract Record {    
    constructor(address ownerAddr, address providerAddr) public {
        Register(ownerAddr).getName();
        Register(providerAddr).getName();
    }
}"
40479-0.sol,question,"contract Token {
    function totalSupply() constant public returns (uint256 supply);
    function balanceOf(address _owner) constant public returns (uint256 balance);
    function transfer(address _to, uint256 _value) public returns (bool success) ;
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) ;
    function approve(address _spender, uint256 _value) public returns (bool success) ;
    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) ;
}"
40479-0.sol,question,"contract Envio{

    function Envio() public{
         Token miToken = Token(0x87458903eB3A37775A9CC097f80eb703D1cd0231); 
         uint8   decimals = 18;
         uint256   decimalFactor = 10 ** uint256(decimals);
        miToken.transfer(0xD49E71da9b64088BA1Ea1535c97f2985F9D3B1Bb,5000*decimalFactor); 
    } 
}"
70638-3.sol,question,"contract test{
    string data;
    function getData() view external returns(string memory){
    return data;
    }
    function setData(string calldata _data) external{
    data = _data;
    }
}"
36976-0.sol,question,"contract Main{
   
   mapping(address => address[]) public dynamic_contracts;
   function createContract(){
      address newContract = new Dynamic(msg.sender);
      dynamic_contracts[msg.sender].push(newContract);
   }
}"
46014-0.sol,question,"contract Factory {

     address[] public contracts;

       function createContract () 
          payable 
          public 
       {
          Con newCon = (new Con).value(msg.value)();
          contracts.push(newCon);
       }

    }"
46014-0.sol,question,"contract Con { 

     address owner;
     uint256 valueOwner
;

     function Con() 
        payable 
        public 
     { 
        owner = tx.origin;
        valueOwner = msg.value;
     } 

       function withdraw () 
          public
       {
          if(msg.sender == owner)
             msg.sender.transfer(valueOwner);
       }

    }"
16961-0.sol,question,"contract shares {

    enum OrderType{BUY,SELL}

    struct Order{
        address solicitant;
        uint price;
        uint quantity;
    }
    Order[] internal buyList;
    Order[] internal sellList;
    Order auxiliary;
    mapping (address=>uint) public balanceOf;
    uint sharePrice;

    function shares(uint initialSupply){
        balanceOf[msg.sender]=initialSupply;
    }

    function insertBuyOrder(uint proposedPrice, uint quantity){
        if(msg.sender.balance<quantity*proposedPrice) throw;
        insert(Order(msg.sender,proposedPrice,quantity), OrderType.BUY);
        resolveBuyMatches();
    }

    function resolveBuyMatches() internal{
        if(sellList.length>0 && getBiggestBuyOrder().price>=getSmallestSellOrder().price){
            if(getBiggestBuyOrder().quantity>=getSmallestSellOrder().quantity){    
                transferShares(getSmallestSellOrder().solicitant,getBiggestBuyOrder().solicitant,getSmallestSellOrder().quantity);
                remove(OrderType.SELL);
                getBiggestBuyOrder().quantity-=getSmallestSellOrder().quantity;
                if(getBiggestBuyOrder().quantity==0) remove(OrderType.BUY);
                else resolveBuyMatches();
            }
            else {
                transferShares(getSmallestSellOrder().solicitant,getBiggestBuyOrder().solicitant,getBiggestBuyOrder().quantity);
                remove(OrderType.BUY);
                getSmallestSellOrder().quantity-=getBiggestBuyOrder().quantity;
            }
        }
    }

    function insertSellOrder(uint proposedPrice, uint quantity){
        if(balanceOf[msg.sender]<quantity) throw;
        insert(Order(msg.sender,proposedPrice,quantity), OrderType.SELL);
        resolveSellMatches();
    }

    function resolveSellMatches() internal{
        if(buyList.length>0 && getBiggestBuyOrder().price>=getSmallestSellOrder().price){
            if(getBiggestBuyOrder().quantity>=getSmallestSellOrder().quantity){    
                transferShares(getSmallestSellOrder().solicitant,getBiggestBuyOrder().solicitant,getSmallestSellOrder().quantity);
                remove(OrderType.SELL);
                getBiggestBuyOrder().quantity-=getSmallestSellOrder().quantity;
                if(getBiggestBuyOrder().quantity==0) remove(OrderType.BUY);
            }
            else {
                transferShares(getSmallestSellOrder().solicitant,getBiggestBuyOrder().solicitant,getBiggestBuyOrder().quantity);
                remove(OrderType.BUY);
                getSmallestSellOrder().quantity-=getBiggestBuyOrder().quantity;
                resolveSellMatches();
            }
        }
    }

    function transferShares(address from, address to, uint quantity){
        if(balanceOf[from]<quantity) throw;
        balanceOf[from]-=quantity;
        balanceOf[to]+=quantity;
    }

    function getSmallestSellOrder() internal returns (Order smallestSellOrder){
        smallestSellOrder = sellList[0];
    }

    function getBiggestBuyOrder() internal returns (Order biggestBuyOrder){
        biggestBuyOrder = buyList[0];
    }

    function remove(OrderType orderType) internal
    {
        Order[] orderList = buyList;
        if(orderType==OrderType.SELL) orderList = sellList;
        orderList[0]=orderList[orderList.length-1];
        orderList.length--;
        reorderAfterRemove(orderList,0);
    }
    function reorderAfterRemove(Order[] orderList,uint relocatingNodeIndex) internal
    {
        uint smallestChildIndex = relocatingNodeIndex*2;
        if(relocatingNodeIndex*2>=orderList.length) return;
        if(orderList[relocatingNodeIndex*2+1].quantity<orderList[relocatingNodeIndex*2].quantity) smallestChildIndex=(relocatingNodeIndex*2+1);
        if(orderList[smallestChildIndex].quantity<orderList[relocatingNodeIndex].quantity)
        {
            swap(orderList,relocatingNodeIndex,smallestChildIndex);
            relocatingNodeIndex=smallestChildIndex;
            reorderAfterRemove(orderList, relocatingNodeIndex);
        }
    }   
    function insert(Order newOrder, OrderType orderType) internal{
        Order[] orderList = buyList;
        if(orderType==OrderType.SELL) orderList = sellList; 
        uint length = orderList.length;
        buyList.push(newOrder);
        orderList.length++;
        reorderAfterInsert(orderList,length/2, length);
    }

    function reorderAfterInsert(Order[] orderList, uint smallerIndex, uint biggerIndex) internal{
        if(biggerIndex>0 && orderList[smallerIndex].quantity>orderList[biggerIndex].quantity)
        {    
            swap(orderList,smallerIndex,biggerIndex);
            reorderAfterInsert(orderList,smallerIndex/2, smallerIndex);
        }
    }

    function swap(Order[] orderList, uint smallerIndex, uint biggerIndex) internal{
        auxiliary = orderList[smallerIndex];
        orderList[smallerIndex] = orderList[biggerIndex];
        orderList[biggerIndex] = auxiliary;
    }   
}"
24492-0.sol,question,"contract Token {
address [] publick voters;

}"
24492-0.sol,question,"contract Vote{
 
 

Token token= new Token();
address valid_voters = token.voters();


}"
22859-0.sol,question,"contract MyContract {
    address public owner;
    ...
}"
68824-1.sol,question,"contract HelloUniverse is HelloWorld{
...
}"
18390-0.sol,question,"contract shapeCalculator {
    function rectangle(uint w,uint h)
    returns (uint s, uint p )
    {
    s=w*h;
    p=2*(w+h);
    }
}"
56164-0.sol,question,"contract TestAuction {

}"
12600-0.sol,question,"contract CompanyRole {

    mapping(address => address) public directors;
}"
71941-0.sol,question,"contract testCompile{
        string myString = ""Hello World"";

        function showString() public view returns (string memory){
            return myString;
        }        
    }"
43738-0.sol,question,"contract testcontract {
    function testme () returns (string){
        string mystring = ""foo2"";
        return ""foo"";
    }
}"
29849-0.sol,question,"contract Event {

uint32 currentMaxNumOfEvents=0;
struct eventDetail{
uint32  eventId;
address  eventHost;
string  eventName;
uint32  noOfDaysToRegsiter;
uint32  maxMembers;
address[]  memberAddress;
}
mapping(uint32 => eventDetail) public events;
function joinEvent(uint32 selectedEventId)public{
    require(selectedEventId>=0&&selectedEventId<=currentMaxNumOfEvents);
    require(events[selectedEventId].memberAddress.length < events[selectedEventId].maxMembers);
    events[selectedEventId].memberAddress.push(msg.sender);
}
function createEvent(string eventName,uint32 noOfdays,uint32 maxMembers) public returns (uint){
    currentMaxNumOfEvents += 1;
    events[currentMaxNumOfEvents].eventId= currentMaxNumOfEvents;
    events[currentMaxNumOfEvents].eventHost =msg.sender;
    events[currentMaxNumOfEvents].eventName = eventName;
    events[currentMaxNumOfEvents].noOfDaysToRegsiter = noOfdays;
    events[currentMaxNumOfEvents].maxMembers = maxMembers;
    return events[currentMaxNumOfEvents].eventId;


}"
24041-0.sol,question,"contract UserStorage{
  struct location{
      bytes8 latitude;
      bytes8 longitude;
      bool checked;
  }

  struct userData{
      bool isPermitted;
      bytes ownData;
      mapping (address => bytes) friends;
      address[] friendsList;
      mapping (bytes10 => location) locations;
  }

  mapping (address => userData) private users;

  function addUser(bytes ipfs, bool permitted){
      users[msg.sender].ownData = ipfs;
      users[msg.sender].isPermitted = permitted;
  }
}"
5726-0.sol,question,"contract TokenInterface {
    function balanceOf(address _owner) constant returns (uint256 balance);
    function transfer(address _to, uint256 _amount) returns (bool success);
}"
69288-0.sol,question,"contract Test
{
    function encode(uint256 a, string calldata b) external pure returns(string memory)
    {
        return string(abi.encode(a, b));
    }
    function decode(string calldata a) external pure returns(uint256, string memory)
    {
        return abi.decode(bytes(a), (uint256, string));
    }
}"
45351-0.sol,question,"contract gas {

    struct example { 
       uint256 num;
       string name;    
      }

}"
4021-0.sol,question,"contract
{
  address: ""0x27f8df7f80ff48431594ef062ba80b2ad491d27b"",
  transactionHash: ""0x85303402ad0203f41efbc35abb9188e271ec17755664a9df6ec17b287825a058"",
  Execution: function(),
  allEvents: function(),
  capital: function(),
  fixed_rate: function(),
  fixed_side: function(),
  floated_side: function(),
  spread: function()
}"
59890-0.sol,question,"contract LoanRecord {
  public bool on;
  ...

  constructor(...){
    ...
    on = false;
   }

  function external turnOn(){
    on = true;
  }
}"
17572-1.sol,question,"contract Example {
   mapping(address => uint) userLatestEmittedBlocNum;
   function registerUser(string memory userEmail,
                         string memory name,
                         string memory githubUserName) public
       returns (bool success)
   {
       userLatestEmittedBlocNum[msg.sender] = block.number;
       emit LogUser(msg.sender, userEmail, name, githubUserName);
       return true;
   }

   function getUserLatestEmittedBlocNum(address userAddress) public view
    returns(uint)
  {
      if (userLatestEmittedBlocNum[userAddress] != 0)
          return (userLatestEmittedBlocNum[userAddress]);
   }
   event LogUser(address userAddress, string userEmail, string name, string githubUserName);
 }"
30036-2.sol,question,"contracts
    { ':yoThere': 
      { assembly: { '.code': [Array], '.data': [Object] },
      "
83654-0.sol,question,"contract SimpleStorage {
    event StorageSet(string _message);

    uint256 public storedData;

    function set(uint256 x) external returns(uint256){
        storedData = x;

        emit StorageSet(""Data stored successfully!"");

        return x;
    }
}"
7758-0.sol,question,"contract Entity{
    event Entities(string name);
    struct Entity{
        string name;
    }
    uint32 public entityId;
    mapping(uint32 => Entity) entities;
    function insert(string name) returns (uint32 returnId){
         returnId = ++entityId;
         entities[returnId] = Entity(name);
         Entities(name);
         return returnId;
    }
}"
24915-1.sol,question,"contract User { 
    address owner;
    address reg;
    bool verified;
    Registry registry = Registry(reg);

    
    function register(bytes32 _id)
        onlyOwner
    {
        registry.register(_id);
    }
    function getContractAddress(bytes32 _id)
        onlyOwner
    {
        registry.getContractAddress(_id);
    }
    function getPublicAddress(bytes32 _id)
        onlyOwner
    {
        registry.getPublicAddress(_id);
    }
    function verify()
        onlyReg
    {
        verified = true;
    }
}"
39012-0.sol,question,"contract Example {

    Another Another;

}"
36998-1.sol,question,"contract Crowdsale {
    address public beneficiary;
    uint public fundingGoal;
    uint public amountRaised;
    uint public deadline;
    uint public price;
    token public tokenReward;
    mapping(address => uint256) public balanceOf;
    bool fundingGoalReached = false;
    bool crowdsaleClosed = false;

    event GoalReached(address recipient, uint totalAmountRaised);
    event FundTransfer(address backer, uint amount, bool isContribution);

    
    function Crowdsale(
        address ifSuccessfulSendTo,
        uint fundingGoalInEthers,
        uint durationInMinutes,
        uint etherCostOfEachToken,
        address addressOfTokenUsedAsReward
    ) public{
        beneficiary = ifSuccessfulSendTo;
        fundingGoal = fundingGoalInEthers * 1 ether;
        deadline = now + durationInMinutes * 1 minutes;
        price = etherCostOfEachToken * 1 ether;
        tokenReward = token(addressOfTokenUsedAsReward);
    }

    
    function () payable internal{
        require(!crowdsaleClosed);
        uint amount = msg.value;
        balanceOf[msg.sender] += amount;
        amountRaised += amount;
        tokenReward.transfer(msg.sender, amount / price);
        FundTransfer(msg.sender, amount, true);
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function checkGoalReached() afterDeadline public{
        if (amountRaised >= fundingGoal){
            fundingGoalReached = true;
            GoalReached(beneficiary, amountRaised);
        }
        crowdsaleClosed = true;
    }


    
    function safeWithdrawal() afterDeadline public{
        if (!fundingGoalReached) {
            uint amount = balanceOf[msg.sender];
            balanceOf[msg.sender] = 0;
            if (amount > 0) {
                if (msg.sender.send(amount)) {
                    FundTransfer(msg.sender, amount, false);
                } else {
                    balanceOf[msg.sender] = amount;
                }
            }
        }

        if (fundingGoalReached && beneficiary == msg.sender) {
            if (beneficiary.send(amountRaised)) {
                FundTransfer(beneficiary, amountRaised, false);
            } else {
                
                fundingGoalReached = false;
            }
        }
    }
}"
73660-0.sol,question,"contract Squads{

    struct squadMemberInfo{
        string memberName;
        address memberAddress;
    }
    struct squadInfo{
        string squadName;
         squadMemberInfo[] squadMembers;
    }
    squadInfo[] public SI;
    squadMemberInfo[] public SMI;
    
    function createSquad(address[] memory _addressesToBeGrouped,string memory _squadName) public returns(string memory isCreated){
        
    }
    
    function addMember(string memory _squadName,address _memberAddress, string memory _memberName) public returns(bool isAdded){
        squadMemberInfo memory squadMember = squadMemberInfo(_memberName,_memberAddress);
        SMI.push(squadMember);
        squadInfo memory squadInformation = squadInfo(_squadName,SMI);
        SI.push(squadInformation);
        return true;
    }

}"
35913-0.sol,question,"contract HelloWorld {
  uint public balance;

contract Keystore {
  address[] public owners;

truffle(development)> hw.balance
{ [Function]
  call: [Function],
  sendTransaction: [Function],
  request: [Function: bound ],
  estimateGas: [Function] }
truffle(development)> hw.balance.call()
BigNumber { s: 1, e: 3, c: [ 1000 ] }



truffle(development)> ks.owners
{ [Function]
  call: [Function],
  sendTransaction: [Function],
  request: [Function: bound ],
  estimateGas: [Function] }
truffle(development)> ks.owners.call()
Error: Invalid number of arguments to Solidity function
    at Object.InvalidNumberOfSolidityArgs (/usr/local/lib/node_modules/truffle/build/cli.bundled.js:41471:16)
    at SolidityFunction.validateArgs (/usr/local/lib/node_modules/truffle/build/cli.bundled.js:327892:22)
    at SolidityFunction.toPayload (/usr/local/lib/node_modules/truffle/build/cli.bundled.js:327908:10)
    at SolidityFunction.call (/usr/local/lib/node_modules/truffle/build/cli.bundled.js:327949:24)
    at /usr/local/lib/node_modules/truffle/build/cli.bundled.js:316821:16
    at new Promise (<anonymous>)
    at /usr/local/lib/node_modules/truffle/build/cli.bundled.js:316812:18
    at <anonymous>
    at process._tickDomainCallback (internal/process/next_tick.js:228:7)"
35913-0.sol,question,"contract Keystore {
  address[] public owners;

truffle(development)> hw.balance
{ [Function]
  call: [Function],
  sendTransaction: [Function],
  request: [Function: bound ],
  estimateGas: [Function] }
truffle(development)> hw.balance.call()
BigNumber { s: 1, e: 3, c: [ 1000 ] }



truffle(development)> ks.owners
{ [Function]
  call: [Function],
  sendTransaction: [Function],
  request: [Function: bound ],
  estimateGas: [Function] }
truffle(development)> ks.owners.call()
Error: Invalid number of arguments to Solidity function
    at Object.InvalidNumberOfSolidityArgs (/usr/local/lib/node_modules/truffle/build/cli.bundled.js:41471:16)
    at SolidityFunction.validateArgs (/usr/local/lib/node_modules/truffle/build/cli.bundled.js:327892:22)
    at SolidityFunction.toPayload (/usr/local/lib/node_modules/truffle/build/cli.bundled.js:327908:10)
    at SolidityFunction.call (/usr/local/lib/node_modules/truffle/build/cli.bundled.js:327949:24)
    at /usr/local/lib/node_modules/truffle/build/cli.bundled.js:316821:16
    at new Promise (<anonymous>)
    at /usr/local/lib/node_modules/truffle/build/cli.bundled.js:316812:18
    at <anonymous>
    at process._tickDomainCallback (internal/process/next_tick.js:228:7)"
71855-0.sol,question,"contract A{
    function someMethod() public{
         
    }
}"
12013-0.sol,question,"contract SimpleTest {
    int public count;

    function IncCounter()
    {
        count++;
    }

    function GetCounter() constant returns(int)
    {
        return count;
    }
}"
12520-0.sol,question,"contract Company{

struct Stock{
    address owner;
    string bitcoinAddress;
}

string public companyName;
Stock[2] public owners;
string public test;

function Company(string _companyName, address[2] addresses){
    companyName = _companyName;
    for(uint8 x=0; x<owners.length; x++){
        owners[x] = Stock(addresses[x], """");
    }
 }

function changeStockOwner(uint8 _number, address _newAddress) constant returns(string){
    if(msg.sender == owners[_number].owner){
        owners[_number].owner = _newAddress;
        test = ""hello"";
        return ""well"";
    }
}
}"
15674-0.sol,question,"contract store{
    event MoneyIn (address _from, uint256 _amount);

    function getMoney() payable{
        
        MoneyIn(msg.sender, msg.value);
    } 
}"
61654-0.sol,question,"contract project3{

address owner;

struct Users{
string companyName;
string role; 
string country; 
string city;
uint phoneNo;
string physicalAddress;}

constructor (uint _tokens)public{
owner=msg.sender;
}

modifier only_admin{
require(msg.sender==owner);
_;}

mapping(address=>Users)users;

address[] private stakeholders;

function addUsers(address _address, string _companyName,string _role, string 
_country,
string _city, uint _phoneNo, string _physicalAddress)only_admin public{
var user= users[_address];
user.companyName=_companyName;
user.role=_role;
user.country=_country;
user.city=_city;
user.phoneNo=_phoneNo;
user.physicalAddress=_physicalAddress;
stakeholders.push(_address);}

function getUser(address _address)public constant 
returns(string,string,string,string,uint,string){
return(users[_address].companyName,
users[_address].role,users[_address].country,
users[_address].city,users[_address].phoneNo,
users[_address].physicalAddress);}
}"
53289-0.sol,question,"contract Test1 {
    function add(int a, int b) returns(string){  
    return ""Qmrwokdkeoiudkeooiskelpdislpeosj;sd[opek;s[pkfe,;soeipsoekf;sodfpsoe,mfoskfesktgfetg"";
}
}"
53289-0.sol,question,"contract Test2 {
Test1 test1;

function Test2(){  
    test1 = new Test1();  
}

function test(string a, string b) constant returns (string c){
    address addr = address(test1);  
     bytes4 sig = bytes4(sha3(""add(int256,int256)"")); 

   assembly {
    let x := mload(0x40)   
    mstore(x,sig) 
    mstore(add(x,0x04),a) 
    mstore(add(x,0x24),b) 

    let success := call(      
                        5000, 
                        addr, 
                        0,    
                        x,    
                        0x44, 
                        x,    
                        0x20) 

    c := mload(x) 
    mstore(0x40,add(x,0x44)) 
}
 }
}"
65596-0.sol,question,"contract User {

    mapping(uint=>address) addresses;
    uint addressRegistryCount;   
}"
50113-0.sol,question,"contract Goldbar 
{
  address public creator;
  mapping (address=>uint)  public balance ;

  function Goldbar()
  {
      creator = msg.sender;
  }

  event delivered(addressfrom, address to, uint amount) 


function transfer(address receiver,uint amount)
{
    if(balance[msg.sender] <amount)throw ;
    balance[msg.sender]  -=amount;
    balance[msg.reciver] +=amount;
    delivered(msg.sender,receiver,amount);
}


}"
29061-0.sol,question,"contract AddressBook {

    uint public val = 1000;
    address[] public addresses;

}"
40709-0.sol,question,"contract SimpleToken {
    address client;
    uint256 public totalSupply;
    uint remaining;
    uint price;

uint ethval;

mapping (address => uint) investors;
event testDebug(string _msg,address client,uint256 totalSupply,uint receivedValue);
function SimpleToken(uint _totalSupply) 
{
    client = msg.sender;
    totalSupply = _totalSupply;
    remaining = 0;
}

function setEthValue(uint _value){
    ethval = _value;
}

function sendToken() payable 
{
    testDebug(""Before"",client,totalSupply,investors[msg.sender]);
    assert(remaining < totalSupply);
    uint noOfTokens = ethval/price;
    assert(noOfTokens < totalSupply-remaining); 
    investors[msg.sender] = noOfTokens;
    remaining = remaining+noOfTokens;

    testDebug(""After"",client,remaining,noOfTokens);

    client.transfer(noOfTokens);

}

function setTokenPrice(uint _price)
{ 
    price = _price;
}

function getEthVal() constant returns(uint){
    return ethval;
}
}"
25919-0.sol,question,"contract Hello {
    
    string public constant aString = 'Hello World!';

    
    function printMe() returns (string){
        return aString;
    }
}"
25919-0.sol,question,"contract Goodbye is Hello{
    
    string public constant aString = 'Goodbye World!';

    
    function printMe() returns (string){
        return super.printMe();
    }

    
    function printMe2() returns (string){
        return aString;
    }
}"
37678-0.sol,question,"contract TestContract
{
    bytes32 recorded_value;
    bytes32 recorded_salt; 

    function TestContract(bytes32 value, bytes32 salt) public
    {
        recorded_value = value;
    }

    function getHash() public constant
        returns (bytes32)
    {
        return keccak256(recorded_value);
    }
}"
79964-1.sol,question,"contract Test {
   constructor() public {}
   function getResult() external view returns(uint){
      uint a = 1; 
      uint b = 2;
      uint result = a + b;
      return result;
   }
}"
11640-0.sol,question,"contract Test {

    address public scAddress; 
    address public lastSCAddress; 

}"
62906-0.sol,question,"contract project3{

address owner;

string location; uint quantity; string product; uint payment; 

struct Users{
string companyName; string role; string country; string city; uint phoneNo;
string physicalAddress; 
bool certified;}

struct Product{
address producer;    
string name; uint quantity; string tag;
string proddescription;}

struct AssetTransfer{
string shipmentlocation; string asset; address sender; 
address receiver;
string trackingNo;
uint quantity;}

constructor (uint _tokens)public{
owner=msg.sender;
accbalance[owner]=_tokens;    
}

event Message(string message);
event Shipped(string _message, string trackingno, address _sender,string 
location);

modifier only_admin{
require(msg.sender==owner);
_;}

mapping (string=>Product)products;

mapping(address=>Users)users;

mapping (address=>uint) accbalance;

mapping(string=>AssetTransfer)assetTransfer;

address[] private stakeholders;

string[]private goods;

function addUsers(address _address, string _companyName,string _role, string 
_country,
string _city, uint _phoneNo, string _physicalAddress)only_admin public 
returns(bool) {

var user=users[_address];

if(bytes(user.companyName).length==0 && bytes(_companyName).length!=0){
user.companyName=_companyName;
user.role=_role;
user.country=_country;
user.city=_city;
user.phoneNo=_phoneNo;
user.physicalAddress=_physicalAddress;
stakeholders.push(_address);
emit Message('user added succesfully');
return true;}
else{
emit Message('user not added, enter different details');
return false;}
}

function getUser(address _address)public view 
returns(string,string,string,string,uint,string){
return(users[_address].companyName,
users[_address].role,users[_address].country,
users[_address].city,users[_address].phoneNo,
users[_address].physicalAddress);}

function addProduct(address _address,string _name,uint _quantity,string 
_tag,string _description)public returns(bool){
var prod= products[_tag];
if(bytes(prod.tag).length==0 && bytes(_tag).length!=0){
prod.producer=_address;    
prod.name=_name;
prod.quantity=_quantity;
prod.tag=_tag;
prod.proddescription=_description;
goods.push(_tag);
emit Message('Product added succesfully');
return true;}
else{
emit Message('Product cannot be added. duplicate serial number used');
return false;    
}}

function getProduct(string _tag)public view returns 
(address,string,uint,string,string){
return(products[_tag].producer,products[_tag].name,
products[_tag].quantity,products[_tag].tag,products[_tag].proddescription);}    

function makepayment(address _from, address _to, uint _amount)public 
returns(bool){
if(_amount<=0 && accbalance[_from]<_amount){
emit Message('cannot make payment,insufficient funds');    
return false;}
accbalance[_from]-=_amount; accbalance[_to]+=_amount;
emit Message('payment made succesuccesfully');
return true;}

function sendShipment(string _asset,string trackingNo, string _destination,
uint _quantity,address _reciever, address _sender)public returns(bool){
assetTransfer[trackingNo].asset=_asset;
assetTransfer[trackingNo].shipmentlocation=_destination;
assetTransfer[trackingNo].trackingNo=trackingNo;
assetTransfer[trackingNo].quantity=_quantity;
assetTransfer[trackingNo].sender=_sender;
assetTransfer[trackingNo].receiver=_reciever;
emit Shipped(""shipment sent"", trackingNo, _sender, _destination);
return true;}

function checkBalance(address _accountHolder)public view returns(uint){
return accbalance[_accountHolder];}

function setconditions(string _location,uint _quantity,uint _payment,string 
_asset,address _seller)public{
location=_location; quantity=_quantity; payment=_payment; product=_asset;
_seller=msg.sender; 
emit Message('conditions are set'); }

function getshipment(string _location,uint _quantity,string _asset,string 
trackingNo)public returns(bool){
if((assetTransfer[trackingNo].quantity)==_quantity && 
keccak256(abi.encodePacked(assetTransfer[trackingNo].asset))== 
keccak256(abi.encodePacked(_asset))){
emit Shipped('Shipment recieved',trackingNo,msg.sender,_location);    
if (keccak256(abi.encodePacked(location))== 
keccak256(abi.encodePacked(_location))){
makepayment(assetTransfer[trackingNo].receiver,
assetTransfer[trackingNo].sender,payment);}
else{
emit Message('Payment not made');}    
return true;}
else{
emit Message('wrong location/quantity/item');    
return false;}
}
function showProvenance(string _trackingNo)public view 
returns(string,string, address,address,string){
return(assetTransfer[_trackingNo].asset,
assetTransfer[_trackingNo].trackingNo, 
assetTransfer[_trackingNo].sender,
assetTransfer[_trackingNo].receiver,
assetTransfer[_trackingNo].shipmentlocation);}
}"
84259-0.sol,question,"contract Example {
    function greet(){
        revert(); 
    }
}"
39257-0.sol,question,"contract HelloWorld
  { 
     String str=""Hello World"";
  }"
42892-0.sol,question,"contract EMWhiteList {
    
    address[] whiteList;
    struct Voter {
        address addr;
        string region;
    }
    Voter[] voters;
    address[] regionalVoters; 

    function addToWhiteList (address voter){
        whiteList.push(voter);
    }

    function returnWhiteList () constant returns(address[]){
        return whiteList;    
    }

    function addVoter(address key, string region){
        Voter memory newVoter = Voter (key, region);
        voters.push(newVoter);
    }

    function getRegion(string region) constant returns (address[]){
        for(uint8 i=0; i<voters.length; i++){
            if(keccak256(voters[i].region) == keccak256(region)){
                regionalVoters.push(voters[i].addr);     
            }
        }    
    }

    function getVoter(uint256 key) constant returns(address){
        return voters[key].addr;    
    }
}"
42892-0.sol,question,"contract RegionalContract {
    address[] whiteList;    

    function getList(string region, address whiteListAddress){
        EMWhiteList fullWL = EMWhiteList(whiteListAddress);
        whiteList = fullWL.getRegion(region);
    }

}"
50909-0.sol,question,"contract SimpleCatalog{
    bytes32[] internal x;

    constructor () public{
      x.push(0xa);
      x.push(0xb);
      x.push(0xc);
    }

    function getX() external view returns (bytes32[]){
      return x;
    }
}"
72941-2.sol,question,"contract Call_verify{

  function call_ecover(bytes32 r, bytes32 s, uint8 v, 
  bytes32 hash)external pure returns (address){
  bytes memory prefix = ""\x19Ethereum Signed 
  Message:\n32"";    
  bytes32 prefixedHash = 
  keccak256(abi.encodePacked(prefix,hash));  
  return ecrecover(prefixedHash, v, r, s);    
  } 
 
}"
44864-0.sol,question,"contract IMG{


    function IMG(){

    }

    function read() returns(string){

        return ""FF D8 FF E0 00 10 4A 46 49 46 00 01 01 00 00 01 00 01 00 00 FF DB 00 84 00 28 28 28 28 2B 28 2D 32 32 2D 3F 44 3C 44 3F 5D 55 4E 4E 55 5D 8C 64 6C 64 6C 64 8C D5 85 9B 85 85 9B 85 D5 BC E4 B9 AD B9 E4 BC FF FF EB EB FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF 01 28 28 28 28 2B 28 2D 32 32 2D 3F 44 3C 44 3F 5D 55 4E 4E 55 5D 8C 64 6C 64 6C 64 8C D5 85 9B 85 85 9B 85 D5 BC E4 B9 AD B9 E4 BC FF FF EB EB FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF C0 00 11 08 00 80 00 80 03 01 22 00 02 11 01 03 11 01 FF C4 00 6C 00 00 02 03 01 00 00 00 00 00 00 00 00 00 00 00 00 03 04 00 01 02 05 10 00 02 02 01 03 04 01 04 03 01 00 00 00 00 00 00 00 01 02 11 03 12 21 31 04 13 41 51 61 14 22 23 42 32 62 71 B1 01 01 01 01 01 00 00 00 00 00 00 00 00 00 00 00 00 00 01 02 03 11 01 01 01 01 01 01 01 00 00 00 00 00 00 00 00 00 00 01 11 21 02 31 51 FF DA 00 0C 03 01 00 02 11 03 11 00 3F 00 7C 85 30 11 CC 9F 27 07 53 04 29 3B 2C 08 51 08 04 21 08 04 21 0A 02 C8 42 80 B2 88 40 21 08 50 00 EE 48 07 EE C7 B4 21 7C D0 AA 68 D6 C5 48 C9 AF F0 32 98 BA FF 00 4D 53 5E 51 03 1A D1 76 80 46 B8 34 F6 08 2D A2 5A 17 73 33 DC 18 1A 2C 5A 39 53 B2 D6 52 E2 19 A2 52 00 B2 7C 11 E5 A7 43 03 1A 51 7A 50 A7 D4 04 8E 6B 18 74 7D 31 26 98 83 D7 23 2E 6D 72 C7 0E B3 DD 89 52 94 65 16 81 F6 4A ED 31 C5 61 3F 46 B6 F4 8A 94 5C 4C D8 56 CA 77 5B 92 0A 4C D6 8F 0D 84 44 B6 D4 56 26 E5 BF 80 D3 8B 78 DA 46 63 50 82 44 18 8B 50 96 44 09 34 D2 51 37 CF 92 94 6A CA 37 07 6A D7 00 BB 92 D7 A4 62 15 54 0E 10 FC ED BE 06 98 AC 97 15 60 D5 3A A7 4F 90 B9 93 7B 24 E8 03 8B F0 20 61 64 69 03 72 DC CA BA A3 51 AF 20 3A 41 3E EC 89 DD 90 C3 4C E4 DE 0C 4A D4 6D B0 DD D6 D5 01 58 96 57 BF 02 70 17 BF 05 01 07 97 34 DE C3 F9 FA 78 C3 0D C2 22 53 7A 31 AA 2C C4 B5 B5 9F 3E 2A D6 9D 0F B8 AC 98 B5 2E 1A 38 FA F2 CD 69 B6 D1 D6 C1 3D 18 61 01 EA 48 79 B6 A9 41 AA 33 38 B7 B2 18 BF 26 7B 91 4C C6 D6 B1 23 8D C6 22 73 EA A3 09 34 B7 61 FA 9C ED C3 44 0E 5C 23 A6 DB 46 E4 D6 6D B0 67 D4 E4 93 FE 21 F1 F5 38 E5 B3 54 C5 5F 53 36 AA A2 65 AD 51 4D 72 6A F9 8C CA E8 4D 24 DB 45 25 68 1C BA 6C CA 09 A6 0E 12 9C 5D 48 CB 4E 96 94 56 88 97 A9 13 52 32 A5 F2 AB D9 18 57 1D 86 52 5B B6 2D 91 A9 3E 4A 0B 0C B3 5E 42 D6 39 FF 00 2C 11 15 8A 7A 92 1B 8C B7 5E 59 29 8D 68 BF D5 46 3E 12 10 73 8F 71 AD 47 5A 3F 27 37 AB E9 E1 1F CB 01 0D 62 79 12 5B CC 98 57 71 8B E1 C5 DF 92 4D 9D 8C 38 31 61 5F 69 AB 38 6E 52 D3 C4 D4 D4 90 69 C3 0E 48 FD F0 09 92 5A 39 4E 80 AC 8B C7 06 3A BF 4B 7D 27 4B EE 61 A0 B0 62 A7 1C 66 72 71 A8 0B 6D EE 6F B5 30 79 75 36 2F 26 A4 B7 2A DB 75 46 96 36 B6 03 5A 24 4D 12 F6 34 53 E0 9A 61 59 CA 55 B3 07 0C 6D BB 61 92 B4 EC D2 D8 2A A1 8D 26 34 B4 C7 60 29 A2 F5 7C 90 30 E7 4B 81 1C F9 B6 68 C6 5C AD 6C 85 9E 39 4B 79 1A 91 04 E9 B2 51 D3 8E 4B F1 67 1B B7 28 F0 12 19 DA 74 CD 59 A8 EB 6B 8F 87 40 67 04 FF 00 AF FC 06 B2 36 4B 66 1A 54 A2 E9 AB 14 B7 17 BA 63 8D 58 09 5D D3 42 01 AC CB D0 7C 6F DB 16 9E 3F 46 61 91 C5 9A 47 4F 51 7A 91 44 D8 C3 58 06 4D 9E A4 C1 77 02 E4 DC 5B B3 E9 96 58 65 30 A5 65 49 FC 80 ED 4D 71 23 32 86 5F 65 E2 77 F0 C2 A6 C2 3A 13 83 C9 17 BA 36 F2 BB E1 8C 07 69 0B CE 09 98 96 67 E9 99 EE 4B D3 35 89 AD A9 4E 21 63 95 BF 1B 80 52 6F F5 61 62 FF 00 AB 00 FA AC A7 2F 0C CD FC 03 7A BD 11 56 EF C0 27 BF 3C 9A 4D F9 4C A9 4B C5 15 1D 32 99 08 72 74 09 99 A3 6C C8 54 A2 9A 34 5D 00 3A 29 A3 74 53 03 14 BD 15 48 D9 28 0C D2 2D 23 5A 4B A0 2A 8A 68 D1 90 2A 8A A3 44 03 FF D9"";
    }
"
58920-0.sol,question,"contract DeployedContract {

struct emailNetworkLists {
     bytes32[] emailArray;
}

struct Namecards{
    address ethAddress;
    bytes32 personName;
    bytes32 designation;
    bytes32 companyName;
    bytes32 comaddress;
    bytes32 emailId;
    bytes32 mobNumber;
    bytes32 date;
    bool isActive;
    uint index;
    mapping(bytes32=> emailNetworkLists) contactList;
}

bytes32[] public addressList;
mapping(bytes32 => Namecards) public nameStructMapping;

function getEmails(bytes32 email, bytes32 date) public view returns(bytes32[]){
    return (nameStructMapping[email].contactList[date].emailArray);
}

}"
58920-0.sol,question,"contract External {
    DeployedContract d = DeployedContract(0xe90f4f8ae................);
    function getEmailList(bytes32 email, bytes32 date) public view returns(bytes32[] ){ 
       return (d.getEmails(email, date));
    }
}"
66023-0.sol,question,"contract MultiSignatureWallet {



  uint constant public MAX_OWNER_COUNT = 2; 

  event Confirmation(address indexed sender, uint indexed transactionId);
  event Revocation(address indexed sender, uint indexed transactionId);
  event Submission(uint indexed transactionId);
  event Execution(uint indexed transactionId);
  event ExecutionFailure(uint indexed transactionId);
  event Deposit(address indexed owner);
  event RequirementChange(uint required);

   mapping (uint => Transaction) public transactions;
   mapping (uint => mapping(address => bool)) public confirmations;
   mapping (address => bool) public isOwner;
   address[] public owners;
   uint public required;
   uint public transactionCount;

      struct Transaction {
        address destination;
        uint value;
        bytes data;
        bool executed;
      }



  modifier onlyWallet() {
      if (msg.sender !=address(this))
          revert();
      _;
  }

  modifier ownerDoesNotExist(address owner) {
      if (isOwner[owner])
      revert();
      _;
  }

  modifier confirmed(uint transactionId, address owner) {
      if (!confirmations[transactionId] [owner])
      revert();
      _;
  }

  modifier notConfirmed(uint transactionId, address owner) {
      if (confirmations[transactionId][owner])
      revert();
      _;
  }

  modifier notExecuted(uint transactionId) {
      if (transactions[transactionId].executed)
      revert();
      _;
  }

  modifier notNull(address _address) {
      if (_address == address(0))
          revert();
      _;
  }

  modifier  validRequirement( uint ownerCount, uint _required) {
      if (  _required > ownerCount
          ||  _required == 0
          ||  ownerCount   == 0)
          revert();
          _;
        }






    
    
    
    
    function MultiSigWallet(address[] memory _owners, uint _required)
          public
          validRequirement(_owners.length, _required)
      {
          for (uint i=0; i<_owners.length; i++) {
            if (isOwner[_owners[i]] || _owners[i] == address (0))
              revert();
            isOwner[_owners[i]] = true;
          }
          owners = _owners;
          required = _required;
      }

    
    
    
    
    
    function submitTransaction(address destination, uint value, bytes
    memory data)
    public
    returns (uint transactionId)
  {
    require(isOwner[msg.sender]);
    transactionId = addTransaction(destination, value, data);
    confirmTransaction(transactionId);
  }

    
    
    function confirmTransaction(uint transactionId)
    public
  {
     require(isOwner[msg.sender]);
     require(transactions[transactionId].destination != address (0));
     require(confirmations[transactionId][msg.sender] == false);
     confirmations[transactionId][msg.sender] = true;
     executeTransaction(transactionId);
  }

    
    
    function revokeConfirmation(uint transactionId)
    public
 {
    require(transactions[transactionId].executed == false);
 }

    
    
    function executeTransaction(uint transactionId)
    public
{
    require(transactions[transactionId].executed == false);
    if (isConfirmed(transactionId)) {
      Transaction storage t  = transactions[transactionId];
      t.executed = true;
      (bool success, bytes memory data) =
      t.destination.call.value(t.value)(t.data);
      if (success)
          emit Execution(transactionId);
      else {
          emit ExecutionFailure(transactionId);
          t.executed = false;
      }
}
}
        
    
    
    
    function isConfirmed(uint transactionId) 
    public
    view
    returns (bool)
  {
    uint count = 0;
     for(uint i=0; i<owners.length; i++) {
        if (confirmations[transactionId][owners[i]])
            count += 1;
        if (count == required)
            return true;
  }
}
    
    
    
    
    
    function addTransaction(address destination, uint value, bytes memory data)
    internal
    returns (uint transactionId)
  {
    transactionId = transactionCount;
    transactions[transactionId] = Transaction({
      destination: destination,
      value: value,
      data: data,
      executed: false
    });
    transactionCount +=1;
    emit Submission(transactionId);
  }
}"
15060-0.sol,question,"contract StorageMapping {

    struct S {
        mapping(bytes32 => uint) m;
        bytes32[] b;
        uint x;
    }

    mapping(bytes32 => S) public sStructs;

}"
53273-0.sol,question,"contract Purchase {

 address public buyer;
 address public seller;
 address public companyEscrow;
 uint private moneyInEscrow = 0;

 modifier onlyCompanyEscrow {
    require(
        msg.sender == companyEscrow,
        ""Only the escrow account of the company can call this function.""
    );
    _;
 }

 modifier onlyBuyer {
    require(
        msg.sender == buyer,
        ""Only the buyer can call this function.""
    );
    _;
 }

 constructor (address addressSeller, address addressCompanyEscrow) public payable {
    buyer = msg.sender;
    seller = addressSeller;
    companyEscrow = addressCompanyEscrow;
 }

 function sendFundsToCompany ()
      public
      payable
      onlyBuyer
      returns (bool completed)
  {
      moneyInEscrow = msg.value;
      companyEscrow.transfer(moneyInEscrow);
      return true;
  }


  function sendFundsToSeller ()
      public
      payable
      onlyCompanyEscrow
      returns (bool completed)
  {
      seller.transfer(moneyInEscrow);
      moneyInEscrow = 0;
      return true;
  }
}"
12667-0.sol,question,"contract Contract {
    function hashIt(string a, uint b) returns(bytes32){
        return sha3(a, b);
    }
}"
7990-0.sol,question,"contract X{
uint a=12+1 ether;

function checkConstant(uint conversionRate) constant returns(uint integer, uint decimal){

    integer= a / conversionRate;
    decimal= a % conversionRate;
}

}"
66351-0.sol,question,"contract ERC20Interface {
function balanceOf(address whom) view public returns (uint);
}"
10640-0.sol,question,"contract ItemListContract {
    struct  item 
    {
      bytes iname;
      uint16 itemid;
      bytes icode;
      uint ivalue;
    }
    uint itemcount;
    mapping(bytes => item) itemlist;
    item[] itemarray;
    function ItemListContract()
    {
       log0('hi');
    }
    function AddItem(bytes name, uint16 iid, bytes code, uint val)
    {        
       var itemnew = item(name, iid ,code, val);
       log0(itemnew);
       itemlist[code] = itemnew;
       itemarray.push(itemnew);
       itemcount++;
    }
    function countitemlist() returns (uint count)
    {     
      return itemcount;
    }

    function removeitem(bytes code)
    {
    delete itemlist[code];
    itemcount--;
    }
    function getitem(bytes code) returns (bytes iname, uint val)
    {   
      return (itemlist[code].iname,itemlist[code].ivalue);
    }
}"
8201-0.sol,question,"contract AbstractB {
    function getX() returns(uint);
}"
8201-0.sol,question,"contract A {
    function makeCall(address addressB){
         AbstractB(addressB).getX();
    }
}"
72113-1.sol,question,"contract Caller is Callee{

    
    
    
    
    function someAction() public returns(uint){
      return getValue();
    }
    function inc() public returns(uint){
      return increment();
    }

}"
72405-1.sol,question,"contract UserContract {
    StorageContract storages;
    constructor (address _storageAddress) public {
        storages = StorageContract(_storageAddress);
    }

    function userSetNewUser(address _userId, string memory _userName) public returns(address){
        require(msg.sender != address(0));
        address userId = storages.setNewUser(_userId, _userName);
        return userId;
    }
}"
42574-0.sol,question,"contract TestContract{

    uint testUint;

    function testFunc() public view returns(uint[]){
        uint[] memory testArr = new uint[](1);
        testArr[0]++;   
        testUint++;     
        return testArr;
    }    
}"
79690-0.sol,question,"contract customer{
  address payable[]  public onboarded;
  bytes public fullname;
  bytes public id;
  bool public KYC;
  uint256 public categor;
  function prime(bytes memory fname, bytes memory iden, bool KYCresult, uint256 level, address payable bank) public{
    fullname=fname;
    id=iden;
    KYC=KYCresult;
    categor=level;
    onboarded.push(bank);
  }
  function() external payable{}
  }"
66539-0.sol,question,"contract CampaignFactory{    token public token_instance;
    constructor() public payable{
         token_instance = token(token_address);}

    function createCampaign() public payable{
        address newCampaign = address((new Campaign).value(msg.value)(deposit, ll, token_address, 1, your));
}


contract Campaign{
    token public tokenReward;

    constructor (uint depositInWei, address ll, address addressOfTokenUsed, uint weiCostOfEachToken, address your) public payable{
        tokenReward.transferFrom(0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c, your, msg.value/price);
}
"
66539-0.sol,question,"contract Campaign{
    token public tokenReward;

    constructor (uint depositInWei, address ll, address addressOfTokenUsed, uint weiCostOfEachToken, address your) public payable{
        tokenReward.transferFrom(0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c, your, msg.value/price);
}
"
7980-0.sol,question,"contract A {
    function logUint(uint a);
    function logString(string a);
}"
7980-0.sol,question,"contract B {
    A logger;
    function registerLogger(address loggerAddress){
        logger = A(loggerAddress);
    }       
    function logUint(uint a){
        
        logger.logUint(a);
    }
    function logString(string a){
        
        logger.logString(a);
    }   
}"
19661-0.sol,question,"contract Zusatzaufgabe {

    struct Student {
        string name;
        string vorname;
        uint matnr;
        uint punkte;
        bool[] solved;
    }

    address[] public addressen;

    mapping(address => Student) public studenten;

    modifier hurdle(uint _n) {
        require(_n == msg.value/2);
        _;
    }

    modifier onlyTillTest() {
        require(block.timestamp < 1499702400);
        _;
    }

    function Zusatzaufgabe(){

    }

    function register(string _name, string _vorname, uint _matnr) onlyTillTest(){
        studenten[msg.sender] = Student(_name,_vorname,_matnr,1,new bool[](3));
        addressen.push(msg.sender);
    }

    function onepoint() payable hurdle(10000) onlyTillTest(){
        if(studenten[msg.sender].solved[0] == false){
            studenten[msg.sender].solved[0] = true;
            studenten[msg.sender].punkte += 1;
        }
    }

    function twopoints(uint _value) onlyTillTest(){
        if(studenten[msg.sender].solved[1] == false
        && _value == studenten[addressen[0]].matnr
        ){
            studenten[msg.sender].solved[1] = true;
            studenten[msg.sender].punkte += 2;
        }
    }

    function sixpoints(bytes32 _h, uint8 _v, bytes32 _r, bytes32 _s) onlyTillTest(){
        if(
            studenten[msg.sender].solved[2] == false
            && ecrecover(_h, _v, _r, _s) == msg.sender
            && _h == sha3(this)
        ){
            studenten[msg.sender].solved[2] = true;
            studenten[msg.sender].punkte += 6;
        }
    }
}"
80830-0.sol,question,"contract SoloMargin {
        struct OperatorArg {
            address operator;
            bool trusted;
        }

        function operate(Account.Info[] memory accounts, Actions.ActionArgs[] memory actions) public;
        function getAccountWei(Account.Info memory account, uint256 marketId) public view returns (Types.Wei memory);
        function setOperators(OperatorArg[] memory args) public;

        function getMarketTokenAddress(
            uint256 marketId
        )
            public
            view
            returns (address);

        function getIsLocalOperator(
            address owner,
            address operator
        )
            public
            view
            returns (bool);
    }"
80830-0.sol,question,"contract SoloTest
    {
        address sm; 

        Account.Info[] accounts;
        Actions.ActionArgs[] actions;

        constructor(address soloMargin) public {
            sm = soloMargin;
        }

        function operate(Account.Info memory account, uint amount, uint market, bool isDeposit) public
        {
            bytes memory data;

            Actions.ActionArgs memory action = Actions.ActionArgs({
                actionType: isDeposit ? Actions.ActionType.Deposit : Actions.ActionType.Withdraw,
                amount: Types.AssetAmount({
                    sign: isDeposit,
                    denomination: Types.AssetDenomination.Wei,
                    ref: Types.AssetReference.Delta,
                    value: amount
                }),
                primaryMarketId: market,
                otherAddress: msg.sender,
                accountId: 0,
                secondaryMarketId: 0,
                otherAccountId: 0,
                data: data
            });

            if (accounts.length > 0) {
                accounts[0] = account;
                actions[0] = action;
            } else {
                accounts.push(account);
                actions.push(action);
            }

            SoloMargin(sm).operate(accounts, actions);
        }
    }"
13702-0.sol,question,"contract SimpleContractTest {
    event ReturnValue(address _from, uint256 _value);
    function SimpleContractTest()
    payable
    {

    }
    function myBalanceConstant() constant returns (uint256 amount)
    {
      return msg.sender.balance;
    }
    function contractBalanceConstant() constant returns (uint256 amount)
    {
      return this.balance;
    }
    function myBalancePublic() public returns (uint256 amount)
    {
      ReturnValue(msg.sender, msg.sender.balance);
      return msg.sender.balance;
    }
    function contractBalancePublic() public returns (uint256 amount)
    {
      ReturnValue(msg.sender, msg.sender.balance);
      return this.balance;
    }
}"
62529-1.sol,question,"contract DappTokenCrowdsale is Crowdsale {

  constructor(
    uint256 _rate,
    address _wallet,
    ERC20 _token
  )
    Crowdsale(_rate, _wallet, _token)
    public
  {
  }
}"
11708-0.sol,question,"contract Genobject{
uint public item;
function Genobject(uint _val){
    item=_val;}
}"
11708-0.sol,question,"contract Caller{
   Genobject public instance;
   function Caller(){
       instance= new Genobject(3);
   }
   function Recall() returns (uint){
      return Genobject.item; }
}"
44145-0.sol,question,"contract A{
    uint8 mem1;
    uint8 mem2;

    function store(uint8 store1, uint8 store2){
        mem1=store1;
        mem2=store2;
    }
}"
13874-1.sol,question,"contract delegateCall{
uint public testInt;
address public sender;

function delegateCall(){
    testInt = 1;
}

function delegateCallC(address _c, uint _testInt){
if(_c.delegatecall(bytes4(sha3(""setTestInt(uint"")),_testInt ))
throw;
}  
}"
68914-0.sol,question,"contract Tester {

    function loo() public pure returns(string memory){
        uint i = 1;
        uint c = 0;
        while(i == 1){
            c = c + 1;
        }
        return ""good"";
    }
}"
10357-0.sol,question,"contract Process{
address public owner;
uint balance;
uint amount;

function Process(){
    owner = msg.sender;
    balance = 1000;
}

 event DepositMade(string msg);
 event WithdrawalMade(string msg);

 function deposit(uint amot){
    balance = balance + amot;
    DepositMade(""Deposit is done"");
}

function getBalance()constant returns (uint){
    return balance;   
}

function withdraw(uint amot)returns (bool){
    if(amot > balance){
        return false;
    }
    else{
        balance = balance - amot;
        WithdrawalMade(""Withdrawal is done"");
        return true;
    }
}"
33070-0.sol,question,"contract Test
{

    function sendEther(address toAddr) public payable
    {
        toAddr.transfer(msg.value);
    }
}"
44664-2.sol,question,"contract EquityInvestments 
{
    AppleToken appleToken;
    Group [] _Groups;
    uint PriceEth = 1;
    address tokenAddress = 0x580156edb25D3c3deD584F1075CcCC5dA4861883;
    mapping (address => mapping(uint=>UserInvestment)) private _UserInvestments;

    function EquityInvestments () public
    {
        _Groups.push(Group({
            GroupID: 1,
            GroupName: ""Google"",
            TotalInvestment: 0,
            GroupPriceDollars: 200,
            GroupPriceEth: 1
        }));
         _Groups.push(Group({
            GroupID: 2,
            GroupName: ""Tesla"",
             TotalInvestment: 0,
             GroupPriceDollars: 200,
             GroupPriceEth: 1
        }));
         _Groups.push(Group({
            GroupID: 3,
            GroupName: ""Apple"",
             TotalInvestment: 0,
             GroupPriceDollars: 200,
             GroupPriceEth: 1
        }));
    }

    struct Group
    {
     uint GroupID;
     string GroupName;
     uint TotalInvestment;
     uint GroupPriceDollars;
     uint GroupPriceEth;
    }

    function sendTokens () public payable returns (uint)
    {
        appleToken = AppleToken(tokenAddress);
        
        
        require(appleToken.transfer(msg.sender, 10));
        return appleToken.balanceOf(msg.sender);
    }



}"
57309-0.sol,question,"contract PayCheck {

    address[] employees = [0xE83fad0b5EdF2999c29a00199Ca9B773A4627239, 0x118531D9C6C9114c8B999Ac1197778d1669Fc6c6];

    mapping (address => uint) withdrawnAmounts;

    constructor() payable public{
    }

    function () payable public{
    }

    modifier canWithdraw() {
        bool contains = false;

        for(uint i = 0; i < employees.length; i++) {
            if(employees[i] == msg.sender) {
                contains = true;
            }
        }
        require(contains);
        _;
    }

    function withdraw() canWithdraw public{
        uint amountAllocated = address(this).balance/employees.length;
        uint amountWithdrawn = withdrawnAmounts[msg.sender];
        uint amount = amountAllocated - amountWithdrawn;
        withdrawnAmounts[msg.sender] = amountWithdrawn + amount;
        if (amount > 0) {
            msg.sender.transfer(amount);
        }

    }

}"
6646-0.sol,question,"contract Test{
    address public creator;

    function Test(){
        creator = msg.sender;
    }

    function get1() returns (address){
        return creator;
    }
}"
12389-1.sol,question,"contract usingProperty{
    struct Property{
        bytes32 name;
        uint id;
        mapping (address => bool) accessStakeholders;
        uint[] rating;
    }

    Property[] public propertyList;

    function addProperty(bytes32 _name, address[] _accessStakeholders, uint _rating) returns(bool success, uint _id){

        _id = propertyList.length++;

        Property prop = propertyList[_id];
        for (uint i = 0 ; i < _accessStakeholders.length ; i++){
          prop.accessStakeholders[_accessStakeholders[i]] = true;
        }

        prop.name = _name;
        prop.id= _id;
        prop.rating.push(_rating);
    }


    function removeProperty(uint _id){
        if (propertyList[_id].length == 0) throw;
    }

}"
33634-0.sol,question,"contract MyContact {

    mapping(address => uint) private balances;

    modifier positiveNumber(uint number) {
        require(number > 0);
        _;
    }

    function deposit(uint amount)
      external
      positiveNumber(amount)
    {
      balances[msg.sender] += amount;
    }

    function hasFunds(address depositor, uint amount)
        external
        view
        positiveNumber(amount)
        returns (bool)
    {
        return balances[depositor] >= amount;
    }
}"
8717-0.sol,question,"contract Demo {

    uint _x = 0;

    function setX(uint x){
        _x = x;
    }

    function getX() constant returns (uint x){
        return _x;
    }
}"
54759-0.sol,question,"contract test{
    function multiply(uint a) constant returns(uint d){
        return a*7;
    }
}"
73737-0.sol,question,"contract TusharCoin {

  uint256 public totalSupply;  
  string public name;  
  string public symbol;  
  uint32 public decimals; 

    constructor () public {
  symbol  = ""TUSHAR"";  
  name = ""TusharCoin"";  
  decimals = 5;  
  totalSupply = 100000000000;
    }

    constructor() public { 
  owner = msg.sender;  
  balances[msg.sender] = totalSupply;
    }
    emit Transfer(0x0, msg.sender, totalSupply);  
 }"
67663-0.sol,question,"contract ManagedWalletLookup { 
    address private _owner;

    mapping(address => address) public _managedWallets;

    constructor () internal {
        _owner = msg.sender;
    }

    modifier isOwner() {
        require(msg.sender == _owner);
        _;
    }

    function updateManagedWallets(address wallet, address owner) public 
        isOwner {
        _managedWallets[owner] = wallet;
    }

}"
80759-3.sol,question,"contract ERC735 {


    event ClaimAdded(
        bytes32 indexed claimId,
        uint256 indexed claimType,
        uint256 scheme,
        address indexed issuer,
        bytes signature,
        bytes data,
        string uri
    );
    event ClaimRemoved(
        bytes32 indexed claimId,
        uint256 indexed claimType,
        uint256 scheme,
        address indexed issuer,
        bytes signature,
        bytes data,
        string uri
    );


    struct Claim {
        uint256 claimType;
        uint256 scheme;
        address issuer; 
        bytes signature; 
        bytes data;
        string uri;
    }

    function getClaim(bytes32 _claimId)
        public
        view
        returns (
            uint256 claimType,
            uint256 scheme,
            address issuer,
            bytes memory,
            bytes memory,
            string memory
        );
    function getClaimIdsByType(uint256 _claimType)
        public
        view
        returns (bytes32[] memory); 
    function addClaim(
        uint256 _claimType,
        uint256 _scheme,
        address issuer,
        bytes memory, 
        bytes memory, 
        string memory 
    ) public returns (bytes32 claimRequestId);
    function removeClaim(bytes32 _claimId) public returns (bool success); 
}"
76156-1.sol,question,"contract greeter {
     address owner;
     string greeting;

constructor (string memory _greeting) public {
        greeting = _greeting;
        owner = msg.sender;
    }

    function greet() public view returns(string memory) 
    {
        return greeting;
    }
}"
68774-0.sol,question,"contract ERC20 {
  function totalSupply() public view returns (uint256);

  function balanceOf(address _who) public view returns (uint256);

  function allowance(address _owner, address _spender)
    public view returns (uint256);

  function transfer(address _to, uint256 _value) public returns (bool);

  function approve(address _spender, uint256 _value)
    public returns (bool);

  function transferFrom(address _from, address _to, uint256 _value)
    public returns (bool);

  function decimals() public view returns (uint256);

  event Transfer(
    address indexed from,
    address indexed to,
    uint256 value
  );

  event Approval(
    address indexed owner,
    address indexed spender,
    uint256 value
  );
}"
6113-0.sol,question,"contract ContractFactory {
  contractAddress = new Contract();
  Contract(contractAddress).someFunction();
}"
69351-0.sol,question,"contract Ballot {
  uint256 icotokenPrice;
  mapping(string => uint256) tokensPrice;

  function assignICOPrice(uint256 _tokenPrice) public returns(bool){
    icotokenPrice = _tokenPrice;
    return true;
  }

  function createTokenPrice(string symbol_, uint256 price_) public returns(bool){
    tokensPrice[symbol_] = icotokenPrice / price_;
    return true;
  }

  function returnPrice(string symbol_) public view returns(uint256){
    return(tokensPrice[symbol_]);
  }
}"
47308-0.sol,question,"contract sample{
    function returnsData() returns(string){

        require(msg.sender==<some specific address>)    
        return ""SSJK"";
    }
}"
13414-0.sol,question,"contract Foo{

    function createBar(){

      Bar bar = new Bar();
    }
}"
64720-0.sol,question,"contract sendEther{

address payable rec= address(0xD694fab8b63BeF0149aa47b8333dFeAe7f55E9C7);
address public sender = msg.sender;


function send() public payable{

    rec.transfer(msg.value);

}

}"
37739-0.sol,question,"contract test {
    enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }
    ActionChoices choice;
    ..."
23501-1.sol,question,"contract Crowdsale is StandardToken {

contract Crowdsale is MintableToken {

contract Crowdsale is BasicToken {"
23501-1.sol,question,"contract Crowdsale is MintableToken {

contract Crowdsale is BasicToken {"
23501-1.sol,question,contract Crowdsale is BasicToken {
37485-0.sol,question,"contract TestSize{
    event Test1(uint param1, string param2); function test1(uint param1, string param2){ Test1(param1, param2);}
    event Test2(uint param1, string param2); function test2(uint param1, string param2){ Test2(param1, param2);}
    event Test3(uint param1, string param2); function test3(uint param1, string param2){ Test3(param1, param2);}
    ...
    event Test87(uint param1, string param2); function test87(uint param1, string param2){ Test87(param1, param2);}
}"
42091-2.sol,question,"contract storagetest8 {

    mapping(uint256 => uint256) inventories;

    function setCharacter(address other_address, uint256 index1) 
        external 
    {
        uint256 _id = uint256(msg.sender);
        _id |= uint96(other_address)<<160;
        inventories[index1] = _id;        
    }


    function getCharacter(uint256 index1) 
        external view
    returns(address owner_address, uint256 secondpart) {
        uint256 _id = inventories[index1];
        owner_address = address(_id);
        secondpart = uint256(uint96(_id>>160));
    }

}"
66536-0.sol,question,"contract ApprovedPOCreateAndOwnershipTransferContract {

    struct PO{
        bytes32 bill_to_location;
        bytes32 ship_to_location;
        bool exists;
    }

    

    mapping(uint256 => PO) poMap;  


    event PODebugParameters(
        uint256 po_num,
        
        uint256 business_unit_id,
        bytes32 ipfs_hash,
        bytes32 bill_to_location,
        bytes32 ship_to_location,
        uint256 po_status_code,
        uint256 bill_to_location_code,
        uint256 ship_to_location_code,
        address maintain_org_add_map_contract_add_sender,
        address maintain_org_add_map_contract_add_receiver,
        address msg_receiver,
        uint256 supplier_id,
        uint256  status
    );

    
    function saveApprovedPONotSigned(uint256 po_num,                                 
                                    uint256 business_unit_id,
                                    bytes32 ipfs_hash,
                                    bytes32 bill_to_location,
                                    bytes32 ship_to_location,
                                    uint256 po_status_code,
                                    uint256 bill_to_location_code,
                                    uint256 ship_to_location_code,
                                    address maintain_org_add_map_contract_add_sender,
                                    address maintain_org_add_map_contract_add_receiver,
                                    address msg_receiver,
                                    uint256 supplier_id,
                                    uint256  status) external {        


        
        require(po_status_code == 1, ""PO is not approved in ERP"");


        
        require(bill_to_location_code == 1 && ship_to_location_code == 2, ""PO raised with incorrect billing or shipping locations"");

        poMap[po_num].exists = true;
        poMap[po_num].bill_to_location = bill_to_location;
        poMap[po_num].ship_to_location = ship_to_location;

        emit PODebugParameters(po_num,business_unit_id,ipfs_hash,bill_to_location,ship_to_location,po_status_code,bill_to_location_code,ship_to_location_code,maintain_org_add_map_contract_add_sender,maintain_org_add_map_contract_add_receiver,msg_receiver,supplier_id,status);

    }  


     
    function verifyForExistingPO(uint256 po_num,bytes32 bill_to_location,bytes32 ship_to_location) constant external returns (bool){
        if (poMap[po_num].bill_to_location == bill_to_location && poMap[po_num].ship_to_location == ship_to_location){
            return true;
        }else{
            return false;
        }
    }


}"
70399-0.sol,question,"contract GameTokenERC20 is ERC20{

  function transferERC20(uint _value) public{
    approve(address(this), _value);
   
   emit Approval(msg.sender, address(this), _value);
   transferFrom(msg.sender,address(this), _value);
  }


}"
13414-1.sol,question,"contract Bar{

}"
11995-0.sol,question,"contract demo {string public name = ""Petros""; function changeName(string _newName){name = _newName; } }"
72641-0.sol,question,"contract test {
  if(player1Points > Player2Points || player1Points >= 50){
      result = 1;
  }
}"
44734-0.sol,question,"contract students{

    struct students{
        string fname;
        string lname;
        string course;      
    }

    mapping (address => students) studentsMappig;

    address[] public studentsArray;

    function setStudents(address _address, string _fname, string _lname,string _course) public{

        var student = studentsMappig[_address];

        student.fname = _fname;
        student.lname = _lname;
        student.course = _course;
        studentsArray.push(_address) -1;

    }

}"
68740-0.sol,question,"contract Lottery{
    address public manager;
    address[] public players;

    function Lottery () public
    {
        manager = msg.sender;
    }

    function enter() public payable
    {
        require(msg.value>.01 ether);
        players.push(msg.sender);
    }

    function random () public view returns(uint)
    {
        return uint (keccak256(block.difficulty,now,players));
    }

    function pickWinner() public restricted 
    {
        uint index = random() % players.length;
        players[index].transfer(this.balance);
        players = new address[](0);
    }

    modifier restricted()
    {
        require(msg.sender==manager);
        _;
    }

    function getPlayers() public view returns (address[])
    {
        return players;
    }
}"
12006-0.sol,question,"contract Contract {
    bytes32 password;
    uint public someVar;

    function Contract(string secret){
        password = sha3(secret);
    }

    function changeSomeVar(string secret, uint someValue) passwordProtected(secret){
        someVar = someValue;
    }

    modifier passwordProtected(string secret){
        if(sha3(secret) != password) {
            throw;
        }
        _;
    }
}"
62730-0.sol,question,"contract Test{

    uint[2] public u2=[1,2];
    uint[3] public u3;


    function test() public{
        u3=u2;
        test2(u2); 
    }

    function test2(uint[3] arr) internal{ }
}"
19199-0.sol,question,"contract EmployeeDir{
    uint public id;
    string public name;
    address public currentVersion;
    address public owner;

    struct employee{
        string name;
        uint days_present;
    }

    mapping (uint => employee) public dir;

    
    function EmployeeDir(string _name, address _versionAddr){
        dir[id].name = _name;
        currentVersion = _versionAddr;
        owner = msg.sender;
    }

    function updateVersionAddress(address _versionAddr){
        if(msg.sender == owner)
            currentVersion = _versionAddr;
    }

    function addEmployee(string _name){
        if(msg.sender == owner){
            
            
            
            currentVersion.delegatecall(bytes4(sha3(""addEmployee(string)"")), _name);

            dir[id].name = name;
        }
    }
}"
19199-0.sol,question,"contract Code{
    uint public id;
    string public name;

    function addEmployee(string _name){
        id += 1;
        name = _name;
    }
}"
9257-0.sol,question,"contract MoneyFountain{

    address owner;
    uint256 sendAmount;

    function MoneyFountain(){
        owner = msg.sender;
        sendAmount = 100000000000000000;
    }

    function getBalance() returns (uint){
        return address(this).balance;
    }

    function sendWei(address recp) returns (bool){        
        recp.send(sendAmount);
    }
}"
51810-0.sol,question,"contract Example{

struct Institution {
    bytes32 name;
    bool exists;
}

event AddedInstitution(bytes32 name);

mapping(bytes32 => Institution) institutions;


function addInstitution(
    bytes32 name,
    bytes32 upi
) public {
    require(!isInstitutionExists(upi));
    institutions[upi].name = name;
    institutions[upi].exists = true;
    emit AddedInstitution(name);

}

function getInstitution(bytes32 upi) public constant returns (bytes32 name){
    require(isInstitutionExists(upi));
    return (
    institutions[upi].name
    );

}

function isInstitutionExists(bytes32 upi) private constant returns (bool){
    if (institutions[upi].exists) {
        return true;
    }
    return false;
}"
59244-0.sol,question,"contract Conditional {
struct Condition {
    address to;
    bytes4 selector;
    bytes parameters;
    bytes32 expectedValueHash;
    bool onlyCheckForSuccess;
  }

 function isSatisfied(Condition memory condition)
    public
    view
    returns (bool)
  {
    if (condition.onlyCheckForSuccess) {
      return assertNotFails(condition);
    } else {
      return assertReturnsExpectedResult(condition);
    }
  }"
71535-0.sol,question,"contract Token is ERC20 {

        string public name = ""test"";
        string public symbol = ""TST"";
        uint8 public decimals = 18;
        uint256 public initSup = 1000;

        constructor() public {
            _totalSupply = initSup;
            balances[msg.sender] = initSup;
        }


    }"
61350-1.sol,question,"contract MyContract {
  ...
  function mine(address who) public payable{
    s.mine(who);
  }
  ...
}"
62966-0.sol,question,"contract toss3D{
  uint tossvalue = 0;
  uint targetBlock = 0;
  bool isgameStarted = false;
  struct winningToss{
    uint256 blocksAwayFromWin;
    address winnerAddress;
  }

  function tossCoin() public payable{
    if msg.value(uint) >= 2.5 finney{

    }
}"
56708-0.sol,question,"contract DonationContract
{
    address owner;

    struct Applicant
    {
        address Appl;
        string Name;
        string OrgType;
        string Number;
        string Email;
        uint256 Funds; 
        bool approved;
    }

    mapping (address => Applicant) applicants;

    modifier Owner() 
    {
        require(msg.sender == owner);
        _;
    }

     modifier Approved() 
    {
        require(applicants[msg.sender].approved == true);
        _;
    }

    function approve(address Org) Owner public
    {
        applicants[Org].approved = true;
    }   
}"
60043-0.sol,question,"contract ApprovalContract {

  function random() external view returns (uint8){
  return uint8(uint256(keccak256(abi.encodePacked(block.timestamp, 
  block.difficulty)))%251);
  } 
 ...
 }"
79619-0.sol,question,"contract Demo{
  string public name;

  function setName(string memory  _name) public{
    name= _name;
  }
  function getName()view public returns (string memory){
    return name;
  }
}"
71786-0.sol,question,"contract Test {
        function test() public view  returns (uint){
             return 10*10;
        }

        function test2() external view  returns (uint){
             return 10*2;
        }
    }"
55890-0.sol,question,"contract ContractA is DetailedERC20 {

    uint8 public constant decimals = 18;

    uint256 public constant INITIAL_SUPPLY = (500 * (10**6)) * (10 ** uint256(decimals));

    constructor(string _name, string _symbol) 
    public 
    DetailedERC20(_name, _symbol, decimals)
    {
        totalSupply_ = INITIAL_SUPPLY;
        balances[this] = INITIAL_SUPPLY;
        emit Transfer(address(0), this, INITIAL_SUPPLY);
    }
}"
7975-0.sol,question,"contract Contract {
  function() {
    
    
    
    
    MyLib.doNothing();
  }
}"
15982-0.sol,question,"contract MyLogContract {
    event genericLog(
        uint256 indexed _index1, uint256 indexed _index2,  uint256 indexed _index3, string _log);

    function writeGenericLog01(
        uint256 _index1, uint256 _index2,  uint256 _index3,
        string _log) 
    returns (bool success) {
        genericLog(_index1, _index2, _index3, _log);
        return true;
    }
}"
24574-0.sol,question,"contract T1{
   address public a;
   function T1(){
   a=msg.sender;
  }
}"
24574-0.sol,question,"contract T2{
   address public b;
   T1 t1=new T1();
   function T2(){
     b= t1.a(); 
   
  }
}"
64766-0.sol,question,"contract Test{
    constructor(uint256 _num) public {
    num = _num
    ;}
}"
62786-0.sol,question,"contract Simple {
    function arithmetics(uint a, uint b){           
                     require(a % 2 == 0, ""Even value required."");             
                    b = b * 3; 
            }
}"
55122-0.sol,question,"contract TestContract
{
function multiply(uint a, uint b) returns (uint)
    {
        return a * b;
    }
}"
33789-0.sol,question,"contract TokenRegistry is Ownable {

mapping (address => TokenMetadata) public tokens;
mapping (string => address) tokenBySymbol;
mapping (string => address) tokenByName;

address[] public tokenAddresses;

struct TokenMetadata {
    address token;
    string name;
    string symbol;
    uint8 decimals;
    bytes ipfsHash;
    bytes swarmHash;
}

function addToken(
    address _token,
    string _name,
    string _symbol,
    uint8 _decimals,
    bytes _ipfsHash,
    bytes _swarmHash)
    public
    onlyOwner
    tokenDoesNotExist(_token)
    addressNotNull(_token)
    symbolDoesNotExist(_symbol)
    nameDoesNotExist(_name)
{
    tokens[_token] = TokenMetadata({
        token: _token,
        name: _name,
        symbol: _symbol,
        decimals: _decimals,
        ipfsHash: _ipfsHash,
        swarmHash: _swarmHash
    });
    tokenAddresses.push(_token);
    tokenBySymbol[_symbol] = _token;
    tokenByName[_name] = _token;

}
"
74073-0.sol,question,"contract Buy {
    address[] public buyers;
    uint256 public minAmount;

    struct Buyer {
    uint256 amountPayed;
    uint256 itemSelected;
    }
    mapping(address => Buyer) public buyerInfo;

    function buy(uint256 itemSelected) public payable returns (uint amount){
    require(itemSelected >= 1 && itemSelected <= 10);
    require(msg.value >= minAmount);

    buyerInfo[msg.sender].amountPayed = msg.value;
    buyerInfo[msg.sender].itemSelected = itemSelected;

    buyers.push(msg.sender);

        return amount;
  }
}"
68479-0.sol,question,"contract PushStruct {

  struct MyStruct {
    uint field1;
    uint field2;
  }

  MyStruct[] public myStructs;

  function pushStruct() 
    public

  {
    MyStruct memory m;
    m.field1 = 1;
    m.field2 = 2;
    myStructs.push(m);

  }
}"
59181-1.sol,question,"contract DriverProfile{
    address watch_adrs=0x8c1eD7e19abAa9f23c476dA86Dc1577F1Ef401f5;

     function doFine(uint offenceID,string location,address officer) public{
         TrafficFine trafficfine = TrafficFine(watch_adrs);
         require(officer==trafficfine.getOfficer(officer));
     }

}"
59181-1.sol,question,"contract TrafficFine{
    function addOfficer(string firstName,string lastName,address officer) public;
    function getOfficer(address officer) public;
}"
83667-4.sol,question,"contracts

  const { register, handleSubmit, watch, errors }"
77099-0.sol,question,"contract {
        address customer;
        uint8 tokentype; 
        uint8 size;  
        bool  gender; 
        bool  active;  
    }"
10615-0.sol,question,"contract Concatenator {
    address[]  Accounts1;
    function ConcatenateArrays(address[] Accounts2){
        uint i = 0;
        while (i++ < Accounts2.length) {
            Accounts1.push(Accounts2[i]);
        }
    } 
}"
11640-2.sol,question,"contract Test {

   address public lastSCAddress; 
   string name;

}"
69930-0.sol,question,"contract StructAccess {

    struct SimpleStruct {
        
        uint c;
        uint[] d; 
        mapping (uint => uint) e; 

    }

    SimpleStruct public singleStruct;

    constructor() public {
        singleStruct.c = 5;
    }
}"
65804-1.sol,question,"contract subm{
  address winner;
  reg public regi;

  mapping (address => uint256) public balance;

  function submissions() public{
    if (winner == address(0)){
        winner = msg.sender;
    }
    else {
        return;
    }
  }
}"
72708-1.sol,question,"contract Hello {
    using SafeMath for uint256;
    uint value;

    constructor() public
    {
        value = value.add(100);
    }    
}"
61659-0.sol,question,"contract A{
    function test() public{
        
    }

    function test(uint256 param) public{
        
    }
}"
29290-0.sol,question,"contract Bar {
    Foo public foo;

   Bar() {
        foo = new Foo();
   }
}"
76565-0.sol,question,"contract A
{
    struct Prop
    {
    }

    struct App
    {
        Prop[] props;
    }

    App[] apps;

    function AddProp(string memory name) public
    {
        App memory a = FindApp(name);

        if(bytes(a.name).length > 0)
            a.props.push(Prop()); 

        else
            revert('Application not found');        
    }

    function FindApp(string memory name) public returns (App memory) 
    {
        for(uint256 i = 0; i < apps.length; i++)
        {
            if(apps[i].name == name)
            {
                return apps[i];
            }
        }

        return App();
    }

}"
71290-1.sol,question,"contract B{    

  function aBid() public payable{


    A a = A(address);    

    a.bid.value(msg.sender);

  }

}"
43946-0.sol,question,"contract Tenants{

  address admin;
  uint256[] public tenatIDs;
  mapping(bytes32 => Tenant) tenantDetails;

  function Tenants() public{

      admin = msg.sender;
  }

  struct Tenant{

      string uniqueID;
      string name;
      uint256 flatNum;
      uint256 phoneNum;
      uint256 advanceAmt;
      uint256 rent;
  }


  function addTenant(**Tenant tenantObj**) public{
          
  }

}"
69132-0.sol,question,"contract Maxsupply {
    string public message;
    function Maxsupply(string newMessage) public{
        message = newMessage;
    }
    function setmessage(string _message) public{
        message = _message;
    }
}"
78265-0.sol,question,"contract thiscontract
{

uint256 balancer = 3000;

function something() public payable
{
if(balancer > 0)
{
balancer -= 1000;
msg.sender.transfer(1000);

}

}
}"
62049-0.sol,question,"contract ERC20 is IERC20 {

}"
62049-0.sol,question,"contract TestCoin is ERC20 {

}"
72408-0.sol,question,"contract Test
{
    uint public m_ReceivedWei;

    function()
        external payable
    {
        m_ReceivedWei += msg.value;
    }

}"
9733-0.sol,question,"contract A {
    function f1()
    {}
}"
2826-1.sol,question,"contract Proxy is mortal {

    address watch_addr  = 0xEB1e2c19bd833b7f33F9bd0325B74802DF187935;
    address user_addr   = msg.sender;

    function register(){
        watch_addr.call(bytes4(sha3(""register()"")))
    }
}"
15056-0.sol,question,"contract MedicalStaffObject {
    using strings for *;
    event LogCreatedTrip(address);

    struct medicalStaffDetails {
       string phoneNumber;
       string physicalAddress;
    }

    medicalStaffDetails public details;
    address[] public trips;
    address public orgAddresses; 

    function MedicalStaffObject (address orgAddress, string phoneNumber, string physicalAddress){
        details.phoneNumber = phoneNumber;
        details.physicalAddress = physicalAddress;
        orgAddresses = orgAddress;
    }

    function getDetails() public constant returns (string, string, address){
        return (details.phoneNumber, details.physicalAddress, orgAddresses);
    }

    function getTrips() public constant returns (address[]){
        return (trips);
    }

    function newTrip(address zone1, address zone2, address zone3, address zone4, bytes32 name, bytes32 startingDate, uint duration) public returns(address){
        TripObject newTrip = new TripObject(zone1, zone2, zone3, zone4, name, startingDate, duration);
        trips.push(newTrip);
        LogCreatedTrip(newTrip);
        return newTrip;
    }
}"
62900-0.sol,question,"contract Travel {

address private owner;

struct TravelStruct 
{
    
    address clientAddress;
    string originAirportName;
    uint32 originTime; 
    uint16 originBagWeight;
    
    uint32 tapeArrivedTime; 
    
    bytes8 flyCode;
    uint32 takeOffTime; 
    
    string destinationAirportName;
    uint32 destinyTime; 
    uint16 destinyBagWeight;
}

mapping(uint => Travel) travels;
uint public travelsRegistryCount;

constructor() public
{
    owner = msg.sender;
    travelsRegistryCount = 1;
}

modifier ownerFunc 
{
    require(owner == msg.sender);
    _;
}


function setOrigin (string _originAirportName, uint32 _originTime, uint16 _originBagWeight) private
{
    travels[travelsRegistryCount] = TravelStruct(owner, _originAirportName, _originTime, _originBagWeight, 0, """", 0, """", 0, 0);
}  
}"
68740-2.sol,question,contract is managed by {this.state.manager}
11152-1.sol,question,"contract abc{
    struct Owner{
        bool exist;
        address owner;
        uint share;
        bool sub;
    } 

    mapping (address => Owner) public Owners;
    uint public no_owners; 
    uint public no_sub;


    function abc(){ 
        
    }

    function transfer(address to,uint amount){
        
    }
}"
11152-1.sol,question,"contract cde{
    mapping (uint => abc) all_cde;
    uint public f;


    function ask_subdivise(abc a){
        
        
        if (a.Owners[msg.sender].sub = false){
            a.Owners[msg.sender].sub=true;
            a.no_sub+=1;

        }
    }
}"
27146-1.sol,question,"contract Crowdsale {
  using SafeMath for uint256;

   MintableToken public token;

  
  uint256 public startTime;
  uint256 public endTime;
...."
67367-7.sol,question,"contract TestAll
{
    mapping(uint => uint) m_DataA;
    mapping(uint => mapping(uint => uint)) m_DataB;

    constructor()
        public
    {
        m_DataA[0] = 111;
        m_DataA[1] = 112;

        m_DataB[0][0] = 211;
        m_DataB[0][1] = 212;
    }

    function getAddress(uint pA)
        external view
        returns(uint)
    {
        return m_DataA[pA];
    }

    function getAddress(
        uint pA,
        uint pB
    )
        external view
        returns(uint)
    {
        return m_DataB[pA][pB];
    }
}"
73969-0.sol,question,"contract SubToken{ 
    MainContract mc;

    constructor(address _address) public{  
       mc=MainContract(_address);

    }  

    function getName1() view public returns(string memory){
        return mc.getNameMain(address(this));
    }



    
    
    
    
    

    event Transfer(address indexed from, address indexed to, uint tokens); 
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens); 

}"
73969-0.sol,question,"contract MainContract {
    

    

    address[] public contracts;

    using SafeMath for uint;

    address contract_address;

    struct token{ 
        string  name; 
        string   symbol; 
        uint8  decimals; 
        uint  totalSupply; 
        uint balances;
    } 
    mapping(address => token) public tokens;

    address mycontraddress;

    function createNewContract(string memory _name,string memory _symbol,uint8 _decimals,uint256 _totalSupply,uint _balance) public returns(address youraddress){ 
        SubToken st = new SubToken(address(this));
        tokens[address(st)] = token(_name,_symbol,_decimals,_totalSupply,_balance);
        mycontraddress=address(st);
        return mycontraddress;
    } 
    function seeContracttAddress() public view returns(address){
        return mycontraddress;
    }

    function getNameMain(address _address) public view returns(string memory){
        return tokens[_address].name;
    }

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

}"
68832-1.sol,question,contract SmartInvoiceFactory {}
57604-1.sol,question,"contract ILoanParams {

    function setParams(uint256 id,uint256 _lenderID,address _borrowerAddress,string loanHughString) public;

    function loanStatus(uint256 _loanId) public returns(string status);

    function setSignatures(uint256 _loanId,string _signatures) public;

    function getBorrowerAddress(uint256 _loanId) public returns(address);

    function getLenderID(uint256 _loanId) view public returns(uint256);

    function setStatus(uint256 _loanId,string _status) public;


    
    function testGetLoanAddress() public view returns(address);

    function testGetStatus(uint256 _loanId) public view returns(string);


}"
5973-0.sol,question,"contract testContract{
  Student[] public students;

  struct Student{
    string name;
    uint256 age;
  }

  function addStudent(string name, uint256 age){
    students[students.length++] = Student({name:name,age:age});
  }
}"
40778-2.sol,question,"contract messageHash {

function hashPersonalMessage() returns (bytes32){
    bytes32 msgHash = sha3('\x19Ethereum Signed Message:\n64', ""\x3a\x44\x3d\x83\x81\xa6\x79\x8a\x70\xc6\xff\x93\x04\xbd\xc8\xcb\x01\x63\xc2\x32\x11\xd1\x16\x28\xfa\xe5\x2e\xf9\xe0\xdc\xa1\x1a\x00\x1c\xf0\x66\xd5\x6a\x81\x56\xfc\x20\x1c\xd5\xdf\x8a\x36\xef\x69\x4e\xec\xd2\x58\x90\x3f\xca\x70\x86\xc1\xfa\xe7\x44\x1e\x1d"");
    return msgHash;
}
}"
34024-0.sol,question,"contract Ballot {
    
    
    
    struct Voter {
        uint weight; 
        bool voted;  
        address delegate; 
        uint vote;   
    }
}"
26028-0.sol,question,"contract Exemple{

       Token public myToken

       function Exemple(){
               myToken=Token(this);
       }
}"
34526-0.sol,question,"contract Main {

function getValue() constant returns (bool){
  return true;
 }
}"
59777-2.sol,question,"contract Driverfactory{

    struct Driver {
        address contractd;
        address account;
    }

    address[] private deployedDriverContracts;

    mapping(address=>Driver) public drivers;

    function createDriver(string lisenceId,string firstName,string lastName,string vehicle,string vehicleType) public{
        require(msg.sender!=drivers[msg.sender].account);
        address newDriver = new DriverProfile(lisenceId,firstName,lastName,vehicle,vehicleType,msg.sender);
        deployedDriverContracts.push(newDriver);
        Driver  memory newDriver1 = Driver({
            contractd:newDriver,
            account:msg.sender
        });
        drivers[msg.sender] = newDriver1;
    }

    function getDeployedDriverContracts() public view returns(address[]){
        return deployedDriverContracts; 
    }

    function checkDriver(address driver) public view returns(bool){
        if(driver==drivers[driver].account){
            return true;
        }

        else{
            return false;
        }

    }

    function driverContract(address driver) public view returns(address){
        address dc_adrs =drivers[driver].contractd;
        return dc_adrs;
    }



}"
59777-2.sol,question,"contract DriverProfile{
    struct Driver{
        string lisenceId;
        string firstName ;
        string lastName; 
        address account;
        string vehicle;
        string vehicleType;
        uint totalOffenceAmount;
        uint offenceCount;
        uint pendingPayments;
        mapping(uint=>Fine)  fines;
    }

    Driver public driver;

    constructor(string lisenceId,string firstName,string lastName,string vehicle,string vehicleType,address owner) public{
        driver = Driver({
            lisenceId:lisenceId,
            lastName:lastName,
            firstName:firstName,
            account:owner,
            vehicle:vehicle,
            vehicleType:vehicleType,
            totalOffenceAmount:0,
            offenceCount:0,
            pendingPayments:0
        });
    }





}"
15246-0.sol,question,"contract Demo
{
     address public test;
     function Demo(address test) payable
     {
        test = test;
     }
}"
59418-0.sol,question,"contract smart{
event TransformToken(
    address _source,
    address _destination,
    uint amount
    );
mapping (address => uint)account;

function showToken(address _address)public view returns(uint){
 uint token=account[_address];
 return (token);

}
function addToken(address _address,uint amount)public{
 account[_address]+=amount;
 }
 function subToken(address _address,uint amount)public{
 account[_address]-=amount;
}

 function transfer(address _address,uint amount)public view returns(uint){
   addToken(_address,amount);
   subToken(msg.sender,amount);
   emit TransformToken(msg.sender,_address,amount);
   return showToken(_address);
   } 
  }"
8216-0.sol,question,"contract Attacker {
    address victimAddress;
    function attack(){
        victimAddress.call.value(1 ether)(bytes4(sha3('bid()')), this);
    }
    function reachStackDepth(uint x){
        if(x == 1023) {
            attack();
        }
        Attacker(this).reachStackDepth(x++);
    }
    function setVictimAddress(address _victimAddress){
        victimAddress = _victimAddress;
    }
}"
5818-0.sol,question,"contract NameReg{
    event AddressRegistered(bytes32 indexed name, address indexed account);
    mapping(address => bytes32) toName;

    function register(bytes32 name){
        toName[msg.sender] = name;
        AddressRegistered(name, msg.sender);
    }

    function resolve(address addr) constant returns(bytes32 name){
        return toName[addr];
    }
}"
84667-3.sol,question,"contract myContract{

uint256[] objects
mapping (uint256 => uint4) objectStage
mapping (uint256 => mapping(address => uint4)) objectInteraction
mapping (uint256 => uint256) objectData
mapping (uint256 => address) objectOwner


function createObject(uint256 data)
external
{
uint256 newObjectIndex = objects.length;
objects.push(newObjectIndex );
objectOwner[newObjectIndex ]=msg.send;
objectData[newObjectIndex ]=data;
}

function interactWithObject(uint256 index, uint4 data)
external
{
objectInteraction[index][msg.sender]=data;
}



"
74566-3.sol,question,"contract DoubleSigWallet {
    IERC20 public DAI;

    
    event NewTransaction(uint256 transactionId);
    event EndUserSigned(bool signed);
...
"
46024-0.sol,question,"contract helloWorld {

  string public message;

  function constructor() public{
    message = ""Hello World"";
  }

  function sayHi() constant public returns (string){
    return message;
  }
}"
40690-0.sol,question,"contract OLD_CONTRACT {
    mapping (address => mapping (uint => uint)) public balances;
"
82866-0.sol,question,"contract A {
    function foo() public pure returns (uint8){
        return 1;
    }
}"
82866-0.sol,question,"contract B {
    function foo() public pure returns (uint8){
        return 2;
    }
}"
19733-0.sol,question,"contract test {

  bool test_bool1 = false;

  bool test_bool2 = true;

  modifier test_modifier(bool _test_bool){
      if (_test_bool == false) throw;
      _;
  }

  function test1(uint input1) test_modifier(test_bool1) returns (uint){
      return input1;
  }

   function test2(uint input2) test_modifier(test_bool2) returns (uint){
      return input2;
  }

}"
50888-0.sol,question,"contract ScoreStore{
    mapping(string => int) PersonScores;

    function AddPersonScore(string name, int startingScore){
        if(PersonScores[name]>0){
            throw;
        } else {
            PersonScores[name] = startingScore;
        }
    }

    function GetScore(string name) returns (int){
        return PersonScores[name];
    }
}"
44682-1.sol,question,"contract myContract is Crowdsale {
    function myContract 
    (
        uint256 _rate,
        address _wallet,
        MintableToken _token
    )
        public
        Crowdsale(_rate, <<this.address>>, _token)
}"
23007-0.sol,question,"contract ABC{

    struct Data{
        bytes32 data;
        bytes32 data2;
        bytes32 data3;
        bytes32 data4;
        bytes32 data5;
    }
    mapping(uint => Data) public metaData;

    function ABC(){

    }

    function addData(bytes32 data,
        bytes32 data2,
        bytes32 data3,
        bytes32 data4,
        bytes32 data5){
        metaData[0]=Data(data,data2,data3,data4,data5);
    }

    function getData() returns(bytes32,bytes32,bytes32,bytes32,bytes32){
        return (metaData[0].data,metaData[0].data2,metaData[0].data3,metaData[0].data4,metaData[0].data5);
    }
}"
59690-3.sol,question,"contract Test2{
    constructor() public{

    }
}"
59690-3.sol,question,"contract Test{

    function createInstance() public{
        address test2 = new Test2();
    }
}"
61585-0.sol,question,"contract ReadLogPOC
{
    uint gi_sum;
    event adduintevent(uint indexed p_data,uint p_sum);    


    function adduint(uint p_1) external returns(uint){
        gi_sum = 10 + p_1;
        emit adduintevent(p_1,gi_sum);
        return gi_sum;
    }
    function getsum() external returns(uint){
        return gi_sum;
    }    
}"
71102-2.sol,question,"contract vulnerable{

    mapping (address => uint256) balance;
    uint256 _amount;

    function() external payable{
    }

    function deposit() payable public{
        address(this).transfer(_amount);
    }
}"
70062-1.sol,question,"contract second{

first firstContract = 
first(0x0FdF4894a3b7C5a101686829063BE52Ad45bcfb7);

    function combine(uint256 a, uint256 b, uint256 d) public view returns(uint256){
         uint256 c = firstContract.one(a, b);
         uint256 e = firstContract.two(c, d);
         return e;
    }

}"
66857-0.sol,question,"contract Example
{
    using SafeMath for uint256;

    uint256 internal _amount;

    function example(uint256 amount)
    external
    {
        _amount = _amount.add(amount);
    }
}"
3784-0.sol,question,"contract Thing{
  uint public number;
  function Thing(bytes32 _number){
    number = uint(_number);
  }
}"
11606-0.sol,question,"contract C {
    uint public data;
}"
8009-0.sol,question,"contract C {
    event myEvent(bool x, address y);
    address someAddress;

    function someAddressExist(){
        if(someAddress != 0){
            myEvent(true, someAddress);
        }
    }    

    function setSomeAddress(address y){
        someAddress = y;
    }
}"
23191-0.sol,question,"contract c5 {
    uint currentVersion;
    string command;
    address owner;

    
    function c5(){
            currentVersion = 1;
            command = ""test1"";
            owner = msg.sender;
    }

    function update(uint input){
            if(msg.sender != owner) return;
            currentVersion = input;
    }

    function query() constant returns (string){
            return command;
    }

    function version() constant returns (uint){
            return currentVersion;
    }
}"
61124-0.sol,question,contract A is I { }
61124-0.sol,question,contract C is A { }
70402-0.sol,question,"contract Test{
    event Here(uint256 indexed a);
    uint256 public a;

    function add() public returns (uint256){
        a += 1;
        emit Here(a);
        return a;
    }
}"
46998-0.sol,question,"contract DApp
{
    uint256 acconto;
    uint256 saldo;
    address committent;
    address technician;
    bool done = false;
    uint timeFinish;

modifier onlyCom
{
    if (msg.sender != committent)
    {
        assert(true);
    }
    else
    {
        _;
    }
}

function DApp (uint256 _acconto, uint256 _saldo, address _technician, uint _Time) payable public
{
    if (msg.value >= _acconto + _saldo) {
    acconto = _acconto * 1000000000000000000;
    saldo = _saldo * 1000000000000000000;
    committent = msg.sender;
    technician = _technician;
    timeFinish = block.timestamp + _Time;

    technician.transfer(acconto);
    } else revert();
}

function Done () public onlyCom
{
    done = true;
}

function reciveReward () payable public
{
    if(done == true)
    {
        technician.transfer(saldo);
        selfdestruct(this);
    }
    else
    {
        if(block.timestamp >= timeFinish)
        {
            committent.transfer(saldo);
            selfdestruct(this);
        }

        assert(true);
    }
}
}"
28625-0.sol,question,"contract Post{
    address author;
    uint _id;
    struct UserDetails{
     string title;
     string description;
     address owner;
}

mapping (uint => UserDetails) postDetails;

function Post() public{
    author = msg.sender;
}

function addPost(string title, string description) public returns (uint){
    _id += 1;
    postDetails[_id] = UserDetails(title, description, author);
    return _id;
}

function getPost(uint id) constant returns (string title, string description, address owner){
    return (postDetails[id].title, postDetails[id].description, postDetails[id].owner);
}


function getPostCount() constant returns (uint){
    return _id;
}

}"
83555-0.sol,question,"contract ReceiveEther {
    uint256 public clicksfromcreatorcount; 
    uint256 public count;
    address public creatorino = tx.origin;"
9642-0.sol,question,"contract DataStore {

   struct DataModel
   {
       uint id;
       bytes32 string1;
       bytes32 string2;
       bytes32 string3;
       uint actorId;
       bytes32 string4;
       bytes32 string5;
       bytes32 string6;
       bytes32 string7;
    }

    mapping(bytes32 => DataModel) dataMapping;
    DataModel datamodel;
    address owner;

    function DataStore()
    {
        owner = msg.sender;
    }

    function storeData(bytes32 hash, uint id, bytes32 string1, bytes32    string2, bytes32 string3, uint actorId, bytes32 string4, bytes32 string5, bytes32 string6, bytes32 string7) returns (bool response)
    {
        if(msg.sender != owner)
        {
            return false;
        }else
        {
            datamodel.id = id;
            datamodel.string1 = string1;
            datamodel.string2 = string2;
            datamodel.string3 = string3;
            datamodel.actorId = actorId;
            datamodel.string4 = string4;
            datamodel.string5 = string5;
            datamodel.string6 = string6;
            datamodel.string7 = string7;

            dataMapping[hash] = datamodel;

            return true;
        }
    }

    function queryData(bytes32 hash) returns (uint, bytes32, bytes32, bytes32, uint, bytes32, bytes32, bytes32, bytes32)
    {
        if(msg.sender != owner)
        {
            throw;
        }

        DataModel model = dataMapping[hash];
        return (model.id, model.string1, model.string2, model.string3, model.actorId, model.string4, model.string5, model.string6, model.string7);
    }
}"
56568-1.sol,question,"contract FixedSupplyToken is ERC20Token {
  using SafeMath for uint;

  mapping(address => uint) balances;
  uint _totalSupply;

  constructor() public {
    decimals = 18;
    _totalSupply = 1000000 * 10**uint(decimals);
    balances[owner] = _totalSupply;
  } 
}"
68198-0.sol,question,"contract Dapp {
    uint public totalSupply;

    constructor() public {
        totalSupply = 1000000;
    }
}"
64996-6.sol,question,"contract PermissionsManagerProxy is Proxy { 
    constructor(address _initialImplementation)
    Proxy(_initialImplementation)
    public
    {   }
}"
48937-0.sol,question,"contract Club {
    address public owner;
    uint public price; 
    uint public membersCount;
    uint public bestSale; 
    address public bestSeller; 
"
51707-0.sol,question,"contract Test {
    constructor(uint size) {
        uint[size] storage arr;
        for (uint i = 0; i < size; i++) { arr[i] = 0 }
    }
}"
45277-0.sol,question,"contract Base{
    uint public data1;
    bytes32 public data2;

    function setdata(uint a, bytes32 b){
        data1 = a;
        data2 = b;
    }
    function getdata() public view returns(uint){
        return data1 ;
    }

}"
45277-0.sol,question,"contract extra{
   bool public retrive;
   bool public retrive_setter;
   address public baseaddress = 0xca598f876f79a5f8f479bfa1dcc8f4f2dffbd5c2;
   uint a = 5;
   bytes32 b =""Lina"";
   function caller(){
        retrive = baseaddress.call.gas(10000)(bytes8(keccak256(""getdata()"")));
        retrive_setter = baseaddress.call.gas(1000000)(bytes24(keccak256(""setdata(uint, bytes32)"")),a,b);
   }
}"
25557-0.sol,question,"contract MyContract {
    struct MyStruct {
        bytes32 name;
        mapping (address => uint256) balances;
    }

    Result[] public results;
}"
15271-0.sol,question,"contract RegProvider { 
address[] public registrators_contracts; 
address[] public counters_contracts; 


event EventReg(address useraddr); 
event EventTick(address useraddr, uint chislo); 
event EventRemove(address useraddr); 

function getRegistratorsContractCount() 
public 
returns(uint contractCount) 
{ 
return registrators_contracts.length; 
} 

function getCountersContractCount() 
public
returns(uint contractCount) 
{ 
return counters_contracts.length; 
} 

function NotifyRegister(address client) 
public 
{ 
EventReg(client); 
} 

function NotifyGetTick(address client, uint chislo) 
public 
{ 
EventTick(client, chislo); 
} 

function NotifyRemove(address client) 
public 
{ 
EventRemove(client); 
} 

function newRegistratorCounterPair() 
public 
{ 
Registrator reg = new Registrator(); 
registrators_contracts.push(reg); 
Counter cnt = new Counter(); 
counters_contracts.push(cnt); 
reg.set_counter_addr(cnt); 
reg.set_provider_addr(this); 
cnt.set_registrator_addr(reg); 
cnt.set_provider_addr(this); 
} 
}"
15271-0.sol,question,"contract Registrator { 
address counter_addr; 
address provider_addr; 

function set_counter_addr(address myaddr) 
public 
{ 
counter_addr = myaddr; 
} 

function set_provider_addr(address myaddr) 
public 
{ 
provider_addr = myaddr; 
} 

function Register(address useraddr) 
public 
{ 
var rez = provider_addr.call(bytes4(sha3(""NotifyRegister(address client)"")), useraddr); 
uint random_number = uint(block.blockhash(block.number-1))%10 + 1; 
var rez2 = counter_addr.call(bytes4(sha3(""SetInitNumber(address user_addr, uint init_number)"")), useraddr, random_number); 
} 

function Remove(address useraddr) 
public 
{ 
var rez = provider_addr.call(bytes4(sha3(""NotifyRemove(address client)"")), useraddr); 
uint random_number = uint(block.blockhash(block.number-1))%10 + 1; 
var rez2 = counter_addr.call(bytes4(sha3(""RemoveUser(address user_addr)"")), useraddr); 
} 

}"
15271-0.sol,question,"contract Counter { 
mapping (address => uint) usersInfo; 
mapping (address => bool) isAdmin; 
address registrator_addr; 
address provider_addr; 

function set_registrator_addr(address myaddr) 
public 
{ 
registrator_addr = myaddr; 
isAdmin[registrator_addr] = true; 
} 

function set_provider_addr(address myaddr) 
public 
{ 
provider_addr = myaddr; 
} 

function SetInitNumber(address user_addr, uint init_number) 
public 
{ 

usersInfo[user_addr] = init_number; 
} 

function TickNumber(address user_addr) 
public
returns (uint curval) 
{ 
uint currentvalue = usersInfo[user_addr]; 
var rez = provider_addr.call(bytes4(sha3(""NotifyGetTick(address client, uint chislo)"")), user_addr, currentvalue); 
usersInfo[user_addr] = usersInfo[user_addr]+1; 
return currentvalue; 
} 

function RemoveUser(address user_addr) 
public 
{ 

delete usersInfo[user_addr]; 
} 
}"
20888-1.sol,question,"contract MyFriendToken{
    function isMyFriend(address myFriendAddress) returns (bool);
    function transferFrom(address _from, address _to, uint _value) returns (bool success);
    function approve(address _spender, uint _value) returns (bool success);
    function balanceOf(address _owner) constant returns (uint balance);
}"
20888-1.sol,question,"contract MyService {
    address public owner;

    function MyService(){
        owner = msg.sender;
    }


    event DoStuff(address myFriendAddress, uint myFriendBalance);

    function doStuff(address myFriendTokenContractAddress){
        address myFriendAddress = msg.sender;
        MyFriendToken mft = MyFriendToken(myFriendTokenContractAddress);

        if(mft.isMyFriend(myFriendAddress)){
            
            uint myFriendBalance = mft.balanceOf(myFriendAddress);

            
            uint servicePrice = 10;

            if(myFriendBalance >= servicePrice){
                

                
                DoStuff(myFriendAddress , myFriendBalance);
            }
        }
    }
}"
75944-0.sol,question,"contract Puzzle {
     address payable public owner ;
     bool public locked ;
     uint public reward ;
     bytes32 public diff ;
     bytes public solution ;


    constructor () public {
       owner = msg.sender ;
       reward = msg.value ;
       locked = false ;
       diff = bytes32 (11111); 
    }"
84105-0.sol,question,"contract Test {
    function getAdd() public view returns(address){
        address add = address(this);
        return add;
    }
}"
54936-0.sol,question,"contract testUser {
  constructor () {
    address(this).balance = 1 ether;
    }"
66925-2.sol,question,"contract TokenImpl {
    function transfer(address recipient, uint amount) public returns(bytes32)
    {
         return ""true"";
    }
}"
8007-0.sol,question,"contract TestContract
{
    struct Structure {
        bytes32 structure_name;
    }

    mapping (Structure => address) public test_mapping;
}"
65596-1.sol,question,"contract Event is User{

    struct EventStruct {
        uint average;
        uint quantity;
    }

    mapping(uint=>EventStruct) events;
    uint eventsCounter;
}"
10473-0.sol,question,"contract Mappulator {
    mapping(address => int256) public BigMap;
    struct mapper { mapping (address => int256) map;}

    function MappingCombiner(mapper map1, mapper map2){ 
        BigMap = map1.map + map2.map;
    }
}"
3727-1.sol,question,"contract Parents {
    string public childName;
    Child child;
    function Parents(address _childAddress){
        child = Child(_childAddress);
        childName = child.name();  
    }
}"
79571-0.sol,question,"contract Operations {

    Operation[] public operations;

    struct Operation {
        uint startOperation;
        uint endOperation;
        string responsible; 
        string opType;
    }

    function getAllOperations() public view returns(Operation[] memory){
        return operations;
    }
}"
62071-0.sol,question,"contract StarNotary is ERC721 { 

    struct Star { 
        string name;
        string dec;
        string mag;
        string cent;
        string story;
    }

    using Library for Library.data;
    mapping(uint256 => Star) public tokenIdToStarInfo; 
    mapping(address => uint256[]) private _ownerToTokenId; 
    mapping(uint256 => uint256) private _starsForSale;
    mapping(bytes32 => Library.data) private _hashToTokenId;

    Star[] public stars;
    uint256[] tokensForSale;

    function createStar(string _name, string _dec, string _mag, string _cent, string _story) 
    public
    returns(uint256) 
    {
        require(!checkIfStarExist(_dec, _mag, _cent), ""Star already registered!"");

        Star memory newStar = Star(_name,_dec,_mag,_cent,_story);

        uint256 tokenId = stars.push(newStar) - 1;

        return tokenId;

    }
}"
38291-0.sol,question,"contract ERC20 {
    function totalSupply() constant returns (uint totalSupply);
    function balanceOf(address _owner) constant returns (uint balance);
    function transfer(address _to, uint _value) returns (bool success);
    event Transfer(address indexed _from, address indexed _to, uint _value);
}"
38291-0.sol,question,"contract Test{

    ERC20 icoToken;

    function Test(){
        icoToken = ERC20(0x86fa049857e0209aa7d9e616f7eb3b3b78ecfdb0);
        
    }

    function getMyBalance(address myAddress) constant returns (uint256 theB){
        theB = icoToken.balanceOf(myAddress);
        return theB;
    }
}"
80606-0.sol,question,"contract Token {

  mapping(address => uint256) public balanceOf;

  event Transfer(
    address indexed _from,
    address indexed _to,
    uint256 _value
    );

  constructor(uint256 _initialSupply) public {
    owner = msg.sender;
    balanceOf[msg.sender] = _initialSupply;
    totalSupply = _initialSupply;
  }

  function getTokens() public returns (bool success){
    balanceOf[owner] -= 48;
    balanceOf[msg.sender] += 48;
    emit Transfer(owner, msg.sender, 48);
    return true;
  }


}"
79539-0.sol,question,"contract TypeConversion{

    uint96 data = 5;
    bytes32 b = bytes32(data);

}"
49160-0.sol,question,"contract TestToken is ERC20 {
    using SafeMath for uint256;

    string public symbol = ""TEST"";
    string public name = ""TEST Token"";
    uint8 public decimals = 18;
    uint256 public _totalSupply = 140000000 * 10**uint256(decimals);
}"
74266-0.sol,question,"contract SessionManagement { 

    struct ChargeProfileSegment{
        uint startDateTimeSeg;
        uint power;
    }

    struct Session{
        address userWalletAddr;
        uint stationId;
        uint startDateTime; 
        uint endDateTime; 
        ChargeProfileSegment[] chargeProfileSegments;
    }

    mapping (address => Session[]) sessionList;
    Session[] public sessions;
    ChargeProfileSegment[] public chargeProfileSegments;

}"
25046-0.sol,question,"contract A{
   address public owner;

   function A(){
       owner = msg.sender;
   }

   function doSomething(){
       
   }
}"
25046-0.sol,question,"contract B is A{

   function doSomething(){
       require(msg.sender == owner);
       
       super.doSomething();
   }

}"
79565-0.sol,question,"contract MyContract {
  
  uint count;
  uint[] totalPoints;

  function localVars(){
     
     uint[] localArr;
     
     uint[] memory memoryArr;
     
     uint[] pointer = totalPoints;
  }
}"
70982-1.sol,question,"contract Score {
    unit24[]score;

    function addScore(unit24 s) public returens(unit24 []memory){
        score.push(s);
        return score;
    }

    function getLength()view public returens(unit){
        return score.length;
    }

    function clearArray() public returens(unit24 [] memory){
        delete score;
        return score;
    }
}"
65014-0.sol,question,"contract factorywallet { 

   function newWallet(uint256 _unlockDate) public returns(address wallet){
        wallet = new createWallet(msg.sender);
    }
}"
65014-0.sol,question,"contract createWallet{
    address public owner;

    constructor(address _owner) public {
        owner = _owner;
    }
}"
24978-1.sol,question,"contract A{

    mapping (uint=>Storage) idToStorage;
    Storage storage=new Storage();

    function addNewB(uint id){
         idToStorage[id]=storage;
    }
    function getStatus(uint id){
         idToStorage[id].status();
    }

}"
79664-1.sol,question,"contract customer{
  function() external payable{}
  }"
72740-1.sol,question,"contract TokenAccessor { 
  ERC721Token public nft;

  constructor(address _tokenAddress) public {
    nft= ERC721Token(_tokenAddress);
  }
}"
77253-0.sol,question,"contract MyContract {

    
    address contractOwner;

    address[] userFilesList;

    mapping ( string => address ) private accountAddressesByProfile;
    address[] public accountList;

    bytes16[] accountTypes;
    mapping(bytes16 => bool) accountTypesMap;

    constructor() public {
        contractOwner = msg.sender;

        bytes16[5] memory initialAccountTypes = [
            bytes16(""Account1""),
            bytes16(""Account2""),
            bytes16(""Account3""),
            bytes16(""Account4""),
            bytes16(""Account5"")
        ];

        for (uint8 i = 0; i < initialAccountTypes.length; i++ ) {
            bytes16 accountType = initialAccountTypes[i];
            accountTypes.push(accountType);
            accountTypesMap[accountType] = true;
        }
    }

}"
84226-0.sol,question,"contract GraphTraversal {
    using HitchensUnorderedAddressSetLib for HitchensUnorderedAddressSetLib.Set;
    using HitchensUnorderedKeySetLib for HitchensUnorderedKeySetLib.Set;

    struct User {
        uint256 balance;
        uint256[] incomingStreamIds;
        mapping(uint256 => uint256) incomingStreamIdPointers; 
        uint256[] outgoingStreamIds;
        mapping(uint256 => uint256) outgoingStreamIdPointers; 
    }

    mapping(address => User) public users;
    HitchensUnorderedAddressSetLib.Set userSet;

    struct Stream {
        uint256 interval;
        uint256 paymentRate;
        address sender; 
        address recipient; 
        uint256 startTime;
        uint256 stopTime;
    }

    mapping(bytes32 => Stream) public streams;
    HitchensUnorderedKeySetLib.Set streamSet;
}"
84109-0.sol,question,"contract structWithMapping{

    struct Data{
        string[] user;
        string[] catagory;
        string[]  data;
    }

    mapping(string => Data) mappedData;
    string[] public dataArray;

    function setUserData(string _user, string _catagory, string _data)public{
        var addData = mappedData[_user];

        addData.user.push(_user);
        addData.catagory.push(_catagory);
        addData.data.push(_data);

        dataArray.push(_user) -1;
    }

    function getUsers() view public returns(string[]){
        return dataArray;
    }

    function getUserData(string _user) view public returns(string[] memory, string[] memory, string[] memory){
        return(mappedData[_user].user, mappedData[_user].catagory, mappedData[_user].data);
    }
}"
11647-0.sol,question,"contract Test {
    uint public sum;
    function makeRequest(){
      sum += msg.value;
    }
}"
23058-1.sol,question,"contract test {
  bytes32 public Date;

  function test(bytes32 _date){
      Date=_date; 
  }
}"
39446-0.sol,question,"contract C{
    uint public ConstructorUint;

    function C(uint SetConstructorUint)public{
        ConstructorUint = SetConstructorUint;
    }
}"
56938-0.sol,question,"contract Demo2{

    address public owner = msg.sender;
    address[] user;
    address Bank1;

    constructor (string _ID ,address _addr ) {
    }
}"
70409-0.sol,question,"contract ArrayOverflow{
    uint256 public target = 10;
    uint256[] public array = [9,8];

    function modifyArray (uint256 _index, uint256 _value){
        array[_index] = _value;
    }

    function popLength() public{
        
        array.length--;
    }

    function getLength() constant returns(uint256){
        return array.length;
    }

}"
39089-1.sol,question,"contract token{

mapping (address => uint256) public balanceOf;

event Transfer(address indexed from, address indexed to, uint256 value);

function buy() public payable returns (uint amount){
    amount = msg.value;                    
    require(balanceOf[this] >= amount);               
    balanceOf[msg.sender] += amount;                  
    balanceOf[this] -= amount;                        
    Transfer(this, msg.sender, amount);               
    return amount;                                    
}

function sell(uint amount) public returns (uint revenue){
    require(balanceOf[msg.sender] >= amount);         
    balanceOf[this] += amount;                        
    balanceOf[msg.sender] -= amount;                  
    revenue = amount;
    msg.sender.transfer(revenue);                     
    Transfer(msg.sender, this, amount);               
    return revenue;                                   
}"
69147-0.sol,question,"contract basics{
    using SafeMath for *;
    uint time;
    address payable sender;
    uint amount;
    event moneySent(address s,uint a);

    mapping(address=>person) public accounts;

    struct person {
        uint time;
        uint vault;
    }        

    function sendToContract() public payable{
        accounts[msg.sender].vault=accounts[msg.sender].vault.add(msg.value);
        accounts[msg.sender].time=now;
    }

    function takeFromContract() public payable{
        if(now>=accounts[msg.sender].time+10 seconds){
            msg.sender.transfer(accounts[msg.sender].vault);
            accounts[msg.sender].time=now;
        }           
    }
}"
75959-0.sol,question,"contract Test {
  enum EnumTest {
    Test0,
    Test1
  }

  struct StructTest {
    EnumTest Foo;
    uint256 Bar;
  }
}"
77772-0.sol,question,"contract XXXX{
    address  owner;
    constructor()public
    {
        owner=msg.sender;

    }
        struct Project
        {


            string  proName;
            string  proDetails;
            uint  proPrice;
            address  proOwner;

        }
        Project [] public  pros;
        mapping (address => Project) public enrolled;

    function ProjectDetails(uint _price, string _name,string _projectDetails) public 
    
    {
        require(msg.sender!=owner);
        

        Project memory newPro = Project
        ({
            proPrice:_price,
            proOwner:msg.sender,
            proDetails:_projectDetails,
            proName:_name

            });
            pros.push(newPro);

            enrolled[msg.sender]=newPro;

    }
}"
78536-1.sol,question,"contract Judge {

    struct Misbehavior{
        address subject;   
        address device;
        string resource;
        string action;   
        string misbehavior;
        uint time;   
        uint penalty;   
    }

    mapping (address => Misbehavior[]) public MisbehaviorList;

    function misbeaviorJudge(
        address _subject, 
        address  _device, 
        string memory _resource,
        string memory _action,
        string memory _misbehavior,
        uint  _time) 
        public returns (uint  penalty) 
    {
        penalty = MisbehaviorList[_subject].length;
        MisbehaviorList[_subject].push(Misbehavior(_subject, _device, _resource, _action, _misbehavior, _time, penalty));
    }

    function getLatestMisbehavior(address _requester) public view 
        returns (address _subject, address _device, string memory _resource, string memory _action, string memory _misbehavior, uint _time)
    {
        uint latest = MisbehaviorList[_requester].length  - 1;
        _subject = MisbehaviorList[_requester][latest].subject;
        _device = MisbehaviorList[_requester][latest].device;
        _resource = MisbehaviorList[_requester][latest].resource;
        _action = MisbehaviorList[_requester][latest].action;
        _misbehavior = MisbehaviorList[_requester][latest].misbehavior;
        _time = MisbehaviorList[_requester][latest].time;
    }
}"
11318-1.sol,question,"contract Magger {  
    function getOrderMag(int256 input) constant returns (int256){
        int counter=0;
        int temp = input;
        while((temp/10)>1){
            temp = temp/10;
            counter++;
        }
        return counter;
    }
}"
736-0.sol,question,"contract greeter
{
  string greeting;
  uint calls;

  function greeter ( string _greeting ) public
  {
    greeting = _greeting;
    calls = 0;
  }

  function greet ( ) constant returns ( string )
  {
    calls = calls + 1; 
    return greeting;
  }
}"
84384-0.sol,question,"contract GLDToken is ERC20 {
    constructor(uint256 initialSupply) ERC20(""Gold"", ""GLD"") public {
        _mint(msg.sender, initialSupply);
    }
}"
73958-0.sol,question,"contract SubToken{ 
    MainContract mc;

    constructor(address _address) public{  
       mc=MainContract(_address);

    }  

    function getName1() view public returns(string memory){
        return mc.getNameMain(address(this));
    }

    function getName2() view public returns(string memory){
        return mc.tokens[address(this)].name;
    }

    
    
    
    
    

    event Transfer(address indexed from, address indexed to, uint tokens); 
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens); 

}"
69235-0.sol,question,"contract Passport
{
    struct      Person
    {
        string  name;
        string  surname;
        uint8   age;
        uint256 id;
        bool    registered;
    }

    address payable public              owner;
    mapping(address => Person) public   people;
    uint256                             idCount;

    modifier ownerOnly()
    {
        require(msg.sender == owner);
        _;
    }

    constructor() public payable
    {
        owner = msg.sender;
    }

    function registerID(string memory _name, string memory _surname, uint8 _age) public
    {
        require(!people[msg.sender].registered);

        people[msg.sender].name = _name;
        people[msg.sender].surname = _surname;
        people[msg.sender].age = _age;
        people[msg.sender].id = idCount;

        people[msg.sender].registered = true;

        idCount += 1;
    }

    
    function isRegistered(address _address) public view returns (bool)
    {
        return people[_address].registered;
    }

    function end() ownerOnly public
    {
        selfdestruct(owner);
    }
}"
71806-0.sol,question,"contract Forwarder {

 address payable public receiversAddress = 0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C;
 address payable public feeAddress = 0xdD870fA1b7C4700F2BD7f44238821C26f7392148;

 constructor() payable public {
   uint amountToSendReceiver = msg.value-194740000000000;
   receiversAddress.transfer(amountToSendReceiver);
   feeAddress.transfer(194740000000000);
  }

 }"
77910-1.sol,question,"contract B{
    A a;
    constructor() public{
        a = A(0xE6c28FEF0491c7626c002131a2c833094f6135D3);       
    }
    function useCall() public{
        require(address(a).call(bytes4(sha3(""checkMe(uint)"")), 2));
    }

    function useDelegateCall() public{
        require(address(a).delegatecall(bytes4(sha3(""checkMe(uint)"")), 3));
    }
}"
84253-0.sol,question,"contract Example{
    function greet(){
        revert(""Hello World"");        
    }
}"
71656-0.sol,question,"contract Token {

    uint256 public price;

    constructor() public {
        price =
    }"
75883-0.sol,question,"contract PersonalInfo{
    address public userAddress;
    address[] public Users;
    string public email;
    string public userName;


    function PersonalInfo ()public{
        userAddress = msg.sender;
        Users.push(userAddress);
    }
    function SavePersonalInfo(string Name, string Email)public{
        userName = Name;
        email = Email;
    }


}"
79713-0.sol,question,"contract GuessTheNumberChallenge {
    constructor() public payable {
        require(msg.value == 1 ether);
    }

}"
42624-0.sol,question,"contract SEexample {

    int256[3] thing;
    uint8 internal i=0;

    function submit(int256[3] bids,int256[3] prefs) public returns (int256[3]){
            for (i=0;i<3;i++){
                thing[i] = bids[i] + prefs[i];
            }
        return thing;
    }
}"
79259-0.sol,question,"contract customer{

bytes public name=""Alireza Kiakojouri"";

}"
50086-1.sol,question,"contract Child {

  
  Parent p = Parent(0x692a70d2e424a56d2c6c27aa97d1a86395877b3a);

  uint256 public totalSupply;
  mapping (address => uint256) balances;

  function getName(address addr)constant returns(string, string){
      return (p.getFName(addr), p.getLName(addr));
  }

  function addBalance(address addr){
      if (uint(keccak256(p.getFName(addr))) == uint(keccak256(""a"")) && uint(keccak256(p.getLName(addr))) == uint(keccak256(""b""))){
          balances[addr] += (p.accountTx(addr)[p.accountTx(addr).length - 1]) * 2;
          totalSupply += (p.accountTx(addr)[p.accountTx(addr).length - 1]) * 2;

      }

      if (uint(keccak256(p.getFName(addr))) == uint(keccak256(""a"")) && uint(keccak256(p.getLName(addr))) == uint(keccak256(""c""))){
          balances[addr] += (p.accountTx(addr)[p.accountTx(addr).length - 1]) * 3;
          totalSupply += (p.accountTx(addr)[p.accountTx(addr).length - 1]) * 3;

      }

      if (uint(keccak256(p.getFName(addr))) == uint(keccak256(""a"")) && uint(keccak256(p.getLName(addr))) == uint(keccak256(""d""))){
          balances[addr] += (p.accountTx(addr)[p.accountTx(addr).length - 1]) * 4;
          totalSupply += (p.accountTx(addr)[p.accountTx(addr).length - 1]) * 4;

      }

      if (uint(keccak256(p.getFName(addr))) == uint(keccak256(""a"")) && uint(keccak256(p.getLName(addr))) == uint(keccak256(""e""))){
          balances[addr] += (p.accountTx(addr)[p.accountTx(addr).length - 1]) * 5;
          totalSupply += (p.accountTx(addr)[p.accountTx(addr).length - 1]) * 5;

      }

      else {
          balances[addr] += (p.accountTx(addr)[p.accountTx(addr).length - 1]) * 6;
          totalSupply += (p.accountTx(addr)[p.accountTx(addr).length - 1]) * 6;

      }

  }

  function checkBalance(address addr) constant returns(uint){
      return balances[addr];
  }

}"
12723-0.sol,question,"contract PowerOfTest {
    
    uint8 public placesA = 3;
    uint public EXP_A = 10**placesA;

    
    uint public placesB = 3;
    uint public EXP_B = 10**placesB;

    
    uint8 public placesC = 3;
    uint public EXP_C = 10**uint(placesC);

    
    
    

    
    function pow(uint base, uint8 exponent) returns(uint)
    {
        return base**exponent;
    }

    
    function pow2() returns(uint)
    {
        uint8 EXP_D = 3;
        return 10**EXP_D;
    }
}"
12737-0.sol,question,"contract ContractA{
  address[] instancesOfB;

  function ContractA(){
     
     ...
  }

 function updateB(){
   
   for(uint8 i=0; i < instancesOfB; i++) {
      instancesOfB[i].setAddressOfA(address(this));
   }
 }
}"
34618-2.sol,question,"contract z3 is z1  {


    function z3 (){}

    function getZ3example() returns(uint){
        return (z1.getZ1example());
    }


}"
60399-0.sol,question,"contract Greet
    {
  string message;
  constructor() public
  {
    message = ""I'm ready!"";

}
function setgreetings(string _message)public
{
    message = _message;

}
function getgreetings()public constant returns(string)
{
    return message;
}
}"
70124-1.sol,question,"contract Department
{

    struct Departmentinfo 
    {
        string Dep_name;
        string email;
        string location;
        uint256 contact_no;

    }


    uint256 id=0;
    mapping(uint256 => Departmentinfo) Departments;
    uint256[] public DepartmentIds;


    function registerDepartment(string memory name, string memory location,string memory email, uint256 contact_no) public returns(uint256)    
         {
                id=id+1;
                Departmentinfo storage newDept = Departments[id];
                newDept.Dep_name = name;
                newDept.location=location;
                newDept.email = email;
                newDept.contact_no = contact_no;
                DepartmentIds.push(id);
         }

    function getDepartmentDetails(uint256 deptid) public view returns (string memory, string memory,string memory, uint256)
         {
               Departmentinfo storage d = Departments[deptid];
               return(d.Dep_name,d.location,d.email,d.contact_no);
         }

    function getdept(uint256 deptid) public view returns (string memory)
         {
                Departmentinfo storage d = Departments[deptid];
                return(d.Dep_name);
         }

    function comparestring(string memory a , string memory b) public view returns(bool)
        {
           return (keccak256(abi.encodePacked(a))==keccak256(abi.encodePacked(b)));

        }
        function getid() public view returns(uint256)
        {
            return id;
        }
        function getname(uint256 mid) public view returns(string memory)
        {
            Departmentinfo storage d=Departments[mid];
            return(d.Dep_name);
        }

    function validatedept(string memory email,uint256 contact_no) public view returns (uint256 )
        {
            uint256 deptid=0;
            uint256 n=id;
            for(uint256 i=1;i<=n;i++)
             {
                Departmentinfo storage d=Departments[i];
                string memory chck_email=d.email;
                uint256 chck_contact_no=d.contact_no;
                if((comparestring(chck_email,email)) && (chck_contact_no==contact_no))
                     {
                        deptid=id;
                         break;
                     }
             }

             return deptid;
        }"
83625-0.sol,question,"contract VenueRegistry{
    struct Queue{
        uint head;
        uint tail;
        mapping(uint => address) queue;
    }

    struct Venue{
        uint id;
        Queue queue;
    }

    mapping (uint => Venue) public venues;

}"
60992-1.sol,question,"contract CB
{
    function FB() public
    {
        
    }

    function FC() public
    {
       
    }
}"
42569-0.sol,question,"contract BCSchema {

struct DefinitionV1{
   uint16   version;

   address adrs;
   uint8   id;
   string  name;
   string  description;
   string  bytecode;
 } 

struct DefinitionV2{
   uint16   version;

   address adrs;
   uint8   id;
   string  name;
   string  description;
   string  bytecode;
   string  ABI;
 }
}"
62024-0.sol,question,"contract Sample{

  struct Info
  {
    address pubKey;        
    bytes32 Id;
  }

  mapping(address => Info) public userMap;

  
  function register(bytes32 orgId, address pubKey) public returns(bool){
    if (pubKey == 0x0 || orgId == 0x0 ) {
        revert(""Pub Key & Org Id are mandatory"");
    }
    if (userMap[pubKey].pubKey == pubKey) {
        revert(""User already exists"");
    }
    userMap[pubKey].pubKey = pubKey;
    userMap[pubKey].orgId = orgId;
    return true;
  }
  
  function getUser(address pubKey) public returns(bytes32 orgId){
    orgId = userMap[pubKey].orgId;
  }
}"
66795-0.sol,question,"contract test{

uint average;
uint counter;

function calcAverage( uint _newValue) public
{
    average = ((average * counter) + _newValue)/(counter + 1);
}

function get() public view returns(uint)
{
    return average;
}
}"
64872-0.sol,question,"contract AddNewVotingBuilder is BaseBuilder
{
    function build()
        external
    {
        emit NewVoting(address(new AddNewVoting()));
    }
}"
76915-0.sol,question,"contract Marketplace {
    string public name;
    address owner;
    uint public fileCount = 0;
    mapping(uint => File) public files; 


    struct File
    {
        uint id;
        string name;
        address owner;
        address sharedWith;
    }

    event FileViewed(
        uint id,
        string name,
        address owner,
        address sharedWith
    );

    constructor() public {
        name = ""File Sharing System"";
        owner = msg.sender;
    }

    function viewFile(uint _id) public 
    {
        File memory _file = files[_id];
        require(msg.sender==_file.sharedWith || msg.sender==owner ,""Not shared with you!!"");
        emit FileViewed(fileCount, _file.name, owner, _file.sharedWith);
    }
}"
8698-1.sol,question,"contract caller_tracker_string
{
    address curr_tracker;
    address owner; 
    function change_contract(address addr)
    {
        curr_tracker=addr;
    }
    function caller_tracker_string(address current_trcker)
    {
        owner=tx.origin;
        curr_tracker=current_trcker;        
    }
    function adduser(address usr_new,uint ts,string tr)
    {
        curr_tracker.call(bytes4(sha3(""callme(address,uint256,string)"")),usr_new,ts,tr);
    }
    function kill()
        { 
        suicide(owner);
        }
}"
67841-0.sol,question,"contract MyCollectable is ERC721Full {

constructor (string memory _name, string memory _symbol) public
    ERC721Full(_name, _symbol) {
}



function mintUniqueTokenTo(address _to, uint256 _tokenId, string memory _tokenURI)  
    public {
        super._mint(_to, _tokenId);
        super._setTokenURI(_tokenId, _tokenURI);
    }
}"
68527-2.sol,question,"contract ChildContract{
    bool isActive;

    constructor() public{
        isActive = true;
    }

    function activate(bool status) public{
        isActive = status;
    }
}"
18153-1.sol,question,"contract RockBand is Group{
    struct MusicianExtra {
        bytes32 instrument;
    }
    mapping (address => MusicianExtra) membersMusicianExtra;
}"
18153-1.sol,question,"contract FootballClub is Group{
    struct PlayerExtra {
        bytes32 position;
    }
    mapping (address => PlayerExtra) membersFootbalExtra;
}"
8490-0.sol,question,"contract MyContract {
    uint public len;
    mapping(uint=>byte) public names;
    function initContracts(byte[] contractNames_){
        for(uint i=0;i<contractNames_.length;i++){
            names[i]=contractNames_[i];
        }
        len=contractNames_.length;
    }
}"
84289-1.sol,question,"contract HelloWorld {

uint public userCount = 0;


constructor() public{
    createUser (""Monicka"", ""Akilan"", 30, ""Chennai"");
}

  struct User {
    uint id;
    string firstName;
    string lastName;
    uint age;
    string city;    
    uint tipAmount;
    address payable author;
  }
event profileTips(string firstName, string lastName, uint age, 
 string city, uint tipAmount, address payable author);

mapping(uint => User) public Users;

 function createUser(string memory _firstName, string memory _lastName, uint _age, 
 string memory  _city) public payable{
    userCount ++;
    
     Users[userCount] = User(userCount, _firstName, _lastName, _age, _city, 20, msg.sender);
    emit profileTips(_firstName, _lastName, _age,  _city, msg.value,  msg.sender);
 }
}"
11378-0.sol,question,"contract Sha_hash_bytes_links
 {
     function return_int()returns(uint x) 
        {
            return(0);
        }
  }"
82292-0.sol,question,"contract waterBill{
    address admin;
    uint public rateperliter;
    struct Individual{
        string name;
        string addr;
        uint water;
        uint BillAmount;
    }
    mapping (address=>Individual) individual;
    address[] Useraccts;
    constructor() public{
        admin=msg.sender;
    }
    modifier onlyAdmin(){
        require(msg.sender==admin,""Only Admin has access to this function"");_;
    }
     event NewUser(
         string _name,
         address _address,
         uint _waterconsumed
         );
     event BillGenerated(
         address _address,
      uint billamount
         );
    function setUser(string memory _name,address _address,uint _waterconsumed,string memory _Physicaladdress) public onlyAdmin()
    {
        Individual memory User=individual[_address];
        User.name=_name;
        User.water=_waterconsumed;
        User.addr=_Physicaladdress;
        Useraccts.push(_address) -1;
    emit NewUser(_name,_address,_waterconsumed);
     }
     function setBill(address _address) public onlyAdmin() returns(uint){
         individual[_address].BillAmount=individual[_address].water*rateperliter;

    emit BillGenerated(_address,individual[_address].BillAmount);
       return individual[_address].BillAmount;
   }
    function getBill(address _address) view public returns(uint){
        return individual[_address].BillAmount;
    }
    function setRate(uint _rate) public onlyAdmin(){
        rateperliter=_rate;
    }
}"
49929-1.sol,question,"contract Autos {

address public owner;
mapping(address => bool) members;


modifier onlyMember {
    require(msg.sender == owner || members[msg.sender] == true);
    _;
    }


}"
58077-0.sol,question,"contract Check {
 function multiply(uint a) public pure returns(uint){
    return a*a;
 }
}"
11802-0.sol,question,"contract A {
  uint public a1;
}"
37660-0.sol,question,"contract DumbCoin1{

    address deployer;
    mapping(address=>uint) balances;

    function DumbCoin1(){

        deployer = msg.sender;

    }

    function giveCoins(uint amount, address receiver){

        if(msg.sender == deployer){
            
            balances[receiver] += amount;
        }
        else{
            throw;
        }

    }


    function viewBalance() returns (uint){

        return balances[msg.sender];

    }

}"
2259-0-0.sol,answer,"contract A {
    function indirect() {
        B.doit();
    }
    function direct() {
        C.doit();
    }
}"
968-1-0.sol,answer,"contract blockchain2emailAPI {function SendEmail(string x, string y) returns(bool) {}}"
968-1-0.sol,answer,"contract Alarm is usingOraclize {

    function Alarm() {
       oraclize_query(1*day, ""URL"", """");
    }

    function SendEmail(string EmailAddress, string Message) internal returns (bool){
        return (blockchain2emailAPI(0xde5ebd0b8879b0a42b23b37e4d76a5e21a0bef4b).
            SendEmail.value(1000000000000000)(EmailAddress, Message));
    }

    function __callback(bytes32 myid, string result) {
        if (msg.sender != oraclize_cbAddress()) throw;
        SendEmail(""example@email.com"", ""Your message goes here."");
    }

}"
72778-0-2.sol,answer,"contract Attack {
    Guess g;
    event LogSuccess(address sender, bool success);
    constructor(address guessIt) public {
        g = Guess(guessIt);
    }
    function notSoHardAfterAll() public {
        if(g.guessMe(uint(blockhash(block.number)))) {
            emit LogSuccess(msg.sender, true);
        }
    }
}"
64644-0-1.sol,answer,"contract Bank {
    struct Customer {
        uint age;
    }

    Customer[][] customers;

    function foo() public {
        if (customers.length > 0) {
            Customer[] storage northBranch = customers[0];
            if (northBranch.length > 1) {
                Customer storage customer = northBranch[1];
                customer.age = 23;
            }
        } else {
            Customer memory bob;
            bob.age = 34;
            customers.length += 1;
            customers[0].push(bob);
        }
    }

    function get() external view returns (Customer[][] memory) {
        return (customers);
    }
}"
29074-0-2.sol,answer,"contract Echo {
    bytes32 public message;

    function sendMessage(bytes32 _message) public {
        message = _message;
    }

    function getMessage() view public returns (bytes32) {
        return message;
    }
}"
68942-0-0.sol,answer,"contract Revoke {

    mapping(string => bool) validities;

    function store(string memory hash) public {
        validities[hash] = true;
    }

    function revoke(string memory hash) public {
        validities[hash] = false;
    }

    function isValid(string memory hash) public view returns (bool) {
        return validities[hash];
    }
}"
4608-0-0.sol,answer,"contract test { 
      event R(uint x);
      function multiply(uint a) returns(uint d) { 
               R(a * 7);
               return a * 7;
      }
}"
71655-0-0.sol,answer,"contract BLSExample {
      struct G1Point {
     uint X;
      uint Y;
     }

struct G2Point {
    uint[2] X;
    uint[2] Y;
}


function P1() internal returns (G1Point memory) {
    return G1Point(1, 2);
}


function P2() internal returns (G2Point memory) {
    return G2Point(
        [11559732032986387107991004021392285783925812861821192530917403151452391805634,
        10857046999023057135944570762232829481370756359578518086990519993285655852781],

        [4082367875863433681332203403145435568316851327593401208105741076214120093531,
        8495653923123431417604973247489272438418190587263600148770280649306958101930]
    );
}


function verifyBLSTest() public returns (bool) {

    bytes memory message = hex""7b0a2020226f70656e223a207b0a20202020227072696365223a2039353931372c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333134323430302c0a2020202020202269736f223a2022323031362d31322d33315430303a30303a30302e3030305a220a202020207d0a20207d2c0a202022636c6f7365223a207b0a20202020227072696365223a2039363736302c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333232383830302c0a2020202020202269736f223a2022323031372d30312d30315430303a30303a30302e3030305a220a202020207d0a20207d2c0a2020226c6f6f6b7570223a207b0a20202020227072696365223a2039363736302c0a20202020226b223a20312c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333232383830302c0a2020202020202269736f223a2022323031372d30312d30315430303a30303a30302e3030305a220a202020207d0a20207d0a7d0a6578616d706c652e636f6d2f6170692f31"";

    G1Point memory signature = G1Point(11181692345848957662074290878138344227085597134981019040735323471731897153462, 6479746447046570360435714249272776082787932146211764251347798668447381926167);

    G2Point memory v = G2Point(
        [18523194229674161632574346342370534213928970227736813349975332190798837787897, 5725452645840548248571879966249653216818629536104756116202892528545334967238],
        [3816656720215352836236372430537606984911914992659540439626020770732736710924, 677280212051826798882467475639465784259337739185938192379192340908771705870]
    );

    G1Point memory h = hashToG1(message);

    return pairing2(negate(signature), P2(), h, v);
}



function verifyBGLS2() public returns (bool) {

    uint numberOfSigners = 2;

    G1Point memory signature = G1Point(7985250684665362734034207174567341000146996823387166378141631317099216977152, 5471024627060516972461571110176333017668072838695251726406965080926450112048);

    bytes memory message0 = hex""7b0a2020226f70656e223a207b0a20202020227072696365223a2039353931372c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333134323430302c0a2020202020202269736f223a2022323031362d31322d33315430303a30303a30302e3030305a220a202020207d0a20207d2c0a202022636c6f7365223a207b0a20202020227072696365223a2039363736302c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333232383830302c0a2020202020202269736f223a2022323031372d30312d30315430303a30303a30302e3030305a220a202020207d0a20207d2c0a2020226c6f6f6b7570223a207b0a20202020227072696365223a2039363736302c0a20202020226b223a20312c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333232383830302c0a2020202020202269736f223a2022323031372d30312d30315430303a30303a30302e3030305a220a202020207d0a20207d0a7d0a6578616d706c652e636f6d2f6170692f30"";
    bytes memory message1 = hex""7b0a2020226f70656e223a207b0a20202020227072696365223a2039353931372c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333134323430302c0a2020202020202269736f223a2022323031362d31322d33315430303a30303a30302e3030305a220a202020207d0a20207d2c0a202022636c6f7365223a207b0a20202020227072696365223a2039363736302c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333232383830302c0a2020202020202269736f223a2022323031372d30312d30315430303a30303a30302e3030305a220a202020207d0a20207d2c0a2020226c6f6f6b7570223a207b0a20202020227072696365223a2039363736302c0a20202020226b223a20312c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333232383830302c0a2020202020202269736f223a2022323031372d30312d30315430303a30303a30302e3030305a220a202020207d0a20207d0a7d0a6578616d706c652e636f6d2f6170692f31"";

    G2Point memory v0 = G2Point(
        [15516709285352539082439213720585739724329002971882390582209636960597958801449, 19324541677661060388134143597417835654030498723817274130329567224531700170734],
        [16550775633156536193089672538964908973667410921848053632462693002610771214528, 10154483139478025296468271477739414260393126999813603835827647034319242387010]
    );

    G2Point memory v1 = G2Point(
        [14125383697019450293340447180826714775062600193406387386692146468060627933203, 10886345395648455940547500614900453787797209052692168129177801883734751834552],
        [13494666809312056575532152175382485778895768300692817869062640713829304801648, 10580958449683540742032499469496205826101096579572266360455646078388895706251]
    );

    G1Point memory h0 = hashToG1(message0);
    G1Point memory h1 = hashToG1(message1);

    G1Point[] memory a = new G1Point[](numberOfSigners + 1);
    G2Point[] memory b = new G2Point[](numberOfSigners + 1);
    a[0] = negate(signature);
    a[1] = h0;
    a[2] = h1;
    b[0] = P2();
    b[1] = v0;
    b[2] = v1;

    return pairing(a, b);
}



function verifyBGLS3() public returns (bool) {

    uint numberOfSigners = 3;

    G1Point memory signature = G1Point(385846518441062319503502284295243290270560187383398932887791670182362540842, 19731933537428695151702009864745685458233056709189425720845387511061953267292);

    bytes memory message0 = hex""7b0a2020226f70656e223a207b0a20202020227072696365223a2039353931372c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333134323430302c0a2020202020202269736f223a2022323031362d31322d33315430303a30303a30302e3030305a220a202020207d0a20207d2c0a202022636c6f7365223a207b0a20202020227072696365223a2039363736302c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333232383830302c0a2020202020202269736f223a2022323031372d30312d30315430303a30303a30302e3030305a220a202020207d0a20207d2c0a2020226c6f6f6b7570223a207b0a20202020227072696365223a2039363736302c0a20202020226b223a20312c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333232383830302c0a2020202020202269736f223a2022323031372d30312d30315430303a30303a30302e3030305a220a202020207d0a20207d0a7d0a6578616d706c652e636f6d2f6170692f30"";
    bytes memory message1 = hex""7b0a2020226f70656e223a207b0a20202020227072696365223a2039353931372c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333134323430302c0a2020202020202269736f223a2022323031362d31322d33315430303a30303a30302e3030305a220a202020207d0a20207d2c0a202022636c6f7365223a207b0a20202020227072696365223a2039363736302c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333232383830302c0a2020202020202269736f223a2022323031372d30312d30315430303a30303a30302e3030305a220a202020207d0a20207d2c0a2020226c6f6f6b7570223a207b0a20202020227072696365223a2039363736302c0a20202020226b223a20312c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333232383830302c0a2020202020202269736f223a2022323031372d30312d30315430303a30303a30302e3030305a220a202020207d0a20207d0a7d0a6578616d706c652e636f6d2f6170692f31"";
    bytes memory message2 = hex""7b0a2020226f70656e223a207b0a20202020227072696365223a2039353931372c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333134323430302c0a2020202020202269736f223a2022323031362d31322d33315430303a30303a30302e3030305a220a202020207d0a20207d2c0a202022636c6f7365223a207b0a20202020227072696365223a2039363736302c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333232383830302c0a2020202020202269736f223a2022323031372d30312d30315430303a30303a30302e3030305a220a202020207d0a20207d2c0a2020226c6f6f6b7570223a207b0a20202020227072696365223a2039363736302c0a20202020226b223a20312c0a202020202274696d65223a207b0a20202020202022756e6978223a20313438333232383830302c0a2020202020202269736f223a2022323031372d30312d30315430303a30303a30302e3030305a220a202020207d0a20207d0a7d0a6578616d706c652e636f6d2f6170692f32"";

    G2Point memory v0 = G2Point(
        [1787282038370667094324364195810339512415273589223814213215040505578200405366, 414568866548933554513940840943382696902163788831396286279770126458218272940],
        [6560020551439455112781785895092032589010633560844445112872109862153018855017, 19411093226570397520343120724285433000937737461010544490862811136406407315543]
    );

    G2Point memory v1 = G2Point(
        [14831125462625540363404323739936082597729714855858291605999144010730542058037, 8342129546329626371616639780890580451066604883761980695690870205390518348707],
        [808186590373043742842665711030588185456231663895663328011864547134240543671, 1856705676948889458735296604372981546875220644939188415241687241562401814459]
    );

    G2Point memory v2 = G2Point(
        [12507030828714819990408995725310388936101611986473926829733453468215798265704, 16402225253711577242710704509153100189802817297679524801952098990526969620006],
        [18717845356690477533392378472300056893077745517009561191866660997312973511514, 20124563173642533900823905467925868861151292863229012000403558815142682516349]
    );

    G1Point memory h0 = hashToG1(message0);
    G1Point memory h1 = hashToG1(message1);
    G1Point memory h2 = hashToG1(message2);

    G1Point[] memory a = new G1Point[](numberOfSigners + 1);
    G2Point[] memory b = new G2Point[](numberOfSigners + 1);
    a[0] = negate(signature);
    a[1] = h0;
    a[2] = h1;
    a[3] = h2;
    b[0] = P2();
    b[1] = v0;
    b[2] = v1;
    b[3] = v2;

    return pairing(a, b);
}





function pairing(G1Point[] memory p1, G2Point[] memory p2) internal returns (bool) {
    require(p1.length == p2.length);
    uint elements = p1.length;
    uint inputSize = elements * 6;
    uint[] memory input = new uint[](inputSize);

    for (uint i = 0; i < elements; i++)
    {
        input[i * 6 + 0] = p1[i].X;
        input[i * 6 + 1] = p1[i].Y;
        input[i * 6 + 2] = p2[i].X[0];
        input[i * 6 + 3] = p2[i].X[1];
        input[i * 6 + 4] = p2[i].Y[0];
        input[i * 6 + 5] = p2[i].Y[1];
    }

    uint[1] memory out;
    bool success;

    assembly {
        success := call(sub(gas, 2000), 8, 0, add(input, 0x20), mul(inputSize, 0x20), out, 0x20)
    
        switch success case 0 {invalid()}
    }
    require(success);
    return out[0] != 0;
}


function pairing2(G1Point memory a1, G2Point memory a2, G1Point memory b1, G2Point memory b2) internal returns (bool) {
    G1Point[] memory p1 = new G1Point[](2);
    G2Point[] memory p2 = new G2Point[](2);
    p1[0] = a1;
    p1[1] = b1;
    p2[0] = a2;
    p2[1] = b2;
    return pairing(p1, p2);
}

function hashToG1(bytes memory message) internal returns (G1Point memory) {
    uint256 h = uint256(keccak256(message));
    return mul(P1(), h);
}

function modPow(uint256 base, uint256 exponent, uint256 modulus) internal returns (uint256) {
    uint256[6] memory input = [32, 32, 32, base, exponent, modulus];
    uint256[1] memory result;
    assembly {
        if iszero(call(not(0), 0x05, 0, input, 0xc0, result, 0x20)) {
            revert(0, 0)
        }
    }
    return result[0];
}


function negate(G1Point memory p) internal returns (G1Point memory) {
    
    uint q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;
    if (p.X == 0 && p.Y == 0)
        return G1Point(0, 0);
    return G1Point(p.X, q - (p.Y % q));
}


function add(G1Point memory p1, G1Point memory p2) internal returns (G1Point memory r) {
    uint[4] memory input;
    input[0] = p1.X;
    input[1] = p1.Y;
    input[2] = p2.X;
    input[3] = p2.Y;
    bool success;
    assembly {
        success := call(sub(gas, 2000), 6, 0, input, 0xc0, r, 0x60)
    
        switch success case 0 {invalid()}
    }
    require(success);
}


function mul(G1Point memory p, uint s) internal returns (G1Point memory r) {
    uint[3] memory input;
    input[0] = p.X;
    input[1] = p.Y;
    input[2] = s;
    bool success;
    assembly {
        success := call(sub(gas, 2000), 7, 0, input, 0x80, r, 0x60)
    
        switch success case 0 {invalid()}
    }
    require(success);
    }
}"
12920-0-0.sol,answer,"contract C {
  uint u;
  function f() {
    u = 1;
  }
}"
12920-0-0.sol,answer,"contract B is C {
  function f() {
    u = 2;
  }
}"
12920-0-0.sol,answer,"contract A is B {
  function f() {  
    u = 3;
  }
  function f1() { 
    super.f();
  }
  function f2() { 
    B.f();
  }
  function f3() { 
    C.f();
  }
}"
8222-0-1.sol,answer,"contract ClassRoom {
    address studentAddr;
    Student student;
    function ClassRoom(address addr) {
        studentAddr = addr;
        student = Student(addr);
    }

    
    function updateTookTest (uint ID) {
        student.updateStudent(ID);
    }
    
    function readStudentStruct (uint ID) constant returns (string, uint, bool) {
        return student.studentNames(ID);
    }
}"
71026-0-0.sol,answer,"contract C {
    ERC20 token = ERC20(0x...);
    address ownerOfFoo;

    function buyFoo(address owner) external {
        require(ownerOfFoo == address(0), ""already owned"");
        require(token.transferFrom(msg.sender, address(this), 1000), ""foo costs 1,000 token units"");

        ownerOfFoo = owner;
    }
}"
71026-0-0.sol,answer,"contract B {
    ERC20 token = ERC20(0x...);
    C c = C(0x...);

    function helpMeBuyFoo() external {
        
        

        token.approve(c, 1000); 
        c.buyFoo(msg.sender);   
    }
}"
78679-0-1.sol,answer,"contract stringsContract {

    function takesTwo(string memory str, uint idx) public pure returns (bytes memory) {
        bytes memory bytesStr = bytes(str);
        return bytesStr;
    }
}"
11383-0-2.sol,answer,"contract myContract is usingOraclize {
    function myContract() {
        OAR = OraclizeAddrResolverI(0x145437eac36aeacee0c135c9015fff316ba938ed);
        
    }
    
}"
60840-0-0.sol,answer,"contract CrowdFunding {

    struct Investor {

        address addr;

        uint amount;
 }

address public owner;

uint public numInvestors;

uint public _starting;
uint public deadline;
uint public _current;

string public status;

bool public ended;
uint public goalAmount;
uint public totalAmount;

mapping (uint => Investor) public Investors;

modifier onlyOwner () {     
    require(msg.sender == owner, ""Not owner"");
    _;
}

modifier notEnded () {
    require (!ended, ""Crowfunding ended."");
    _;
}

modifier deadlineReached () {
    require (now >= deadline, ""Crowfunding still running."");
    _;
}

constructor(uint _duration, uint _goalAmount) public {

    owner = msg.sender;

    _starting = now;
    deadline = _starting + _duration;

    goalAmount = _goalAmount;

    status = ""Funding"";

    ended = false;

    numInvestors = 0;

    totalAmount = 0;
}

function fund() public payable notEnded {

    Investor storage inv = Investors[numInvestors++];

    inv.addr = msg.sender;

    inv.amount = msg.value;

    totalAmount += inv.amount;

}


function checkGoalReached () public onlyOwner notEnded deadlineReached {

    if(totalAmount >= goalAmount) {

        status = ""Campaign Succeeded"";
        ended = true;

        
        require(owner.send(address(this).balance),""Not able to send funds to owner.""); 

        return;

    }   

    status = ""Campaign Failed"";
    ended = true;

    for(uint i = 0; i <= numInvestors; i++) {

        require(Investors[i].addr.send(Investors[i].amount));  

      } 
}

    function kill() public onlyOwner {

        selfdestruct(owner);

    }

}"
50542-0-0.sol,answer,"contract Garbage {
    address[3] public addresses;
    uint idx;

    function addAddress(address _address) public {
        require(idx < addresses.length);

        addresses[idx] = _address;
        idx++;
    }
}"
78984-0-0.sol,answer,"contract BreadCrumbs {

    uint public prevChange;

    event LogChange(string arg1, string arg2, string arg3. uint previous);

    function change(string memory _arg1, string memory _arg2, string memory _arg3) public {
        emit LogChange(_arg1, _arg2, _arg3, prevChange);
        prevChange = block.number;
    }

}"
72479-2-0.sol,answer,"contract feeBurningToken is ERC20Token {
  using SafeMath for uint;
  uint256 constant PRECISION = 10 ** 3;
  mapping(address => uint256) unpaidPreciseFees; 

  function transfer(address to, uint256 amount) {
    uint256 fee = feesToBurn(amount);
    super.transfer(bonfire, fee);
    super.transfer(to, amount - fee);
  }

  function transferFrom(address from, address to, uint256 amount) {
    uint256 fee = feesToBurn(amount);
    super.transferFrom(from, bonfire, fee);
    super.transferFrom(from, to, amount - fee);

  }

  function feesToBurn(uint256 amount) public returns (uint256 fee){

    uint256 fee = amount / 100;

    uint256 preciseFee = amount.mul(PRECISION) / 100;

    unpaidPreciseFees[destination] += preciseFee.mod(PRECISION);




    if (unpaidPreciseFees[destination] >= PRECISION) {
      unpaidPreciseFees[destination] -= PRECISION;
      fee++;
    }
    return fee;
  }
}"
5861-0-4.sol,answer,"contract TestModifier {

    string[] public messages;
    uint256 testVariable;

    function numberOfMessages() constant returns (uint256) {
        return messages.length;
    }

    modifier checkOne {
        messages.push(""checkOne - 1"");
        if (testVariable == 123) 
            throw;
        _
        messages.push(""checkOne - 2"");
        if (testVariable == 123) 
            throw;
    }

    modifier checkTwo {
        messages.push(""checkTwo - 1"");
        if (testVariable == 123) 
            throw;
        _
        messages.push(""checkTwo - 2"");
        if (testVariable == 123) 
            throw;
    }

    modifier checkThree {
        messages.push(""checkThree - 1"");
        if (testVariable == 123) 
            throw;
        _
        messages.push(""checkThree - 2"");
        if (testVariable == 123) 
            throw;
        _
        messages.push(""checkThree - 3"");
        if (testVariable == 123) 
            throw;
    }

    function test() checkOne checkTwo checkThree returns (uint256) {
        messages.push(""test - 1"");
        testVariable = 345;
        messages.push(""test - 2"");
        return testVariable;
    }
}"
11393-0-0.sol,answer,"contract Test is owned {
    function freezeAccount(address target, bool freeze) onlyowner {
       
    }
}"
25372-1-0.sol,answer,"contract C {
    string constant text = ""abc"";

    function getMystr() constant returns (string) {
        return mystr;
    }
}"
46318-0-3.sol,answer,"contract contractB {
  address tracker_0x_address = 0xd26114cd6EE289AccF82350c8d8487fedB8A0C07; 
  mapping ( address => uint256 ) public balances;

  function deposit(uint tokens) public {

    
    balances[msg.sender]+= tokens;

    
    ERC20(tracker_0x_address).transferFrom(msg.sender, address(this), tokens);
  }

  function returnTokens() public {
    balances[msg.sender] = 0;
    ERC20(tracker_0x_address).transfer(msg.sender, balances[msg.sender]);
  }

}"
795-0-0.sol,answer,"contract Twitter is accountProviderBase {
  Lookup lookup;

  address owner;

  modifier owneronly { if (msg.sender == owner) _ }

  function setOwner(address addr) owneronly {
    owner = addr;
  }

  function Twitter() {
    owner = msg.sender;
  }

  function setLookup(address addr) owneronly {
    lookup = Lookup(addr);
  }

  
  mapping (bytes32 => bytes32) expectedId;

  
  mapping (bytes32 => bool) isVerification;

  
  function __callback(bytes32 myid, string result, bytes proof) {
    if (msg.sender != oraclize_cbAddress()) throw;

    if (isVerification[myid])
      processVerification(myid, result);
    else
      processScore(myid, result);

    
    delete expectedId[myid];
    delete isVerification[myid];
  }

  function processScore(bytes32 myid, string result) internal {
    uint followers = parseInt(result);
    uint24 newScore = 1000000;
    if (followers / 10000 == 0)
      newScore = 100 * uint24(followers % 10000);

    Storage(lookup.addrStorage()).updateScore(lookup.accountProvider_TWITTER(), expectedId[myid], newScore);
  }

  
  function score(bytes32 id, string userId) coupon(""HackEtherCamp"") {
    bytes memory _userId = bytes(userId);
    string memory head = ""html(https:
    bytes memory _head = bytes(head);
    string memory tail = "").xpath(
    bytes memory _tail = bytes(tail);
    string memory query = new string(_head.length + _userId.length + _tail.length);
    bytes memory _query = bytes(query);
    uint i = 0;
    for (uint j = 0; j < _head.length; j++)
      _query[i++] = _head[j];
    for (j = 0; j < _userId.length; j++)
      _query[i++] = _userId[j];
    for (j = 0; j < _tail.length; j++)
      _query[i++] = _tail[j];
    oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
    bytes32 oraclizeId = oraclize_query(""URL"", query);
    expectedId[oraclizeId] = id;
    isVerification[oraclizeId] = false;
  }

  function processVerification(bytes32 myid, string result) internal {
    
    string memory expected = iudexIdToString(expectedId[myid]);
    bool asExpected = indexOf(result, expected) > -1;
    Storage(lookup.addrStorage()).updateAccount(lookup.accountProvider_TWITTER(), expectedId[myid], asExpected, myid);
  }

  
  function verifyUrl(string userId, string proofLocation) internal returns (bool){
    bytes memory _userId = bytes(userId);
    string memory twitterPrefix = "":
    bytes memory _twitterPrefix = bytes(twitterPrefix);
    string memory urlHead = new string(_twitterPrefix.length + _userId.length + 1);
    bytes memory _urlHead = bytes(urlHead);
    uint i = 0;
    for (uint j = 0; j < _twitterPrefix.length; j++)
      _urlHead[i++] = _twitterPrefix[j];
    for (j = 0; j < _userId.length; j++)
      _urlHead[i++] = _userId[j];
    _urlHead[i++] = byte(""/"");

    if (indexOf(proofLocation, string(_urlHead)) == -1)
      return false;

    return true;
  }

  
  function verify(bytes32 id, string userId, string proofLocation) coupon(""HackEtherCamp"") {
  

    
    if (!verifyUrl(userId, proofLocation))
      throw;

    
    string memory head = ""html("";
    bytes memory _head = bytes(head);
    string memory tail = "").xpath(
    bytes memory _tail = bytes(tail);

    bytes memory _tweetUrl = bytes(proofLocation);

    string memory query = new string(_head.length + _tail.length + _tweetUrl.length + 2);
    bytes memory _query = bytes(query);
    uint i = 0;
    for (uint j = 0; j < _head.length; j++)
      _query[i++] = _head[j];
    for (j = 0; j < _tweetUrl.length; j++)
      _query[i++] = _tweetUrl[j];
    for (j = 0; j < _tail.length; j++)
      _query[i++] = _tail[j];
    _query[i++] = 0;

    oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
    bytes32 oraclizeId = oraclize_query(""URL"", query);
    expectedId[oraclizeId] = id;
    isVerification[oraclizeId] = true;
  }
}"
30887-0-0.sol,answer,"contract SimpleReturn {
    bool value = false;

    function get() public constant returns (bool) {
      return value;
    }
  }"
79791-0-0.sol,answer,"contract TestArray {
    mapping(uint => uint[]) users;

    function addUser(uint _id, uint[] memory _users) public {
        users[_id] = _users;   
    }

    function getUsers(uint _id) public view returns(uint[] memory){
        return users[_id];
    }

    function emptyUsers(uint _id) public {
        uint[] memory empty;
        users[_id] = empty;
        
        
    }
}"
3511-0-0.sol,answer,"contract TwoStructs {
    struct A {
        address[] count;
    }
    struct B {
        uint8[] count;
    }

    mapping (address => A) a;
    mapping (address => B) b;

    function add(address c, uint8 g) {
        a[msg.sender].count.push(c);
        b[msg.sender].count.push(g);
    }

    function get1(address sender) constant returns (address, uint8) {
        return (a[sender].count[0], b[sender].count[0]);
    }

    function get2() constant returns (address, uint8) {
        return (a[msg.sender].count[0], b[msg.sender].count[0]);
    }

    function getMsgSender() constant returns (address) {
        return msg.sender;
    }
}"
28217-0-0.sol,answer,"contract X {

    struct Voter {
        bytes32 data;
        uint amount;
    }
    mapping(address => Voter) voter;
    address[] voterIndex;
    uint voter_count;

    event Deposit(address a, uint b);

    function sendEther(bytes32 data) public payable  {
      address sender = msg.sender;
      uint value = msg.value;
      voter[sender].data = data;
      voter[sender].amount = value;
      voterIndex[voter_count] = sender;
      voter_count = voter_count + 1;
      Deposit(sender, value);
    }

}"
2417-0-0.sol,answer,"contract rainbowCoin {
mapping (address => mapping (uint => uint)) balances;
function rainbowCoin() {
    balances[msg.sender][0] = 10000; 
    balances[msg.sender][1] = 10000; 
    balances[msg.sender][2] = 10000; 
    balances[msg.sender][3] = 10000; 
    balances[msg.sender][4] = 10000; 
    balances[msg.sender][5] = 10000; 
    balances[msg.sender][6] = 10000; 
}
function sendCoin(address receiver, uint amount, uint coin) returns(bool successful) {
    if (balances[msg.sender][coin] < amount) return false;
    balances[msg.sender][coin] -= amount;
    balances[receiver][coin] += amount;
    return true;
}"
77232-0-0.sol,answer,"contract test3 {
    constructor(address[] memory _user_addresses) public {
        usersAddresses = _user_addresses;
    }

    struct User {
        string name; 
        uint tokens;
        bool isValid;
    }

    mapping(address => User) users;
    address[] public usersAddresses;

    function checkUser(address _user_address) public returns(uint) {
        return users[_user_address].tokens;
    }

    function freeTokens() public {
       uint reciversLength = usersAddresses.length;
       for (uint i = 0; i < reciversLength; i++) {
           User storage theUser = users[usersAddresses[i]];
           theUser.tokens += 10000;
       }
    }

    function freeTokensSingle(address _user_address) public {
       User storage theUser = users[_user_address];
       theUser.tokens += 10000;
    }
}"
21469-0-0.sol,answer,"contract MarketMaker {
    address iplogic;
    address ipxaddr;

    event log(address ipx);

    function MarketMaker(address _iplogic, address _ipx) {
        iplogic = _iplogic;
        ipxaddr = _ipx;
        log(ipxaddr);
        log(iplogic);
    }

    function createNewMarket(string prop, uint256 minBet, bool initUtility) returns (address, address) {
        log(ipxaddr);
        log(iplogic);
    }
}"
52277-0-1.sol,answer,"contract MyToken {

    struct Certificate {
      uint64 certificateId;
      uint64 meterId;
      uint32 timestamp;
      uint48 value;
      address[] owners;
      mapping (address => uint48) ownershipSplit;
      bool burned;
    }

    mapping (uint64 => Certificate) public certificates;
    uint64 public numCertificates = 1;

    function MyToken() public {
      
    }

    function produceCertificate(
      uint64 meterId,
      uint32 timestamp,
      uint48 value,
      address owner
      ) public {
        
        
        Certificate storage newCertificate = certificates[numCertificates];
        newCertificate.meterId = meterId;
        newCertificate.timestamp = timestamp;
        newCertificate.value = value;
        newCertificate.owners.push(owner);
        newCertificate.ownershipSplit[owner] = value;
        newCertificate.burned = false; 
        newCertificate.certificateId = numCertificates;
        numCertificates= numCertificates +1;
    }

}"
79637-0-0.sol,answer,"contract ArrayStuff {

  bytes32[] d;

  function makeHuge() public {
      uint massive = uint(0)-uint(1); 
      d.length = massive;
  }
}"
71060-0-0.sol,answer,"contract C1 {
    function pay(address whoToPay) external payable {
        require(whoToPay.send(msg.value)); 

        
    }

    function getBoolValue() external pure returns (bool) {
        return true;
    }
}"
71060-0-0.sol,answer,"contract C2 {
    function() external payable {
        if (C1(msg.sender).getBoolValue()) { ... }
    }
}"
71618-0-0.sol,answer,"contract Signed1 {
    uint val = 0;
    mapping (address => bool) transferred;

    function withdrawOnce(int amount) public returns (uint) {
        require(amount > 0, 'only postive amount');
        require(transferred[msg.sender] == false, 'withdraw only once');
        transferred[msg.sender] = true;
        msg.sender.transfer(uint(amount));
    }

}"
72333-0-0.sol,answer,"contract NewHello {

    mapping(address => string) public users; 

    function updateUser(string memory name) public {
        require(keccak256(abi.encodePacked(name)) != keccak256(abi.encodePacked(users[msg.sender])));
        users[msg.sender] = name; 
    }

    function getUser(address userAddress) public view returns(string memory) {
        return users[userAddress]; 
    }
}"
4102-0-2.sol,answer,contract Test {  function double(int a) constant returns(int) { return 2*a; } }
67799-1-0.sol,answer,"contract EthereumLottery {

    uint[6] array;
    uint[6] winners;
    string warning = ""please be sure to bet below 67 for the first 5 balls and 34 for the 6th"";
    address owner;
    uint addr = address(this).balance;
    uint nonce = 1;
    uint startTime = now;
    int8 fdsa;              

    constructor() public {
      owner = msg.sender;
    }

    function WARNING() public view returns (string memory) {
        return warning;
    }

    function PickYourNumbers(uint8 firstBall, uint8 secondBall, 
      uint8 thirdBall, uint8 fourthBall, 
      uint8 fithBall, uint8 powerballllll) public {
        if (firstBall <= 66) array[0] = firstBall;
        if (secondBall <= 66) array[1] = secondBall;
        if (thirdBall <= 66) array[2] = thirdBall;
        if (fourthBall <= 66) array[3] = fourthBall;
        if (fithBall <= 66) array[4] = fithBall;
        if (powerballllll <= 66) array[5] = powerballllll;
    }

    function GetHash() public view returns (uint[6] memory) {
        return array;
    }

                   
    function StartTheLotto(int8 asdf) public returns (uint[6] memory) {
        fdsa = asdf; 
        nonce++;
        winners[0] = random();
        nonce++;
        winners[1] = random();
        nonce++;
        winners[2] = random();
        nonce++;
        winners[3] = random();
        nonce++;
        winners[4] = random();
        nonce++;
        winners[5] = random();
    }


    function lottoWinners() public view returns (uint[6] memory) {
        return winners;
    }

    function random() private view returns(uint) {

        uint interval = now - startTime;

        bytes32 randomNum = keccak256(abi.encodePacked(interval + nonce + tx.gasprice + addr));

        uint number;
        for(uint i=0;i<randomNum.length;i++){
            number = number + uint(randomNum[i])*(2**(8*(randomNum.length-(i+1))));
        }
        return number % 67;
    }

}"
76502-1-0.sol,answer,"contract BaseContract is IBaseContract {
    function func(uint _x) external view returns (bool) {
        return _x == 1;
    }
}"
76502-1-0.sol,answer,"contract DerivedContract is BaseContract {
    uint public x;
    function func(uint _x) external view returns (bool) {
        return _x == x;
    }
}"
59132-0-0.sol,answer,"contract A {
    function deployB() public payable returns (address) {
        B instance = (new B).value(msg.value)(42); 
        return instance;
    }
}"
59132-0-0.sol,answer,"contract B {
    uint public num;
    constructor(uint _num) public payable {
        require(msg.value > 0); 
        num = _num; 
    }
}"
41739-0-0.sol,answer,"contract Original {
  mapping(bytes32 => Person) public persons;
}"
41739-0-0.sol,answer,"contract SecondContract {
  Original original;

  function SecondContract(address ofOriginalContract) {
    original = Original(ofOriginalContract);
  }

  function processData(bytes32 someBytes) {
    Person entry = original.persons[someBytes];
    
  }
}"
61098-0-0.sol,answer,"contract TokenExchange {
    IERC20 token1;
    IERC20 token2;
    address owner;
    uint exchangeRate;
    
    address trnFrom;
    uint trnAmount;

    constructor() public {
        token1 = IERC20(0x508ce9c3c5219fc1cd08a448a247c08c707c6eb1);
        token2 = IERC20(0xf5de6643a3e30462e0ef34dc3fb3905a7824043b);
        owner = msg.sender;
        exchangeRate = 2;
    }

    function askConversionTNK1toTKN2 (uint256 _amount) public {
        trnFrom = msg.sender;
        trnAmount = _amount;
    }

    function executeConversionTKN1toTKN2 () public { 
        token1.transferFrom(trnFrom, this, trnAmount);
        token2.transfer(trnFrom, trnAmount*exchangeRate);
    }
}"
6676-0-2.sol,answer,"contract SomeTest {
    

    modifier requiresFee() {
        if (msg.value < computeFee()) { throw; }
        _
    }

    
    function computeFee() internal returns (uint) {
        
    }

    function sellEnergy(uint kwh) public requiresFee() {
        coinAccount[msg.sender] += (kwh * kWh_rate);
    }
}"
72213-1-0.sol,answer,"contract Array {

    uint[] arr;   
    uint[2] arr2; 



    
    function setDynArrayElement() public {
        arr.push(2);
        arr.push(3);
        arr.push(4);
    }

    
    function getDynArrayLength() public view returns (uint _l) {
        assembly {
            _l := sload(0)
        }
    }

    
    function getDynElement(uint i) public view returns (uint _x) {
        assembly {
            _x := sload(add(keccak256(sload(0), 32),i))
        }
    }



    
    function setFixnArrayElement() public {
        arr2[0]= 5;
        arr2[1]= 6;
    }

    
    function getFixElement() public view returns (uint _value1, uint _value2) {
        assembly {
            _value1 := sload(1)
            _value2 := sload(2)
        }
    }



    
    function getFixMemoryArrayElement(uint i) public pure returns (uint _l) {
        uint[2] memory arr3;
        arr3[0] = 7;
        arr3[1] = 8;
        assembly {
            _l := mload(add(arr3,mul(i,0x20)))
        }
    }

    function getFixMemoryArrayLen() public pure returns (uint _l) {
        uint[] memory arr4 = new uint[](10);
        assembly {
            _l := mload(arr4)
        }
    }
    function getFixMemoryArrayElement_2(uint i) public pure returns (uint _l) {
        uint[] memory arr4 = new uint[](5);
        arr4[0] = 9;
        arr4[1] = 10;
        assembly {
            _l := mload(add(arr4,mul(i,0x20)))
        }
    }
}"
28662-0-0.sol,answer,"contract Contract_B {

    address public c_addr;
  uint public val;
  function Contract_B(){
   val=7;}
   function change(){
   val+=90;}

   function create() {

    Contract_C cc = new Contract_C();
    c_addr = address(cc); 

   }
}"
28662-0-0.sol,answer,"contract Contract_C {

    
}"
34145-0-2.sol,answer,"contract MrHungry {

    uint oranges = 2;
    uint apples = 0;

    modifier checkOrangeStock() {
        require(oranges > 0);
        _;
    }

    modifier checkAppleStock() {
        require(apples > 0);
        _;
    }

    function eatStuff() public {
        eatOranges();
        eatApples();
    }

    function eatOranges() private checkOrangeStock {
        oranges--;
    }

    function eatApples() private checkAppleStock {
        apples--;
    }
}"
42445-1-0.sol,answer,"contract Test {
  address[] a;
  address[] b;

  function testFeature() {
    
  }
}"
38718-1-0.sol,answer,"contract A {
function sendtoken() payable returns(bool) {
      require(msg.value!=0);
      owner.transfer(msg.value);
      balances[msg.sender]+= 1;
      balances[owner]-= 1;
      return true;
 }
}"
73041-1-0.sol,answer,"contract Stages {

    struct Stage {
        uint first;
        uint last;
    }

    Stage[] public stages;

    function appendStage(uint first, uint last) public {
        Stage memory s = Stage({
            first: first,
            last: last
        });
        stages.push(s);
    }

    function isStage(uint i) public view returns(bool) {
        return block.number >= stages[i].first && block.number <= stages[i].last;
    }

    
}"
2609-1-6.sol,answer,"contract random {
    
    function randomGen(uint seed) constant returns (uint randomNumber) {
        return(uint(sha3(block.blockhash(block.number-1), seed ))%100);
    }

    
    function multiBlockRandomGen(uint seed, uint size) constant returns (uint randomNumber) {
        uint n = 0;
        for (uint i = 0; i < size; i++){
            if (uint(sha3(block.blockhash(block.number-i-1), seed ))%2==0)
                n += 2**i;
        }
        return n;
    }
}"
15663-0-0.sol,answer,"contract Test {
  uint public myVal;

  modifier onlySelf(){
      if (msg.sender != address(this)) throw;
      _;
  }

  function callIt() {
      this.call.gas(50000)(bytes4(sha3(""setMyVal(uint256)"")), 123);
  }

  function setMyVal(uint _newVal) onlySelf {
      myVal = _newVal;
  }
}"
73024-0-0.sol,answer,"contract Animals {

    enum Branch {mammal, bird, fish, insect}
    enum Diet {carnivore, herbivore, onmivore}

    struct Animal {
        
        Branch branch;
        Diet diet;
    }

    mapping(bytes32 => Animal) public animals;

    function setAnimal(bytes32 id, Branch branch, Diet diet) public {
        Animal storage a = animals[id];
        a.branch = branch;
        a.diet = diet;
    }

    function animalIsBranch(bytes32 id, Branch branch) public view returns(bool isIndeed) {
        return animals[id].branch == branch;
    }
    function animalIsDiet(bytes32 id, Diet diet) public view returns(bool isIndeed) {
        return animals[id].diet == diet;
    }

    
    function carnivoreFish(bytes32 id) public view returns(bool isIndeed) {
        return animalIsBranch(id, Branch.fish) && animalIsDiet(id, Diet.carnivore);
    }
    
}"
13677-0-0.sol,answer,"contract Demo {
    address public user;
    uint public i = 0;

    function Demo() {
        user=msg.sender;
    }

    address[10] users;
    bytes32[10] name;

    function add(bytes32 _name) {
        users[i] = user;
        name[i] = _name;
        i++;
    }

    function get_names() constant returns(bytes32[10]) {
        return name;
    }

    function get_address() constant returns(address[10]) {
        return users;
    }
}"
54387-1-0.sol,answer,"contract Holdem {

    mapping(address => uint) public balances;

    event LogDeposit(address sender, uint amount);
    event LogWithdrawal(address receiver, uint amount);
    event LogTransfer(address sender, address receiver, uint amount);

    function depost() public payable {
        balances[msg.sender] += msg.value;
        emit LogDeposit(msg.sender, msg.value);
    }

    function withdraw(uint amount) public {
        uint bal = balances[msg.sender];
        require(bal >= amount, ""Insufficient Funds."");
        balances[msg.sender] -= amount;
        emit LogWithdrawal(msg.sender, amount);
        msg.sender.transfer(amount);
    }

    function transfer(uint amount, address receiver) public {
        uint bal = balances[msg.sender];
        require(bal >= amount, ""Insufficient Funds."");
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        emit LogTransfer(msg.sender, receiver, amount);
    }

}"
56969-2-1.sol,answer,"contract MyToken {
    string public name;
    string public symbol;
    uint8 public decimals;

    mapping (address => uint256) public balanceOf;
    event Transfer(address _from, address _to, uint _value);

    constructor(string memory tokenName, string memory tokenSymbol, uint8 decimalUnits, uint256 initialSupply) public {
        name = tokenName;
        symbol = tokenSymbol;
        decimals = decimalUnits;
        balanceOf[msg.sender] = initialSupply;
        }

    function transfer(address _to, uint256 _value) public {
        require(_value <= balanceOf[msg.sender]);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
        emit Transfer(msg.sender, _to, _value);
    }
}"
7488-0-2.sol,answer,"contract OwnedToken {    TokenCreator public creator; address public owner; string public name;   function OwnedToken(string _name) { owner = msg.sender;     creator = TokenCreator(msg.sender); name = _name; } function changeName(string newName) {    if (msg.sender == address(creator)) name = newName; } function transfer(address newOwner) {  if (msg.sender != owner)  return;      if (creator.isTokenTransferOK(owner, newOwner)) owner = newOwner; }}"
7488-0-2.sol,answer,"contract TokenCreator { mapping(string => address) addresses; function getAddress(string name) constant returns (address) { return addresses[name]; } function createToken(string name) returns (OwnedToken tokenAddress) {     tokenAddress = new OwnedToken(name); addresses[name] = tokenAddress; } function changeName(string oldName, string newName) {   address tokenAddress = addresses[oldName]; delete addresses[oldName]; addresses[newName] = tokenAddress; OwnedToken(tokenAddress).changeName(newName); } function isTokenTransferOK( address currentOwner, address newOwner ) returns (bool ok) {  address tokenAddress = msg.sender; return (sha3(newOwner) & 0xff) == (bytes20(tokenAddress) & 0xff); }}"
63433-0-0.sol,answer,"contract Another {
    uint public balance;
    function sendToAnother() public returns (bool success) {
        balance += 10;
        return true;
    }
}"
82032-0-0.sol,answer,"contract IA {
    function setNumber(uint n) public;
}"
82032-0-0.sol,answer,"contract B {
    IA public a;    
    function setContract(IA _a) public {
        a = _a;
    }   
    function setNumber() public {
        a.setNumber(10);
    }
}"
77588-0-0.sol,answer,"contract MappingStructArray {

    struct S1 {
        uint a;
        bool b;
    }

    struct S2 {
        mapping(uint => S1[]) s1Arrays;
    }

    mapping(uint => S2) S2Structs;

    function pushS1(uint key, uint g, uint a, bool b) public {
        S2 storage s2 = S2Structs[key];
        S1 memory s1 = S1({
            a: a,
            b: b
        });
        s2.s1Arrays[g].push(s1);
    }
}"
12519-0-0.sol,answer,"contract HelloFactory {
    event CreatedHS(address indexed hsAddr);

    function createHS() returns (address hsAddr) {
        HelloSystem hs = new HelloSystem();
        CreatedHS(hs);
        return hs;
    }

    function deleteHS(address hs){
        HelloSystem(hs).remove();
    }

}"
57347-0-0.sol,answer,"contract Base {
    bool public active;

    modifier canSetMetadata() {
        require(canSetMetadata_());
        _;
    }

    function canSetMetadata_() internal view returns (bool) {
        return (active == false);
    }
}"
57347-0-0.sol,answer,"contract BaseWithMetadataControl is Base {
    address public metadataControl;

    function canSetMetadata_() internal view returns (bool) {
        if(msg.sender != metadataControl) {
            return super.canSetMetadata_();
        } else {
            return true;
        }
    }
}"
48880-0-0.sol,answer,"contract V {
    Random api = Random(0xAddress);

    function roll(uint guess) public payable {
        if (api.random(6) == guess) {
            msg.sender.transfer(msg.value * 2);
        }
    }
}"
8974-0-0.sol,answer,"contract MembersMODDED {

    mapping (address => uint) public memberId;
    mapping (uint => Member) public members; 

    struct Member {  
        string Name;
        string SurName;
        address MemberAccountNo;
        bool IsActive;
        int AccountType;
        uint MemberNo;
        uint memberSince;
    }

    function MembersMODDED( ) { 
        memberId[12345] = 0;
    }

    function changeMembership(address memberAccountNo, bool isActive, string name, 
    string surName,int accountType,uint memberNo) {
        uint id;
        if (memberId[memberAccountNo] == 0) {
            memberId[memberAccountNo] = memberNo;
            id = memberNo;
            members[id] = Member({MemberAccountNo: memberAccountNo, IsActive: isActive, memberSince: now, Name: name, SurName: surName, AccountType: accountType, MemberNo: memberNo});
        } else {
            id = memberId[memberAccountNo];
            Member m = members[id];
            m.IsActive = isActive;
            m.Name = name;
            m.SurName = surName;
        }  
    }
}"
8201-0-0.sol,answer,"contract AbstractB {
    function getX() returns(uint) {
        return 3;
    }
}"
8201-0-0.sol,answer,"contract A {
    function makeCall(address addressB) returns(uint) {
        return AbstractB(addressB).getX.gas(1000)();
    }
}"
19380-1-0.sol,answer,"contract Test {

    
    function test(uint[20] a) public returns (uint) {
        return a[10] * 2;
    }

    
    function test(uint[20] a) external returns (uint) {
        return a[10] * 2;
    }


    
    function test(uint[20] a) internal returns (uint) {
        return a[10] * 2;
    }
}"
71712-0-0.sol,answer,"contract CrowdFactory {    
  function executeGetInfo (uint _userId) {
    
    ClientSc sc = usersinfo[msg.sender];
    
    var (userId, mail, password, contractAddress, publickey, ...) = sc.getMyInfo()
  }
}"
43458-1-0.sol,answer,"contract MyToken {
    
    mapping (address => uint256) public balanceOf;

    
    function MyToken(
        uint256 initialSupply
        ) {
        balanceOf[msg.sender] = initialSupply;              
    }

    
    function transfer(address sender, address _to, uint256 _value) {
        require(balanceOf[sender] >= _value);           
        require(balanceOf[_to] + _value >= balanceOf[_to]); 
        balanceOf[sender] -= _value;                    
        balanceOf[_to] += _value;                           
    }
}"
43458-1-0.sol,answer,"contract MyTokenI {function transfer(address sender, address _to, uint256 _value) public; }"
43458-1-0.sol,answer,"contract ADTest {

    
    MyTokenI myToken;

    
    function ADTest(address _myToken) public {
        
        myToken = MyTokenI(_myToken);
    }

    function CallTransfer(address _to, uint256 _value) public {
        
        myToken.transfer(msg.sender, _to, _value);
    }

}"
60695-0-0.sol,answer,"contract FunWithArrays {

  struct Project{
    int id;
    string name;
    int votes;    
    address[] voters;
    string[] comments;
  }

  Project[] public projects;

  function vote(uint index , string comment) public {
    Project storage project = projects[index];
    project.votes++;     
    project.voters.push(msg.sender);
    project.comments.push(comment); 
  }
}"
2404-7-0.sol,answer,"contract SomeRegister {
    address backendContract;
    address[] previousBackends;
    address owner;

    function SomeRegister() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner)
        _;
    }

    function changeBackend(address newBackend) public
    onlyOwner()
    returns (bool)
    {
        if(newBackend != backendContract) {
            previousBackends.push(backendContract);
            backendContract = newBackend;
            return true;
        }

        return false;
    }
}"
7678-0-2.sol,answer,"contract PubKey {
     bytes32 pubKeyHalf1, pubKeyHalf2;

     function PubKey(bytes32 initKeyHalf1, bytes32 initKeyHalf2) {
         pubKeyHalf1 = initKeyHalf1;
         pubKeyHalf2 = initKeyHalf2;
     }

     function getPubKeyHalf1() constant returns (bytes32) {
        return pubKeyHalf1;
     }

     function getPubKeyHalf2() constant returns (bytes32) {
        return pubKeyHalf2;
     }
}"
58794-0-1.sol,answer,"contract Test {
    function addTest() public pure returns (byte c1, byte c2, byte c3) {
        
        bytes memory b = new bytes(169);
        b[0] = byte(59);
        b[1] = byte(42);
        b[2] = byte(99);

        assembly {
            
            
            let data32b := mload(add(b, 0x20))
            c1 := data32b
            
            c2 := mul(data32b, 256)
            
            c3 := mul(data32b, exp(256, 2))
        }
    }
}"
40769-0-2.sol,answer,"contract MyContract {
    function myFunction(MethodStringInterface _a) {
        _a.method(""abc"");
    }
}"
18003-1-0.sol,answer,"contract Registry {
  mapping (bytes32 => address) public libraries;
  mapping (bytes32 => address) public contracts;

    function addLibrary(bytes32 _name, address _lib) external {
    require(libraries[_name] == address(0), ""LIBRARY_ALREADY_EXISTS"");
    require(_lib != address(0), ""INSERT_VALID_LIBRARY_ADDRESS"");
    libraries[_name] = _lib;
  }

  function addContract(bytes32 _name, address _contract) external {
    Enabled(_contract).setCMCAddress(address(this));
    contracts[_name] = _contract;
  }
}"
18003-1-0.sol,answer,"contract Enabled {
  address public CMC;
  function setCMCAddress(address _CMC) external {
    if (CMC != 0x0 && msg.sender != CMC) {
        revert();
    } else {
        CMC = _CMC;
    }
  }
}"
18003-1-0.sol,answer,"contract setXproxy is Enabled {
  function () payable public {
    address _impl =  ContractProvider(CMC).libraries('setXlib');
    require(_impl != address(0));
    assembly {
      let ptr := mload(0x40)
      calldatacopy(ptr, 0, calldatasize)
      let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)
      let size := returndatasize
      returndatacopy(ptr, 0, size)
      switch result
      case 0 { revert(ptr, size) }
      default { return(ptr, size) }
    }
  }
}"
18003-1-0.sol,answer,"contract setXstorage is Enabled {
    using setXinterface for setXinterface.X;
    setXinterface.X X;
    function setX(uint _x) external {
        X.setX(_x);
    }

    function getX() external view returns (uint) {
      return X.x;
    }
}"
22890-2-0.sol,answer,"contract Test {

    address da;

    function Test() public {
        da = msg.sender;
    }

    function getSender () public view returns (address){
        return da;
    }
}"
17558-0-1.sol,answer,"contract MainContract {
    function getBalanceInEth() returns (uint256) {
        return Converter.weiToEther(this.balance);
    }
}"
49407-0-4.sol,answer,"contract MetaCoin {
          struct  Entity {
                   string name;
                   string nickname;
                   string streetaddress;
          }
          mapping (uint => Entity) public entities;
          uint entitiesCount;
          event EntityAdded(address indexed _senderAddress, uint _entityId);

          function addEntity(string _name, string _nickname, string _streetaddress) returns(uint entityCount) {
                
                entitiesCount++;
                entities[entitiesCount]=Entity(_name,_nickname,_streetaddress);
                EntityAdded(msg.sender,entitiesCount);
          }
     }"
42715-0-12.sol,answer,"contract Numbers {
    int[] public numbers;

    function Numbers() public {
        numbers.push(20);
        numbers.push(32);
    }

    function changeArray() private {

    }
}"
28689-0-0.sol,answer,"contract C {
  function doSomething(uint x, uint y) public returns (uint) {
    return Helper.add(uint x, uint y);
  }
}"
66686-0-0.sol,answer,"contract SuperClassParent {

    event LogSender(address sender, address origin, address me);

    function lookWhosTalking() public returns(address) {
        emit LogSender(msg.sender, tx.origin, address(this));
        return msg.sender;
    }

}"
66686-0-0.sol,answer,"contract SubClassChild is SuperClassParent {

    

    

    function rightHere() public returns(address) {
        emit LogSender(msg.sender, tx.origin, address(this));
        return msg.sender;
    }

}"
62430-0-0.sol,answer,"contract ExampleTwo {

  IExampleOne exampleOne;

  constructor(address _exampleOne) {
    exampleOne = IExampleOne(_exampleOne);
  }

  function func(bytes32 name) {
    (bytes32 a, bytes32 b, bytes32[] memory c, uint d) = exampleOne.problems(name); 
    
  }
}"
59612-0-0.sol,answer,"contract PublicArray {
   uint256[8] public array;
}"
59612-0-0.sol,answer,"contract InvalidAccess {  
    PublicArray array_contract;
    constructor() {
         array_contract = PublicArray.at(0x(...))
    }

    function go() {
       return array_contract.array[1000];
    }
}"
19685-0-1.sol,answer,"contract Example {
    function testRecovery(bytes32 h, uint8 v, bytes32 r, bytes32 s) returns (address) { 
        
        
        

        address addr = ecrecover(h, v, r, s);

        return addr;
    }
}"
16673-0-1.sol,answer,"contract Test {
    uint public myArray;

    function Test() public {
        myArray.push(1);
        myArray.push(10);
        myArray.push(30);
    }

    function getArrayLength() public view returns (uint) {
        return myArray.length;
    }

    function getFirstElement() public view returns (uint) {
        return myArray[0];
    }"
46789-0-0.sol,answer,"contract Spoke {

    string public storedString;

    event LogSetHubString(address sender, string _string);

    function setString(string _string) public returns(bool success) {
        emit LogSetHubString(msg.sender, _string);
        storedString = _string;
        return true;
    }

}"
46789-0-0.sol,answer,"contract Hub is Owned {

    address[] public spokes;
    mapping(address => bool) public isSpoke;

    event LogNewSpoke(address sender, address spoke);

    constructor() public { owner = msg.sender; }

    function getSpokeCount() public view returns(uint count) { return spokes.length; }

    function newSpoke() public onlyOwner returns(address newContract) {
        Spoke s = new Spoke();
        spokes.push(address(s));
        isSpoke[address(s)] = true;
        emit LogNewSpoke(msg.sender, address(s));
        return address(s);
    }

}"
25464-0-0.sol,answer,"contract Voting {

  mapping (bytes32 => uint8) public votesReceived;
  mapping (bytes32 => bool) public candidateList;

  function Voting(bytes32[] candidateNames) {
    for(uint i = 0; i < candidateNames.length; i++) {
      candidateList[candidateNames[i]] = true;
    }
  }

  function totalVotesFor(bytes32 candidate) constant returns (uint8) {
    require(validCandidate(candidate));
    return votesReceived[candidate];
  }

  function voteForCandidate(bytes32 candidate) {
    require(validCandidate(candidate) == true);
    votesReceived[candidate] += 1;
  }

  function validCandidate(bytes32 candidate) constant returns (bool) {
    return candidateList[candidate];
  }

}"
65151-0-1.sol,answer,"contract delegatedcalled {      
  address public callerAddress;
  uint public number;
function setNumber(uint _number) {
    number = _number;
    callerAddress = msg.sender;
  }
}"
8207-0-0.sol,answer,"contract AddressStore {
    address[] public bought;

    
    function setStore(address[] _addresses) public {
        bought = _addresses;
    }
}"
71881-1-0.sol,answer,"contract Escrow {

    mapping(address => uint256) public payments;
    mapping(address => uint256) public released;
    mapping(address => uint256) public transferred;
    address public owner;

    constructor() public {
        owner = msg.sender;
    }
    function payInto() payable {
        require(msg.value > 0, 'Sender attempted to pay zero amount.');
        require(payments[msg.sender] == 0, 'Sender previously paid into escrow.');
        payments[msg.sender] = msg.value;
    }

    function release() {
        require(payments[msg.sender] > 0, 'Sender has not paid into escrow.');
        require(released[msg.sender] == 0, 'Sender has already released funds.');
        released[msg.sender] = payments[msg.sender];
    }

    function safeWithdraw(address buyer) {
        require(msg.sender == owner, 'Non-owner tried to withdraw funds.');
        require(released[buyer] > 0, 'No released funds from buyer to withdraw.');
        require(transferred[buyer] == 0, 'Re-entrancy attempt during withdrawal.');
        transferred[buyer] = released[buyer];
        owner.transfer(released[buyer]);
    }
}"
72641-0-0.sol,answer,"contract Test {

    function comparePoints (uint player1Points, uint player2Points) public pure returns (uint) {
        uint result;

        if(player1Points > player2Points || player1Points >= 50){
            result = 1;
        }
        return result;
    }
}"
16873-0-0.sol,answer,"contract Test {
    function getSha256(uint32 nonce) constant returns (bytes32 hash) {
        return sha256(nonce);
    }
}"
65837-0-0.sol,answer,"contract Workload {

address payable public receiver;

constructor(address payable _receiver) public {
    receiver = _receiver;
}

event Sent();


function getBalance(address _from) public view returns (uint256) {
    return address(_from).balance;
}


function getSender() public view returns (address){
    return address(msg.sender);
}


function send() public payable {
    require(msg.value > 0);
    address payable sender = msg.sender;
    require(msg.value <= sender.balance, ""Insufficient balance."");
    receiver.transfer(msg.value);
    emit Sent();
}
}"
10973-0-2.sol,answer,"contract Hub {

    event LogNewAuction(address auction);

    function newSimpleAuction(uint duration) returns(address createdAuctionContract) {
        SimpleAuction newSimpleAuction = new SimpleAuction(duration, msg.sender);
        LogNewAuction(newSimpleAuction);
        return newSimpleAuction;
    }
}"
74391-0-0.sol,answer,"contract newInstance {

 mapping(address=>address) public userContracts;

  function newInstanceFunc(address _address) public returns(address) {
    ContractToBeInstanced T = new ContractToBeInstanced(_address);
    address deployedAddress = address(T);
    userContracts[_address] = deployedAddress;
    return deployedAddress;
  }
}"
15364-2-0.sol,answer,"contract test {

  function test() {
  }

  function verify(bytes32 _message, uint8 _v, bytes32 _r, bytes32 _s) constant returns (address) {
    bytes memory prefix = ""\x19Ethereum Signed Message:\n32"";
    bytes32 prefixedHash = sha3(prefix, _message);
    address signer = ecrecover(prefixedHash, _v, _r, _s);
    return signer;
  }
}"
11743-0-0.sol,answer,"contract ECVerify {
    function ecverify(bytes32 hash, bytes sig, address signer) returns (bool);
}"
11743-0-0.sol,answer,"contract Foo {
    ECVerify ecv = ECVerify(0x3bbb367afe5075e0461f535d6ed2a640822edb1c);

    function callEcv(bytes32 hash, bytes sig, address signer) {
        bool b = ecv.ecverify(hash, sig, signer);
        
    }
}"
34024-2-1.sol,answer,"contract Voting {
address[100] public voters;


function vote(uint voterId) public view returns (uint) {
  require(alreadyVoted(voteId));

  voters[voterId] = msg.sender;

  return voterId;
}


function getVoters() public returns (address[16]) {
  return voters;
}
}"
9213-1-1.sol,answer,"contract Test {
    function testit(address a) {
        if (!a.send(123))
            throw;
    }
}"
33011-0-0.sol,answer,"contract BaseLookup {

  struct Lookup {
    uint id;
    bytes32 name;
  }

  mapping(uint => Lookup) lookupById;

  function setLookupById(uint id, bytes32 name) public returns(bool success) {
    Lookup memory lookup;
    lookup.id = id;
    lookup.name = name;
    lookupById[id] = lookup;
    return true;
  }

  function getLookupById(uint _id) public constant returns (uint, bytes32) {
    return (lookupById[_id].id, lookupById[_id].name);
  }
}"
33011-0-0.sol,answer,"contract ClientLookup {

  BaseLookup b;

  function DerivedLookup(address baseLookupAddress) public {
    b = BaseLookup(baseLookupAddress);
  }

  struct Lookup {
    uint id;
    string name;
  }

  function set(uint id, bytes32 name) public returns(bool success) {
    return b.setLookupById(id, name);
  }

  function get(uint id) public view returns(uint  theId, bytes32 name) {
    (theId, name) = b.getLookupById(id);
    return (theId, name);
  }
}"
12740-0-4.sol,answer,"contract A {
   address[] public addElements;

   event newAddress(address a);

   function A() payable { }

   function create() returns (address a) {
       B obj = new B();
       addElements.push(obj);

       
       newAddress(obj);
   }

   function getElements() returns (address[] ) {
       return addElements;
   }
}"
8938-0-0.sol,answer,"contract Ballot {
    struct Escrow {
        address thirdParty;
        address seller;
        address buyer;
        uint amount;
        address recipient;
        uint status;
    }
    uint numEscrows;
    mapping (uint => Escrow) escrows;

    function start(address seller, address thirdParty) returns (uint escrowId) {
        escrowId = numEscrows;
        numEscrows++;
        Escrow memory e;
        e.thirdParty = thirdParty;
        e.seller = seller;
        e.buyer = msg.sender;
        e.amount = msg.value;
        e.recipient = seller;
        e.status = 1; 

        escrows[escrowId] = e;

        return escrowId;
    }

    function start1(address seller, address thirdParty) returns (uint escrowId) {
        escrows[numEscrows].thirdParty = thirdParty;
        escrows[numEscrows].seller = seller;
        escrows[numEscrows].buyer = msg.sender;
        escrows[numEscrows].amount = msg.value;
        escrows[numEscrows].recipient = seller;
        escrows[numEscrows].status = 1; 
        numEscrows++;
        return numEscrows;
    }
}"
67828-0-0.sol,answer,"contract TestAssemblyAndRevert {
    function test(address from, address to, uint256 value) public {
        
        address token = 0xedc2d4aca4f9b6a23904fbb0e513ea0668737643;

        
        assembly {
            let ptr := mload(0x40)

            
            mstore(ptr, 0x23b872dd00000000000000000000000000000000000000000000000000000000)

            
            
            calldatacopy(add(ptr, 4), 4, 96)

            
            let result := call(gas, token, 0, ptr, 100, ptr, 32)

            if eq(result, 1) {
                return(0, 0)
            }
        }

        revert(""TOKEN_TRANSFER_FROM_ERROR"");
    }
}"
50507-0-0.sol,answer,"contract Stoppable {

    bool public isRunning;

    modifier onlyIfRunning {
        require(isRunning);
        _;
    }

    function Stoppable() public {
        isRunning = true;
    }

    function setRunSwitch(bool newSetting) public returns(bool contractRunning) {
        isRunning = newSetting;
    }
}"
73041-0-0.sol,answer,"contract MultiStage {

    struct stage {
      uint256 startDate;
      uint256 endDate;
      uint8 discount;
    }

    stage[] saleStages;

    function addStage(uint256 _start, uint256 _end, uint8 _discount) external {
        require(_start < _end);
        uint256 _length = saleStages.length;
        if (_length > 0) {
             
             require(saleStages[_length-1].startDate > _end);
        }
        saleStages.push(stage(_start, _end, _discount));
    }

    function getCurrentStage() private returns (uint256 _index) {
        _index = saleStages.length;
        while (_index > 0 && now > saleStages[_index-1].endDate) {
            _index--;
        }
        if (_index != saleStages.length) {
            saleStages.length = _index;
        }
        require(_index > 0, ""Final stage has ended"");
        return _index - 1;
    }
}"
11593-0-1.sol,answer,"contract Test1 {
    uint8[3] a; 
    function Test1() {
        a = [1, 2, 3];
    }
}"
32708-0-0.sol,answer,"contract array {


function conversion (uint8[] array8) returns(uint[] array256) {
   for (uint i = 0 ; i < array8.length ; i++ ) {
       array256[i] = array8[i];

   }

   return array256;
}

}"
43127-0-0.sol,answer,"contract DoublyLinkedList {
    struct Node {
        bytes payload;
        uint256 next;
        uint256 prev;
    }

    uint256 nextNodeID = 1;  
    mapping(uint256 => Node) nodes;
    uint256 head;
    uint256 tail;
    uint256 count = 0;

    function append(bytes payload) public {
        if (tail == 0) {
            
            head = nextNodeID;
            tail = nextNodeID;
            nodes[nextNodeID].payload = payload;
        } else {
            nodes[tail].next = nextNodeID;
            nodes[nextNodeID].payload = payload;
            nodes[nextNodeID].prev = tail;
            tail = nextNodeID;
        }
        nextNodeID += 1;
        count += 1;
    }

    function validNode(uint256 nodeID) internal view returns (bool) {
        return nodeID == head || nodes[nodeID].prev != 0;
    }

    function remove(uint256 nodeID) public {
        require(validNode(nodeID));

        Node storage node = nodes[nodeID];

        
        if (tail == nodeID) {
            tail = nodes[nodeID].prev;
        }
        if (head == nodeID) {
            head = nodes[nodeID].next;
        }

        
        if (node.prev != 0) {
            nodes[node.prev].next = node.next;
        }

        
        if (node.next != 0) {
            nodes[node.next].prev = node.prev;
        }

        
        delete nodes[nodeID];

        count -= 1;
    }

    function getNodeIDs() public view returns (uint256[] ids) {
        ids = new uint256[](count);

        uint256 current = head;
        for (uint256 i = 0; i < count; i++) {
            ids[i] = current;
            current = nodes[current].next;
        }
    }

    function getPayload(uint256 nodeID) public view returns (bytes) {
        require(validNode(nodeID));

        return nodes[nodeID].payload;
    }
}"
50255-1-0.sol,answer,"contract VotethComment {

    string public comment;
    string public nickname;
    address public author;
    address[] public votethComments;
    address votethCommentMaker;

    constructor(string _comment, string _nickname, address _author, address _votethCommentMaker) public {
        comment = _comment;
        nickname = _nickname;
        author = _author;
        votethCommentMaker = _votethCommentMaker;
    }

    function addComment(string _comment, string _nickname) public {
        VotethCommentSupplier votethCommentSupplier = VotethCommentSupplier(votethCommentMaker);
        votethComments.push(votethCommentSupplier.makeComment(_comment, _nickname, msg.sender));
    }
}"
50255-1-0.sol,answer,"contract VotethCommentSupplier {
   function makeComment(string _comment, string _nickname, address _author) public returns(address);
}"
50255-1-0.sol,answer,"contract VotethCommentMaker {
    function makeComment(string _comment, string _nickname, address _author) public returns(address) {
        return new VotethComment(_comment, _nickname, _author, this);
    }
}"
63224-0-0.sol,answer,"contract SortStruct {

    struct TestStruct {
        address user;
        uint256 value;
    }


    mapping (uint => uint) helper;

    TestStruct[] public testStructArray;
    TestStruct[] public sortedArray;

    function add(uint256 _value) public {

        TestStruct memory test;

        test.value = _value;
        test.user = msg.sender;
        testStructArray.push(test);

    }

    function sort () public {


        for (uint i = 0; i < testStructArray.length; i++) {


            helper[i] = 0;


            for (uint j = 0; j < i; j++){


                if (testStructArray[i].value < testStructArray[j].value) {


                    if(helper[i] == 0){
                        helper[i] = helper[j];
                    }


                    helper[j] = helper[j] + 1;
                }
            }


            if(helper[i] == 0) {
                helper[i] = i + 1;
            }
        }


        var lengthSortedArray = sortedArray.length;
        for (uint i = 0; i < testStructArray.length; i++) {
            if (i < lengthSortedArray) continue;
            sortedArray.push(TestStruct(msg.sender, 0));
        }


        for (uint i = 0; i < testStructArray.length; i++) {
            sortedArray[helper[i]-1] = testStructArray[i];
        }
    }
}"
191-18-0.sol,answer,"contract Verifiable6SidedDiceRoll is VRFConsumerBase {
    using SafeMath for uint;

    bytes32 internal keyHash;
    uint256 internal fee;

    event RequestRandomness(
        bytes32 indexed requestId,
        bytes32 keyHash,
        uint256 seed
    );

    event RequestRandomnessFulfilled(
        bytes32 indexed requestId,
        uint256 randomness
    );

    
    constructor(address _vrfCoordinator, address _link)
        VRFConsumerBase(_vrfCoordinator, _link) public
    {
        vrfCoordinator = _vrfCoordinator;
        LINK = LinkTokenInterface(_link);
        keyHash = 0xced103054e349b8dfb51352f0f8fa9b5d20dde3d06f9f43cb2b85bc64b238205; 
        fee = 10 ** 18; 
    }

    
    function rollDice(uint256 userProvidedSeed) public returns (bytes32 requestId) {
        require(LINK.balanceOf(address(this)) > fee, ""Not enough LINK - fill contract with faucet"");
        uint256 seed = uint256(keccak256(abi.encode(userProvidedSeed, blockhash(block.number)))); 
        bytes32 _requestId = requestRandomness(keyHash, fee, seed);
        emit RequestRandomness(_requestId, keyHash, seed);
        return _requestId;
    }

    function fulfillRandomness(bytes32 requestId, uint256 randomness) external override {
        uint256 d6Result = randomness.mod(6).add(1);
        emit RequestRandomnessFulfilled(requestId, randomness);
    }

}"
6891-1-0.sol,answer,"contract Cast {

    uint n;
    string s;
    address a;

    function convert() public view {
        bytes32 b1 = bytes32(n);
        bytes32 b2 = bytes32(a);
        bytes32 b4 = bytes32(""string"");
        bytes memory b5 = bytes(s);
    }
}"
43865-0-0.sol,answer,"contract Test {
    uint256 public integer = 100;
    uint256[] public array;

    function fill_array() {
        while (integer > 0) {
            uint256 bit = integer%2;
            uint256 quotient = integer/2;
            array.push(bit);
            integer = quotient;
        }
    }
}"
11945-0-1.sol,answer,"contract Ballot {
    string public title;

    function Ballot(string _title) {
        title = _title;
    }

   function getTitle() constant returns (string) { 
       return title; 
   }
}"
11627-0-0.sol,answer,"contract A {
    B public b;
    function foo() {
        b = new B();
        throw;
    }

    function getXfromB() returns (uint) {
        return b.x();
    }
}"
11627-0-0.sol,answer,"contract B {
    uint public x;

    function B() {
        x = 1;
    }
}"
57249-0-0.sol,answer,"contract Relay {

    IOtherContract private otherContractInterface;

    modifier onlyOwner() {
      require(msg.sender == owner, ""Sender is not owner"");
      _;
    }

    function initialize(address _otherContractAddress) external onlyOwner {

        otherContractInterface = IOtherContract(_otherContractAddress);
    }
}"
72421-0-0.sol,answer,"contract Contract1 {
        function func(uint256 x, uint8 y) public returns (uint32, uint32)  {
            return (uint32(x), uint32(y));
        }
    }"
72421-0-0.sol,answer,"contract Contract2 {

        Contract1 public contract1 = new Contract1();

        function func() public returns (uint32, uint32) {
            (uint32 arg1, uint32 arg2) = contract1.func(uint256(789), uint8(123));
            return (arg1, arg2);
        }
    }"
8383-0-6.sol,answer,"contract Test {
   mapping (address => uint256) public balanceOf;

   function test(address _address, uint256 _value) {
       balanceOf[_address] = _value;
   }
}"
52989-0-0.sol,answer,"contract Foo {
  function baz(uint32 x, bool y) returns (bool r) { r = x > 32 || y; }
}"
41702-0-0.sol,answer,"contract Example {
    DBKeys.keyStruct knownValues;

    function add(bytes32 value) public {
        require(DBKeys.addZkey(knownValues, value));
    }
    function remove(bytes32 value) public {
        require(DBKeys.delZkey(knownValues, value));
    }
}"
24897-0-0.sol,answer,"contract Basic {
    bytes32 value;

    function Basic() {
        value = ""mcansado"";
    }

    function getValue() constant returns(bytes32) {
        return value;
    }

    function setValue(bytes32 _value)  {
        value = _value;
    }
}"
18475-0-0.sol,answer,"contract storeStuff {
  string content
  address owner;

  
  
  function storeStuff() {
    owner = msg.sender;
  }

  function updateContent (string newContent) {
    if (msg.sender == owner)
      content = newContent;
  }
}"
43650-1-0.sol,answer,"contract Ownable {
    address public owner = 0xca35b7d915458ef540ade6068dfe2f44e8fa733c; 

    function getOwner() public view returns(address theOwner) {
        return owner;
    }
}"
43650-1-0.sol,answer,"contract SampleCrowdsale is Ownable {

    address public owner = 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c; 

    

    function getOwner2() public view returns(address theOwner) {
        return super.getOwner();
    }
}"
43650-1-0.sol,answer,"contract CappedCrowdsale is SampleCrowdsale {

    address public owner = 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db;

    

    function getOwner3() public view returns(address anotherOwner) {
        return super.getOwner2(); 
    }

    

    function telling() public view returns(address chained) {
        return super.getOwner();
    }
}"
43650-1-0.sol,answer,contract RefundableCrowdsale is SampleCrowdsale {}
43650-1-0.sol,answer,contract MintedCrowdsale is SampleCrowdsale {}
43650-1-0.sol,answer,contract TieredCrowdsale is SampleCrowdsale {}
43650-1-0.sol,answer,contract FinalizedCrowdsale is RefundableCrowdsale {}
43650-1-0.sol,answer,contract TimedCrowdsale is FinalizedCrowdsale {}
67681-0-0.sol,answer,"contract Ownable is Initializable {
    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    function initialize(address sender) public initializer {
        _owner = sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    
    function owner() public view returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(isOwner());
        _;
    }

    
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0));
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }

    uint256[50] private ______gap;
}"
3461-0-1.sol,answer,contract Test { bytes32 public lastblockhashused; uint public lastblocknumberused; uint public AA; function test() { lastblocknumberused = (block.number-1) ;  lastblockhashused = block.blockhash(lastblocknumberused); } function getTest1() constant returns (uint) { return uint(lastblockhashused) & 0xfff;  } function Test2() { AA=(uint(lastblockhashused) & 0xfff); return;  } function getTest2AA() constant returns (uint) { return AA; }}
42226-0-0.sol,answer,"contract ReceiverPays {
    address owner = msg.sender;

    mapping(uint256 => bool) usedNonces;

    
    function ReceiverPays() public payable { }

    
    function() public payable {
    }

    function claimPayment(uint256 amount, uint256 nonce, bytes sig) public {
        require(!usedNonces[nonce]);
        usedNonces[nonce] = true;

        
        bytes32 message = prefixed(keccak256(msg.sender, amount, nonce, this));

        require(recoverSigner(message, sig) == owner);

        msg.sender.transfer(amount);
    }

    
    function kill() public {
        require(msg.sender == owner);
        selfdestruct(msg.sender);
    }


    

    function splitSignature(bytes sig)
        internal
        pure
        returns (uint8, bytes32, bytes32)
    {
        require(sig.length == 65);

        bytes32 r;
        bytes32 s;
        uint8 v;

        assembly {
            
            r := mload(add(sig, 32))
            
            s := mload(add(sig, 64))
            
            v := byte(0, mload(add(sig, 96)))
        }

        return (v, r, s);
    }

    function recoverSigner(bytes32 message, bytes sig)
        internal
        pure
        returns (address)
    {
        uint8 v;
        bytes32 r;
        bytes32 s;

        (v, r, s) = splitSignature(sig);

        return ecrecover(message, v, r, s);
    }

    
    function prefixed(bytes32 hash) internal pure returns (bytes32) {
        return keccak256(""\x19Ethereum Signed Message:\n32"", hash);
    }
}"
16673-0-0.sol,answer,"contract Test {
    uint public myArray;

    function Test() public {
        myArray.push(1);
        myArray.push(10);
        myArray.push(30);
    }

    function getArrayLength() public view returns (uint) {
        return myArray.length;
    }"
11802-0-1.sol,answer,"contract B is A {
  uint8 public b1;

  function B() A(0x0011223344556677889900112233445566778899) {
  }
}"
80733-0-0.sol,answer,"contract State {

  uint public x; 

  function setX(uint newX) public {
    x = newX; 
  }
}"
44220-0-0.sol,answer,"contract Test {
    ...

    function check(bytes32[] msgHash, uint8[] v, bytes32[] r, bytes32[] s) public view returns (bool) {
        for (uint256 i = 0; i < msgHash.length; i++) {
            address signer = recoverAddr(msgHash[i], v[i], r[i], s[i]);
            ...
        }
    }
}"
24592-0-1.sol,answer,"contract CrowdsaleToken is Token {

  function mint(address _to, uint _amount) public returns (bool) {
      balances[_to] = balances[_to] + _amount;
      return true;
  }

  
}"
33463-2-0.sol,answer,"contract House {
    using Cars for Cars.Car;
    Cars.Car public myCar;

    function startCar(uint fuel) public {
        myCar.startEngine(fuel);
        myCar.enableBrakes(false);
    }
}"
31256-0-0.sol,answer,"contract Greetable {
        function Greetable() public {}
        function greet() constant public returns (bytes32);
    }"
31256-0-0.sol,answer,"contract GreeterContainer is Greetable {

    
    Greetable greeter;

    function GreeterContainer(address greeter_address) public {
        greeter = Greetable(greeter_address);
    }

    
    
    function setGreeter(address _greeter_address) public {
        greeter = Greetable(_greeter_address);
    }

    
    function greet() constant public returns (bytes32) {
        return greeter.greet();
    }
}"
67407-0-2.sol,answer,"contract MyContract {
    string public message;

    function MyContract(string initialMessage) public {
        message = initialMessage;
    }

    function setMessage(string newMessage) public {
        message = newMessage;
    }
}"
56138-0-1.sol,answer,"contract Untested {

    
    
    struct OracleCallbackDetails {
        uint arg1;
        uint arg2;
    }

    
    mapping(bytes32 => OracleCallbackDetails) oracleDetails;

    
    
    function __callback(bytes32 myid, string result) public {
        require(msg.sender == oraclize_cbAddress());

        OracleCallbackDetails storage details = oracleDetails[myid];
        functionToCall(details.arg1, details.arg2);
    }

    
    
    function doSomethingThatNeedsOraclize (uint arg1, uint arg2) {
        bytes32 queryId = oraclize_query(""URL"", <URL_string>);
        oracleDetails[queryId] = OracleCallbackDetails(arg1, arg2);
    }
}"
12348-1-0.sol,answer,"contract HelloWorld {

    string saySomething;

    constructor() public  {
        saySomething = ""Hello World!"";
    }

    function speak() public view returns(string memory) {
        return saySomething;
    }

    function saySomethingElse(string memory newSaying) public  returns(bool success) {
        saySomething = newSaying;
        return true;
    }

}"
78967-1-0.sol,answer,"contract timeLock {
    struct accountData
    {
        uint balance;
        uint releaseTime;
    }

    mapping (address => accountData) accounts;

    function payIn(uint _lockTimeS) public payable {
        uint amount = msg.value;
        payOut();
        if (accounts[msg.sender].balance > 0)
            msg.sender.transfer(msg.value);
        else
        {
            accounts[msg.sender].balance = amount;
            accounts[msg.sender].releaseTime = now + _lockTimeS;
        }
    }

    function payOut() public {
        if (accounts[msg.sender].balance != 0 && accounts[msg.sender].releaseTime < now)
        {
            msg.sender.transfer(accounts[msg.sender].balance);
            accounts[msg.sender].balance = 0;
            accounts[msg.sender].releaseTime = 0;
        }
    }

    function getMyLockedFunds() view public returns (uint x)
    {
        return accounts[msg.sender].balance;
    }

    function getMyLockedFundsReleaseTime() view public returns (uint x)
    {
        return accounts[msg.sender].releaseTime;
    }

    function getNow() view public returns (uint x)
    {
        return now;
    }
}"
71468-0-0.sol,answer,"contract MetaCoint {
    uint public index;
    mapping(uint => uint) public counters;

    function addCounter() external {
        index++;
    }

    function incCounter(uint _index) external {
        require(_index < index, ""counter was not created"");
        counters[_index]++;
    }
}"
75940-2-0.sol,answer,"contract ModByZero {

    event LogSomeState(uint256 a, uint256 b);

    function doIt(uint256 a, uint256 b) public returns (uint256) {
        emit LogSomeState(a, b);
        return a % b;
    }
}"
36676-0-0.sol,answer,"contract SerialitySample is Seriality {

function sample() public returns(int8 n1, int24 n2, uint32 n3, int128 n4, address n5, address n6) {

    bytes memory buffer = new bytes(64);
    int8    out1 = -12;
    int24   out2 = 838860;
    uint32  out3 = 333333333;
    int128  out4 = -44444444444;
    address out5 = 0x15B7926835A7C2FD6D297E3ADECC5B45F7309F59;
    address out6 = 0x1CB5CF010E407AFC6249627BFD769D82D8DBBF71;

    
    uint offset = 64;

    intToBytes(offset, out1, buffer);
    offset -= sizeOfInt(8);

    intToBytes(offset, out2, buffer);
    offset -= sizeOfUint(24);

    uintToBytes(offset, out3, buffer);
    offset -= sizeOfInt(32);

    intToBytes(offset, out4, buffer);
    offset -= sizeOfUint(128);

    addressToBytes(offset, out5, buffer);
    offset -= sizeOfAddress();

    addressToBytes(offset, out6, buffer);

    
    offset = 64; 

    n1 = bytesToInt8(offset, buffer);
    offset -= sizeOfInt(8);

    n2 = bytesToInt24(offset, buffer);
    offset -= sizeOfUint(24);

    n3 = bytesToUint8(offset, buffer);
    offset -= sizeOfInt(32);

    n4 = bytesToInt128(offset, buffer);
    offset -= sizeOfUint(128);

    n5 = bytesToAddress(offset, buffer);
    offset -= sizeOfAddress();

    n6 = bytesToAddress(offset, buffer);
}
"
12119-0-0.sol,answer,"contract Oursurance {

  address public creator;

  event LogFundsReceived(address sender, uint amount);
  event LogFundsSent(address receiver, uint amount);

  function() payable {
    LogFundsReceived(msg.sender, msg.value);
  }

  function Oursurance() payable {
    creator = msg.sender;
    LogFundsReceived(msg.sender, msg.value);
  }

  function kill() {
    selfdestruct(creator);
  }

  function send(address target, uint256 amount) {
    if (!target.send(amount)) throw;
    LogFundsSent(target, amount);
  }

}"
63894-0-0.sol,answer,"contract Ordered {

    uint public nonce;

    event LogNextTransaction(address sender, uint transactionNumber);

    function doSomethingOrdered(uint transactionNumber) public {
        require(transactionNumber == nonce);
        emit LogNextTransaction(msg.sender, transactionNumber);
        nonce++;
    }
}"
79546-0-1.sol,answer,"contract Consumer {
    InfoFeed feed;
    function setFeed(InfoFeed addr) public { 
        feed = addr;             
    }
    function callFeed() public { 
        feed.info.value(10).gas(800)();             
    }
}"
10423-1-0.sol,answer,"contract MyContract {
    struct Obj {
        uint32 a;
        uint32 b;
        uint32 c;
    }

    mapping(string => Obj) internal objs;

    function set1(string objName, uint256 obja, uint256 objb, uint256 objc) external {
        Obj memory obj;
        obj.a = uint32(obja);
        obj.b = uint32(objb);
        obj.c = uint32(objc);
        objs[objName] = obj;
    }

    function set2(string objName, uint256 obja, uint256 objb, uint256 objc) external {
        objs[objName].a = uint32(obja);
        objs[objName].b = uint32(objb);
        objs[objName].c = uint32(objc);
    }
}"
73664-0-0.sol,answer,"contract C {
    mapping(uint256 => uint256) items;
    function C() {
      items[0xC0FEFE] = 0x42;
    }
}"
11593-1-1.sol,answer,"contract Test {

    struct Struct {
      uint[] myArray;
    }

    Struct myStruct; 

    function Test()  {
        myStruct.myArray.push(1);
        myStruct.myArray.push(2);
        myStruct.myArray.push(3);
    }

    function getter(uint index) returns(uint value) {
        return myStruct.myArray[index];
    }

}"
69659-0-0.sol,answer,"contract Contract {

    struct Everything {
        uint a;
        bytes32 b;
        bool c;
        address d;
    }

    Everything[] public my_array;

    function expand() public {
        my_array.length++;
    }
}"
82907-0-1.sol,answer,"contract B {
    ERC20 token;
    uint256 public constant ticketPrice = 10 ** 18; 
    function processPayment(uint amount) public return bool {
        
        if (amount >= ticketPrice) {
            
            require(token.transferFrom(msg.sender, address(this), ticketPrice), ""Transfer failed"");
            
            emit TicketSold(msg.sender, ticketPrice);
            return true;
        } else {
            
            return false;
        }
    }
}"
9614-0-8.sol,answer,"contract TokenInterface {
    mapping (address => uint256) balances;
    mapping (address => mapping (address => uint256)) allowed;
    ...
    
    
    function balanceOf(address _owner) constant returns (uint256 balance);
    ...
    
    
    
    
    
    
    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);

    
    
    
    
    
    function approve(address _spender, uint256 _amount) returns (bool success);

    
    
    
    
    function allowance(
        address _owner,
        address _spender
    ) constant returns (uint256 remaining);
    ...
}"
9614-0-8.sol,answer,"contract Token is TokenInterface {
    ...
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function transferFrom(
        address _from,
        address _to,
        uint256 _amount
    ) noEther returns (bool success) {

        if (balances[_from] >= _amount
            && allowed[_from][msg.sender] >= _amount
            && _amount > 0) {

            balances[_to] += _amount;
            balances[_from] -= _amount;
            allowed[_from][msg.sender] -= _amount;
            Transfer(_from, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

    function approve(address _spender, uint256 _amount) returns (bool success) {
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }
}"
35790-2-1.sol,answer,"contract DeleteUser {

    struct UserStruct {
        bytes32[] assets;
        mapping(bytes32 => uint) assetPointers;
    }

    mapping(address => UserStruct) userStructs;

    function isUserAsset(address user, bytes32 assetId) public view returns(bool isIndeed) {
        if(userStructs[user].assets.length == 0) return false;
        return userStructs[user].assets[userStructs[user].assetPointers[assetId]] == assetId;
    }

    function deleteUserAsset(address user, bytes32 assetId) public {
        UserStruct storage u = userStructs[user];
        require(isUserAsset(user, assetId));
        uint rowToDelete = u.assetPointers[assetId];
        u.assets[rowToDelete] = u.assets[u.assets.length-1];
        u.assets.length--;
    }

}"
63331-2-0.sol,answer,"contract Another {
    function sendToAnother() public;
}"
9455-3-0.sol,answer,"contract ProofOfExistence4 is usingOraclize {

string public currentRound;
bytes32 public id;

function ProofOfExistence4 () {
  
}
function() payable {}

event ResultUpdated (string currentRound);

function __callback(bytes32 myid, string result, bytes proof)  {
    currentRound = ""0"";
    if (msg.sender != oraclize_cbAddress()) throw;

    currentRound = ""1"";
    currentRound = result;
    ResultUpdated(currentRound);
}

function __callback(bytes32 myid, string result)  {
    currentRound = ""2"";
    if (msg.sender != oraclize_cbAddress()) throw;

    currentRound = ""3"";

    currentRound = result;
    ResultUpdated(currentRound);
}

function getNumber() public payable {
    id = 3;
    oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
    id = oraclize_query(""WolframAlpha"", ""random number between 0 and 100"");
    
    }
}"
67644-0-0.sol,answer,"contract A {

    function test(bytes32 r) public pure returns (bytes8 i, bytes8 j, bytes8 k, bytes8 m) {
        uint256 rr = uint256(r);
        i = bytes8(uint64(rr >> 64*3));
        j = bytes8(uint64(rr >> 64*2));
        k = bytes8(uint64(rr >> 64*1));
        m = bytes8(uint64(rr >> 64*0));
    }

    function bar(bytes32 r) public pure returns (bytes8 i, bytes8 j, bytes8 k, bytes8 m) {
        i = bytes8(r);
        j = bytes8(r << 64*1);
        k = bytes8(r << 64*2);
        m = bytes8(r << 64*3);
    }

    function foo(bytes32 r) public pure returns (bytes8 i, bytes8 j, bytes8 k, bytes8 m) {
        assembly {
            i := r
            j := shl(64, r)
            k := shl(128, r)
            m := shl(192, r)
        }
    }
}"
15928-0-0.sol,answer,"contract Test {
    Receiver myR;

    function setReceiver (address a) {
        myR = Receiver(a);
    }

    function callR() {
        myR.call(this.balance);
    }

    function sendCash() payable {
    }

}"
15928-0-0.sol,answer,"contract Receiver {
    uint public numCalled;

    function () payable {
        numCalled++;
    }
}"
64736-0-1.sol,answer,"contract A  {

      mapping(address =>address[]) public inves;

      function totalInvesCount(address index) public view returns(uint){
        return(inves[index].length);
      }

}"
64736-0-1.sol,answer,"contract B {

    A a;

    constructor(address _a) public {
        a = A(_a); 
    }

    function totalInvesCount() public view returns(uint) {
        return a.totalInvesCount(msg.sender);
    }

}"
17402-0-0.sol,answer,"contract TestSend {

  function sendToOther(address receiver) payable returns(bool success) {
    if(!receiver.send(msg.value) throw; 

..."
12251-1-0.sol,answer,"contract ObjectTree {

bytes32 public treeRoot;

struct NodeStruct {
    bytes32 parent; 
    uint parentIndex; 
    bytes32[] children; 
    
}

mapping(bytes32 => NodeStruct) nodeStructs;

event LogNewNode(bytes32 nodeId, bytes32 parentId);
event LogDelNode(bytes32 nodeId);

function ObjectTree() {
    treeRoot = newNode(0);
}

function newNode(bytes32 parent) 
    public
    returns(bytes32 newNodeId)
{
    
    

    newNodeId = sha3(parent, msg.sender, block.number);
    NodeStruct memory node;
    node.parent = parent;
    if(parent>0) {
        node.parentIndex = registerChild(parent,newNodeId);
    }
    nodeStructs[newNodeId] = node;
    LogNewNode(newNodeId, parent);
    return newNodeId;
}

function registerChild(bytes32 parentId, bytes32 childId)
    private
    returns(uint index)
{
    return nodeStructs[parentId].children.push(childId) - 1;
}









function pruneBranch(bytes32 nodeId)
    public
    returns(bool success)
{
    bytes32 parent = nodeStructs[nodeId].parent;
    uint rowToDelete = nodeStructs[nodeId].parentIndex;
    uint rowToMove = nodeStructs[parent].children.length-1; 
    
    nodeStructs[parent].children[rowToDelete] = nodeStructs[parent].children[rowToMove];
    
    nodeStructs[nodeStructs[parent].children[rowToMove]].parentIndex = rowToMove;
    
    nodeStructs[parent].children.length--;
    
    nodeStructs[nodeId].parent=0;
    nodeStructs[nodeId].parentIndex=0;
    LogDelNode(nodeId);
    return true;
}






function isActiveNode(bytes32 nodeId)
    public
    constant
    returns(bool isIndeed)
{
    if(nodeId==treeRoot) return true;
    if(nodeStructs[nodeId].parent==0) return false;
    return isActiveNode(nodeStructs[nodeId].parent);
}

function getNodeChildCount(bytes32 nodeId)
    public
    constant
    returns(uint childCount)
{
    return(nodeStructs[nodeId].children.length);
}

function getNodeChildAtIndex(bytes32 nodeId, uint index) 
    public 
    constant
    returns(bytes32 childId)
{
    return nodeStructs[nodeId].children[index];
}


}"
41120-0-0.sol,answer,"contract MyToken {
    
}"
41120-0-0.sol,answer,"contract SomeContract {
    address tokenAddress;
    MyToken token;
    token.approve(this( which is adress of SomeContract), X amount of tokens is able to donate has to be more than 1000 that is what you send)

    
    
    function setTokenAddress(address _tokenAddress) public {
        tokenAddress = _tokenAddress;
        token = MyToken(_tokenAddress);
    }

    function GiveMeTokens() public payable {
        if (msg.value > 1) {
            token.transfer(msg.sender, 1000);
        }
    }
}"
64742-0-0.sol,answer,"contract RegisterCandidate {
    
    struct Address {
        string addressLine;
        string district;
        string state;
        uint pincode;     
    }

    
    struct Candidate {
        uint id;
        string name;
        uint voteCount;
        uint age;
    }
    
    mapping(uint => Candidate) candidates;  
    mapping(uint => Address) public addresses;
    
    uint public candidatesCount;

    function getCandidate(uint key) public view returns(string name, string addressLine, string district, string state, uint pincode, uint voteCount, uint age) {
        Address storage a = addresses[key];
        Candidate storage c = candidates[key];
        return (c.name, a.addressLine, a.district, a.state, a.pincode, c.voteCount, c.age);
    }

    function addCandidate (string _name,uint _age,string _address,string _district,string _state,uint _pincode) public {
        candidatesCount ++;
        addresses[candidatesCount] = Address(_address,_district,_state,_pincode);
        candidates[candidatesCount] = Candidate(candidatesCount, _name, 0, _age);
    }

}"
74253-0-0.sol,answer,"contract Student { 
    bytes32[32] parameters; 
    function setParameters(bytes32[] memory _parameters) public { 
        for (uint i = 0; i < _parameters.length; i++) { 
            parameters[i] = _parameters[i];
        } 
    }
}"
25422-0-0.sol,answer,"contract MyOrgDatabase {
  struct Organization {
    address _where;
    string _name;
  }
  Organization[] public availableOrgs;
  address public owner = msg.sender;

  function addOrg(address _where, string _name) {
    require(msg.sender == owner);
    availableOrgs.push(Organization(_where, _name));
  }
}"
11319-0-0.sol,answer,"contract SimplySend {
    event Paid(uint);
    function () payable {
        Paid(msg.value);
    }
}"
11319-0-0.sol,answer,"contract NeedExtraGas {
    event Paid(uint);
    uint total;
    function () payable {
        total += msg.send;
        Paid(msg.value);
    }
}"
8945-0-0.sol,answer,"contract TipFaucet {

    uint public received;
    uint public paid;

    modifier isDev { if (msg.sender != 

    function withdraw() isDev {
        paid += this.balance;
        msg.sender.send(this.balance);
    }

    function () {
        received += msg.value;
    }
}"
41889-0-0.sol,answer,"contract MyContract {
    function myFunction() returns(string myString) {
        return ""Hello!%"";
    }
}"
8630-0-0.sol,answer,"contract Test {
    mapping (address => uint256) weismap;

    function bet(uint vote) payable returns (uint256 weis) {
        if (msg.value==0) 
            throw;
        weismap[msg.sender]= msg.value;
        return  weismap[msg.sender];
    }

    function test() constant returns (uint myVote)  {
        return 1;
    }
}"
26726-0-1.sol,answer,"contract OwnedContract {

    mapping (address => bool) private _owners;
    address private _masterAdmin;

    modifier isOwner() {
        require(_masterAdmin == msg.sender || _owners[msg.sender]);
        _;
    }

    function OwnedContract() {
       _masterAdmin = msg.sender;
    }

    

}"
57759-0-0.sol,answer,"contract Test {
    address owner;

    constructor() public {
        owner = msg.sender;
    }

    event dying(bool dead);

    function kill() public {
        emit dying(true);
        selfdestruct(owner);
    }
}"
24086-1-0.sol,answer,"contract test {
enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }
ActionChoices choice;
ActionChoices constant defaultChoice = ActionChoices.GoStraight;

function setGoStraight() public {
    choice = ActionChoices.GoStraight;
}






function getChoice() public view returns (ActionChoices) {
    return choice;
}

function getDefaultChoice() public pure returns (uint) {
    return uint(defaultChoice);
}


}"
2-0-0.sol,answer,"contract KrakenPriceTicker is usingOraclize {
    string public ETHXBT;

    function PriceTicker() {
        oraclize_setNetwork(networkID_testnet);
        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
        oraclize_query(""URL"", ""json(https:
    }

    function __callback(bytes32 myid, string result, bytes proof) {
        if (msg.sender != oraclize_cbAddress()) throw;
        ETHXBT = result;
        
    }
}"
11030-0-1.sol,answer,contract Array is owned { using LinkedList for LinkedList.data; using LinkedList for LinkedList.Node; LinkedList.data list; function Array(){  if( test_callstack() != 1 ) throw;  list.construct_me(); } function test_callstack() constant returns ( int ){ return 1; }}
52727-0-0.sol,answer,"contract ethTransferTest {
    function ethTrans(address _to) public {
        uint256 pay = msg.value;
        _to.transfer(pay);
    }
}"
52727-0-0.sol,answer,"contract ethReceiverTest {
    function () payable public {
    }
}"
49797-0-0.sol,answer,"contract ICO {
    address public bank = ......;

    function withdrawal() public {
        require(address(this).balance >= 1000000000000000);
        bank.transfer(address(this).balance);
    }

}"
15717-0-0.sol,answer,"contract WithdrawalContract {
    address public richest;
    uint public mostSent;

    mapping (address => uint) pendingWithdrawals;

    function WithdrawalContract() payable {
        richest = msg.sender;
        mostSent = msg.value;
    }

    function becomeRichest() payable returns (bool) {
        if (msg.value > mostSent) {
            pendingWithdrawals[richest] += msg.value;
            richest = msg.sender;
            mostSent = msg.value;
            return true;
        } else {
            return false;
        }
    }

    function withdraw() returns (bool) {
        uint amount = pendingWithdrawals[msg.sender];
        
        
        pendingWithdrawals[msg.sender] = 0;
        if (msg.sender.send(amount)) {
            return true;
        } else {
            pendingWithdrawals[msg.sender] = amount;
            return false;
        }
    }
}"
50027-2-1.sol,answer,"contract Test {

    function getValue(string something) public view returns (string, uint) {
        return (something, 123);
    }
}"
30843-0-0.sol,answer,"contract Thingy {
    uint[] public thing = [1];


    function addToArray() public {
        thing.push(1);
    }
}"
11127-0-0.sol,answer,"contract Practice {

    function refillAccount(address receiver) payable returns(bool isRefilled) {

        if(msg.value != 1 ether) throw; 
        
        if(!receiver.send(msg.value)) {
            throw; 
        }
        
        return true;
    }
}"
59792-0-0.sol,answer,"contract SuperSimpleFaucet {

    uint topupAmount = 5 ether;

    function () public payable {}

    

    function topup() public {
        msg.sender.transfer(topupAmount);
    }

    

    function topupAccount(address account) public {
        account.transfer(topupAmount);
    }

    

    function sendFunds(address account, uint amount) public {
        account.transfer(amount);
    }
}"
44539-0-0.sol,answer,"contract TestOraclizeCall is usingOraclize {
        uint public price;
       event Log(string text);
       
       function TestOraclizeCall() {
             OAR = OraclizeAddrResolverI(0x5049063e4a7704ac155e4f1f42a4954bbef5bbde);
        }
  function __callback(bytes32 _myid, string _result) {
             require (msg.sender == oraclize_cbAddress());
             Log(_result);
              price = parseInt(_result, 2);
    }
    function update() payable {
            oraclize_query(""URL"",""json(https:
    }
"
43174-0-1.sol,answer,"contract Safe {
    function isSafe() public pure returns (bool) { return true; }
}"
43174-0-1.sol,answer,"contract FakeSafe {
    function isSafe() public pure returns (uint) { return 12345; }
}"
43174-0-1.sol,answer,"contract NotSafe {
    function isSafe() public pure returns (bool) { return false; }
}"
43174-0-1.sol,answer,"contract NoFallback {
    
}"
43174-0-1.sol,answer,"contract EmptyFallback{
    function() public {}
}"
43174-0-1.sol,answer,"contract Caller {
    Safe safeInstance;
    NotSafe notSafeInstance;
    FakeSafe fakeSafeInstance;
    NoFallback noFallbackInstance;
    EmptyFallback emptyFallbackInstance;

    function Caller() public {
        safeInstance = new Safe();
        fakeSafeInstance = new FakeSafe();
        notSafeInstance = new NotSafe();
        noFallbackInstance = new NoFallback();
        emptyFallbackInstance = new EmptyFallback();
    }

    
    function testSafe()
        public
        returns (bool _isSafe)
    {
        return testIsSafe(address(safeInstance));
    }

    
    function testNotSafe()
        public
        returns (bool _isSafe)
    {
        return testIsSafe(address(notSafeInstance));
    }

    
    function testFakeSafe()
        public
        returns (bool _isSafe)
    {
        return testIsSafe(address(fakeSafeInstance));
    }

    
    function testNoFallback()
        public
        returns (bool _isSafe)
    {
        return testIsSafe(address(noFallbackInstance));
    }

    
    function testEmptyFallback()
        public
        returns (bool _isSafe)
    {
        return testIsSafe(address(emptyFallbackInstance));
    }



    function testIsSafe(address _addr)
        private
        returns (bool _isSafe)
    {
        bytes32 sig = bytes4(keccak256(""isSafe()""));
        bool _success = false;
        assembly {
            let x := mload(0x40)    
            mstore(x, sig)          
            _success := call(
                5000,   
                _addr,  
                0,      
                x,      
                4,      
                x,      
                32      
            )
            
            _isSafe := and(_success, mload(x))
        }
    }
}"
24086-0-0.sol,answer,"contract SimpleEnum {

  enum SomeData {DEFAULT,ONE,TWO}
  SomeData someData;

  constructor() public {
      someData = SomeData.DEFAULT;
  }

  function setValues(uint _value) public {
      require(uint(SomeData.TWO) >= _value);
      someData = SomeData(_value);
  }

  function getValue() public view returns (uint){
      return uint(someData);
  }
}"
80721-1-0.sol,answer,"contract MyContract {
    uint[] public list;

    struct Item {
        bool valid;
        uint index;
        uint value; 
        string name; 
    }

    mapping(uint => Item) public table;

    
    function upsert(uint ID, uint value, string name) external {
        Item storage item = table[ID];
        if (!item.valid) {
            item.valid = true;
            item.index = list.length;
            list.push(ID);
        }
        item.value = value; 
        item.name = name; 
    }

    
    function remove(uint ID) external {
        Item storage item = table[ID];
        require(item.index < list.length);
        require(ID == list[item.index]);
        uint lastItem = list[list.length - 1];
        table[lastItem].index = item.index;
        list[item.index] = lastItem;
        list.length -= 1;
        delete table[ID];
    }

    
    function count() external view returns (uint) {
        return list.length;
    }
}"
65760-0-0.sol,answer,"contract a { 

  struct Str {
    uint256 totalTokens;
    mapping(address => uint256) playerTokens;
  }

  mapping(uint256 => Str) private tokenStores;  

  function getPlayerToken(uint256 tokenId, address player) public returns(uint, uint) {
      Str storage t =  tokenStores[tokenId];
      return (t.totalTokens, t.playerTokens[player]);
  }
}"
61570-0-0.sol,answer,"contract Uniqueness {
    mapping(bytes32 => bool) public isUsed;

    function claimId(bytes32 key) public returns(bool success) {
        require(!isUsed[key]);
        isUsed[key]=true;
        return true;
    }
}"
19546-0-0.sol,answer,"contract testPay {
    function pay() payable {
    }
}"
24853-0-1.sol,answer,"contract Foo {
  function foo(bytes sha) constant returns (bytes) {
    return sha;
  }
}"
10640-0-0.sol,answer,"contract ItemListContract {
    struct item {
        bytes iname;
        uint16 itemid;
        bytes icode;
        uint ivalue;
    }

    uint itemCount;
    mapping(bytes => item) itemList;
    item[] itemArray;

    function ItemListContract() {
        log0('hi');
    }

    function addItem(bytes name, uint16 iid, bytes code, uint val) {        
        var itemnew = item(name, iid ,code, val);
        
        itemList[code] = itemnew;
        itemArray.push(itemnew);
        itemCount++;
    }

    function countItemList() constant returns (uint count) {     
        return itemCount;
    }

    function removeItem(bytes code) {
        delete itemList[code];
        itemCount--;
    }

    function getItem(bytes code) constant returns (bytes iname, uint val) {   
        return (itemList[code].iname, itemList[code].ivalue);
    }
}"
57327-0-0.sol,answer,"contract MyContract is usingOraclize {

  
  uint256 public ethusd = 1;

  
  bool public soldOut = false;  

  
  bool public oracleActive = false;

  
  uint256 public oracleInterval;

  
  uint256 public oracleGasPrice = 5000000000;

  
  
  uint256 public oracleGasLimit = 100000;


  constructor(uint _oracleInterval, uint _oracleGasPrice) public {
    require(_oracleInterval > 0);
    require(_oracleGasPrice > 0);

    oracleInterval = _oracleInterval;    
    oracleGasPrice = _oracleGasPrice;

    oraclize_setCustomGasPrice(_oracleGasPrice);
  }

  
  function activateOracle() external payable {
    oracleActive = true;
    requestEthUsd(0);
  }

 
  function requestEthUsd(uint _delay) internal {
    if (oracleActive && !soldOut) {
      if (oraclize_getPrice(""URL"") > address(this).balance) {
        oracleActive = false;
      } else {
        if (_delay == 0) {
          oraclize_query(""URL"", ""json(https:
        } else {
          oraclize_query(_delay, ""URL"", ""json(https:
        }
      }
    }
  }

  
  function __callback(bytes32 myid, string result) public {
    if (msg.sender != oraclize_cbAddress()) revert();
    ethusd = parseInt(result, 2);
    requestEthUsd(oracleInterval);
  }

  
  function setOracleGasPrice(uint256 _gasPrice) external {
    require(_gasPrice > 0, ""Gas price must be a positive number."");
    oraclize_setCustomGasPrice(_gasPrice);
    oracleGasPrice = _gasPrice;
  }


  
  function setOracleGasLimit(uint256 _gasLimit) external {
    require(_gasLimit > 0, ""Gas limit must be a positive number."");
    oracleGasLimit = _gasLimit;
  }


  
  function setOracleInterval(uint256 _interval) external {
    require(_interval > 0, ""Interval must be > 0"");
    oracleInterval = _interval;
  }
}"
34095-0-0.sol,answer,"contract WidgetMaker {
  
}"
34095-0-0.sol,answer,"contract WidgetManager {

  WidgetMaker maker;

  function WidgetManager() public {
    maker = new WidgetMaker();
  }

  
}"
65711-0-0.sol,answer,"contract MyContract1 {
    uint256 public successCount;
    uint256 public failureCount;

    function() external payable {}

    function test(address wallet, uint256 amount) external {
        if (wallet.send(amount))
            successCount++;
        else
            failureCount++;
    }
}"
65711-0-0.sol,answer,"contract MyContract2 {
    function() external payable {}
}"
65711-0-0.sol,answer,"contract MyContract3 {
    function() external payable {revert();}
}"
6676-0-1.sol,answer,"contract SomeTest {
    

    modifier requiresFee(uint fee) {
        if (msg.value < fee) { throw; }
        _
    }

    function sellEnergy(uint kwh) public requiresFee(0.001 ether) {
        coinAccount[msg.sender] += (kwh * kWh_rate);
    }
}"
40687-0-0.sol,answer,"contract Owned {
    address owner;
    mapping(address=>bool) allowedUsers;
    function Owned() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function whitelistAddress (address user) onlyOwner {
        allowedUsers[user]=true;
    }   

    modifier onlyusers() {
        
        require(allowedUsers[msg.sender]);
        _;
    }

    function accessbyonlyusers () onlyusers {
        
    }
}"
7842-1-0.sol,answer,"contract Storage {

   address owner = 0xdeadbeef...; 

   bytes32[] storageContainer;

   function pushByte(bytes32 b) {
      storageContainer.push(b);
   }

}"
1527-3-0.sol,answer,"contract TestArray {
    uint[] public original;
    uint[] public newOr;
    event Log(uint n, uint a, uint b, uint c);

    function TestArray(){
        original.push(1);
        original.push(2);
        original.push(3);
        original.push(4);

    }

    function test(){
        newOr = remove(original, 1);
        Log(newOr.length, newOr[0], newOr[1], newOr[2]);
    }
    function remove(uint[] array, uint index) internal returns(uint[] value) {
        if (index >= array.length) return;

        uint[] memory arrayNew = new uint[](array.length-1);
        for (uint i = 0; i<arrayNew.length; i++){
            if(i != index && i<index){
                arrayNew[i] = array[i];
            } else {
                arrayNew[i] = array[i+1];
            }
        }
        delete array;
        return arrayNew;
    }

}"
49929-0-0.sol,answer,"contract Autos {
    address owner; 

    bool ifmember;
    mapping(address => bool) members;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyMember {
        require(msg.sender == owner || members[msg.sender] == true);
        _;
    }
    function addMember(address _address) public onlyMember {
        ifmember = members[_address];
    }
}"
10761-0-0.sol,answer,"contract test {

  struct my_struct {
    int a;
  }

  mapping (address=>my_struct[]) Map;

  function fill_map(my_struct struct1,my_struct struct2) internal  {

    Map[msg.sender].push(struct1);
    Map[msg.sender].push(struct2);

  }
}"
12228-0-0.sol,answer,"contract RootContract {
    event StateChanged();
    modifier modifies() {
        _;
        StateChanged();
    }
}"
12228-0-0.sol,answer,"contract Simple is RootContract {
  uint public data; 
  event Notify(uint newData);

  function setData(uint _data) modifies { data = _data; }
}"
8947-0-3.sol,answer,"contract TokenA {
    mapping (address => uint256) balances;

    event Transfer(address indexed _from, address indexed _to, uint256 _amount);

    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    function transfer(address _to, uint256 _amount) noEther returns (bool success) {
        if (balances[msg.sender] >= _amount && _amount > 0) {
            balances[msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(msg.sender, _to, _amount);
            return true;
        } else {
           return false;
        }
    }
}"
2993-0-0.sol,answer,"contract DieselPricePeg is usingOraclize {

    uint public DieselPriceUSD;


    function DieselPricePeg() {
        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);
        update(0); 
    }

    function __callback(bytes32 myid, string result, bytes proof) {
        if (msg.sender != oraclize_cbAddress()) throw;
        DieselPriceUSD = parseInt(result, 2); 
        
        update(60*10); 
    }

    function update(uint delay) {
        oraclize_query(delay, ""URL"", ""xml(https:
    }

}"
71477-0-0.sol,answer,"contract MetaCoin {
    function createVariable(uint _x) public  {
        assembly {
            let v := _x
            sstore(0, v)
            let w := add(_x,1)
            sstore(1, w)
        }
    }

    function getVariable() public view returns (uint r, uint s) {
        assembly{
            r := sload(0)
            s := sload(1)
        }
    }

    function addValue(uint _y) public returns (uint t){
        assembly{
            t := add(_y,sload(0))
            sstore(0,t)
        }
    }
}"
11109-0-0.sol,answer,"contract Token {

  modifier onlyOwner() {
    
    if(msg.sender != owner) throw;
    _;
  }

  function Token() {
    
    owner = msg.sender; 
    
  }
...
  function transfer(address sender, address receiver, uint amount) 
    onlyOwner  
    returns (bool success)
  {
    if(balances[sender] < amount) throw;
    balances[sender] -= amount;
    balances[receiver] += amount;
    return true;
  }
"
6665-0-0.sol,answer,"contract contractA {
    function blah(int x, int y) payable {}
}"
6665-0-0.sol,answer,"contract contractB {
    function invokeContractA() { 
        contractA a = contractA(0x1234567891234567891234567891234567891234);
        uint ValueToSend = 1234;
        a.blah.value(ValueToSend)(2, 3);
    }  
}"
73570-0-0.sol,answer,"contract Raffle {
    mapping(uint256 => address) reserved;

    event Reserved(uint256 value, address owner);

    function reserve(uint256 value) public {
        require(reserved[value] == address(0), ""Already reserved"");
        reserved[value] = msg.sender;
        emit Reserved(value, msg.sender);
    }
}"
13982-0-0.sol,answer,"contract Mapping {
    mapping(address => address) public matches;

    function writeMapping(address addr) {
        matches[addr] = msg.sender;
    }
}"
24141-0-0.sol,answer,"contract Conference { 

   address public organizer;
   mapping (address => uint) public registrantsPaid;
   uint public numRegistrants;
    uint quota = 2000;
   

   function buyTicket() payable public returns (bool success) { 
        require(numRegistrants >= quota);
        registrantsPaid[msg.sender] = msg.value;
         numRegistrants++;
         return true;
   }

   

  function destroy() { 
     if (msg.sender == organizer) {
        suicide(organizer); 
     }
  }

  function getContractBalance() constant returns (uint){
    return this.balance;    
  }

}"
27026-0-0.sol,answer,"contract CircularBuffer {
    uint[100] Arr;

    
    uint8 start;

    
    uint8 end;

    
    uint8 size;

    function append(uint value) public {
        Arr[end] = value;
        end = (end + 1) % 100;

        if (size < 100) {
            size += 1;
        } else {
            
            start = (start + 1) % 100;
        }
    }

    function enumerate() public {
        for (uint8 i = 0; i < size; i++) {
            uint value = Arr[(start + i) % 100];
            
        }
    }
}"
30305-0-0.sol,answer,"contract SimpleSet {
    
    
    mapping (address => uint) index;

    
    address[] store;

    function SimpleSet() public {
        
        store.push(0x0);
    }

    function addToArray(address who) public {
        if (!inArray(who)) {
            
            index[who] = store.length;
            store.push(who);
        }
    }

    function inArray(address who) public view returns (bool) {
        
        if (who != 0x0 && index[who] > 0) {
            return true;
        }
        return false;
    }

    function getPosition(uint pos) public view returns (address) {
        
        require(pos > 0); 
        return store[pos];
    }
}"
55193-1-0.sol,answer,"contract Set {
    bytes32[] public items;

    
    mapping(bytes32 => uint256) indexOf;

    function add(bytes32 value) public {
        if (indexOf[value] == 0) {
            items.push(value);
            indexOf[value] = items.length;
        }
    }

    function remove(bytes32 value) public {
        uint256 index = indexOf[value];

        require(index > 0);

        
        bytes32 lastValue = items[items.length - 1];
        items[index - 1] = lastValue;  
        indexOf[lastValue] = index;

        items.length -= 1;
        indexOf[value] = 0;
    }

    function contains(bytes32 value) public view returns (bool) {
        return indexOf[value] > 0;
    }

    function count() public view returns (uint256) {
        return items.length;
    }
}"
56506-1-0.sol,answer,"contract FactoryTest { 
    address[2] newContracts;

    function createContract(string name) public {
        address newContract = new ContractTest(name);
        newContracts[0] = newContract;
    }

    function getContract() public view returns (address) {
      return newContracts[0];
    }
}"
41082-2-0.sol,answer,"contract CA3 {

    struct Student {
        uint age;
        uint income;
        uint score;
        uint attendance;
    }

    Student[] public students;
    uint public studentCount=0;

    function setStudent (uint _age, uint _income, uint _score, uint _attendance) public {
        Student memory tempStudent = Student(_age, _income, _score, _attendance);
        students.push(tempStudent);
    }
}"
23221-2-0.sol,answer,"contract Owned {

    address public owner;

    function Owned() public {
        owner = msg.sender;
    }

    function changeOwner(address newOwner) public returns(bool success) {
        require(msg.sender == owner);
        owner = newOwner;
        return true;
    }
}"
23221-2-0.sol,answer,"contract HubInterface {
    function deployStub() public returns(address newStub);
    function isHub() public pure returns(bool isIndeed);
    function getUserContractAtRow(address user, uint row) public view returns(address userContract);
}"
23221-2-0.sol,answer,"contract Stub is Owned{

    address public owner;
    HubInterface hub;

    function Stub() public {
        hub = HubInterface(msg.sender);
        require(hub.isHub());
    }
}"
25810-0-0.sol,answer,"contract SimpleExample {
    event LogSender(address sender);
    function getSender() returns (address) {
        LogSender(msg.sender);
        return msg.sender;
    }
}"
13970-0-1.sol,answer,"contract Controlled {  
    address public userAddr;  

    struct User {  
      address a;  
      string name;  
      string email;  
      uint phone;  
    }  

    mapping (address => User) public Users;  

    event LogNewUser(address user, string name, string email, uint phone);

    function Controlled() {
        userAddr = msg.sender;
    }

    function registerUser(string _name, string _email, uint _phone) returns (bool success) {  
      Users[msg.sender].a = msg.sender;  
      Users[msg.sender].name = _name;  
      Users[msg.sender].email = _email;  
      Users[msg.sender].phone = _phone;  
      LogNewUser(msg.sender, _name, _email, _phone);
      return true;
    }

    modifier onlyUser {
        if (msg.sender != userAddr) throw;
        _;
    }

}"
13970-0-1.sol,answer,"contract Main is Controlled {  

  using DataSet for *;    
  DataSet.Data d;  

  struct userProduct {  
    address user_address;  
    uint id;  
    string desc;  
    uint price;  
  }  

  userProduct[] public products; 

  event LogNewUserProduct(address user, uint index, string description, uint price);

  function newUserProduct  (  
    address u,
    uint i,
    string d,
    uint p) onlyUser returns (bool added) {

    userProduct memory newProduct;
    newProduct.user_address = msg.sender;
    newProduct.id = i;  
    newProduct.desc= d;
    newProduct.price = p;
    products.push(newProduct);
    LogNewUserProduct(msg.sender, i, d, p);
    return true;
  }  

  function getUserInfo (uint g) constant returns (address ,bytes32, uint ) {  
      for (uint i = 0; i <= products.length; i++) {  
          if (products[i].id == g) {  
             return(products[i].user_address, DataSet.stringToBytes32(products[i].desc), products[i].price);  
          }  
      }  
  }  
}"
9965-2-0.sol,answer,"contract Student {
  uint public studentId;

  function getStudentId() public returns (uint) {
    return studentId++;
  }
}"
76985-0-0.sol,answer,"contract MappingInStruct {

    struct Parent {
        mapping(bytes32 => Child) childrenOfTheMapping;
        Child[] childrenOfTheArray;
    }

    struct Child {
        uint value;
        string name;
    }

    Parent[] parents;

    function newParent() public {
        Parent memory p;
        parents.push(p);
        
    }

    

    function newChildOfTheMapping(uint parent, bytes32 key, uint value, string memory name) public {
        Parent storage p = parents[parent]; 
        Child storage c = p.childrenOfTheMapping[key]; 
        c.value = value;
        c.name = name;
    }

    function getChildOfTheMapping(uint parent, bytes32 key) public view returns(uint value, string memory name) {
        Child storage c = parents[parent].childrenOfTheMapping[key];
        return (c.value, c.name);
    }

    

    function newChildOfTheArray(uint parent, uint value, string memory name) public {
        Child memory c = Child({
            value: value,
            name: name
        });
        Parent storage p = parents[parent];
        p.childrenOfTheArray.push(c);
    }

    function getChildOfTheArray(uint parent, uint child) public view returns(uint value, string memory name) {
        Child storage c = parents[parent].childrenOfTheArray[child];
        return (c.value, c.name);
    }

    
    function parentChildrenOfTheArrayCount(uint parent) public view returns(uint count) {
        count = parents[parent].childrenOfTheArray.length;
    }
}"
79177-0-2.sol,answer,"contract ProcessAmortization {

    using HitchensOrderStatisticsTreeLib for HitchensOrderStatisticsTreeLib.Tree;

    struct Pending {
        uint amount;
        address user;
        uint validTime;
    }

    mapping(bytes32 => Pending) public pendingStructs; 
    HitchensOrderStatisticsTreeLib.Tree pendingSorted; 

    event LogNewPending(address sender, uint validTime, address user, uint amount, bytes32 key);
    event LogCancelledPending(address sender, address user, bytes32 key);
    event LogProcessedPending(address sender, bytes32 key, uint amount, address user, uint validTime);

    modifier amortizedWork {
        
        if(backlog() > 0) {  
            
            uint first = next(); 
            
            bytes32 key = pendingSorted.valueKeyAtIndex(first, 0); 
            
            Pending storage p = pendingStructs[key]; 
            
            
            
            pendingSorted.remove(key, first);
            emit LogProcessedPending(msg.sender, key, p.amount, p.user, p.validTime);
        }
        _;
    }

    function pendingKey(uint validTime, address user, uint amount) public pure returns(bytes32) {
        return keccak256(abi.encodePacked(validTime, user, amount));
    }

    function insertPendingTransfer(uint validTime, address user, uint amount) public amortizedWork {
        bytes32 key = pendingKey(validTime, user, amount); 
        emit LogNewPending(msg.sender, validTime, user, amount, key);
        pendingSorted.insert(key, validTime); 
        Pending storage p = pendingStructs[key];
        p.amount = amount;
        p.user = user;
        p.validTime = validTime;
    }

    function cancelPendingTransfer(address user, bytes32 key) public amortizedWork {
        emit LogCancelledPending(msg.sender, user, key);
        Pending storage p = pendingStructs[key];
        pendingSorted.remove(key, p.validTime); 
        delete pendingStructs[key];
    }

    function next() public view returns(uint nextTime) {
        nextTime = pendingSorted.first();
    }

    function backlog() public view returns(uint count) {
        count = pendingSorted.below(now);
    }

    function whatTimeIsIt() public view returns(uint) {
        return now;
    }

    

}"
52698-0-0.sol,answer,"contract HashToUint {

    uint256 randNonce;

    function test() public returns(uint) {
        randNonce++;
        return uint(keccak256(abi.encodePacked(msg.sender, randNonce, now)));
    }
}"
31534-0-0.sol,answer,"contract Store {
  event ItemSet(bytes32 key, bytes32 value);

  string public version;
  mapping (bytes32 => bytes32) public items;

  constructor(string _version) public {
    version = _version;
  }

  function setItem(bytes32 key, bytes32 value) external {
    items[key] = value;
    emit ItemSet(key, value);
  }
}"
50764-0-0.sol,answer,"contract MyContract {
    struct myStruct {
        address id;
    }
    mapping(address => myStruct) myMapping;

    function doSomeStuff(address _tokenId) public view returns(address) {    
        myStruct storage myObj = myMapping[_tokenId];

        return myObj.id;
    }   
}"
7163-0-0.sol,answer,"contract Equipment {
    uint atk;
    uint duration;
    
    
    uint unique;

    function Equipment(uint atk_param, uint duration_param) {
       atk = atk_param;
       duration = duration_param;
    }

    
    function getWeaponOrArmor() constant public (uint) {
       return unique;
    }
}"
7163-0-0.sol,answer,"contract Weapon is Equipment {

    
    function Weapon(uint atk, uint duration) public {
        unique = 0;
    }

}"
37543-0-0.sol,answer,"contract Test {
    address public someAddr;
    function nullifySomeAddr() {
        someAddr = address(0);
    }
}"
44544-0-0.sol,answer,"contract RegisterContract {

    uint public contractWeight;

    mapping(bytes32=>string) public contracts;
    bytes32[] public myHashes;

    event LogAddContract(address sender, bytes32 hashKey, string jsonInput);
    event LogAddWeight(address sender, uint weight);

    function addContract ( string jsonInput, bytes32 hashKey) public {
        contracts[hashKey] = jsonInput;
        myHashes.push(hashKey);
        LogAddContract(msg.sender, hashKey, jsonInput);
     }

    function addWeight (uint weight) public {
        contractWeight = weight;
        LogAddWeight(msg.sender, weight);
    }

    function () payable public {
    }

}"
72754-0-0.sol,answer,"contract RefundTest {

    bool public boolGasTest;
    uint256 public uintGasTest;

    function unsetBool() public {
        boolGasTest = false;
    }

    function setBool() public {
        boolGasTest = true;
    }

    function unsetUint() public {
        uintGasTest = 0;
    }

    function setUint() public {
        uintGasTest = 1;
    }
}"
11703-0-0.sol,answer,"contract PlayWithGas {

  mapping(address => bytes32) names;

  function setName(address userAddress, bytes32 name) returns(bool success) {
    names[userAddress] = name;
    return true;
  }

  function getName(address userAddress) returns(bytes32 name) {
    return names[userAddress];
  }
}"
50507-0-1.sol,answer,"contract A {

  bytes32 public something;

  function setSomething(bytes32 newThing) public {
    something = newThing;
  }
}"
41082-0-0.sol,answer,"contract CA3 {

  uint public test=9;
  struct Student {
    uint16 age;
    uint16 income;
    uint16 score;
    uint16 attendance;
  }
  Student[] public students;
  uint public studentCount=0;

  function setStudent (uint16 _age, uint16 _income, uint16 _score, uint16 _attendance) public {
    test=19;
    Student memory tempStudent = Student({age: _age, income: _income, score: _score, attendance: _attend
ance});
    students.push(tempStudent);
    
  }   
}"
76966-0-0.sol,answer,"contract Increment {

    uint epoch;

    mapping(bytes32 => Contract) private contracts; 

    bytes32[] public idList;
    struct Contract { 
            uint data;
            uint vintage;
    }

    function newContract(bytes32 id, uint data, uint vintage) public {
        idList.push(id); 
        Contract storage c = contracts[id];
        c.data = data;
        c.vintage = vintage;
    }


    function setEpoch(uint e) public {
        epoch = e;
    }

    function getContract(uint row) public view returns(bytes32 id, uint data, uint age) {
        require(row <= idList.length);
        id = idList[row];
        Contract storage c = contracts[id];
        data = c.data;
        age = epoch - c.vintage; 
    }
}"
56920-0-0.sol,answer,"contract game {

    struct User
    {
        string name;
        
        
        
        
        
        uint level;
        uint score;
    }

    mapping(uint => User[]) mulUsers;

    function addUsers (string _name, uint _level, uint _score) public {
        User memory user = User(_name,_level,_score); 
        mulUsers[_level].push(user);
    }

    
    function getUsers (uint _level) public view returns (bytes32[] users)
    {
        uint length = mulUsers[_level].length;
        users = new bytes32[](length);

        for(uint i = 0; i < length; i++)
        {
            users[i] = stringToBytes32(mulUsers[_level][i].name);
        }   
    }

    
    function stringToBytes32(string memory source) private pure returns (bytes32 result) {
        bytes memory tempEmptyStringTest = bytes(source);
        if (tempEmptyStringTest.length == 0) {
            return 0x0;
        }

        assembly {
            result := mload(add(source, 32))
        }
    }
}"
13616-0-0.sol,answer,"contract External {

  Product p;

  function External(address addr) {
    p = Product(addr);
  }

  function readProduct(uint u) constant returns(bytes32 name, bool status) {
    return(p.productStructs(u));
  }
}"
15553-1-0.sol,answer,"contract DeletableMapping {
    
    mapping (bytes32 => string) carfaxReports;
    uint32 currentMappingVersion;

    function getCarfaxReport(string _carVIN) external view returns(string) {
        bytes32 key = keccak256(currentMappingVersion, _carVIN);
        return carfaxReports[key];
    }

    function setCarfaxReport(string _carVIN, string _reportJSON) external {
        bytes32 key = keccak256(currentMappingVersion, _carVIN);
        carfaxReports[key] = _reportJSON;
    }

    function deleteAllReports() external {
        currentMappingVersion++;
    }

    function recoverGas(uint32 _version, string _carVIN) external {
        require(_version < currentMappingVersion);
        bytes32 key = keccak256(_version, _carVIN);
        delete(carfaxReports[key]);
    }
}"
9203-1-0.sol,answer,"contract User {
    uint age;

    function User(uint _age) public {
        age = _age;
    }
}"
13480-1-0.sol,answer,"contract IsPayable {
  function () payable {}
}"
37273-0-0.sol,answer,"contract Car {

    struct car {
      bool available;
    }

    car audi;

    function Car() public {
        audi = car(true);
    }

    function checkAvailability() public view returns (bool) {
        return(audi.available);
    }
}"
73966-0-0.sol,answer,"contract GameItem is ERC721Full {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds;

    constructor() ERC721Full(""GameItem"", ""ITM"") public {
    }

    function awardItem(address player, string memory tokenURI) public returns (uint256) {
        _tokenIds.increment();

        uint256 newItemId = _tokenIds.current();
        _mint(player, newItemId);
        _setTokenURI(newItemId, tokenURI);

        return newItemId;
    }
}"
43865-0-1.sol,answer,"contract Test {
    uint256 public integer = 100;
    bool[] public array;

    function fill_array() {
        while (integer > 0) {
            bool bit = (integer%2) != 0;
            uint256 quotient = integer/2;
            array.push(bit);
            integer = quotient;
        }
    }
}"
38718-1-1.sol,answer,"contract A {
function sendtoken() payable returns(bool) {
      require(msg.value!=0);
      require(owner.send(msg.value));
      balances[msg.sender]+= 1;
      balances[owner]-= 1;
      return true;
 }
}"
59780-0-0.sol,answer,"contract Pausable is Ownable {

  bool public isRunning;

  modifier onlyWhenRunning {
    require(isRunning);
    _;
  }

  function stopContract() public onlyOwner {
    isRunning = false;
  }
}"
62384-0-1.sol,answer,"contract NoMixing {

    bytes public first;
    bytes public second;

    function mix() public returns (bytes, bytes) {  

        for (uint8 cnt = 0; cnt<8; cnt++) {
            first.push(9);
        }

        for (uint8 cnt2 = 0; cnt2<8; cnt2++) {
            second.push(8);
        }

        return (first,second);
    }

}"
12099-0-0.sol,answer,"contract ERC20Interface {

    
    function totalSupply() constant returns (uint256 totalSupply);

    
    function balanceOf(address _owner) constant returns (uint256 balance);

    
    function transfer(address _to, uint256 _value) returns (bool success);

    
    
    
    
    
    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);

    
    
    function approve(address _spender, uint256 _value) returns (bool success);

    
    function allowance(address _owner, address _spender) constant returns (uint256 remaining);

    
    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}"
12099-0-0.sol,answer,"contract BokkyPooBahTestToken is ERC20Interface {

    string public name;
    string public symbol;
    uint8 public decimals;

    
    address public owner;

    
    mapping(address => uint256) balances;

    
    mapping(address => mapping (address => uint256)) allowed;

    
    uint256 _totalSupply;

    
    modifier onlyOwner() {
        if (msg.sender != owner) {
            throw;
        }
        _;
    }

    
    function BokkyPooBahTestToken() {
        owner = msg.sender;
        name = ""BokkyPooBahTest"";
        symbol = ""BPBT"";
        decimals = 18;
        
        _totalSupply = 1000000000000000000000000;
        balances[owner] = _totalSupply * 50 / 100;
        balances[0x00001009bd8f0b1301cc5edc28ed1222a3ce671e] = _totalSupply * 5 / 100;
        balances[0x00011009bd8f0b1301cc5edc28ed1222a3ce671e] = _totalSupply * 5 / 100;
        balances[0x00021009bd8f0b1301cc5edc28ed1222a3ce671e] = _totalSupply * 5 / 100;
        balances[0x00031009bd8f0b1301cc5edc28ed1222a3ce671e] = _totalSupply * 5 / 100;
        balances[0x00041009bd8f0b1301cc5edc28ed1222a3ce671e] = _totalSupply * 5 / 100;
        balances[0x00051009bd8f0b1301cc5edc28ed1222a3ce671e] = _totalSupply * 5 / 100;
        balances[0x00061009bd8f0b1301cc5edc28ed1222a3ce671e] = _totalSupply * 5 / 100;
        balances[0x00071009bd8f0b1301cc5edc28ed1222a3ce671e] = _totalSupply * 5 / 100;
        balances[0x00081009bd8f0b1301cc5edc28ed1222a3ce671e] = _totalSupply * 5 / 100;
        balances[0x00091009bd8f0b1301cc5edc28ed1222a3ce671e] = _totalSupply * 5 / 100;
    }

    function totalSupply() constant returns (uint256 totalSupply) {
        totalSupply = _totalSupply;
    }

    
    function balanceOf(address _owner) constant returns (uint256 balance) {
        return balances[_owner];
    }

    
    function transfer(address _to, uint256 _amount) returns (bool success) {
        if (balances[msg.sender] >= _amount && _amount > 0) {
            balances[msg.sender] -= _amount;
            balances[_to] += _amount;
            Transfer(msg.sender, _to, _amount);
            return true;
        } else {
           return false;
        }
    }

    
    
    
    
    
    
    function transferFrom(
        address _from,
        address _to,
        uint256 _amount
    ) returns (bool success) {

        if (balances[_from] >= _amount
            && allowed[_from][msg.sender] >= _amount
            && _amount > 0) {

            balances[_to] += _amount;
            balances[_from] -= _amount;
            allowed[_from][msg.sender] -= _amount;
            Transfer(_from, _to, _amount);
            return true;
        } else {
            return false;
        }
    }

    
    
    function approve(address _spender, uint256 _amount) returns (bool success) {
        allowed[msg.sender][_spender] = _amount;
        Approval(msg.sender, _spender, _amount);
        return true;
    }

    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    
    function () {
        throw;
    }
}"
76843-0-0.sol,answer,"contract Graph {

    

    using HitchensUnorderedKeySetLib for HitchensUnorderedKeySetLib.Set;
    HitchensUnorderedKeySetLib.Set vertexSet;

    struct Vertex {
        
        HitchensUnorderedKeySetLib.Set inEdgeSet; 
        HitchensUnorderedKeySetLib.Set outEdgeSet; 
        mapping(bytes32 => Edge) outEdgeStructs;
    }

    mapping(bytes32 => Vertex) vertexStructs;

    struct Edge {
        
        uint limit;
    }

    

    function insertVertex(bytes32 vertexId) public {
        vertexSet.insert(vertexId); 
    }

    function insertEdge(bytes32 vertexFromId, bytes32 vertexToId, uint limit) public {
        require(vertexSet.exists(vertexFromId), ""From vertex does not exist."");
        require(vertexSet.exists(vertexToId), ""To vertex does not exist."");
        Vertex storage from = vertexStructs[vertexFromId];
        Vertex storage to = vertexStructs[vertexToId];
        from.outEdgeSet.insert(vertexToId); 
        to.inEdgeSet.insert(vertexFromId); 
        from.outEdgeStructs[vertexToId].limit = limit; 
    }

    function removeEdge(bytes32 vertexFromId, bytes32 vertexToId) public {
        require(vertexSet.exists(vertexFromId), ""From vertex does not exist."");
        require(vertexSet.exists(vertexToId), ""To vertex does not exist."");
        Vertex storage from = vertexStructs[vertexFromId];
        Vertex storage to = vertexStructs[vertexToId];
        from.outEdgeSet.remove(vertexToId); 
        to.inEdgeSet.remove(vertexFromId); 
        delete from.outEdgeStructs[vertexToId];
    }

    function removeVertex(bytes32 vertexId) public view {
        require(vertexStructs[vertexId].inEdgeSet.count() == 0, ""Cannot delete vertex with incoming edges."");
    }

    
}"
62188-1-1.sol,answer,"contract Sharer {
    function sendHalf() public payable {
        require(msg.value % 2 == 0, ""zonk bonk"");
    }
}"
84825-0-1.sol,answer,"contract B {
    A a_contract_instance;
    constructor(address _a_contract_address) public {
        a_contract_instance = A(_a_contract_address);
    }
    
    function callToContractA() public payable {
        a_contract_instance.updateLastFundSentToContract.value(msg.value)();
    }
    
    function getContractBalance() public view returns(uint256) {
        return address(this).balance;
    }
}"
65448-0-0.sol,answer,"contract GroupFactory is Owned {

  RegistryInterface r;

  function setRegistry(address reg) public onlyOwner {
    r = RegistryInterface(reg);
  }

  function createAndRegisterGroup(bytes32 groupName, uint units) public onlyOwner {
    Group g = new Group(groupName, units);
    r.registerGroup(address(g));
  }
"
18387-0-0.sol,answer,"contract relay {
  address target;

  function relay(address _target) {
    target = _target;
  }

  function () payable {
    target.send(msg.value);
  }
}"
43929-0-0.sol,answer,"contract Tester {
    struct Foo {
        bool stayFalse;
    }

    function Tester() public {
    }

    function runTest() public pure returns (bool, bool) {
        Foo memory foo;
        return one(foo);
    }

    function one(Foo memory foo) public pure returns (bool, bool){
        Foo memory foobar = two(clone(foo));
        return (foo.stayFalse, foobar.stayFalse);
    }

    function two(Foo memory bar) public pure returns (Foo) {
        bar.stayFalse = true;
        return bar;
    }

    function clone(Foo memory from) internal pure returns (Foo memory) {
        return Foo(from.stayFalse);
    }
}"
28759-0-1.sol,answer,"contract Sender {

    function() payable{

    }

    function sendTo(address receiverAddr) payable {
        var receiver = Receiver(receiverAddr);
        receiver.payMe.value(msg.value)();
    }
}"
28759-0-1.sol,answer,"contract Receiver {
    bool public received;

    function() payable{

    }

    function payMe() payable returns(bool success) {
        received = true;
        return true;
    }
}"
82470-0-0.sol,answer,"contract AMLToken is BurnableCrowdsaleToken {

  
  event OwnerReclaim(address fromWhom, uint amount);

  function AMLToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable) BurnableCrowdsaleToken(_name, _symbol, _initialSupply, _decimals, _mintable) {

  }

  
  
  
  function transferToOwner(address fromWhom) onlyOwner {
    if (released) revert();

    uint amount = balanceOf(fromWhom);
    balances[fromWhom] = balances[fromWhom].sub(amount);
    balances[owner] = balances[owner].add(amount);
    Transfer(fromWhom, owner, amount);
    OwnerReclaim(fromWhom, amount);
  }
}"
24744-0-1.sol,answer,"contract Test {

    

    
    function deposite() payable{

    }

    
    function sendWeis(address _receiver) payable returns (bool) {
        _receiver.transfer(msg.value);
        return true;
    }

    function getBalance(address _owner) constant returns (uint256) {
        return _owner.balance;
    }

}"
80219-0-0.sol,answer,"contract Test {
    function getHash(bytes32 challenge, address adr, uint256 nonce) external pure returns (bytes32) {
        return keccak256(abi.encodePacked(challenge, adr, nonce));
    }
}"
83448-0-0.sol,answer,"contract AtariToken is ERC20Interface {

    string public constant name = ""AtariToken"";
    string public constant symbol = ""ATAR"";
    uint8 public constant decimals = 0;

    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);
    event Transfer(address indexed from, address indexed to, uint tokens);
    event RegistrationSuccessful(uint256 nonce);
    event RegistrationFailed(uint256 nonce);

    mapping(address => uint256) balances;

    mapping(address => mapping (address => uint256)) allowed;

    uint256 totalSupply_ = 7777100000;

    mapping (string => address) addressTable;

    using SafeMath for uint256;

    constructor( uint256 _totalSupply) public{
        totalSupply_ = _totalSupply;
        balances[msg.sender] = totalSupply_;
    }

    function totalSupply() public override view returns (uint256) {
        return totalSupply_;
    }

    function balanceOf(address tokenOwner) public override view returns (uint) {
        return balances[tokenOwner];
    }

    function balanceOf(string memory tokenOwner) public view returns (uint) {
        address userAddress;
        userAddress = addressTable[tokenOwner];
        return balances[userAddress];
    }

    function transfer(address receiver, uint numTokens) public override returns (bool) {
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(numTokens);
        balances[receiver] = balances[receiver].add(numTokens);
        emit Transfer(msg.sender, receiver, numTokens);
        return true;
    }

    function transfer(string memory receiver, uint numTokens) public returns (bool) {
        address receiverAddress;
        receiverAddress = addressTable[receiver];
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(numTokens);
        balances[receiverAddress] = balances[receiverAddress].add(numTokens);
        emit Transfer(msg.sender, receiverAddress, numTokens);
        return true;
    }

    function approve(address delegate, uint numTokens) public override returns (bool) {
        allowed[msg.sender][delegate] = numTokens;
        emit Approval(msg.sender, delegate, numTokens);
        return true;
    }

    function approve(string memory delegate, uint numTokens) public returns (bool) {
        address delegateAddress;
        delegateAddress = addressTable[delegate];
        allowed[msg.sender][delegateAddress] = numTokens;
        emit Approval(msg.sender, delegateAddress, numTokens);
        return true;
    }

    function allowance(address owner, address delegate) public override view returns (uint) {
        return allowed[owner][delegate];
    }

    function allowance(string memory owner, string memory delegate) public view returns (uint) {
        address ownerAddress;
        ownerAddress = addressTable[owner];
        address delegateAddress;
        delegateAddress = addressTable[delegate];
        return allowed[ownerAddress][delegateAddress];
    }

     function transferFrom(address owner, address buyer, uint numTokens) public override returns (bool) {
        require(numTokens <= balances[owner]);    
        require(numTokens <= allowed[owner][msg.sender]);

        balances[owner] = balances[owner].sub(numTokens);
        allowed[owner][msg.sender] = allowed[owner][msg.sender].sub(numTokens);
        balances[buyer] = balances[buyer].add(numTokens);
        emit Transfer(owner, buyer, numTokens);
        return true;
    }

    function transferFrom(string memory owner, string memory buyer, uint numTokens) public returns (bool) {
        address ownerAddress;
        ownerAddress = addressTable[owner];
        address buyerAddress;
        buyerAddress = addressTable[buyer];

        require(numTokens <= balances[ownerAddress]);    
        require(numTokens <= allowed[ownerAddress][msg.sender]);

        balances[ownerAddress] = balances[ownerAddress].sub(numTokens);
        allowed[ownerAddress][msg.sender] = allowed[ownerAddress][msg.sender].sub(numTokens);
        balances[buyerAddress] = balances[buyerAddress].add(numTokens);
        emit Transfer(ownerAddress, buyerAddress, numTokens);
        return true;
    }

    function registerUser(string memory user, uint256 nonce) public returns (bool) {
        if (addressTable[user] == address(0)) {
            addressTable[user] = msg.sender;
            emit RegistrationSuccessful(nonce);
            return true;
        } else {
            emit RegistrationFailed(nonce);
            return false;
        }
    }
}"
27080-0-0.sol,answer,"contract Store {
  event ItemSet(bytes32 key, bytes32 value);

  mapping (bytes32 => bytes32) public items;

  function setItem(bytes32 key, bytes32 value) external {
    items[key] = value;
    emit ItemSet(key, value);
  }
}"
21643-0-0.sol,answer,"contract C {
    function getBalance() constant returns(uint) {
        return this.balance;
    }

    function buy() payable public {
        
    }

}"
21643-0-0.sol,answer,"contract D {
    
    function D() payable {
    }

    function getBalance() constant returns(uint) {
        return this.balance;
    }

    function sendToC(address c) public {
        C(c).buy.value(12)();
    }
}"
78738-1-1.sol,answer,"contract Wallet {
    address public owner;
    uint public foo;

    constructor(address _owner, uint _foo) public {
        owner = _owner;
        foo = _foo;
    }
}"
78738-1-1.sol,answer,"contract Factory {
    event Deployed(address addr, uint256 salt);

    function getCreationBytecode(address _owner, uint _foo) public pure returns (bytes memory) {
        bytes memory bytecode = type(Wallet).creationCode;

        return abi.encodePacked(bytecode, abi.encode(_owner, _foo));
    }

    
    function deploy(bytes memory bytecode, uint _salt) public {
        address addr;
        assembly {
            addr := create2(0, add(bytecode, 0x20), mload(bytecode), _salt)

            if iszero(extcodesize(addr)) {
                revert(0, 0)
            }
        }

        emit Deployed(addr, _salt);
    }
}"
64974-0-0.sol,answer,"contract C {
    D d = new D(4); 
    function createD(uint arg) public {
        D newD = new D(arg);
        newD.x();
    }
    function createAndEndowD(uint arg, uint amount) public payable {
        
        D newD = (new D).value(amount)(arg);
        newD.x();
    }
}"
51898-0-1.sol,answer,"contract Test {
    function Test() {...}
}"
79080-1-0.sol,answer,"contract Ownable {
    address public owner;

    
    constructor() public {
        owner = msg.sender;
    }

    
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    
    function transferOwnership(address newOwner) public onlyOwner {
        if (newOwner != address(0)) {
            owner = newOwner;
        }
    }

}"
79080-1-0.sol,answer,"contract ERC20Basic {
    uint public _totalSupply;
    function totalSupply() public view returns (uint);
    function balanceOf(address who) public view returns (uint);
    function transfer(address to, uint value) public;
    event Transfer(address indexed from, address indexed to, uint value);
}"
79080-1-0.sol,answer,"contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender) public view returns (uint);
    function transferFrom(address from, address to, uint value) public;
    function approve(address spender, uint value) public;
    event Approval(address indexed owner, address indexed spender, uint value);
}"
15663-1-1.sol,answer,"contract Test {
  uint public myVal;

  event LogNewVal(bool success, uint newVal);

  function doIt(uint newVal) returns(bool success) {
      bool s = setMyVal(newVal);
      LogNewVal(s, newVal);
      return true;
  }

  function setMyVal(uint _newVal) internal returns(bool success){
      myVal = _newVal;
      return true;
  }
}"
42715-0-2.sol,answer,"contract Crowdfunding {
        struct Request {
            string description;
            uint value;
            address recipient;
            bool complete;
        }

        Request[] public requests;
        address public manager;
        uint public minimumContribution;
        address[] public approvers;


function createRequest(string description, uint value, address recipient) public restricted {
        Request newRequest = Request({
           description: description,
           value: value,
           recipient: recipient,
           complete: false
        });

        requests.push(newRequest);
    }
}"
24160-0-0.sol,answer,"contract MyTest {

        string public publicKey;

        function setPublicKey(string _publicKey)
        {
            publicKey = _publicKey;
        }

        function getPublicKey() constant returns (string _publicKey) {
            return publicKey;
        }
    }"
54752-0-0.sol,answer,"contract TimedTokenVault {
    uint256 startTime;

    function setStartTime(uint256 _startTime) public {
        

        startTime = _startTime;
    }

    
    function requestToken() public {
        require(startTime > now, ""Sorry, token requests is not open yet"");

        
    }
}"
76673-1-0.sol,answer,"contract SillyContract {
    address private owner;
    constructor() public {
        owner = msg.sender;
    }
    modifier wasteEther(uint256 _lowestLimit) {
        uint256 counter = 0;
        while(gasleft() > _lowestLimit) counter++;
        _;
    }
    function getOwner() public view wasteEther(2900000) returns(address aa) {
        return owner;
    }
}"
71609-2-1.sol,answer,"contract UserManager {
   struct User {
      string username;
      string password;
      address userid;
      bool isAdmin;
   }

   mapping (uint => User) users;
   uint totalUsers=0;

   function checkIfUserExists(address userid) public view returns(bool) {
       for (uint o = 0; o < totalUsers; o++) {
           if (users[o].userid == userid) {
               return true;
           } else{
               return false;
           }
       }
   }

   function addUser(address userid) public {
       User memory user = User(""m"", ""n"", userid, true);
       totalUsers++;
       users[totalUsers] = user;

   }

}"
73611-1-0.sol,answer,"contract SubToken{ 
    mapping(address => uint) balances; 

    string  symbol; 
    string  name; 
    uint8  decimals; 
    uint  totalSupply;  

    using SafeMath for uint; 

    address contract_address;  

    constructor(string memory _name,string memory _symbol,uint8 _decimals,uint256 _totalSupply)  public{  
        name = _name;  
        symbol = _symbol;  
        decimals=_decimals;  
        totalSupply = _totalSupply;  
        balances[msg.sender]=_totalSupply;  
    }  

    
    
    
    
    

    event Transfer(address indexed from, address indexed to, uint tokens); 
    event Approval(address indexed tokenOwner, address indexed spender, uint tokens); 

}"
73611-1-0.sol,answer,"contract MainContract { 
    mapping(address => uint) balances; 

    mapping(address => mapping(address => uint)) allowed; 
    mapping(address => address[]) public created; 

    mapping(address => SubToken) public tokenlist; 

    address[] public contracts; 
    address owner = msg.sender; 

    using SafeMath for uint; 

    address contract_address; 
     
    function createNewContract(string memory _name,string memory _symbol,uint8 _decimals,uint256 _totalSupply) public returns(address){  
        SubToken st = new SubToken(_name,_symbol,_decimals,_totalSupply); 
         
        created[msg.sender].push(address(st));  
        contracts.push(address(st));  
        
    }  
    event Transfer(address indexed _from, address indexed _to, uint256 _value); 
    event Approval(address indexed _owner, address indexed _spender, uint256 _value); 

}"
65714-0-0.sol,answer,"contract Bytes {

    function convert(bytes32 b) public pure returns(uint) {
        return uint(b);
    }
}"
58432-0-1.sol,answer,"contract AirDropEarthDeeds is NFToken {
    bytes4 internal constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;

    
    
    function claimPlot(int256 latitude, uint256 longitude) external {
        require (latitude >= -66 && latitude <= 66);
        require (longitude >= 0 && longitude < 360);

        uint tokenId = uint(180 + latitude) * 10000 + longitude;
        address to = msg.sender;
        _mint(to, tokenId);

        if (to.isContract()) 
        {
            bytes4 retval = ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), tokenId, """");
            require(retval == MAGIC_ON_ERC721_RECEIVED);
        }
    }
}"
3285-0-1.sol,answer,"contract Answer { mapping(address => mapping(string => bool)) voters; struct qList { uint count;  mapping(address => mapping(uint => uint)) answer; } mapping(string => qList) questionnaires; function vote(string ID, uint qNum, uint ans) returns (bool) { if(voters[msg.sender][ID]) throw; voters[msg.sender][ID] = true; questionnaires[ID].count += 1; questionnaires[ID].answer[msg.sender][qNum] = ans; return true; } function getNumResult(string ID) constant returns (uint res) { return questionnaires[ID].count; }}"
66610-3-0.sol,answer,"contract MyContract {

    constructor(uint a, address b, bool c) public {
        _init(a, b, c);
    }

    function () public {
        _init(msg.value, msg.sender, false);
    }

    function _init(uint a, address b, bool c) private {
        
    }
}"
2-4-0.sol,answer,"contract GamescoreOracle {
  address public owner;
  string public gameWinner;
  event CallbackGetGameWinner();

  constructor() public {
    owner = msg.sender;
  }

  function updateGameWinner() public {
    emit CallbackGetGameWinner();
  }

  function setWinningTeam(string teamname) public {
    require(msg.sender == owner, ""Err: Not Authorized"");
    gameWinner = teamname;
  }

  function getGameWinner() public view returns (string) {
    return gameWinner;
  }
}"
62375-0-0.sol,answer,"contract Test {

    uint nonce = 0;

    function PRNG() public returns(uint) {
        nonce += 1;
        return uint(keccak256(abi.encodePacked(nonce, msg.sender, blockhash(block.number - 1))));
    }
}"
62448-0-0.sol,answer,"contract Test {

    function checkIntegerETH(uint a) public pure returns (bool) {
        return (a % 1 ether == 0);
    }
}"
10878-0-0.sol,answer,"contract Hub {

  
  mapping(address => uint) personMap;
  address[] public personIndex;

  address public owner;

  function Hub() {
    owner = msg.sender;
  }

  modifier onlyOwner() {
    if(msg.sender != owner) throw;
    _;
  }

  function createPerson() 
    public
    returns(address newPerson)
  {
    Person p = new Person(msg.sender);              
    personMap[p] = personIndex.length;              
    personIndex.push(p);                            
    return p;
  }

  function deletePerson(address person) 
    onlyOwner
    returns(bool success)
  {
    
    uint location = personMap[person];              
    address personAddress = personIndex[location];  
    
    if(personIndex[personMap[person]] != person) throw; 
    
    personIndex[personMap[person]] = personIndex[personIndex.length-1];
    
    
    personMap[personIndex[personIndex.length-1]] = personMap[person]; 
    
    personIndex.length--;
    
    return true;
  }

  

  function getPersonCount() 
    public
    constant
    returns(uint count)
  {
    return personIndex.length;
  }

  function getPersonAtIndex(uint index)
    public
    constant
    returns(address person)
  {
    return personIndex[index];
  }
}"
10878-0-0.sol,answer,"contract Person {

  
  address public personOwner;

  struct PersonStruct {
    bytes32 encrypted1;
    bytes32 encrypted2;
  }

  PersonStruct p;

  modifier onlyPerson {                       
    if(msg.sender != personOwner) throw;
    _;
  }

  function Person(address person) {
    personOwner = person;                   
    
  }

  function getPerson()
    onlyPerson
    constant
    returns(bytes32, bytes32)
  {
    return(p.encrypted1, p.encrypted2);
  }

  function setPerson(bytes32 part1, bytes32 part2)
    onlyPerson
    returns(bool success)
  {
    p.encrypted1 = part1;
    p.encrypted2 = part2;
    return true;
  }
}"
56475-2-0.sol,answer,"contract Counter {
    int private count = 0;

    modifier isAdmin() {
        require(msg.sender == 0xYOUR-ADDRESS-HERE);
        _;
    }

    function incrementCounter() public isAdmin {
        count += 1;
    }

    function decrementCounter() public isAdmin {
        count -= 1;
    }

    function getCount() public constant returns (int) {
        return count;
    }
}"
2567-0-0.sol,answer,"contract A {
    bool aHit;
    bool public aPublicHit;
    bool public aConstructorArg;
    bool cHit;

    function A(bool _aConstructorArg) {
      aHit = true;
      aPublicHit = true;
      aConstructorArg = _aConstructorArg;
    }
}"
2567-0-0.sol,answer,"contract T is Test {

  function testConstructor() {
    B b = new B(true);
    
    
    
    
    
    
  }

}"
62295-0-0.sol,answer,"contract Try {

  using SafeMath for uint256;

  function someFunction() public view returns (bool) {
    uint256 a = 23;
    uint256 b = 48;
    return (a.add(1) > b);
  }

}"
42961-0-0.sol,answer,"contract Checker {

    mapping (address => bytes32) members; 
    mapping (bytes32 => bool) isTaken;

    function isMember(address member) public view returns(bool isIndeed) {
        return (members[member] != 0);
    }

    function isSet(bytes32 name) public view returns(bool isIndeed) {
        return (isTaken[name]);
    }

    function register(bytes32 _name) public returns(bool success){
        require(members[msg.sender] == """");
        require(!isSet(_name));
        members[msg.sender] = _name;
        isTaken[_name] = true;
        return true;
    }

}"
57601-0-0.sol,answer,"contract Caller {

    address public called_address;

    function set_address(address _addy) public {
        called_address = address(_addy);
    }
    function getCalleeValue() public view returns (uint){
        Called c = Called(called_address);
        return c.get();
    }
    function setCalleeValue(uint newValue) public returns (uint){
        Called c = Called(called_address);
        c.set(newValue);

}

interface Called{

    function set(uint) external;
    function get() external view returns (uint);
}
"
25154-0-2.sol,answer,"contract B {
    address public owner;
    string public name;
    function B(address _owner, string _name) {
        owner = _owner;
        name = _name;
    }
}"
632-0-1.sol,answer,"contract UsesMultiReturner {
    function doIt() {
        mr = MultiReturner(0x1234);

        
        var (a, b) = mr.getData();

        
        var (a, b) = mr.getDynamicData();
    }
}"
11056-0-1.sol,answer,"contract Hub {
  event LogSomething(address contract, bytes32 Id);
  ...
  function logSomething(bytes32 Id);
    LogSomething(msg.sender, Id); 

contract Created{ 
   ...
   function important(bytes32 id) {
      .. 
      Hub.logSomething(Id);"
11056-0-1.sol,answer,"contract Created{ 
   ...
   function important(bytes32 id) {
      .. 
      Hub.logSomething(Id);"
376-1-1.sol,answer,"contract Deck {
   uint8[52] deck;

   function shuffle(bytes randomBytes) {
      if (randomBytes.length < 52) throw;

      uint8[52] memory unshuffled;

      for (uint8 i=0; i < 52; i++) {
          unshuffled[i] = i;
      }

      uint8 cardIndex;

      for (i=0; i < 52; i++) {
          cardIndex = uint8(randomBytes[i]) % (52 - i);
          deck[i] = unshuffled[cardIndex];
          unshuffled[cardIndex] = unshuffled[52 - i - 1];
      }
   }
}"
729-2-0.sol,answer,"contract C {
  using strings for *;
  string public s;

  function foo(string s1, string s2) {
    s = s1.toSlice().concat(s2.toSlice());
  }
}"
34012-1-0.sol,answer,"contract Something {

    mapping (address => Ton[]) public allTons;

    struct Ton { 
        uint id;
        string name;
        bool access;
    }

    constructor() public {

        allTons[msg.sender].push(Ton({
            id: 1,
            name: ""CoolDude"",
            access: true
        }));

        allTons[msg.sender].push(Ton({
            id: 2,
            name: ""NotCoolDude"",
            access: false
        }));
    }

    
    

    function getTonCount(address _address) public view returns (uint _count) {
        _count = allTons[_address].length;        
    }

}"
3010-2-0.sol,answer,"contract Ctrt {
    uint public numerator;
    uint public denominator;
    uint public quotient;
    uint public remainder;
    constructor() public {
      numerator = 100;
      denominator = 3;
    }
    function setNumbers(uint _numerator, uint _denominator) public {
      numerator = _numerator;
      denominator = _denominator;
    }
    function safeDiv(uint _numerator, uint _denominator) public {
      quotient = _numerator / _denominator;
      remainder = _numerator - quotient * _denominator;
    }
    function safeDivDefault() public {
      quotient = _numerator / _denominator;
      remainder = _numerator - quotient * _denominator;
      
    }
}"
68824-0-3.sol,answer,"contract HelloUniverse {

  HelloWorld helloWorldContract; 

  constructor(address helloWorldContractAddress) public {
      helloWorldContract = HelloWorld(helloWorldContractAddress);
  }

  function talk() public view returns(string memory) {
    return helloWorldContract.response();
  }
}"
71609-2-0.sol,answer,"contract UserManager {
   struct User {
      string username;
      string password;
      address userid;
      bool isAdmin;
   }

   mapping (uint => User) users;
   uint totalUsers=0;

   function checkIfUserExists(address userid) public view returns(bool) {
       for (uint o = 0; o < totalUsers; o++) {
           if (users[o].userid == userid) {
               return true;
           } else{
               return false;
           }
       }
   }

   function addUser(address userid) public {
       User memory user = User(""m"", ""n"", userid, true);

       users[totalUsers] = user;
       totalUsers++;
   }

}"
42715-0-14.sol,answer,"contract Numbers {
    int[] public numbers;

    function Numbers() public {
        numbers.push(20);
        numbers.push(32);
    }

    function changeArray(int[] myArray) private {
        myArray[0] = 1;
    }
}"
68329-1-0.sol,answer,"contract Test {
    uint public x;

    function set(uint _x) public {
        x = _x;
    }

    function get() public returns(uint) {
        return x;
    }

}"
25493-1-0.sol,answer,"contract pullother {

    function callFunctionInContractOne (address _address) returns (uint) {
        helloworld contractOne = helloworld(_address);
        return contractOne.returnint();
    }

}"
50000-0-0.sol,answer,"contract Bar {
    uint256[] public data;
    constructor() public {
        data.length = uint256(~0);
    }
    function foo(uint256 value) public {
        data.push(value);
    }
}"
12730-2-0.sol,answer,"contract Foobar {
    function checkSignature(bytes32 digest, uint8 v, bytes32 r, byres32 s) constant returns (address signer) {
        return ecrecover(digest, v, r, s);
    }
}"
15353-2-0.sol,answer,"contract CrowdFunding {
    event DeadlineSet(
        address indexed _from,
        uint deadline,
        uint timeNow
    );

    uint deadline;

    function withdrawal() returns(bool) {
        DeadlineSet(msg.sender,deadline,now);
        return true;
    }
}"
61208-0-0.sol,answer,"contract ZK {
    uint private age;

    constructor (uint _age) public {
        age = _age;
    }

    function isAdult() public view returns (bool) {
        return (age >= 18);
    }

    function isTeen() public view returns (bool) {
        return (age >= 13 && age <= 19);
    }

    function addYears (uint _years) public {
        age += _years;
    }
}"
71637-0-1.sol,answer,"contract Lottery {
          address public manager;
          address payable[] public players;

          constructor() public {
              manager = msg.sender;
          }

          function getPlayers() public view returns(address payable[] memory) {
              return players;
          }
      }"
11726-0-0.sol,answer,"contract Example {

   string public brandName;

   function Example(string yourCompanyName) payable { 
       brandName = yourCompanyName;
   }

}"
83226-0-0.sol,answer,"contract FlowTest {

    uint256 public a = 0;
    uint256 public b = 2**256-1; 

    function flow () external {
        a -= 1;
        b += 1;
    }
}"
61048-0-0.sol,answer,"contract TestMyContract {
    MyContract contract = MyContract(DeployedAddresses.MyContract());

    function testCanCallFunction() public {
        myContract.myFunction({from: accounts[0]);
    }
}"
78333-0-1.sol,answer,"contract GraphTest {

    using GraphLib for GraphLib.Graph;
    using HitchensUnorderedAddressSetLib for HitchensUnorderedAddressSetLib.Set;
    GraphLib.Graph userGraph;

    struct UserStruct {
        string name;
        
    }

    HitchensUnorderedAddressSetLib.Set userSet;
    mapping(address => UserStruct) private userStructs;

    function newUser(address userId, string memory name) public {
        userSet.insert(userId);
        userStructs[userId].name = name;
        userGraph.insertNode(toBytes32(userId));
    }

    function removeUser(address userId) public {
        userGraph.removeNode(toBytes32(userId)); 
        delete userStructs[userId];
        userSet.remove(userId);
    }

    function updateUser(address userId, string memory name) public {
        require(userSet.exists(userId), ""GraphTest: Unknown user."");
        userStructs[userId].name = name;
    }

    function follow(address sourceId, address targetId, uint importance) public {
        require(userSet.exists(sourceId), ""GraphTest: Unknown follower."");
        require(userSet.exists(targetId), ""GraphTest: Unknown target."");
        userGraph.insertEdge(toBytes32(sourceId), toBytes32(targetId), importance);
    }

    function unfollow(address sourceId, address targetId) public {
        require(userSet.exists(sourceId), ""GraphTest: Unknown follower."");
        require(userSet.exists(targetId), ""GraphTest: Unknown target."");
        userGraph.removeEdge(toBytes32(sourceId), toBytes32(targetId));
    }

    function adjustFollow(address sourceId, address targetId, uint importance) public {
        userGraph.updateEdge(toBytes32(sourceId), toBytes32(targetId), importance);
    }

    

    function userCount() public view returns(uint count) {
        count = userSet.count();
    }

    function userAtIndex(uint index) public view returns(address userId) {
        userId = userSet.keyAtIndex(index);
    }

    function userInfo(address userId) public view returns(string memory name, uint followerCount, uint followingCount) {
        require(userSet.exists(userId), ""GraphTest: Unknown user."");
        (followerCount, followingCount) = userGraph.node(toBytes32(userId));
        name = userStructs[userId].name;
    }

    function userFollowerAtIndex(address userId, uint index) public view returns(address followerId, uint importance) {
        require(userSet.exists(userId), ""GraphTest: Unknown user."");
        bytes32 edgeId = userGraph.nodeSourceEdgeAtIndex(toBytes32(userId), index);
        (bytes32 source, uint weight) = userGraph.edgeSource(edgeId);
        importance = weight;
        followerId = toAddress(source);
    }

    function userFollowingAtIndex(address userId, uint index) public view returns(address followingId, uint importance) {
        require(userSet.exists(userId), ""GraphTest: Unknown user."");
        bytes32 edgeId = userGraph.nodeTargetEdgeAtIndex(toBytes32(userId), index);
        (bytes32 target, uint weight) = userGraph.edgeTarget(edgeId);
        importance = weight;
        followingId = toAddress(target);
    }

    

    

    

    function toBytes32(address a) private pure returns(bytes32) {
        return bytes32(uint(uint160(a)));
    }

    function toAddress(bytes32 b) private pure returns(address) {
        return address(uint160(uint(b)));
    }
}"
47370-0-0.sol,answer,"contract Canary {

    function timeStamp() constant returns (uint256) {
        return now;
    }
}"
68970-0-0.sol,answer,"contract SimpleERC20Token {
    
    mapping (address => uint256) public balanceOf;

    
    string public name = ""Simple ERC20 Token"";
    string public symbol = ""SET"";
    uint8 public decimals = 18;
    uint256 public totalSupply = 1000000 * (uint256(10) ** decimals);

    event Transfer(address indexed from, address indexed to, uint256 value);

    constructor() public {
        
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0), msg.sender, totalSupply);
    }

    function transfer(address to, uint256 value) public returns (bool success) {
        require(balanceOf[msg.sender] >= value);

        balanceOf[msg.sender] -= value;  
        balanceOf[to] += value;          
        emit Transfer(msg.sender, to, value);
        return true;
    }

    event Approval(address indexed owner, address indexed spender, uint256 value);

    mapping(address => mapping(address => uint256)) public allowance;

    function approve(address spender, uint256 value)
        public
        returns (bool success)
    {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value)
        public
        returns (bool success)
    {
        require(value <= balanceOf[from]);
        require(value <= allowance[from][msg.sender]);

        balanceOf[from] -= value;
        balanceOf[to] += value;
        allowance[from][msg.sender] -= value;
        emit Transfer(from, to, value);
        return true;
    }
}"
10862-0-2.sol,answer,"contract Test {
    uint256 public v1;
    uint256 public v2;
    string public v3;

    function Test(uint256 _v1, uint256 _v2, string _v3) {
        v1 = _v1;
        v2 = _v2;
        v3 = _v3;
    }
}"
83823-0-0.sol,answer,"contract newToken is S5Implement {

      uint256 private price = 1 ether;

      mapping (uint256 => uint256) private priceMapping;

      function getPrice(uint256 _tokenId) public view returns(uint256) {
           return priceMapping[_tokenId];
      }
  }"
57870-0-0.sol,answer,"contract Test2 
{
    address testVal;

    constructor() public {
        testVal= msg.sender;
    } 

   function getMSGSender() public view returns ( address) {
     return testVal;
   }
}"
57870-0-0.sol,answer,"contract Test1 is Test2 {

}"
1527-1-0.sol,answer,"contract Test {
    uint[] array = [1,2,3,4,5];
    function remove(uint index)  returns(uint[]) {
        if (index >= array.length) return;

        for (uint i = index; i<array.length-1; i++){
            array[i] = array[i+1];
        }
        array.length--;
        return array;
    }
}"
43174-1-0.sol,answer,"contract Foo {

    function foo(address _addr) public {
        if(_addr.call(bytes4(keccak256(""isSafe()"")))) {

        }
    }

}"
11708-0-0.sol,answer,"contract Genobject {
    uint public item;

    function Genobject(uint _val) {
        item = _val;
    }
}"
11708-0-0.sol,answer,"contract Caller {
   Genobject public instance;

   function Caller() {
       instance = new Genobject(3);
   }

   function recall() constant returns (uint) {
        return instance.item();
   }
}"
82834-0-0.sol,answer,"contract A is AccessControl {

    event EventCreated(address creator, uint value);

    modifier onlyCreator(address account) {
        require(hasRole(CREATOR_ROLE, account), ""Only creators allowed"");
        _;
    }

    constructor() public {
        _setupRole(CREATOR_ROLE, msg.sender);
    }

    function createEvent(uint amount) public onlyCreator(msg.sender) {
        emit EventCreated(msg.sender, amount);
    }
}"
26530-0-1.sol,answer,"contract Foo is FooInterface {   
    function a(uint _amount) public pure returns(uint amount) {
        return _amount;
    }
}"
38046-0-0.sol,answer,"contract A {

        bytes32 name;
        function A(bytes32 _name) public {
            name = _name;
        }

        function getName() public constant returns (bytes32) {
            return name;
        }
    }"
38046-0-0.sol,answer,"contract handleArray {

        bytes32 public name;
        uint public arrIndex;

        mapping(uint => address) testArray;

        function handleArray() public {
            arrIndex = 0;
        }

        function newEntry(address _newA) public {
            testArray[arrIndex] = A(_newA);
            arrIndex++;
        }

        function returnEntry(uint _index) public returns (string) {
            bytes32 input;
            string memory output;
            A a = A(testArray[_index]);

            
            input = a.getName();

            bytes memory bytesArray = new bytes(32);
            for (uint256 i; i < 32; i++) {
                bytesArray[i] = input[i];
            }

            
            output = string(bytesArray);

            return string(output);
        }
    }"
73427-1-0.sol,answer,"contract timeLock {

    uint256 lockTime = 1 days;

    struct locked{
        uint256 expire;
        uint256 amount;
    }

    mapping(address => locked) users;

    function lockEther() public payable {
        require(msg.value>0);
        locked storage userInfo = users[msg.sender];
        userInfo.expire = block.timestamp + lockTime;
        userInfo.amount = msg.value;
    }

    function withdraw() public {
        require(block.timestamp>=users[msg.sender].expire);
        locked storage userInfo = users[msg.sender];
        uint256 value = userInfo.amount;
        userInfo.expire = 0;
        userInfo.amount = 0;
        msg.sender.transfer(value);
    }



}"
11540-0-0.sol,answer,"contract TestContract {
    function TestContract() public {}

    function test(uint256 iterations) public pure returns(uint) {
        int256[] memory a = new int256[](1000);

        for (uint32 i = 0; i < iterations; ++i) {
            a[i] = i;
        }
        return a.length;
    }
}"
144-2-0.sol,answer,"contract ReceiverPays {
    address owner = msg.sender;

    mapping(uint256 => bool) usedNonces;

    
    function ReceiverPays() public payable { }


    function claimPayment(uint256 amount, uint256 nonce, bytes sig) public {
        require(!usedNonces[nonce]);
        usedNonces[nonce] = true;

        
        bytes32 message = prefixed(keccak256(msg.sender, amount, nonce, this));

        require(recoverSigner(message, sig) == owner);

        msg.sender.transfer(amount);
    }

    
    function kill() public {
        require(msg.sender == owner);
        selfdestruct(msg.sender);
    }


    

    function splitSignature(bytes sig)
        internal
        pure
        returns (uint8, bytes32, bytes32)
    {
        require(sig.length == 65);

        bytes32 r;
        bytes32 s;
        uint8 v;

        assembly {
            
            r := mload(add(sig, 32))
            
            s := mload(add(sig, 64))
            
            v := byte(0, mload(add(sig, 96)))
        }

        return (v, r, s);
    }

    function recoverSigner(bytes32 message, bytes sig)
        internal
        pure
        returns (address)
    {
        uint8 v;
        bytes32 r;
        bytes32 s;

        (v, r, s) = splitSignature(sig);

        return ecrecover(message, v, r, s);
    }

    
    function prefixed(bytes32 hash) internal pure returns (bytes32) {
        return keccak256(""\x19Ethereum Signed Message:\n32"", hash);
    }
}"
10981-0-1.sol,answer,"contract SubjectContract {
    uint public count = 0;

    function increaseCount() returns (uint newCount) {
        count ++;
        newCount = count;
    }
}"
14037-1-1.sol,answer,"contract C {
    
    function test(address addressOfD, bytes bb) {
        addressOfD.call(bb);
    }
}"
14037-1-1.sol,answer,"contract D {
    event LogMsgData(bytes calldata);

    function() {
        LogMsgData(msg.data);
    }
}"
20933-0-0.sol,answer,"contract ForceSend {
  function ForceSend(address recipient) payable {
    selfdestruct(recipient);
  }
}"
8343-0-0.sol,answer,"contract Limited {
    uint constant public weiPerDay = uint(1 ether);
    uint constant public weiPerSecond = weiPerDay /  uint(1 days);
    address public owner;
    uint public allowance;
    uint public lastSendTime; 

    function Limited() {
        owner = msg.sender;
        lastSendTime = now;
        allowance = weiPerDay;
    }

    function update() {
        allowance += weiPerSecond * (lastSendTime - now);
        if(allowance > weiPerDay) allowance = weiPerDay;
        lastSendTime = now;
    }

    function transfer(address _to, uint _amount) {
        update();
        if((msg.sender != owner) || (_amount > this.balance) ||(_amount > allowance)) throw;
        allowance -= _amount;
        if(!_to.send(_amount)) throw;
    }
}"
73574-0-1.sol,answer,"contract CustTest { 
  mapping(address => address) public customers;
  function createProfile() public { 
    customers[msg.sender] = address(new CustList()); 
  } 
}"
35790-2-0.sol,answer,"contract DeleteUser {

    struct UserStruct {
        uint userId;
        uint[] assets;
    }

    mapping(address => UserStruct) public userStructs;

    function deleteUserAsset(address user, uint assetIndex, uint asset) public {
        UserStruct storage u = userStructs[user];
        require(u.assets.length > assetIndex);
        require(u.assets[assetIndex] == asset); 
        u.assets[assetIndex] = u.assets[u.assets.length-1];
        u.assets.length--;
    }

}"
68654-1-0.sol,answer,"contract Store {
    mapping(bytes32 => bytes32) private store;
    mapping(bytes32 => address) private authors;
    address private owner;

    constructor() public {
        owner = msg.sender;
    }

    function set(bytes32 key, bytes32 value) public payable {
        require(msg.value == 1 ether);
        require(store[key] == 0 || authors[key] == msg.sender);
        store[key] = value;
        authors[key] = msg.sender;
    }

    function get(bytes32 key) public view returns(bytes32) {
        return store[key];
    }

    function withdraw(address payable receiver) public {
        require(msg.sender == owner);
        receiver.transfer(address(this).balance);
    }
}"
11533-0-1.sol,answer,"contract C {
    function f(uint len) {
        uint[] memory a = new uint[](7);
        bytes memory b = new bytes(len);
        
        a[6] = 8;
    }
}"
65804-0-0.sol,answer,"contract Reg {
    mapping (address => uint256) public userBalances;
    address payable otherContr;

    constructor(address payable otherContrAddr) public {
        otherContr = otherContrAddr;
    }

    function() payable external  {
        userBalances[msg.sender] += msg.value;
    }

    function transferToOtherContr() public {
        otherContr.transfer(address(this).balance);
    }

}"
65804-0-0.sol,answer,"contract Subm {
    function() payable external { 
        
    }
}"
8362-0-0.sol,answer,"contract SetGetArray {

  uint[] someNumbers;

  function getArray() public constant returns (uint[]) {
    return someNumbers;
  }

  function setArray(uint[] setNumbers) public  {

    someNumbers = setNumbers;

  }

}"
44765-0-0.sol,answer,"contract ContractA {
    function one() public pure returns(uint) {
        return 1;
    }
}"
44765-0-0.sol,answer,"contract ContractB is ContractA {
    function two() public pure returns(uint) {
        return 2;
    }
}"
25744-1-0.sol,answer,"contract Send {
    function sendtest() payable(returns bool){
        bool res = this.address.send(msg.value);
        return res
    }
}"
59899-0-0.sol,answer,"contract DappToken {
  uint256 public _totalSupply;

  function DappToken () public {
    _totalSupply = 10000000;
  }
  function totalSupply() public view returns (uint256) {
    return _totalSupply;
  }
}"
71435-0-0.sol,answer,"contract Victim{
    function() external payable {
        revert();
    }

    function getEthBalance() public view returns (uint){
        return address(this).balance;
    }
}"
71435-0-0.sol,answer,"contract Attack {


    function pay() public payable {

    }

    function getEthBalance() public view returns (uint){
        return address(this).balance;
    }

    function kill(address payable victim) public {
        selfdestruct(victim);
    }

}"
73601-0-1.sol,answer,"contract A2 {
    function doIt() public {
    }
}"
73601-0-1.sol,answer,"contract B2 is A2 {
    function doOther(uint value5) public {
    }
}"
15998-1-0.sol,answer,"contract EventManager {

    struct Event {
        bytes32 name;
        uint time;
    }

    uint totalEvents;

    mapping(uint => Event) EventList;

    event EventAdded(address indexed _senderAddress, uint _eventId);

    function addEvent(bytes32 _name, uint _time) returns(uint eventId) {
        eventId = totalEvents++;
        EventList[eventId] = Event(_name, _time);
        EventAdded(msg.sender, eventId);
    }

    function listEvents(uint _start, uint _count) constant returns(uint[] eventIds, bytes32[] eventNames, uint[] eventTimes) {

        uint maxIters = _count;
        if( (_start+_count) > totalEvents) {
            maxIters = totalEvents - _start;
        }

        eventIds = new uint[](maxIters);
        eventNames = new bytes32[](maxIters);
        eventTimes = new uint[](maxIters);

        for(uint i=0;i<maxIters;i++) {
            uint eventId = _start + i;

            Event memory e = EventList[eventId];
            eventIds[i] = eventId;
            eventNames[i] = e.name;
            eventTimes[i] = e.time;
        }
    }
}"
77245-0-0.sol,answer,"contract YourContract {
    
    InterestRateModel interest_rate_model;

    constructor(address _interest_rate_model_contract_address) public {
        interest_rate_model = InterestRateModel(_interest_rate_model_contract_address);
    }

    function getInterestRateModelBorrowRate() public view returns (uint, uint) {
        return interest_rate_model.getBorrowRate(1, 2, 3);
    }
}"
33792-0-1.sol,answer,"contract UserReg {

    mapping(address => bool) public isUser;

    function add(address userAddress) public {
        require(userAddress != 0x0 && !isUser[userAddress]);             
        isUser[userAddress] = true;    
    }

    function pass(address passAddress) public view returns(bool) {   
        return isUser[passAddress];
    }

    

    function isUserReg() public pure returns(bool isIndeed) {
        return true;
    }
}"
33792-0-1.sol,answer,"contract SaveData {

    address[] public addrs;

    UserReg userReg;

    function instantiateXyz(address userRegAddr) public returns(bool success) {
        userReg = UserReg(userRegAddr);     
        require(userReg.isUserReg());       
        return true;
    }

    function saveAddress(address pubAddress) public returns(bool success) {
        require(userReg.pass(pubAddress)==true);
        addrs.push(pubAddress);    
        return true;
    }

}"
41641-0-0.sol,answer,"contract ReserveToken {

...

    function ExominiumToken(address _addressFounder) {"
45351-0-0.sol,answer,"contract ContractA {
    uint num;

    function ContractA(uint n) public {
        num = n;
    }

    function get() public view returns(uint) {
        return num;
    }
}"
45351-0-0.sol,answer,"contract ContractB {

    struct Info {
        ContractA ainstance;
    }
    mapping(uint => Info) infoMapping;
    uint length;

    function ContractB() public {

    }

    function create(uint n) public {
        infoMapping[length] = Info(
            new ContractA(n)
        );
        length++;
    }

    function get(uint index) public view returns(uint) {
        return infoMapping[index].ainstance.get();
    }

}"
40960-0-0.sol,answer,"contract A {
    B[] public arrayOfBs;
    function create() returns (B) {
        B b = new B();
        arrayOfBs.push(b);
        return b;
    }
}"
46672-0-0.sol,answer,"contract AssetFactory {
    Asset[] deployedAssets;

    function createAsset(string name) public returns (Asset) {
        Asset newAsset = new Asset(name);
        deployedAssets.push(newAsset);
        return newAsset;
    }

}"
46672-0-0.sol,answer,"contract Asset {
    string name;

    constructor(string _name) public {
        name = _name;
    }

    function modifyAssetAndCreateNew(string _name, AssetFactory factory) public {
        factory.createAsset(_name);
        name = _name;
    }
}"
22871-0-0.sol,answer,"contract Nest {

  struct IpfsHash {
    bytes32 hash;
    uint hashSize;
  }

  struct Member {
    IpfsHash ipfsHash;
  }

  mapping(uint => Member) members;

  function addMember(uint id, bytes32 hash, uint size) public returns(bool success) {
    members[id].ipfsHash.hash = hash;
    members[id].ipfsHash.hashSize = size;
    return true;
  }

  function getMember(uint id) public constant returns(bytes32 hash, uint hashSize) {
    return(members[id].ipfsHash.hash, members[id].ipfsHash.hashSize);
  }
}"
67176-0-0.sol,answer,"contract Conditions {

    struct Topic {
        bool state;
        address owner;
        mapping(address => bool) canChange;
    }

    mapping(bytes32 => Topic) public topics;

    modifier onlyTopicOwner (bytes32 topic) {
        require(msg.sender == topics[topic].owner);
        _;
    }

    modifier onlyTopicTrustee (bytes32 topic) {
        require(msg.sender == topics[topic].owner || userTopicPermission(topic, msg.sender));
        _;
    }

    function isTopic(bytes32 topic) public view returns(bool) {
        return(topics[topic].owner != address(0));
    }

    function userTopicPermission(bytes32 topic, address user) public view returns(bool) {
        if(!isTopic(topic)) return false;
        return topics[topic].canChange[user];
    }

    function createTopic(bytes32 topic, bool state) public {
        require(!isTopic(topic));
        Topic storage t = topics[topic];
        t.state = state;
        t.owner = msg.sender;
    }

    function changeUserAccess(bytes32 topic, address user, bool canChange) public onlyTopicOwner(topic) {
        topics[topic].canChange[user] = canChange;
    }

    function changeTopicState(bytes32 topic, bool state) public onlyTopicTrustee(topic) {
        topics[topic].state = state;
    }

}"
42715-0-15.sol,answer,"contract Numbers {
    int[] public numbers;

    function Numbers() public {
        numbers.push(20);
        numbers.push(32);

        changeArray(numbers);
    }

    function changeArray(int[] myArray) private {
        myArray[0] = 1;
    }
}"
8160-1-0.sol,answer,"contract StringStore {
    string public myString;
    address public updater; 

    function StringStore(address _updater) {
        updater = _updater;
    }

    function setString(string newString) {
        if (updater != msg.sender) throw;
        myString = newString;
    }
}"
76422-1-0.sol,answer,"contract Test {
    uint256[] public globalArray = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20];

    function getPartialArray() public view returns (uint256[] memory) {
        uint256[] memory localArray = clone(globalArray, globalArray.length);
        for (uint256 i = 0; i < localArray.length; i++) {
            uint256 n = i + uint256(keccak256(abi.encodePacked(msg.sender, now))) % (localArray.length - i);
            uint256 temp = localArray[n];
            localArray[n] = localArray[i];
            localArray[i] = temp;
        }
        return clone(localArray, localArray.length / 4);
    }

    function clone(uint256[] memory _array, uint256 _length) private pure returns (uint256[] memory) {
        uint256[] memory array = new uint256[](_length);
        for (uint256 i = 0; i < _length; i++) {
            array[i] = _array[i];
        }
        return array;
    }
}"
38931-0-3.sol,answer,"contract Hack {
    Supreme public sup;

    function Hack(Supreme _sup) public {
        sup = _sup;
    }

    function sneak() public payable {
        sup.Road.value(msg.value)();
    }
}"
79417-0-2.sol,answer,"contract Ownable {

    address private _owner;

    modifier onlyOwner  {
        require(msg.sender == _owner);
        _;
    }

    constructor () internal {
        _owner = msg.sender;
    }

    function changeOwner(address newOwner) public onlyOwner {
        _owner = newOwner;
    }

    function owner() public view returns(address) {
        return _owner;
    }
}"
57249-0-1.sol,answer,"contract OtherContract {


  address relay;

  modifier onlyRelay() {
      require(msg.sender == relay, ""Sender is not relay."");
      _;
  }

  function setRelay(address _relay) external onlyOwner {
      relay = _relay;
  }
}"
71734-0-0.sol,answer,"contract Underflow1 {
    uint8[256] arr;
    uint8 i = 0;

    function testf2() public returns (bool) {
        for (i = 0; i < arr.length; ++i) {
            
        }
        if (i == 256) {
            return true;
        } else {
            return false;
        }
    }
}"
9249-0-0.sol,answer,"contract minimalToken {

     mapping (address => uint256) public balanceOf;

    function minimalToken(uint256 initialSupply) {
        balanceOf[msg.sender] = initialSupply;
    }

    function transfer(address _to, uint256 _value) {
        require(balanceOf[msg.sender] >= _value);
        require(balanceOf[_to] + _value >= balanceOf[_to]);
        balanceOf[msg.sender] -= _value;
        balanceOf[_to] += _value;
    }
}"
42898-0-0.sol,answer,"contract Refunds {

    mapping(uint => bool) public data;

    function setIt() public {
        data[1] = true;
    }

    function deleteIt() public {  
        delete data[1];
    }
}"
4539-0-1.sol,answer,contract C1 { function f1() returns(uint) {} }
42435-0-0.sol,answer,"contract CommunityChest {
    function withdraw() public {
        msg.sender.transfer(this.balance);
    }

    function deposit(uint256 amount) payable public {
        require(msg.value == amount);
        
    }

    function getBalance() public view returns (uint256) {
        return this.balance;
    } 
}"
42207-0-0.sol,answer,"contract Lockers {
    struct Locker {
      uint creationTime;
      uint holdTime;
      uint balance;
   }

   mapping (address => Locker[]) lockersByAddress;

   event Withdrawal(address sender, uint balance);

    function store(uint holdTime) external payable {
        Locker memory locker = Locker(now, holdTime, msg.value);
        lockersByAddress[msg.sender].push(locker);
    }

    function withdrawAll() public {
      Locker[] storage lockers = lockersByAddress[msg.sender];
      for (uint i = 0; i < lockers.length; i++) {
        if (lockers[i].creationTime + lockers[i].holdTime < now) {
          msg.sender.transfer(lockers[i].balance);
          Withdrawal(msg.sender, lockers[i].balance);
          delete lockers[i];
        }
      }
    }

    function getNumLockers(address owner) external view returns(uint) {
        return lockersByAddress[owner].length;
    }

    function getLockerDetails(address owner, uint index) external view returns(uint creationTime, uint holdTime, uint balance) {
        Locker memory locker = lockersByAddress[owner][index];
        creationTime = locker.creationTime;
        holdTime = locker.holdTime;
        balance = locker.balance;
    }
}"
12056-0-0.sol,answer,"contract Number { 

    int public number;

    
    function Number(int initialize) {
        number = initialize;
    }

    
    function setNumber(int value) {
        number = value;
    }   
}"
39234-0-0.sol,answer,"contract AirdropEth {
  function drop(address[] recipients, uint256[] values) payable public {
    for (uint256 i = 0; i < recipients.length; i++) {
      recipients[i].transfer(values[i]);
    }
  }
}"
4539-1-0.sol,answer,"contract C1 {

  function call (address myContractsAddress, uint aParameter) returns(uint){
    C2 c2= new C2(myContractsAddress);
    return c2.aFunction(aParameter);
  }
}"
4539-1-0.sol,answer,"contract C2 {
  function aFunction(uint aParameter) returns(uint) {
    return 1;
  }
}"
11484-0-2.sol,answer,"contract myContract is Owned {
    function test() public onlyOwner {
        
    }
}"
11484-0-1.sol,answer,"contract Owned {
    address public owner;
    modifier onlyOwner() {
        if (msg.sender != owner) throw;
        _;
    }
    function transfer(address newOwner) public onlyOwner {
        owner = newOwner;
    }
}"
3936-0-5.sol,answer,"contract SimplifiedTheDAOCode {
    uint public closingTime = 1464426000;
    address public privateCreation;
    SimplifiedManagedAccount public extraBalance;
    mapping (address => uint256) balances;
    uint256 public totalSupply;
    mapping (address => uint256) weiGiven;
    uint public minTokensToCreate = 50000000000000000000000;
    bool public isFueled = true;
    event FuelingToDate(uint value);
    uint constant creationGracePeriod = 40 days;

    function createTokenProxy(address _tokenHolder) returns (bool success) {
        if (now < closingTime && msg.value > 0
            && (privateCreation == 0 || privateCreation == msg.sender)) {

            uint token = (msg.value * 20) / divisor();
            extraBalance.call.value(msg.value - token)();
            balances[_tokenHolder] += token;
            totalSupply += token;
            weiGiven[_tokenHolder] += msg.value;
            CreatedToken(_tokenHolder, token);
            if (totalSupply >= minTokensToCreate && !isFueled) {
                isFueled = true;
                FuelingToDate(totalSupply);
            }
            return true;
        }
        throw;
    }

    function divisor() constant returns (uint divisor) {
        
        
        
        if (closingTime - 2 weeks > now) {
            return 20;
        
        } else if (closingTime - 4 days > now) {
            return (20 + (now - (closingTime - 2 weeks)) / (1 days));
        
        } else {
            return 30;
        }
    }

    function () returns (bool success) {
        if (now < closingTime + creationGracePeriod && msg.sender != address(extraBalance))
            return createTokenProxy(msg.sender);
        else
            return receiveEther();
    }

    function receiveEther() returns (bool) {
        return true;
    }

    event CreatedToken(address indexed to, uint amount);
}"
11770-0-0.sol,answer,"contract VariableLength {

    event LogTest(bytes b);

    function test(bytes b) public returns(bool success) {
        LogTest(b);
        return true;
    }
}"
68231-0-0.sol,answer,"contract Certificates {

    struct Cert {
        address recipient;
        bool confirmed;
    }

    mapping(bytes32 => Cert) public certs;
    bytes32[] public certList;

    event LogNewCert(address sender, bytes32 cert, address recipient);
    event LogConfirmed(address sender, bytes32 cert);

    function isCert(bytes32 cert) public view returns(bool isIndeed) {
        if(cert == 0) return false;
        return certs[cert].recipient != address(0);
    }

    function createCert(bytes32 cert, address recipient) public {
        require(recipient != address(0));
        require(!isCert(cert));
        Cert storage c = certs[cert];
        c.recipient = recipient;
        certList.push(cert);
        emit LogNewCert(msg.sender, cert, recipient);
    }

    function confirmCert(bytes32 cert) public {
        require(certs[cert].recipient == msg.sender);
        require(certs[cert].confirmed == false);
        certs[cert].confirmed = true;
        emit LogConfirmed(msg.sender, cert);
    }

    function isUserCert(bytes32 cert, address user) public view returns(bool) {
        if(!isCert(cert)) return false;
        if(certs[cert].recipient != user) return false;
        return certs[cert].confirmed;
    }
}"
83991-0-0.sol,answer,"contract MyContract {
    bytes4 private constant FUNC_SELECTOR = bytes4(keccak256(""detectTransferRestriction(address,address,uint256)""));

    function callDetectTransferRestriction(address _token, address _to, address _from, uint256 _amount) public returns (bool) {
        bool success;
        bytes memory data = abi.encodeWithSelector(FUNC_SELECTOR, _to, _from, _amount);

        assembly {
            success := call(
                gas,            
                _token,         
                0,              
                add(data, 32),  
                mload(data),    
                0,              
                0               
            )
        }

        return success;
    }
}"
65782-0-0.sol,answer,"contract MyContract {
  address token_address = 

  function hasTokens() public returns (bool) {
    let balance = ERC20(token_address).balanceOf(msg.sender);
    return (balance > 0);
  }

}"
3609-3-0.sol,answer,"contract Example {

    struct Store {
        string id;         
        uint time;         
    }

    mapping (string => Store) public purchases;

    function set(string memory _id, uint _time) public returns(bool) {
        purchases[msg.sender].id = _id;
        purchases[msg.sender].time = _time;
        return true;
    }

    function get() public view returns(Store memory) {
        return purchases[msg.sender];
    }
}"
39721-0-0.sol,answer,"contract SafeMath {
  function mul2(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
       return 0;
     }
     uint256 c = a * b;
     assert(c / a == b);
     return c;
   }

  function div2(uint256 a, uint256 b) internal pure returns (uint256) {
     uint256 c = a / b;
     return c;
  }

  function sub2(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
     return a - b;
   }

  function add2(uint256 a, uint256 b) internal pure returns (uint256) {
     uint256 c = a + b;
    assert(c >= a);
     return c;
   }
}"
56381-0-0.sol,answer,"contract parameterOverflows {

    uint8 public selectedCharacter;

    modifier onlyCharacter(uint _character) {
        require(_character <= 255);
           _;
    }

    function selectCharacter(uint _character) public onlyCharacter(_character) {
        selectedCharacter = uint8(_character);
    }

}"
64148-0-5.sol,answer,"contract Reason {

    function doSomething() public pure {
        require(false, ""Just because"");
    }
}"
48971-1-1.sol,answer,"contract Test {
  address testAddress;
  constructor() {
    testAddress = msg.sender;
  }

  
  function test() public {
    require(msg.sender == testAddress);

  }
}"
60695-0-1.sol,answer,"contract FunWithArrays {

  struct Voter {
      address voter;
      string comment;
  }

  struct Project{
    int id;
    string name;
    int votes;    
    Voter[] voters;
  }

  Project[] public projects;

  function vote(uint index , string comment) public {
    Project storage project = projects[index];
    project.votes++;     
    Voter memory v;
    v.voter = msg.sender;
    v.comment = comment;
    project.voters.push(v);
  }
}"
24492-0-0.sol,answer,"contract Token {
    address [] public voters;

    function Token(address first_voter) {
        voters.push(first_voter);
    }
}"
24492-0-0.sol,answer,"contract Vote{
     
     

    function check_first_voter() returns (address) {
        Token token = new Token(0x123);
        address valid_voter = token.voters(0);  

        
        assert(valid_voter == 0x123);
        
        return valid_voter;
    }
}"
39932-1-0.sol,answer,"contract Test {

  struct Example {
  bool v1;
  bool v2;
  bool v3;
  bool v4;
  bool v5;
  bool v6;
  bool v7;
  bool v8;
  }

  Example example;

  function test() public {
    Example memory ex = Example({
    v1: true,
    v2: true,
    v3: true,
    v4: true,
    v5: true,
    v6: true,
    v7: true,
    v8: true
    });

    example = ex;
  }
}"
40993-0-0.sol,answer,"contract C {
    function testRevert() pure public returns (uint result) {
        uint memOffset;
        assembly {
             memOffset := msize() 
             mstore(add(memOffset, 0x00), 6) 
             mstore(0x40, add(memOffset, 0x20)) 
             revert(memOffset, 0x20) 
        }
    }
}"
76168-0-0.sol,answer,"contract StorageCostTest {

    struct MyStruct {
        bool foo;
        uint256 bar;
        uint256 baz;
        address qux;
    }

    mapping(uint256 => MyStruct) private myStructs;
    uint256 public nextMyStructId;

    constructor() public {
        nextMyStructId = 1;
    }

    function addItem(bool foo, uint256 bar, uint256 baz, address qux) external {
        myStructs[nextMyStructId] = MyStruct({
           foo: foo,
           bar: bar,
           baz: baz,
           qux: qux
        });
        nextMyStructId += 1;
    }
}"
9189-0-3.sol,answer,"contract B is J {
    function doOnI(address i) {
        I(i).doSomething();
    }
}"
45915-2-0.sol,answer,"contract Item {
    Item public next;
    address owner;

    constructor(Item _next) public {
        owner = msg.sender;
        if (_next == Item(0)) {
            next = this;
        } else {
            next = _next;
        }
    }

    function addNew(Item item) public {
        require(msg.sender == owner);
        next = item;
    }
}"
45915-2-0.sol,answer,"contract Factory {
    Item public head;

    constructor() public {
        head = new Item(Item(0));
    }

    function add(Item _to) public {
        Item link = _to.next();
        Item next = new Item(link);
        _to.addNew(next);
    }
}"
55900-2-0.sol,answer,"contract SalesContract {

    address payable public owner;
    bool public isSold = false;
    string public salesDescription = ""Honda Civic"";
    uint public price = 2 ether;

    constructor() public {
        owner = msg.sender;
    }

    function Buy() public payable {
        if(msg.value >= price) {
            owner.transfer(address(this).balance);
            owner = msg.sender;
            isSold = true;
        } else {
            revert();
        }
    }

}"
63337-1-1.sol,answer,"contract XX {
    bool mutexFlag;

    function untrustedCall(address payable _untrusted) public {
        require(mutexFlag == false, ""No reentry!"");
        
        mutexFlag = true; 
        (bool success, ) = _untrusted.call.value(xxx)(""""); 
        mutexFlag = false;
        require(success, ""Transfer failed!"");

        
    }
}"
28698-1-0.sol,answer,"contract TestInt {
    uint value1;
    function setVal(uint _value) public {
      value1 = _value + 10;
    }

    function getVal() public  returns (uint) {
      return value1;
    }

    int value2;
    function set2(int _value) public {
      value2 = _value + 10;
    }

    function get2() public  returns (int) {
      return value2;
    }
    uint value;
  }"
71747-0-0.sol,answer,"contract Courses {
    struct Instructor {
        uint age;
        string fName;
        string lName;
    }

    mapping (address => Instructor) instructors;
    address[] public instructorAccts;

    function setInstructor(address _address, uint _age, string memory _fName, string memory _lName) public {
        Instructor storage instructor = instructors[_address];

        instructor.age = _age;
        instructor.fName = _fName;
        instructor.lName = _lName;

        instructorAccts.push(_address);
    }

    function getInstructors() public view returns (address[] memory) {
        return instructorAccts;
    }
}"
61432-0-1.sol,answer,"contract test {

    mapping (address => uint[]) public transactions;

    constructor() public {
        transactions[msg.sender].push(123456);
        transactions[msg.sender].push(789101);
        transactions[msg.sender].push(865436);
    }

    function getTransactionsLength() public view returns (uint) {

        return transactions[msg.sender].length;

    }

    function getTransactionsValue(uint index) public view returns (uint) {

        return transactions[msg.sender][index];

    }
}"
31545-0-0.sol,answer,"contract ReleaseShares {
    string public constant symbol = ""Test"";
    string public constant name = ""Test Release"";
    uint8 public constant decimals = 18;
    uint256 public totalSupply = 10000000;
    address public owner;
    uint public creationTime;

    
    function ReleaseShares() public {
        owner = msg.sender;
        balances[owner] = totalSupply;
        creationTime = now;
    }

    modifier releaseOfSharesOK() {
        require(now >= (creationTime + 300));
        _;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    
    mapping(address => uint256) balances;
    mapping(address => mapping (address => uint256)) allowed;

    function balanceOf(address _owner) constant public returns (uint256 balance) {
        return balances[_owner];
    }

    
    function transfer(address _to, uint256 _amount) public returns (bool success) {
        if (balances[msg.sender] >= _amount 
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[msg.sender] -= _amount;
            balances[_to] += _amount;
            return true;
        } else {
            return false;
        }
    }

    function transferFrom(
        address _from,
        address _to,
        uint256 _amount
    ) public returns (bool success) {
        if (balances[_from] >= _amount
            && allowed[_from][msg.sender] >= _amount
            && _amount > 0
            && balances[_to] + _amount > balances[_to]) {
            balances[_from] -= _amount;
            allowed[_from][msg.sender] -= _amount;
            balances[_to] += _amount;
            return true;
        } else {
            return false;
        }
    }

    
    
    function approve(address _spender, uint256 _amount) public returns (bool success) {
        allowed[msg.sender][_spender] = _amount;
        return true;
    }

    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {
        return allowed[_owner][_spender];
    }

    function() public payable { }

    
    
    
    struct Holder {
        uint amount;
        string fName;
        string lName;
    }

    mapping (address => Holder) holders;
    address[] public holderAccts;

    function setHolder(
        address _address, 
        uint _amount, 
        string _fName, 
        string _lName
        ) onlyOwner public {
            var holder = holders[_address];

            holder.amount = _amount;
            holder.fName = _fName;
            holder.lName = _lName;

            holderAccts.push(_address) -1;
    }

    function getHolders() view public returns(address[]) {
        return holderAccts;
    }

    function getHolder(address _address) view public returns (uint, string, string) {
        return (holders[_address].amount, holders[_address].fName, holders[_address].lName);
    }

    function countHolders() view public returns (uint) {
        return holderAccts.length;
    }

    function releaseHolderShares() releaseOfSharesOK onlyOwner public {
        uint256 numberOfAccts = holderAccts.length;
        for (uint i = 0; i < numberOfAccts; i ++) {
            transfer(holderAccts[i], holders[holderAccts[i]].amount);
        }
    }
}"
8160-1-1.sol,answer,"contract HoldOff {
    address public owner;

    event LogRequest(
        address requester,
        address target,
        bytes msgData);

    function HoldOff() {
        owner = msg.sender; 
    }

    function requestCall(address target, bytes msgData) 
        returns (bytes32 key) {
        LogRequest(msg.sender, target, msgData);
    }

    function doCall(address target, bytes msgData) 
        returns (bool) {
        if (owner != msg.sender) throw;
        return target.call(msgData);
    }
}"
72333-0-1.sol,answer,"contract NewHello {

    mapping(address => string) public users; 

    function updateUser(string memory name) public {
        require(bytes(users[msg.sender]).length == 0);
        users[msg.sender] = name; 
    }

    function getUser(address userAddress) public view returns(string memory) {
        return users[userAddress]; 
    }
}"
68824-0-1.sol,answer,"contract HelloUniverse {
  bool isHappy;
  string response = ""Hi there!"";
  modifier onlyIfHappy {
    require(isHappy);
    _;
  }
  function talk() public view onlyIfHappy returns(string memory) {
    return response;
  }
}"
70523-0-3.sol,answer,"contract A {
  ServiceRegistry serviceRegistry;

  constructor (ServiceRegistry _serviceRegistry) public {
    serviceRegistry = _serviceRegistry;
    serviceRegistry.register (""A"", address (this));
  }

  function getB () internal view returns (B) {
    return B (serviceRegistry.get (""B""));
  }
}"
70523-0-3.sol,answer,"contract B {
  ServiceRegistry serviceRegistry;

  constructor (ServiceRegistry _serviceRegistry) public {
    serviceRegistry = _serviceRegistry;
    serviceRegistry.register (""B"", address (this));
  }

  function getA () internal view returns (A) {
    return A (serviceRegistry.get (""A""));
  }
}"
8959-0-0.sol,answer,"contract User {
}"
8959-0-0.sol,answer,"contract Tenant {
    address tenant;
    uint256 rent;

    function Tenant(address _tenant) {
        tenant = _tenant;
    }

    function setRent(uint256 _rent) {
        rent = _rent;
    }
}"
8959-0-0.sol,answer,"contract Landlord is User {
    string public landlordName;
    string public physicalAddress;

    function Landlord(
      string _name,
      string _physicalAddress) {
        landlordName = _name;
        physicalAddress = _physicalAddress;
    }

    function setRent(uint256 _rent, address _tenantAddress){
        Tenant person = Tenant(_tenantAddress);
        person.setRent(_rent);
    }
}"
47043-0-0.sol,answer,"contract C {
    
    function overflow() returns (uint256 _overflow) {
        uint256 max = 2**256 - 1;
        return max + 1;
    }

    
    function underflow() returns (uint256 _underflow) {
        uint256 min = 0;
        return min - 1;
    }
}"
46715-0-0.sol,answer,"contract C {
    function f() public {
        
        
        uint[] x = [uint(1), 3, 4];
    }
}"
44142-0-0.sol,answer,"contract Tree {
    struct Node {
        bytes data;
        uint256 parent;
        uint256[] children;
    }

    Node[] nodes;

    function Tree() public {
        
        nodes.push(Node("""", 0, new uint256[](0)));
    }

    function appendChild(uint256 parentID, bytes data) public returns (uint256 newID) {
        newID = nodes.length;

        nodes.push(Node({
            data: data,
            parent: parentID,
            children: new uint256[](0)
        }));

        nodes[parentID].children.push(newID);

        return newID;
    }
}"
15323-0-1.sol,answer,"contract Caller {

  test public t;

  
  

  function Caller(address tAddress) {
    t = test(tAddress); 
  }

  function callIt(address theAddress)
    public
    returns(uint bal)
  {
      return t.FunctionX(theAddress);
  }
}"
15323-0-1.sol,answer,"contract test { 
  function FunctionX(address _address) public returns(uint balanceOf) {}
}"
66152-0-0.sol,answer,"contract DigitalDownload {

    ...

    event DigitalDownloadPurchasedEvent(uint time, address purchaser)

    ...

    function purchaseDigitalDownload() public payable {
        require(msg.value == PRICE);

        emit DigitalDownloadPurchasedEvent(now, msg.sender);
    }
}"
78907-0-0.sol,answer,"contract OwnedToken {
    
    
    
    TokenCreator creator;
    address owner;
    bytes32 name;

    
    
    constructor(bytes32 _name) public {

        owner = msg.sender;
        name = _name;

        
        
        
        
        
        creator = TokenCreator(msg.sender);

    }

    function transfer(address newOwner) public {
        if (msg.sender != owner) return;

        
        
        
        
        
        if (creator.isTokenTransferOK(owner, newOwner))
            owner = newOwner;
    }

    [...rest snipped...]
}"
57257-1-0.sol,answer,"contract Test {

    struct S {
        string s;
        uint u;
    }

    function returnOneValue() private pure returns (S s) {
        s.s = ""123"";
        s.u = 123;
    }

    constructor() {
        S memory s = returnOneValue();
    }
}"
77056-0-0.sol,answer,"contract Cast {

    function weirdResult() public pure returns(uint) {
        uint8 y = 3;
        uint8 x = 10;
        return x**y;
    }
}"
50914-1-0.sol,answer,"contract Test {
    function test(bytes32 data) external pure returns (address) {
        return address(uint160(uint256(data)));
    }
}"
42995-0-1.sol,answer,"contract Test {
  
  event Paid(address indexed _from, uint _value);

  
  
  function () external payable {
    Paid(msg.sender, msg.value);
  }
}"
45676-0-0.sol,answer,"contract Pizzeria {

    bool public isPizzaria;
    uint public param1;
    uint public param2;

    function Pizzeria(uint arg1, uint arg2) public {
        param1 = arg1;
        param2 = arg2;
    }

}"
45676-0-0.sol,answer,"contract PizzeriaFactory {

    address[] public pizzeriaFactories;

    function createPizzeria(uint arg1, uint arg2) public returns(address newPizzeria) {
        Pizzeria p = new Pizzeria(arg1, arg2);
        pizzeriaFactories.push(address(p));
        return address(p);
    }

}"
24133-0-0.sol,answer,"contract testContract {
    uint256 num1;

    address[] contracts = [0x36eaf79c12e96a3dc6f53426c, 0xf235aa56dd96bda02acfb361e];

    function getContractsCount() constant returns (uint256) {
          return contracts.length;
    }

}"
77201-0-0.sol,answer,"contract TestABC {
    function testTotalSupplyTest() public {
        bool a = true;
        bool b = true;
        Assert.equal(a, b, ""message ABC"");
    }
}"
77965-0-0.sol,answer,"contract A {
    uint256 public counter = 1;

    event DelegateCallFailed();

    function foo() public {
        counter += 1000;
        
        revert();
    }

    function bar() public {
        
        counter += 1;
        uint256 b = counter;
        
        (bool res,) = address(this).delegatecall(abi.encodeWithSignature(""foo()""));
        if (!res) {
            
            require(b == counter, ""Counter shouldn't change"");
            emit DelegateCallFailed();
        }
    }
}"
52159-0-0.sol,answer,"contract Lottery {
    address public manager;
    address[] public players;
    address tokenAddress;

    function Lottery() public {
        manager = msg.sender;
    }

    function enter() public payable {
        require(msg.value > .01 ether);

        players.push(msg.sender);
    }

    function provideService() external payable {
        uint amount = msg.value;
        ERC20Interface tokenContract = ERC20Interface(tokenAddress);
        require(tokenContract.transferFrom(msg.sender, this, amount));
        
        players.push(msg.sender);
    }

    function random() private view returns (uint) {
        return uint(keccak256(block.difficulty, now, players));
    }

    function pickWinner() public restricted {
        ERC20Interface tokenContract = ERC20Interface(tokenAddress);
        
        uint contractBalance = tokenContract.balanceOf(address(this)); 
        uint index = random() % players.length;
        
        tokenContract.transfer( players[index], contractBalance / 2 );
        
        address treasury;
        tokenContract.transfer( treasury, contractBalance / 2 );
        
        players = new address[](0);
    }

    modifier restricted() {
        require(msg.sender == manager);
        _;
    }

    function getPlayers() public view returns (address[]) {
        return players;
    }
}"
37542-0-0.sol,answer,"contract Test {
    address[] public addrs;
    mapping (address => uint256) public something;
    mapping (address => bool) public registered;
    function registerSomething(address _addr, uint256 _value) {
        require(!registered[_addr]);
        registered[_addr] = true;
        addrs.push(_addr);
        something[_addr] = _value;
    }
}"
12355-0-0.sol,answer,"contract testInputArray {

    mapping (string => string) aMapping;

    
    event Log(address from, address to, string message);

    function sendMessage(address to, string key) {
        Log(msg.sender, to, aMapping[key]);
    }
}"
44198-0-1.sol,answer,"contract ABI {

    struct TestStruct {
        uint size;
    } 

    function testFunc(TestStruct memory test) public pure returns(bool replaced) {
        return test.size == 0;
    }
}"
72417-0-2.sol,answer,"contract Contract2 {

    Contract1 public contract1 = new Contract1();

    function func() public returns (uint32, uint32) {

        uint32[2] memory ret;

        address dest = address(contract1);

        bytes4 selector = contract1.func.selector;
        

        bytes memory data = abi.encodeWithSelector(selector, uint256(789), uint8(123));
        (bool success, ) = dest.call(data);
        require(success);

        assembly {
            let size := returndatasize
            returndatacopy(ret, 0, size)
        }
        return (ret[0], ret[1]);
    }
}"
70556-0-0.sol,answer,"contract Contract {
    uint[] public large_array;

    function read(uint cursor, uint length) public view returns (uint[] memory) {
        uint[] memory array = new uint[](length);
        for (uint i = cursor; i < cursor+length; i++) {
            array[i] = large_array[i];
        }
        return array;
    }
}"
12006-0-0.sol,answer,"contract Contract {

    address public owner;
    uint public someVar;

    modifier onlyOwner() {
        if(owner != msg.sender) throw;
        _;
    }

    function Contract() {
        owner = msg.sender; 
    }

    function changeSomeVar(string secret, uint someValue) 
        onlyOwner 
    {
        someVar = someValue;
    }

}"
7269-0-0.sol,answer,"contract MyToken {
    
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    function MyToken(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              
        totalSupply = initialSupply;                        
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = decimalUnits;                            
        msg.sender.send(msg.value);                         
    }

    
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            
        Transfer(msg.sender, _to, _value);                   
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        spender.receiveApproval(msg.sender, _value, this, _extraData);
        return true;
    }

    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                 
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  
        if (_value > allowance[_from][msg.sender]) throw;   
        balanceOf[_from] -= _value;                          
        balanceOf[_to] += _value;                            
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    
    function () {
        throw;     
    }
}"
71989-1-0.sol,answer,"contract Case1 {

    struct BB{
        mapping (uint => address) map_2;
    }

    mapping (uint => BB) map_1; 

    function getter(uint structId, uint mapId) public view returns(address) {
        return map_1[structId].map_2[mapId];
    }  
}"
45869-0-0.sol,answer,"contract TransferTest {

        function TransferTest() payable{
        }

        function withdrawEther(uint amount, address sendTo) external {
            sendTo.transfer(amount);
        }

        function getBalance() public view returns (uint){
            return this.balance;
        }
}"
61746-0-1.sol,answer,"contract A_compiled {
    function test_internal() private { log0(0x1111); } 
    function bbb() public { log0(0xbbbb); }
    function test() public {
       bbb(); 
       test_internal(); 
    }
}"
82478-0-0.sol,answer,"contract B {
    function create() public {
        A newContract = new A();
    }
}"
10007-0-0.sol,answer,"contract InterfaceOfA {
        function f(uint) returns (uint);
}"
10007-0-0.sol,answer,"contract InterfaceOfB {
        function g(bool) returns (bool);
}"
10007-0-0.sol,answer,"contract A is InterfaceOfA {
        InterfaceOfB b;
        function f(uint _input) returns (uint) {
                b.g(true);
                return 3;
        }
}"
10007-0-0.sol,answer,"contract B is InterfaceOfB {
        InterfaceOfA a;
        function g(bool _input) returns (bool) {
                a.f(0);
                return false;
        }
}"
50255-0-3.sol,answer,"contract B is IB {
    IA public a;
    function set(IA _a) external {a = _a;}
    
}"
31357-0-1.sol,answer,"contract Owned {
  address public owner;
  function Owned(address _owner) public {
    owner = _owner;
  }
}"
31357-0-1.sol,answer,"contract A is Owned{ 
  B public b;
  function A()
  Owned(msg.sender)
  { 
    b = new B(msg.sender); 
  }
}"
31357-0-1.sol,answer,"contract B is Owned  {
  address parent;
  function B(address _owner)
  Owned(_owner)
  {
    parent = msg.sender;
  }  
}"
11199-0-0.sol,answer,"contract RecurringPayment {
    SchedulerInterface public scheduler;

    uint paymentInterval;
    uint paymentValue;
    uint lockedUntil;

    address recipient;
    address public currentScheduledTransaction;

    event PaymentScheduled(address indexed scheduledTransaction, address recipient, uint value);
    event PaymentExecuted(address indexed scheduledTransaction, address recipient, uint value);

    function RecurringPayment(
        address _scheduler,
        uint _paymentInterval,
        uint _paymentValue,
        address _recipient
    )  public payable {
        scheduler = SchedulerInterface(_scheduler);
        paymentInterval = _paymentInterval;
        recipient = _recipient;
        paymentValue = _paymentValue;

        schedule();
    }

    function ()
        public payable 
    {
        if (msg.value > 0) { 
            return;
        } 

        process();
    }

    function process() public returns (bool) {
        payout();
        schedule();
    }

    function payout()
        private returns (bool)
    {
        require(block.number >= lockedUntil);
        require(address(this).balance >= paymentValue);

        recipient.transfer(paymentValue);

        emit PaymentExecuted(currentScheduledTransaction, recipient, paymentValue);
        return true;
    }

    function schedule() 
        private returns (bool)
    {
        lockedUntil = block.number + paymentInterval;

        currentScheduledTransaction = scheduler.schedule.value(0.1 ether)( 
            this,                   
            """",                     
            [
                1000000,            
                0,                  
                255,                
                lockedUntil,        
                20000000000 wei,    
                20000000000 wei,    
                20000000000 wei,         
                30000000000 wei     
            ]
        );

        emit PaymentScheduled(currentScheduledTransaction, recipient, paymentValue);
    }
}"
56920-1-0.sol,answer,"contract game {

 struct users{
     string name;
     uint level;
     uint score;
 }

 mapping(uint => users[]) mulusers;

 function addusers (uint id, string _name, uint _level, uint _score) public {
     users memory user= users(_name,_level,_score); 
     mulusers[id].push(user);
 }

 function getusers (uint _id) public view returns (string){

    uint index= mulusers[_id].length;

     for(uint i=0; i<index; i++){       
       return mulusers[_id][i].name; 
     }   
  }   
}"
56363-1-0.sol,answer,"contract C {
  function grouped() {
    A.foo();
    B.bar();
  }
}"
56575-1-0.sol,answer,"contract C {
    uint256 public value = 500;
    address b;

    constructor(address _b) {
        b = _b;
    }

    function delegate() public {
        address orgB = b;
        if (b.a != address(0)) {
            b = b.a;
        }
        orgB.delegatecall(bytes4(keccak256(""delegate()"")));
        b = orgB;
    }
}"
37731-0-0.sol,answer,"contract TipJar {

    address owner;    

    function TipJar() public {  
        owner = msg.sender;
    }

    function withdraw() public {
        require(owner == msg.sender);
        msg.sender.transfer(this.balance);
    }

    
}"
10390-0-0.sol,answer,"contract ExampleContract {

struct ExampleStruct {
    address owner;
    string text;
}

ExampleStruct[] public exampleStructs;

function ExampleContract( address myAddress, string myText ) {
    exampleStructs.push(ExampleStruct(myAddress, myText));
}

...

}"
12698-2-0.sol,answer,"contract Child {
    uint i1;
    uint i2;
    uint i3;
    uint i4;
    uint i5;

    function f1() { i1=1;   }
    function f2() { i2=2;   }
    function f3() { i3=3;   }
    function f4() { i4=4;   }
    function f5() { i5=5;   }
}"
12698-2-0.sol,answer,"contract MainFactory {
    Child ch;

    function MainFactory() {
        ch = new Child();
    }

    function test() {
        ch.f1();
        ch.f2();
        ch.f3();
        ch.f4();
        ch.f5();
    }
}"
42762-0-0.sol,answer,"contract Mutex {
    bool locked;
    modifier noReentrancy() {
        require(!locked);
        locked = true;
        _;
        locked = false;
    }

    function Mutex() public payable { }

    function canBeAttacked() public returns (uint) {
        require(msg.sender.call.value(1 ether)());
        return 7;
    }

    
    function f() public noReentrancy returns (uint) {
        require(msg.sender.call());
        return 7;
    }
}"
42762-0-0.sol,answer,"contract Attacker {
    function () public payable {
        if (msg.sender.balance >= 1 ether) {
            Mutex(msg.sender).canBeAttacked();
        }
    }

    function payment(Mutex mutex) public {
        mutex.canBeAttacked();
    }

    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }
}"
65969-0-1.sol,answer,"contract Div {

    function divider(uint numerator, uint denominator, uint precision) public pure returns(uint) {
        return (numerator*(uint(10)**uint(precision+1))/denominator + 5)/uint(10);
    }
}"
52676-0-0.sol,answer,"contract TestCoin {
    mapping(address => uint256) public balanceOf;
    uint256 public totalSupply;

    function TestCoin(uint256 initialSupply) public {
    totalSupply = initialSupply;
    balanceOf[msg.sender] = totalSupply;
  }
}"
49812-1-0.sol,answer,"contract Autos {

address owner;
address[] members;
uint counter = 1;
mapping (address => bool) public owners;

constructor() public {
    owner = msg.sender;
    members = [0xca35b7d915458ef540ade6068dfe2f44e8fa733c,0x14723a09acff6d2a60dcdf7aa4aff308fddc160c];
    for (uint i=0; i lessthan members.length ; i++)
    {
     owners[members[i]]=true;
   }
}

function incCounter() onlyOwner {
       counter++;
   }
    function showCount() view returns(uint){
        return counter;
    }

modifier onlyOwner {
    require(owners[msg.sender]);
_;

}  
}"
52960-0-2.sol,answer,"contract B is A {
    address private owner;
    uint state;
    constructor() public {
        owner = msg.sender;
        state = 0;
    }
    function getOwner() internal returns(address) {
        return owner;
    }
    function performOperation() internal {
        state = state + 1;
    }
}"
18064-0-0.sol,answer,"contract Test {

    enum assetState{something}

    mapping(uint256 => asst) assetsById;

    struct asst {
        uint256 assetId;
        uint256 next;
        uint256 prev;
        uint256 timestampCreation;
        address assetOwner;
        address issuer;
        string content;
        uint256 sellPrice;
        assetState state;
    }

    function getAssetStructById(uint256 assetId) public view returns (asst _asset) {
        return (assetsById[assetId]);
    }

    function tryIt(uint id) public view returns(bool success) {
        asst memory a = getAssetStructById(id); 
        return true;
    }
}"
25068-0-0.sol,answer,"contract OtherContract {
    function otherMethod(address _to, uint _price);
}"
25068-0-0.sol,answer,"contract MyContract {
    uint public unitPrice = 100;

    function myMethod(address _destination, uint _count) {
        
        OtherContract oc = OtherContract(_destination);
        
        oc.otherMethod(address(this), _count * unitPrice);
    }
}"
26756-0-0.sol,answer,"contract Betting is usingOraclize {

event Transfer(address _from, uint256 _value);
function Betting() {

}

function () payable {
   Transfer(msg.sender, msg.value);
}

}"
69412-1-1.sol,answer,"contract MyErc20Contract {
    function transfer(address to, uint256 value) public returns (bool) {
        bytes32 data1 = keccak256(""func1(uint256)"");
        bytes32 data2 = keccak256(""func2(uint256,bool)"");
        bytes32 data3 = keccak256(""func3(uint256,uint256)"");
        bool result1 = external_call(to, 0, data1.length, abi.encodePacked(data1));
        bool result2 = external_call(to, 0, data2.length, abi.encodePacked(data2));
        bool result3 = external_call(to, 0, data3.length, abi.encodePacked(data3));
        if (result1 && result2 && result3) {
            
        }
        else {
            
        }
    }

    function external_call(address destination, uint value, uint dataLength, bytes data) private returns (bool) {
        bool result;
        assembly {
            let x := mload(0x40)   
            let d := add(data, 32) 
            result := call(
                sub(gas, 34710),   
                                   
                                   
                destination,
                value,
                d,
                dataLength,        
                x,
                0                  
            )
        }
        return result;
    }
}"
2519-2-0.sol,answer,"contract Bytes32ToString {

function bytes32ToStr(bytes32 _bytes32) public pure returns (string) {

    
    
    

    bytes memory bytesArray = new bytes(32);
    for (uint256 i; i < 32; i++) {
        bytesArray[i] = _bytes32[i];
        }
    return string(bytesArray);
    }

}"
11149-0-0.sol,answer,"contract Test {
    struct User {
        string name;
        string surname;
        uint active;
    }

    mapping (bytes32 => User) public userRegister;

    function add_user(string _name, string _surname) {
        bytes32 _hc = sha3(_name, _surname);
        User p = userRegister[_hc];
        p.name = _name;
        p.surname = _surname;
        p.active = 1;
    }

    function remove(string _name, string _surname)  {
        bytes32 _hc = sha3(_name, _surname);
        userRegister[_hc].active = 0;
    }

    function active(string _name, string _surname)  {
        bytes32 _hc=sha3(_name, _surname);
        userRegister[_hc].active = 1;
    }

    function getUser(string _name, string _surname) constant
      returns (string name, string surname, uint256 active) {
        bytes32 _hc = sha3(_name, _surname);
        name = userRegister[_hc].name;
        surname = userRegister[_hc].surname;
        active = userRegister[_hc].active;
    }
}"
12737-0-0.sol,answer,"contract ContractA{

  ContractB b;
  address[] instancesOfB;

  function ContractA(){
     
     b = new ContractB();
     instancesOfB.push(b);
  }

  
  

  function newB() 
      
      returns(address newContractB)
  {
      b = new ContractB();
      instancesOfB.push(b);
      return b;
  }

}"
12737-0-0.sol,answer,"contract ContractB {
   address owner;
   function ContractB() {
     owner = msg.sender;
   }
 }"
58208-0-0.sol,answer,"contract Recipient {
  uint public id;
  function deposit(uint _id) public payable {
    id = _id;
  }
}"
12672-1-0.sol,answer,"contract MyHashRegistry {

    mapping (uint => uint) hashes:

    function storeHash(uint documentId, uint hash) {
        hashes[documentId] = hash;
    }
}"
55237-1-0.sol,answer,"contract TestSomething {

    uint256[] public barLengthToBarAmtForSale;

    constructor() public{
        uint16 counter = uint16(0);
        while(counter <= 10) {
            barLengthToBarAmtForSale.push(uint256(0));
            counter++;

        }
    }

    function getVal(uint val) public view returns(uint){
        return barLengthToBarAmtForSale[val]; 
    }

    function setVal(uint16 _length) public {
        barLengthToBarAmtForSale[_length]++;
    }

    function delVal(uint index) public {
        delete barLengthToBarAmtForSale[index];
    }

    function getLen() public view returns(uint){
        return barLengthToBarAmtForSale.length;
    }
}"
75849-0-4.sol,answer,"contract SP {
    IValidator validator;
    ...
    function verifyHash(bytes32 hash) external view returns (address) {
        return validator.verifyHash(hash);
    }
}"
71339-0-0.sol,answer,"contract and {

    string d = ""Hello"";

    function getValueOfabc() public view returns(string memory) {
        return  d;
    }
}"
60684-1-0.sol,answer,"contract Verifiable6SidedDiceRoll is VRFConsumerBase {
    using SafeMath for uint;

    bytes32 internal keyHash;
    uint256 internal fee;

    event RequestRandomness(
        bytes32 indexed requestId,
        bytes32 keyHash,
        uint256 seed
    );

    event RequestRandomnessFulfilled(
        bytes32 indexed requestId,
        uint256 randomness
    );

    
    constructor(address _vrfCoordinator, address _link)
        VRFConsumerBase(_vrfCoordinator, _link) public
    {
        vrfCoordinator = _vrfCoordinator;
        LINK = LinkTokenInterface(_link);
        keyHash = 0xced103054e349b8dfb51352f0f8fa9b5d20dde3d06f9f43cb2b85bc64b238205; 
        fee = 10 ** 18; 
    }

    
    function rollDice(uint256 userProvidedSeed) public returns (bytes32 requestId) {
        require(LINK.balanceOf(address(this)) > fee, ""Not enough LINK - fill contract with faucet"");
        uint256 seed = uint256(keccak256(abi.encode(userProvidedSeed, blockhash(block.number)))); 
        bytes32 _requestId = requestRandomness(keyHash, fee, seed);
        emit RequestRandomness(_requestId, keyHash, seed);
        return _requestId;
    }

    function fulfillRandomness(bytes32 requestId, uint256 randomness) external override {
        uint256 d6Result = randomness.mod(899).add(100);
        emit RequestRandomnessFulfilled(requestId, randomness);
    }

}"
43367-0-1.sol,answer,"contract TruffleDebug {

  function Deposit (uint256 timeout, bytes32 hash, address recipient) public payable returns (uint256)  {
       emit AcceptCommitted(timeout, hash, recipient);
       return 1;
   }

   event AcceptCommitted(uint256 indexed timeout, bytes32 indexed hash, address indexed recipient);

}"
73024-0-5.sol,answer,"contract AnimalsBitwise {

  struct Animal {
    uint characteristics;
  }

  mapping(bytes32 => Animal) public animals;

  function setAnimal(bytes32 id, uint characteristics) public { 
    
    
  }

  function allTrue(bytes32 id, uint profile) public view returns(bool isIndeed) {
    Animal storage a = animals[id];
    uint characteristics = a.characteristics;
    
    
  }
  function anyTrue(bytes32 id, uint profile) public view returns(bool isIndeed) {
    Animal storage a = animals[id];
    uint characteristics = a.characteristics;
    
    
  }
  function or(bytes32 id, uint profile1, uint profile2) public view returns(bool isIndeed) {
    return allTrue(id, profile1) || allTrue(id, profile2);
  }

  function and(bytes32 id, uint profile1, uint profile2) public view returns(bool isIndeed) {
    return allTrue(id,profile1) && allTrue(id, profile2);
  }
}"
10569-0-0.sol,answer,"contract MyToken {
    mapping (address => uint) balanceOf;

    event CoinTransfer(address indexed _from, address indexed _to, uint256 _value);

    function MyToken() {
        balanceOf[msg.sender] = 21000000;
    }

    function sendCoin(address receiver, uint amount) returns(bool sufficient) {
        if (balanceOf[msg.sender] < amount) return false;
        balanceOf[msg.sender] -= amount;
        balanceOf[receiver] += amount;
        CoinTransfer(msg.sender, receiver, amount);
        return true;
    }

    function transfer(address from, address to, uint amount) returns(bool sufficient) {
        if (balanceOf[from] < amount) return false;
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        CoinTransfer(from, to, amount);
        return true;
    }

    function getBalance(address addr) returns(uint) {
        return balanceOf[addr];
    }
}"
10569-0-0.sol,answer,"contract PermService {
    mapping (address => bool) customerPaid;
    address vendor;

    function PermService() {
        vendor = msg.sender;
    }

    function buy(address tokenContractAddress) returns (bool success) {
        if (customerPaid[msg.sender]) {
            
            return true;
        }
        MyToken mt = MyToken(tokenContractAddress);
        if (mt.getBalance(msg.sender) < 5) {
            throw;
            return false;
        }
        mt.transfer(msg.sender, vendor, 5);
        customerPaid[msg.sender] = true;
        return true;
    }
}"
10569-0-0.sol,answer,"contract OnetimeService {
    address vendor;

    function OnetimeService() {
        vendor = msg.sender;
    }

    function buy(address tokenContractAddress) returns (bool success) {
        MyToken mt = MyToken(tokenContractAddress);
        if (mt.getBalance(msg.sender) < 2) {
            return false;
        }
        mt.sendCoin(vendor, 2);

        return true;
    }

}"
10569-0-0.sol,answer,"contract TimeLimitedService {
     ....
     

}"
42521-1-0.sol,answer,"contract Mutex {
  bool locked;
modifier noReentrancy() {
    require(!locked);
    locked = true;
    _;
    locked = false;
}

  function canBeAttacked() public returns (uint) {
    require(msg.sender.call.value(1 ether)());
   return 7;
  }


  function f() public noReentrancy returns (uint) {
    require(msg.sender.call());
   return 7;
  }
}"
63759-0-0.sol,answer,"contract Contract {
 string ipfsHash;
 mapping (address => string[]) userToFiles;
 event (string ipfsHash, address owner) filesUploaded;

 function setHash(string x) public {
   ipfsHash = x;
   
   
 }

 function getHash() public view returns (string x) {
   return ipfsHash;
 }
}"
1517-0-0.sol,answer,"contract Sorter {

    uint[] public data;
    function set(uint[] _data) { data = _data; }
    function sort() {
        if (data.length == 0)
            return;
        quickSort(data, 0, data.length - 1);
    }

    function quickSort(uint[] storage arr, uint left, uint right) internal {
        uint i = left;
        uint j = right;
        uint pivot = arr[left + (right - left) / 2];
        while (i <= j) {
            while (arr[i] < pivot) i++;
            while (pivot < arr[j]) j--;
            if (i <= j) {
                (arr[i], arr[j]) = (arr[j], arr[i]);
                i++;
                j--;
            }
        }
        if (left < j)
            quickSort(arr, left, j);

        if (i < right)
            quickSort(arr, i, right);
    }
}"
11246-1-0.sol,answer,"contract SerialitySample is Seriality {

   function testSample1() public returns(int n1, int8 n2, uint24 n3,  string n4,string n5) {

    bytes memory buffer = new  bytes(200);
    string memory out4  = new string(32);        
    string memory out5  = new string(32);
    n4 = new string(32);
    n5 = new string(32);
    int     out1 = 34444445;
    int8    out2 = 87;
    uint24  out3 = 76545;
    out4 = ""Copy kon lashi"";
    out5 = ""Bia inja dahan service"";

    
    uint offset = 200;

    intToBytes(offset, out2, buffer);
    offset -= sizeOfInt(8);

    uintToBytes(offset, out3, buffer);
    offset -= sizeOfUint(24);

    stringToBytes(offset, bytes(out5), buffer);
    offset -= sizeOfString(out5);

    stringToBytes(offset, bytes(out4), buffer);
    offset -= sizeOfString(out4);       

    intToBytes(offset, out1, buffer);
    offset -= sizeOfInt(256);

    
    offset = 200; 

    n2 = bytesToInt8(offset, buffer);
    offset -= sizeOfInt(8);

    n3 = bytesToUint24(offset, buffer);
    offset -= sizeOfUint(24);

    bytesToString(offset, buffer, bytes(n5));
    offset -= sizeOfString(out5);

    bytesToString(offset, buffer, bytes(n4));
    offset -= sizeOfString(out4);

    n1 = bytesToInt256(offset, buffer);
}"
50460-0-1.sol,answer,"contract Test {
    uint[] public arr;
    uint[] public arr1;

    constructor() public {
        arr = [1];
        arr1 = [2];
    }

    function setMe() public {
        TestLibrary.setMyArray(arr, arr1);
    }
}"
7949-1-3.sol,answer,"contract Test {

    address public constant MY_ADDRESS = msg.sender;

    function check() constant returns (address) {
        return MY_ADDRESS;
    }
}"
12154-0-0.sol,answer,"contract ColorPallet {

  address public owner; 

  
  bytes32[] public colors;

  mapping(address => uint) public userColorChoices;
  mapping(address => bool) public userHasSelectedColor;

  modifier onlyOwner() {
    if(msg.sender != owner) throw;
    _;
  }

  function ColorPallet() {
    owner = msg.sender;
  }

  
  function newColor(bytes32 colorName) 
    onlyOwner
    returns(uint index) 
  {
    colors.push(colorName);
    return colors.length-1;
  }

  

  function setUserColor(uint colorId) 
    public
  {
    if(colorId >= getColorCount()) throw; 
    userColorChoices[msg.sender] = colorId; 
    userHasSelectedColor[msg.sender] = true;
  }

  function getColorCount() 
    public
    constant
    returns(uint count) 
  {
    return colors.length;
  }

  function newUserContract() 
    public
    returns(address newUserContract)
  {
    User u = new User(msg.sender, this);  
    return u;
  }
}"
12154-0-0.sol,answer,"contract User {

  address public owner; 
  address public pallet;
  uint    public myColor;

  ColorPallet c;

  modifier onlyOwner() {
    if(msg.sender != owner) throw;
    _;
  }

  function User(address userOwner, address pallet) {
    
    owner = userOwner;
    
    c = ColorPallet(pallet);
  }

  function selectColor(uint colorId) 
    
    returns(bool success)
  {
    myColor = colorId;                      
    c.setUserColor(colorId);                
    return true;
  }

}"
41071-0-0.sol,answer,"contract Refund {

    mapping(address => uint) public balances;

    event LogDeposit(address sender, uint amount);
    event LogWithdrawal(address receiver, uint amount);

    function withdrawFunds(uint amount) public returns(bool success) {
        require(amount >= balances[msg.sender]);
        LogWithdrawal(msg.sender, amount);
        msg.sender.transfer(amount);
        return true;
    }

    function () public payable {
        require(msg.value > 0);
        uint change;
        uint dep;
        if(msg.value > 20) {
            dep = 20;
            change = msg.value - change;
        }
        balances[msg.sender] += dep;
        if(change > 0) balances[msg.sender] += change;
        LogDeposit(msg.sender, msg.value);
    }
}"
71290-0-0.sol,answer,"contract A {

   uint public bidValue;
   address public bidder;

   function bid() public payable {
     bidValue = msg.value;    
     bidder = msg.sender;
   }
}"
71290-0-0.sol,answer,"contract B {    

  function aBid(address aAddress) public payable{
    A a = A(aAddress);    
    a.bid.value(msg.value)();
  }
}"
70980-0-0.sol,answer,"contract C1 {
    uint256 foo;
    function setFoo(uint256 value) external {
        foo = value;
    }
}"
83883-0-0.sol,answer,"contract Foo {

  function getPatient(uint id) public view returns (patient memory) {
    return patients[id];
  }
}"
62031-0-0.sol,answer,"contract Child {

   string public a;

   event LogCreatedBy(address creator, string arg);

   constructor (string arg) public payable { 
       a = arg;
       emit LogCreatedBy(msg.sender, a);
   }
}"
62031-0-0.sol,answer,"contract Factory {

    event LogCreatedChild(address sender, string arg, address created);

    function createChild(string arg) public payable {
        address issueContract = (new Child).value(msg.value)(arg);
        emit LogCreatedChild(msg.sender, arg, issueContract);
    }
}"
66070-1-0.sol,answer,"contract X {
    event E(bytes data);

    function b(bytes memory _b) public {
        emit E(msg.data);
    }
}"
66070-1-0.sol,answer,"contract Test {
    event E(bytes data);

    X x = new X();

    function b(bytes memory _b) public payable {

        emit E(msg.data);

        
        bytes memory callData = new bytes(msg.data.length-30);

        for(uint i=0; i<callData.length && i<msg.data.length; i++) {
            callData[i] = msg.data[i];
        }

        
        (bool res, bytes memory ret) = address(x).call(callData);

        assert(res);
    }

}"
41760-1-0.sol,answer,"contract CrowdSale {

    ERC20Token token;

    constructor (uint256 _hivePerEther, address _wallet, address _token, uint256 _openingTime, uint256 _closingTime) public {
        token = ERC20Token(_token);
        ...
    }

    function getTokenBalance(address _addr) external view returns (uint256 _balance) {
         _balance = token.balanceOf(_addr);
    }
}"
62443-1-1.sol,answer,"contract owned {
    address public owner;

    constructor () public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner, ""Only owner has the authority"");
        _;
    }

    function transferOwnership(address newOwner) public onlyOwner {
        owner = newOwner;
    }
}"
78562-0-2.sol,answer,"contract FeedConsumer {
    DataFeed feed;
    uint errorCount;
    function rate(address token) public returns (uint value, bool success) {
        
        
        require(errorCount < 10);
        try feed.getData(token) returns (uint v) {
            return (v, true);
        } catch Error(string memory ) {
            
            
            
            errorCount++;
            return (0, false);
        } catch (bytes memory ) {
            
            
            
            errorCount++;
            return (0, false);
        }
    }
}"
66510-0-0.sol,answer,"contract Count {
    mapping(string => uint256) private storedData;

    function set(string key, uint256 value) public {
        storedData[key] = value;
    }

    function get(string key) public view returns(uint256) {
        return storedData[key]; 
    }
}"
68934-1-0.sol,answer,"contract CrowdFunding {

    using HitchensUnorderedKeySetLib for HitchensUnorderedKeySetLib.Set;

    mapping(address => uint) public funderTotalContributions;

    struct Campaign {
        uint totalRaised;
        address beneficiary;
        mapping(address => uint) funderContributions;
        HitchensUnorderedKeySetLib.Set funderSet;
    }

    mapping(bytes32 => Campaign) campaigns;
    HitchensUnorderedKeySetLib.Set campaignSet;

    function newCampaign() public {
        bytes32 campaignId = genCampaignId();
        campaignSet.insert(campaignId);
        campaigns[campaignId].beneficiary = msg.sender;
    }
    function contribute(bytes32 campaignId) public payable {
        require(campaignSet.exists(campaignId), ""Campaign does not exist."");
        Campaign storage c = campaigns[campaignId];
        if(!c.funderSet.exists(addressToBytes32(msg.sender))) c.funderSet.insert(addressToBytes32(msg.sender));
        c.funderContributions[msg.sender] += msg.value;
        funderTotalContributions[msg.sender] += msg.value;
        c.totalRaised += msg.value;
    }
    function getCampaignFundsByAddress(address funder, bytes32 campaignId) public view returns(uint) {
        return campaigns[campaignId].funderContributions[funder];
    }
    function getCampaignInfo(bytes32 campaignId) public view returns(uint, address, uint) {
        require(campaignSet.exists(campaignId), ""Not a campaign."");
        Campaign storage c = campaigns[campaignId];
        return (c.totalRaised, c.beneficiary, c.funderSet.count());
    }
    function getCampaignAtIndex(uint index) public view returns(bytes32) {
        return campaignSet.keyAtIndex(index);
    }
    function getCampaignFunderAtIndex(bytes32 campaignId, uint index) public view returns(address) {
        require(campaignSet.exists(campaignId));
        return bytes32ToAddress(campaigns[campaignId].funderSet.keyAtIndex(index));
    }

    

    function genCampaignId() private view returns(bytes32 campaignId) {
        return keccak256(abi.encodePacked(this, msg.sender, campaignSet.count()));
    }

    

    function addressToBytes32(address a) private pure returns(bytes32) {
        return bytes32(uint(uint160(a)));
    }
    function bytes32ToAddress(bytes32 b) private pure returns(address) {
        return address(uint160(uint(b)));
    }

}"
10862-0-0.sol,answer,"contract Test {
    uint256 public v1;
    string public v2;

    function Test(uint256 _v1, string _v2) {
        v1 = _v1;
        v2 = _v2;
    }
}"
57257-1-1.sol,answer,"contract Test {

    struct S {
        string s;
        uint u;
    }

    function returnTwoValues() private pure returns (string s, uint u) {
        s = ""123"";
        u = 123;
    }

    constructor() public {
        (string memory _s, uint _u) = returnTwoValues();
        S memory s = S(_s, _u);
    }
}"
69020-0-0.sol,answer,"contract ConstantAndTransaction {

    uint trivial;

    function getTrivial() public view returns(uint) {
        
        
        return trivial;
    }

    function add(uint x) public {
        
        
        trivial += getTrivial() + x;
    }
}"
31747-1-0.sol,answer,"contract LocalEthereum {

    address public owner;
    event Created(adress indexed _from, bytes32 _tradeHash);
    function createEvent() onlyOwner external {
        Created(msg.sender, 0x01);
    } 
}"
4085-0-0.sol,answer,"contract C {
  function foo() returns(int) {
    if(msg.sender != owner) {
      Error(""User not authorized"")
      return -1111;  
    }
    
  }
}"
84244-0-2.sol,answer,"contract HelloWorld {

    string public message;

    constructor(string memory initMessage) public {
        message = initMessage;
    }

    function update(string memory) public {

        bytes memory messageB = '\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00`\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xa0\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03foo\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03bar\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00';

        bool result;
        string memory result1;
        string memory result2;

        (result,result1,result2) = abi.decode(messageB,(bool,string,string));

        
        if(result == true){
           message = result1;
        }else{
           message = result2; 
        }

    }
}"
9843-1-1.sol,answer,"contract C {
function g(uint a) returns (uint ret) { return f(); }
function f() returns (uint ret) { return g(7) + f(); }
}"
67052-0-0.sol,answer,"contract Test {
    string public constant text = ""Hello world!"";

    function isEqualTo(string memory myString) public pure returns(bool) {
        return (keccak256(abi.encode(text)) == keccak256(abi.encode(myString)));
    }
}"
16188-0-0.sol,answer,"contract Burner {
    uint256 public totalBurned;

    function Purge() public {
        
        
        msg.sender.transfer(this.balance / 1000);
        assembly {
            mstore(0, 0x30ff)
            
            
            create(balance(address), 30, 2)
            pop
        }
    }

    function Burn() payable {
        totalBurned += msg.value;
    }
}"
67507-0-0.sol,answer,"contract Attacker {

  

  function () payable {
    
    
    if(sufficientGas) {
       victim.withdraw(amountToStealOnThisIteration); 
    } 
  }

}"
78902-0-0.sol,answer,"contract JsonFile {

    event JSONFileEvent(uint256 id, bytes32 product, uint256 prize);

    function writeJsonFile(uint256 _id, bytes32 _product, uint256 _prize) public {
        emit JSONFileEvent(_id, _product, _prize);
    }
}"
17312-2-0.sol,answer,"contract Money {
  struct People{
    uint id;
    string name;
    uint amount;
  }
  mapping (uint => People) public peoples;
  event votedEvent(uint indexed _candidateId);
  uint public candidateConut;

  constructor() public {
    candidateConut = 0;
    addCandidate(""Holder 1"");
    addCandidate(""Holder 2"");
  }
  function addCandidate(string memory _name) public {
    peoples[candidateConut] = People(candidateConut,_name,0);
    candidateConut++;
  }
  
  function get(uint _candidateId) public view returns(People memory) {
    return peoples[_candidateId];
  }
  
  function getPeople() public view returns (uint[] memory, string[] memory,uint[] memory){
      uint[]    memory id = new uint[](candidateConut);
      string[]  memory name = new string[](candidateConut);
      uint[]    memory amount = new uint[](candidateConut);
      for (uint i = 0; i < candidateConut; i++) {
          People storage people = peoples[i];
          id[i] = people.id;
          name[i] = people.name;
          amount[i] = people.amount;
      }

      return (id, name,amount);

  }
  
  function getPeoples() public view returns (People[] memory){
      People[]    memory id = new People[](candidateConut);
      for (uint i = 0; i < candidateConut; i++) {
          People storage people = peoples[i];
          id[i] = people;
      }
      return id;
  }
}"
60385-1-0.sol,answer,"contract Example {
    struct Sample {
        bytes32 key;
        string str1;
        .
        .
        .
        .
        .
        string str8;
        byts32[] someArray; 
    }

    mapping(bytes32 => Sample) sampleMap;

    function set(Sample data) public returns(bool) {
        sampleMap[data.key] = data;
        return true;
    }

    function get(bytes32 key) returns(Sample) {
        return sampleMap[key];
    }
}"
19586-0-0.sol,answer,"contract CrowdFund {

    uint deadline;
    uint goal;
    uint raised;
    address owner;

    function CrowdFund(uint _deadline, uint _goal) {
        owner = msg.sender;
        deadline = _deadline;
        goal = _goal;
    }

    function checkGoalReached() public constant returns(bool isIndeed) {
        return (raised >= goal);
    }

    function checkDeadlinePassed() public constant returns(bool hasIndeed) {
        return(now > deadline);
    }

}"
7557-0-3.sol,answer,contract C { uint[] public numbers; function initNumbers() { numbers.push(1); numbers.push(2); } function stateChanger(uint a) { numbers.push(a); }      }
18507-0-0.sol,answer,"contract c {
    address owner;

    event Error(string error);

    modifier onlyOwner() {
        if (msg.sender != owner) {
            Error('Mortal: onlyOwner function called by user that is not owner');
        }
        _;
    }

    function c() {
        
        owner = msg.sender;
    }

    function f() onlyOwner {

    }
}"
20933-0-1.sol,answer,"contract ForceSender {
  function forceSend(address recipient) payable {
    require(msg.value != 0);
    ForceSend f = (new ForceSend).value(msg.value)(recipient);
    assert(address(f) != address(0));
  }
}"
11455-0-0.sol,answer,"contract Test {
    uint public blockNumber;
    bytes32 public blockHashNow;
    bytes32 public blockHashPrevious;

    function setValues() {
        blockNumber = block.number;
        blockHashNow = block.blockhash(blockNumber);
        blockHashPrevious = block.blockhash(blockNumber - 1);
    }    
}"
73455-0-0.sol,answer,"contract D {

    function delegatecallSetN(address _e, uint _n) public returns (uint, bytes32, uint, string memory) {
        bytes memory data = abi.encodeWithSelector(bytes4(keccak256(""setN(uint256)"")), _n);
        (bool success, bytes memory returnedData) = _e.delegatecall(data);
        require(success);
        return abi.decode(returnedData, (uint, bytes32, uint, string));
    }
}"
73455-0-0.sol,answer,"contract E {

    uint public n;
    struct User {
        uint id;
        string name;
    }

    mapping (address => User) users;

    function setN(uint _n) public returns (uint, bytes32, uint, string memory) {
        bytes32 dataBytes = 0x111122223333444455556666777788889999AAAABBBBCCCCDDDDEEEEFFFFCCCC;
        n = _n;
        users[msg.sender] = User(123, ""mystring"");
        return (n, dataBytes, users[msg.sender].id, users[msg.sender].name);
    }
}"
46998-0-0.sol,answer,"contract DApp {
    uint256 acconto;
    uint256 saldo;
    address committent;
    address technician;
    bool started;
    uint256 timeFinish;

    modifier onlyCom() { require(msg.sender == committent); _; }
    modifier onlyAfter(uint _time) { require(now > _time); _; }

    constructor (uint256 _acconto, uint256 _saldo, address _technician) public {
        technician = _technician;
        committent = msg.sender;
        acconto = _acconto;
        saldo = _saldo;
        started = false;
    }

    function start(uint256 _time) public onlyCom() payable {
        require(started == false);
        require(msg.value >= acconto + saldo);
        started = true;
        timeFinish = now + _time;
        technician.transfer(acconto);
    }

    function good() public onlyCom() { selfdestruct(technician); }
    function bad() public onlyCom() onlyAfter(timeFinish) { selfdestruct(committent); }
}"
71989-0-1.sol,answer,"contract test {
    struct BB {
        mapping(uint => AA) map_2;
    }
    struct AA{
        uint val;
    }
    mapping(uint => BB) map_1;

    function test() public {
        map_1[1].map_2[1].val = 10;
    }

    function maping() public view returns(uint) {
        return map_1[1].map_2[1].val;
    }
}"
57526-0-0.sol,answer,"contract A {

    function methodA(string param) public pure returns(string) {
        
        return ""Behold"";
    }

}"
57526-0-0.sol,answer,"contract B {

    A contractA;

    constructor() public {
        contractA = new A();
    }

    function callA(string param) public view returns(string) {
        string memory callResult=contractA.methodA(param);
        return callResult;
    }

}"
22790-2-0.sol,answer,"contract PaymentGateway {

    
    
    
    

    enum State {
        PENDING,
        ACCEPTED,
        REFUNDED
    }

    struct Transaction {
        uint            id;
        address         from;
        uint256         amount;
        State           state;
        uint            date;
    }

    
    
    
    address public owner;
    uint  constant AUTO_REFUND_AFTER = 5 days;
    uint public sequence;
    uint public nbPendingTrasanction = 0;
    mapping(uint => Transaction) db;
    uint256 pendingVolume = 0;
    uint256 availableVolume = 0;
    


    
    
    

    modifier onlyOwner {
        if (msg.sender != owner) throw;
        _;
    }
    


    
    
    
    event received_payment(uint id, address from, uint amount, State state, uint date);
    


    
    
    
    function PaymentGateway() {
        owner = msg.sender;
        sequence = 0;  
    }
    


    
    
    

    
    function getPendingTransactions() constant returns (uint[]) {

        if(nbPendingTrasanction == 0) {
            return new uint[](0);
        }

        uint[] memory policyIDArray  = new uint[](nbPendingTrasanction);

        uint index = 0;
        for (var id = 0; id < sequence ; id++) {
            Transaction memory t  = db[id];

            if(t.state == State.PENDING) {
                policyIDArray[index] = t.id;
                index++;
            }
        }

        return (policyIDArray);
    }

    
    function getTransactionDetail(uint _id) constant returns (uint, address, uint256, State, uint) {
        return (db[_id].id, db[_id].from, db[_id].amount, db[_id].state, db[_id].date);
    }
    


    
    
    

    
    function receivePayment() payable {

        Transaction memory t; 
        t.id             = sequence;
        t.from           = msg.sender;
        t.amount         = msg.value;
        t.state          = State.PENDING;
        t.date           = now;

        
        db[t.id]  = t;

        
        sequence++; 

        
        nbPendingTrasanction++;

        
        pendingVolume += msg.value; 

        
        received_payment(t.id, t.from, t.amount, t.state, t.date);
    }

    
    function acceptPayment(uint _id) onlyOwner {
         db[_id].state = State.ACCEPTED;

        
        
        availableVolume += db[_id].amount; 
        pendingVolume -= db[_id].amount; 


        
        nbPendingTrasanction--;
    }


    
    function refundPayment(uint _id) onlyOwner {

        
        require(db[_id].amount != 0);

        
        require(this.balance >= db[_id].amount);

        
        db[_id].state = State.REFUNDED;


        
        
        pendingVolume -= db[_id].amount;

        
        nbPendingTrasanction--;

        
        assert(db[_id].from.send(db[_id].amount));
    }

    
    function transfer(address _to, uint256 _amount) onlyOwner {
         
    }


    
    function transferOwnership(address _newOwner) onlyOwner {
        owner = _newOwner;
    }

    



    
    
    

    


}"
45596-1-0.sol,answer,"contract Ownable {
  address public owner;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

  function Ownable() public {
    owner = tx.origin;
  }

  modifier onlyOwner() {
    require(tx.origin == owner);
    _;
  }

  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    require(newOwner != owner);

    owner = newOwner;
    emit OwnershipTransferred(owner, newOwner);
  }
}"
29745-0-0.sol,answer,"contract C {
    bytes32 public x = 0xffff;

    function changeX() external {
        x = 0xffaa;
    }
}"
45885-2-0.sol,answer,"contract owned {
    address public owner;

    function constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address newOwner) onlyOwner public {
        owner = newOwner;
    }
}"
45885-2-0.sol,answer,"contract TokenERC20 {
    
    string public name;
    string public symbol;
    uint8 public decimals = 18;
    
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    event Burn(address indexed from, uint256 value);

    
    function constructor(
        uint256 initialSupply,
        string tokenName,
        string tokenSymbol
    ) public {
        totalSupply = initialSupply * 10 ** uint256(decimals);  
        balanceOf[msg.sender] = totalSupply;                
        name = tokenName;                                   
        symbol = tokenSymbol;                               
    }

    
    function _transfer(address _from, address _to, uint _value) internal {
        
        require(_to != 0x0);
        
        require(balanceOf[_from] >= _value);
        
        require(balanceOf[_to] + _value > balanceOf[_to]);
        
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
        
        balanceOf[_from] -= _value;
        
        balanceOf[_to] += _value;
        emit Transfer(_from, _to, _value);
        
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }

    
    function transfer(address _to, uint256 _value) public {
        _transfer(msg.sender, _to, _value);
    }

    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
        require(_value <= allowance[_from][msg.sender]);     
        allowance[_from][msg.sender] -= _value;
        _transfer(_from, _to, _value);
        return true;
    }

    
    function approve(address _spender, uint256 _value) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        public
        returns (bool success) {
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function burn(uint256 _value) public returns (bool success) {
        require(balanceOf[msg.sender] >= _value);   
        balanceOf[msg.sender] -= _value;            
        totalSupply -= _value;                      
        emit Burn(msg.sender, _value);
        return true;
    }

    
    function burnFrom(address _from, uint256 _value) public returns (bool success) {
        require(balanceOf[_from] >= _value);                
        require(_value <= allowance[_from][msg.sender]);    
        balanceOf[_from] -= _value;                         
        allowance[_from][msg.sender] -= _value;             
        totalSupply -= _value;                              
        emit Burn(_from, _value);
        return true;
    }
}"
46672-1-0.sol,answer,"contract AssetFactory {
    Asset[] public deployedAssets;

  function createAsset(string name) public returns (Asset) {
    Asset newAsset = new Asset(name);
    deployedAssets.push(newAsset);
    return newAsset;
  }

  function isFactory() public pure returns(bool isIndeed) {
    return true;
  }
}"
46672-1-0.sol,answer,"contract Asset {
  string public name;
  AssetFactory factory;

  event LogAsset(address sender, bool isFactory);

  function Asset(string _name) public {
    name = _name;
    factory = AssetFactory(msg.sender);
  }

  

  function modifyAssetAndCreateNew(string _name) public {
    factory.createAsset(_name);
    name = _name;
  }   
}"
57675-0-1.sol,answer,"contract Aa {

    uint public myuint;

    function set(uint _var) public {
            require(_var == 5 || _var == 99, ""Not 5 or 99!"");
        myuint = _var;
    }

    function get() public view returns (uint){
        return myuint;
    }
}"
40890-1-0.sol,answer,"contract Bank {

    

    address private owner;

    modifier onlyOwner {
        require(owner == msg.sender);
        _;
    }

    function Bank() public  {
        
        owner = msg.sender;
    }

    
    function getBalance() public view returns (uint balancr) {
        return this.balance; 
    }

    
    function deposit() public payable {
    }

    function withdraw(uint amount) public onlyOwner {
        
        
        require(this.balance >= amount);
        owner.transfer(amount);
    }

}"
41116-1-1.sol,answer,"contract Attack {
    Guess g;
    event LogSuccess(address sender, bool success);
    constructor(address guessIt) public {
        g = Guess(guessIt);
    }
    function nostrodamus() public {
        if(g.guessMe(uint(blockhash(block.number)))) {
            emit LogSuccess(msg.sender, true);
        }
    }
}"
8201-2-0.sol,answer,"contract A {
    function makeCall(address addressB) {
        AbstractB(addressB).getX.value(1 ether).gas(0);
    }
}"
2549-0-1.sol,answer,"contract A is Test {
  uint[][] multiarray;

  function testMultiArray() {
    
    
    multiarray.length++;
    
    
    
    multiarray[0].length++;
    multiarray[0].length++;
    
    
    multiarray[0][0] = 1;
    multiarray[0][1] = 1;
    
    
    
    
    multiarray.length--;
    
    
    multiarray.length++;
    
    multiarray[0].length++;
    multiarray[0].length++;
    
    
  }
}"
2567-0-2.sol,answer,contract A { function A(bool) { ... }}
34618-0-0.sol,answer,"contract Storage {

    mapping(uint => bytes32) public byteMap;

    function setStorage(uint key, bytes32 value) public returns(bool success) {
        byteMap[key] = value;
        return true;
    }

    function getStorage(uint key) public constant returns(bytes32 value) {
        return byteMap[key];
    }
}"
34618-0-0.sol,answer,"contract Client {

    Storage datastore;

    function Client(address storageAddress) public {
        datastore = Storage(storageAddress);
    }

    function setValue(uint key, bytes32 value) public returns(bool success) {
        datastore.setStorage(key, value);
        return true;
    }

    function getValue(uint key) public constant returns(bytes32 value) {
        return datastore.getStorage(key);
    }
}"
34618-0-0.sol,answer,"contract ClientFactory {

    event LogNewClientCreated(address sender, address newClient);

    function createClient(address storageContract) public returns(address newClient) {
        Client c = new Client(storageContract);
        LogNewClientCreated(msg.sender, c);
        return c;
    }
}"
62760-0-0.sol,answer,"contract ViewVsPure {
  uint public age = 18;

  function addToAge(uint _no) public view returns (uint){
    return age + _no;
  }

  function add(uint _a, uint _b) public pure returns (uint) {
    return _a + _b;
  }
}"
78923-1-0.sol,answer,"contract Airdrop {
    address public owner;
    mapping(address => uint256) public balances;

    constructor() public {
        owner = msg.sender;
    }

    function transferBatch(IERC20Token _token, address[] _targets, uint256[] _amounts) external {
        require(msg.sender == owner);
        uint256 length = _targets.length;
        require(length == _amounts.length);
        for (uint256 i = 0; i < length; i++) {
            address target = _targets[i];
            uint256 amount = _amounts[i];
            require(balances[target] == 0);
            require(_token.transfer(target, amount));
            balances[target] = amount;
        }
    }
}"
24404-0-1.sol,answer,"contract Factory {
  ...
  
  event ContractCreated(address _contract, bytes32 _name, uint _index);

  function createContract (bytes32 name) public {
    address newContract = new Contract(name);
    newContracts.push(newContract);

    
    ContractCreated(newContract, name, newContracts.length - 1);
  } "
5946-0-0.sol,answer,"contract C {
  modifier restrictTargetType(address target, uint contractType) {
    require(contractTypes[target] == contractType);
    _;
  }
  function f(address target, uint contractType) restrictTargetType(target, contractType) {
    ....
  }
}"
42-2-0.sol,answer,"contract Alarm is usingOraclize {
    function Alarm() {
       oraclize_query(1*day, ""URL"", """");
    }

    function __callback(bytes32 myid, string result) {
        if (msg.sender != oraclize_cbAddress()) throw;
        
    }
}"
57277-0-0.sol,answer,"contract DB {

  address public owner;
  mapping(address => bool) public allowedContracts;

  modifier onlyAllowedContracts() {
      require(allowedContracts[msg.sender]);
      _;
  }

  modifier onlyOwner {
      require(msg.sender == owner);
      _;
  }

  constructor() public {
      owner = msg.sender;
  }

  function isAllowedContract(address check) public view returns(bool isIndeed) {
      return allowedContracts[check];
  }

  function addAllowedContract(address newContract) public onlyOwner returns(bool success) {
      require(!isAllowedContract(newContract));
      allowedContracts[newContract] = true;
      return true;
  }

  function removeAllowedContract(address newContract) public returns(bool success) {
      require(isAllowedContract(msg.sender));
      allowedContracts[newContract] = false;
      return true;
  }

  function insertNewDataRecords() public onlyAllowedContracts returns(bool success) {
      
      return true;
  }
}"
21376-0-0.sol,answer,"contract SampleContract {

  struct ChildStruct {
    bool isPresent;
    bytes32 name;
  }

  struct ParentStruct {
    bool isPresent;
    bytes32 name;
    mapping (bytes32 => ChildStruct) childStructs; 
  }

  mapping(bytes32 => ParentStruct) public parentStructs;

  function insertData(
    bytes32 parentKey, 
    bytes32 parentName, 
    bytes32 childKey, 
    bytes32 childName)
    public 
    returns(bool success)
  {

    parentStructs[parentKey].isPresent = true;
    parentStructs[parentKey].name = parentName;
    parentStructs[parentKey].childStructs[childKey].isPresent = true;
    parentStructs[parentKey].childStructs[childKey].name = childName;
    return true;
  }

  function getChild(bytes32 parentKey, bytes32 childKey) public constant returns(bool isPresent, bytes32 name) {
    return (parentStructs[parentKey].childStructs[childKey].isPresent, parentStructs[parentKey].childStructs[childKey].name);
  }

}"
55900-1-0.sol,answer,"contract SalesContract {
    ...
    function SaleContract() {
        ...
    }
    ...
}"
83441-0-0.sol,answer,"contract SendBalanceContract is Ownable {

    using ERC165Checker for address; 

    ERC721 public nonFungibleContract;

    bytes4 constant InterfaceSignature_ERC721 = bytes4(0x9a20483d);

    constructor(address _nftAddress) public {

        ERC721 candidateContract = ERC721(_nftAddress);
        require(candidateContract.supportsInterface(InterfaceSignature_ERC721)); 
        nonFungibleContract = candidateContract;
    }

    function withdrawBalance() external {
        address nftAddress = address(nonFungibleContract);

        require(msg.sender == owner() || msg.sender == nftAddress);
        
        (bool sent, bytes memory data) = nftAddress.call{value:address(this).balance}("""");
    }
}"
79567-0-0.sol,answer,"contract Test {
    uint256 public a;
    constructor (uint256 _a) public {
        a = _a;
    }
}"
79567-0-0.sol,answer,"contract DeployTest {
    function deploy() public {
        new Contract{salt: 0x1234}(123);
    }
}"
2718-0-0.sol,answer,"contract MyTest is Test {

  struct Struct {
    uint timestamp;
  }

  
  mapping(uint => mapping(uint => uint)) mymap;

  mapping(address => mapping(uint => Struct[])) someName;

  function testNestedMappings() {
    
    mymap[1][2] = 42;
    
    
    
    
    someName[msg.sender][1].length++;
    
    someName[msg.sender][1][someName[msg.sender][1].length - 1].timestamp = block.timestamp;
    
  }
}"
5727-0-0.sol,answer,"contract Parent{
  function fallback() internal {
    log0(""Parent fallback function"");
  }

  function (){
     fallback();
  }
}"
5727-0-0.sol,answer,"contract Child is Parent {
  function (){
    log0(""child fallback function"");
    super.fallback();
  }
}"
26028-1-0.sol,answer,"contract Example {

   Token public myToken;

   
  function Example() {
       myToken = new Token();
  }
}"
26028-1-0.sol,answer,"contract Token {
   function getInt() constant returns(uint) {
       return 1;
   }
}"
61877-0-0.sol,answer,"contract ERC223Receiver {
    function tokenReceiveLogic1() internal {
        
        
    }

    function tokenReceiveLogic2() internal {
        
        
    }


    function tokenFallback(
        address _sender,
        uint256 _value,
        bytes _extraData) returns (bool) {

        require(_value > 10);
        return true;
        
        
        
        
        
    }
}"
61877-0-0.sol,answer,"contract Token {
    function transfer(address to, uint value) public {
        bytes memory empty;
        bool shouldFail = ERC223Receiver(to).tokenFallback(msg.sender,value,empty);
        

    }
}"
72363-0-0.sol,answer,"contract Contract2 {
    Contract1 public contract1 = new Contract1();
    function func() public returns (uint32, uint32) {...}
}"
73729-1-0.sol,answer,"contract TimeServer {

  uint256 FUDGE_FACTOR_IN_BLOCKS = 2;
  uint256 public lastBlockNumber;
  uint256 public lastBlockTime;

  constructor(uint256 firstBlockNumber) {
    require(abs(firstBlockNumber - block.number) < FUDGE_FACTOR_IN_BLOCKS));
    lastBlockNumber = block.number;
    lastBlockTime = now;
  }

  function submitNewTime(uint256 newBlockNumber, uint256 newBlockTime) public {
    uint blockDiff = newBlockNumber - lastBlockNumber;
    require(blockDiff > 0, `New block number must be later than last block')'
    uint timeDiff = newBlockTime - lastBlockTime;
    require(abs(timeDiff / 15) - blockDiff) < FUDGE_FACTOR_IN_BLOCKS,
            'Submitted block time is off by more than +/- fudge factor.') )
    lastBlockNumber = newBlockNumber;
    lastBlockTime = newBlockTime;
  }

}"
67793-0-0.sol,answer,"contract Test {

    event Event1(bytes data, uint256 updatedAt);
    event Event2(bytes data, uint256 updatedAt);

    
    uint256 public lastBlock;

    function dosomething1(bytes data) public {
        emit Event1(data, lastBlock);
        lastBlock = block.number;
    }

    function dosomething2(bytes data) public {
        emit Event2(data, lastBlock);
        lastBlock = block.number;
    }
}"
20750-0-0.sol,answer,"contract Banker {
    address silverCoinAddress;

    function Banker(address _silverCoinAddress) {
        silverCoinAddress = _silverCoinAddress;
    }

(...)"
42200-0-0.sol,answer,"contract A {
    uint tokens = 10;
    
    address allowedBurnerAddress = 0x1234;

    
    function burn(uint amount) public {
        require(msg.sender == allowedBurnerAddress);
        tokens -= amount;
    }
}"
42200-0-0.sol,answer,"contract B {
    
    address burnContract = 0x0987;

    
    function PerformBurn() public {
        

        A original = A(burnContract);
        original.burn(5);
    }
}"
42414-0-0.sol,answer,"contract C {

    
    uint[][] data;

    function append(uint _a, uint _b) public {
        data.push([_a, _b]);
    }

    function read(uint _idx) public view returns (uint[]) {
        return data[_idx];
    }
}"
60130-0-0.sol,answer,"contract WorksOnce {

    bool isUsed;

    event LogLuckyWinner(address sender);

    function pickMe() public {
        require(!isUsed);
        isUsed = true;
        emit LogLuckyWinner(msg.sender);
    }
}"
78556-0-0.sol,answer,"contract Test {

    struct Request {
        function(uint) external callback;
    }

    Request[] private requests;

    function getAddress (uint requestID) public view returns (address) {
        return address(requests[requestID].callback);
    }
}"
73038-0-0.sol,answer,"contract Product {
    Factory public factory;
    Product public x;
constructor(Product _reference, Factory _factory) public{
    x = _reference;
    factory = _factory;
}

function haveFactoryCreateProductWithReferenceToThis() public {
    emit ProductCreated(factory.createNewProduct(this));
}

event ProductCreated(Product indexed product);
}"
11187-0-3.sol,answer,"contract AddressArray {

    address[] addresses;

    function AddressArray(uint dummy1, address[] addresses_, uint dummy2) {
        for (uint i = 0; i < addresses_.length; i++) {
            addresses.push(addresses_[i]);
        }
    }

    function getNumberOfAddresses() constant returns (uint) {
        return addresses.length;
    }

    function getAddress(uint i) constant returns (address) {
        return addresses[i];
    }
}"
21656-0-0.sol,answer,"contract Crowdsale {
    ERC20I public tokenInterface;
    function Crowdsale(address _tokenAddress) {
        tokenInterface = ERC20I(_tokenAddress);
    }
}"
83043-1-0.sol,answer,"contract A {

    event Log(address addr);

    function() external {
        emit Log(bytesToAddress(msg.data));
    }

    function bytesToAddress(bytes memory source) public pure returns(address addr) {
        assembly {
            addr := mload(add(source, 0x14))
        }
    }
}"
8756-0-0.sol,answer,"contract ObjectFactory {
    Object public theObj;

    function createObject(string name) returns (address objectAddress) {
        theObj = address(new Object(name));
        return theObj;
    }
}"
15584-0-4.sol,answer,"contract TestReviews {

  function testRateBookUsingDeployedContract() {
    Reviews reviews = Reviews(DeployedAddresses.Reviews());

    reviews.rateBook(0, 5, ""Test comment"");
    var (rating, reviewer, description, dateAdded) = reviews.ratings(0, 0);

    Assert.equal(rating, 5, ""Book should have a rating of 5"");
  }

}"
84068-0-0.sol,answer,"contract MyContract {
    function func1(bytes32 b) public pure returns (address) {
        return address(uint160(bytes20(b)));
    }
    function func2(bytes32 b) public pure returns (address) {
        return address(uint160(uint256(b)));
    }
    function func3(uint256 b) public pure returns (address) {
        return address(uint160(bytes20(b)));
    }
    function func4(uint256 b) public pure returns (address) {
        return address(uint160(uint256(b)));
    }
}"
58688-0-0.sol,answer,"contract Game {
  address[] public winners;
  function submitWinningMove(bytes32 move) public returns(bool success) {
    require(gameIsOn());
    require(moveIsAllowed(move));
    require(moveIsWinner(move));
    winners.push(msg.sender);
    require(closeGame());
    emit LogWinningMove(msg.sender, move);
    return true;
   }
}"
12703-0-0.sol,answer,"contract Unique {

    address[] public tokenHolders;

    

    mapping(address => bool) public tokenHolderKnown;

    function scalableAddTokenHolder(address tokenHolder) returns(bool succes) {
        if(!tokenHolderKnown[tokenHolder]) {
            tokenHolders.push(tokenHolder);
            tokenHolderKnown[tokenHolder] = true;
            return true;
        }
        return false;
    }

}"
12736-0-0.sol,answer,"contract ZonesFactory {
    address[] zones;
    event LogCreatedZone(address indexed hsAddr, bytes32 name, bytes32 P1Lon, bytes32 P1Lat, bytes32 P2Lon, bytes32 P2Lat, bytes32 P3Lon, bytes32 P3Lat, bytes32 P4Lon, bytes32 P4Lat);

    function add(bytes32 name, bytes32 P1Lon, bytes32 P1Lat, bytes32 P2Lon, bytes32 P2Lat, bytes32 P3Lon, bytes32 P3Lat, bytes32 P4Lon, bytes32 P4Lat) public returns(address) {
        zoneObject newZone = new zoneObject(name, P1Lon, P1Lat, P2Lon, P2Lat, P3Lon, P3Lat, P4Lon, P3Lat);
        zones.push(newZone);
        LogCreatedZone(newZone,name, P1Lon, P1Lat, P2Lon, P2Lat, P3Lon, P3Lat, P4Lon, P3Lat);
        return newZone;
    }

    function getOrgAtIndex(uint index) public constant returns(address org){
        return zones[index];
    }

    function getOrganizationCount() public constant returns(uint count) {
        return zones.length;
    }
}"
12736-0-0.sol,answer,"contract zoneObject {

    struct LonLat {
        bytes32 P1Lon;
        bytes32 P1Lat;
        bytes32 P2Lon; 
        bytes32 P2Lat; 
        bytes32 P3Lon; 
        bytes32 P3Lat; 
        bytes32 P4Lon; 
        bytes32 P4Lat;
    }

    LonLat public lonLat;

    bytes32 public name;

    function zoneObject (bytes32 name, bytes32 P1Lon, bytes32 P1Lat, bytes32 P2Lon, bytes32 P2Lat, bytes32 P3Lon, bytes32 P3Lat, bytes32 P4Lon, bytes32 P4Lat){
        name = name;
        lonLat.P1Lon = P1Lon;
        lonLat.P1Lat = P1Lat;
        lonLat.P2Lon = P2Lon;
        lonLat.P2Lat = P1Lat;
        lonLat.P3Lon = P3Lon;
        lonLat.P3Lat = P3Lat;
        lonLat.P4Lon = P4Lon;
        lonLat.P4Lat = P4Lat;
    }

    function getDetails() public constant returns (bytes32, bytes32, bytes32, bytes32, bytes32, bytes32, bytes32, bytes32, bytes32){
        return (name, lonLat.P1Lon, lonLat.P1Lat, lonLat.P2Lon, lonLat.P2Lat, lonLat.P3Lon, lonLat.P3Lat, lonLat.P4Lon, lonLat.P4Lat);
    }
}"
59575-0-1.sol,answer,"contract tracking  {

  struct  data  {
    uint   ownernumber;
    uint   id;
  }

  uint value;
  mapping (uint256 => data) public  datamatching;

  function storedata (uint _ownernumber, uint _id) public {
    var  persondata  = datamatching[value];
    persondata .ownernumber = _ownernumber;
    persondata. id  =  _id;
  }

  function getData(uint256 userId) returns (data){
    return datamatching[userId];
  }
}"
64555-0-0.sol,answer,"contract ArrayTest {
    uint [] public numbers;
    function getNumberCount() public view returns(uint count) {
        return numbers.length;
    }
    function addIfNotPresent(uint num) public{
        uint arrayLength = numbers.length;
        bool found=false;
        for (uint i=0; i<arrayLength; i++) {
            if(numbers[i]==num){
                found=true;
                break;
            }
        }
        if(!found){
            numbers.push(num);
        }
    }
}"
73574-0-0.sol,answer,"contract CustTest { 
  mapping(address => CustList ) public customers;
  function createProfile() public { 
    customers[msg.sender] = new CustList(); 
  } 
}"
29199-0-0.sol,answer,"contract Play {

    address public playOwnerAddress;
    bytes32 public playOwnerName;
    bytes32 public playTitle;

    

    struct PlayActionStruct  {
        bytes32   playTitle;       
        bytes32   playWorkerName;
        address   playWorkerAddress;
        bytes32   playAction;
        bytes32   playActionDescription;
        bytes32   playStatus;
    }

    

    PlayActionStruct [] public playActions;

    event LogInsertPlayAction(
        bytes32   _playTitle,
        bytes32   _playWorkerName,
        bytes32   _playAction,
        bytes32   _playActionDescription,
        bytes32   _playStatus);

    modifier onlyOwner(){
        require(msg.sender == playOwnerAddress);
        _;
    }

    function Play(bytes32 thisPlayOwnerName, bytes32 thisPlayTitle) public  {
        playOwnerAddress = msg.sender;
        playOwnerName    = thisPlayOwnerName;
        playTitle        = thisPlayTitle;
    }

    function appendPlayAction(
        bytes32   _playTitle,
        bytes32   _playWorkerName,
        bytes32   _playAction,
        bytes32   _playActionDescription,
        bytes32   _playStatus)
        public
        onlyOwner 
        returns(bool success)
    {
        

        PlayActionStruct memory p;
        p.playAction            = _playTitle;
        p.playWorkerName        = _playWorkerName;
        p.playWorkerName        = _playWorkerName;
        p.playWorkerAddress     = msg.sender;
        p.playAction            = _playAction;
        p.playActionDescription = _playActionDescription;
        p.playStatus            = _playStatus;
        playActions.push(p);

        LogInsertPlayAction(
            _playTitle,
            _playWorkerName,
            _playAction,
            _playActionDescription,
            _playStatus);
        return true;
    }

    function getActionCount() public view returns(uint count) {
        return playActions.length;
    }
}"
58937-1-0.sol,answer,"contract RandomNumberReservation {
    uint public reservedBlockNumber;

    constructor(uint futureNthBlock) public {
        reservedBlockNumber = block.number + futureNthBlock;
    }

    function getCurrentBlockNumber() public view returns (uint) {
        return block.number;
    }

    function getRandomNumber() public view returns (bytes32) {
        require(block.number > reservedBlockNumber, ""Time has not come yet"");
        return blockhash(reservedBlockNumber);
    }
}"
77046-1-0.sol,answer,"contract MyContract {
    uint x;
    function func(uint _x) public {
        require(x != _x);
        x = _x;
    }
}"
43767-0-0.sol,answer,"contract MyContract {
    mapping(address => uint256) balances;

    function getOnesBalance(address addr) public view returns (uint){
        return balances[addr];
    }
    function getMyBalance() public view returns (uint){
        return balances[msg.sender];
    }
    function getContractBalance() public view returns (uint){
        return address(this).balance;
    }
    function getContractAddress() public view returns (address){
        return address(this)
    }
    function deposit() public payable {balances[msg.sender]+=msg.value;}
    function() public payable {deposit();}
}"
12649-0-1.sol,answer,"contract OrganisationsFactory {
    address[] organizations;
    event LogCreatedOrg(address indexed hsAddr, string name, string vat, string headquarterAddress);

    function add(string name, string vat, string headquarterAddress) public returns(address) {
        OrganizationObject newOrg = new OrganizationObject(name, vat, headquarterAddress);
        organizations.push(newOrg);
        LogCreatedOrg(newOrg, name, vat, headquarterAddress);
        return newOrg;
    }

    function getOrgAtIndex(uint index) public constant returns(address org){
        return organizations[index];
    }

    function getOrganizationCount() public constant returns(uint count) {
        return organizations.length;
    }
}"
12649-0-1.sol,answer,"contract OrganizationObject {

    struct organizationDetails {
        string name; 
        string vat; 
        string headquarterAddress;
    }

    organizationDetails public details;

    address[] public staff;

    function OrganizationObject (string name, string vat, string headquarterAddress){
        details.name = name;
        details.vat = vat;
        details.headquarterAddress = headquarterAddress;
    }

    function addStaff(address x){
        staff.push(x);
    }
}"
7396-0-4.sol,answer,"contract RequiringFunds {
   modifier NeedEth () {
       if (msg.value <= 0 ) throw;
       _
   }
}"
7396-0-4.sol,answer,"contract AmIOnTheFork {
   function forked() constant returns(bool);
}"
7396-0-4.sol,answer,"contract ReplaySafeSplit is RequiringFunds {
   
   address private constant oracleAddress = 0x2bd2326c993dfaef84f696526064ff22eba5b362;   

   
   AmIOnTheFork amIOnTheFork = AmIOnTheFork(oracleAddress);

   
   function split(address targetFork, address targetNoFork) NeedEth returns(bool) {
       
       
       if (targetFork == 0) throw;
       if (targetNoFork == 0) throw;

       if (amIOnTheFork.forked()                   
           && targetFork.send(msg.value)) {        
           return true;
       } else if (!amIOnTheFork.forked()           
           && targetNoFork.send(msg.value)) {      
           return true;
       }

       throw;                                      
   }

   
   function() {
       throw;
   }
}"
72284-0-3.sol,answer,"contract DocRegistry {

  struct Doc {
      address sender;
      uint date;
      bytes32 hash;
  }

  
  mapping(bytes32 => Doc) registry;

  
  function storeHash(bytes32 _hash) external returns (bool) {
    registry[_hash].sender = msg.sender;
    registry[_hash].date = now;
    registry[_hash].hash = _hash;

    emit HashStored(msg.sender, _hash);

    return true;
  }

  
  event HashStored(address indexed _sender, bytes32 _hash);
}"
65279-0-0.sol,answer,"contract Test {
    uint256[] public foo;

    function test() external {
        uint256 oldLength = foo.length;

        append(foo);

        assert(foo.length == oldLength + 1 && foo[oldLength] == 42);
    }

    function append(uint256[] storage arr) internal {
        arr.push(42);
    }
}"
48833-0-0.sol,answer,"contract Consumer {
    Producer currentProducer;

    function setProducer(address addr) public { 
        Producer newProducer = Producer(addr);
        require(newProducer.SOME_VALUE() > 0);
        currentProducer =newProducer; 
    }

    function getSome() public view returns (uint8) {
        return currentProducer.SOME_VALUE(); 

    }
}"
15683-0-2.sol,answer,"contract EInterface {
    uint public x;
    function set(uint _x) returns(bool success) {} 
}"
59922-0-0.sol,answer,"contract Test {

    mapping(int => uint8) one;
    mapping(int => uint256) two;
    int counter = 0;

    function pushOne() public {
        one[counter++] = 1;
    }

    function pushTwo() public {
        two[counter++] = 256;
    }

}"
58058-1-0.sol,answer,"contract StudentManager {
    uint[] public studentList;

    struct Student {
        bool valid;
        uint index;
        string name;
        uint age;
        bool tookTest;
    }

    mapping(uint => Student) public students;

    
    function upsert(uint ID, string _name, uint _age, bool _tookTest) external {
        Student storage student = students[ID];
        if (!student.valid) {
            student.valid = true;
            student.index = studentList.length;
            studentList.push(ID);
        }
        student.name = _name;
        student.age = _age;
        student.tookTest = _tookTest;
    }

    
    function remove(uint ID) external {
        Student storage student = students[ID];
        require(student.index < studentList.length);
        require(ID == studentList[student.index]);
        uint lastStudent = studentList[studentList.length - 1];
        students[lastStudent].index = student.index;
        studentList[student.index] = lastStudent;
        studentList.length -= 1;
        delete students[ID];
    }

    
    function studentCount() external view returns (uint) {
        return studentList.length;
    }
}"
59575-0-0.sol,answer,"contract tracking  {

  struct  data  {
    uint   ownernumber;
    uint   id;
  }

  uint value;
  mapping (uint256 => data) public  datamatching;

  function storedata (uint _ownernumber, uint _id) public {
    var  persondata  = datamatching[value];
    persondata .ownernumber = _ownernumber;
    persondata. id  =  _id;
  }

  function getData(uint256 userId) returns (uint, uint){
    return (datamatching[userId].ownernumber, datamatching[userId].id);
  }
}"
2519-1-1.sol,answer,"contract C {
    function bytes32ToString(bytes32 x) constant returns (string) {
        bytes memory bytesString = new bytes(32);
        uint charCount = 0;
        for (uint j = 0; j < 32; j++) {
            byte char = byte(bytes32(uint(x) * 2 ** (8 * j)));
            if (char != 0) {
                bytesString[charCount] = char;
                charCount++;
            }
        }
        bytes memory bytesStringTrimmed = new bytes(charCount);
        for (j = 0; j < charCount; j++) {
            bytesStringTrimmed[j] = bytesString[j];
        }
        return string(bytesStringTrimmed);
    }

    function bytes32ArrayToString(bytes32[] data) returns (string) {
        bytes memory bytesString = new bytes(data.length * 32);
        uint urlLength;
        for (uint i=0; i<data.length; i++) {
            for (uint j=0; j<32; j++) {
                byte char = byte(bytes32(uint(data[i]) * 2 ** (8 * j)));
                if (char != 0) {
                    bytesString[urlLength] = char;
                    urlLength += 1;
                }
            }
        }
        bytes memory bytesStringTrimmed = new bytes(urlLength);
        for (i=0; i<urlLength; i++) {
            bytesStringTrimmed[i] = bytesString[i];
        }
        return string(bytesStringTrimmed);
    }    
}"
56747-0-0.sol,answer,"contract Mapping {
struct Entity{
    bool isActive;
    uint index;
}
mapping(address => Entity) values;
address[] valuesTrue;
function getValue(address a) public view returns (bool) {
    return values[a].isActive;
} 

function getAllValues() public view returns(address[]) { 
    return valuesTrue;
}

function addValue(address a, bool b) public {
    values[a].isActive = b;
    if (b)
        values[a].index     = valuesTrue.push(a)-1;


    else {

        if (values[a].isActive) {
            uint rowToDelete = values[a].index;
            address keyToMove = valuesTrue[valuesTrue.length-1];
            valuesTrue[rowToDelete] = keyToMove;
            values[keyToMove].index = rowToDelete; 
            valuesTrue.length--;
        }

    }
}
}"
78462-1-1.sol,answer,"contract Proxy {
  address private _owner;
  address private _dest;

  constructor(address dest) public {
    _owner = msg.sender;
    _dest = dest;
  }

  function getDest() public view returns(address) {
    return _dest;
  }

  function setDest(address dest) public {
    require(msg.sender == _owner);
    _dest = dest;
  }

  
  function invoke(string memory method, bytes memory data) public payable {
    require(data.length >= 64, 'Insufficient space in payload');
    assembly {
        mstore(add(data, 0x20), caller())
        mstore(add(data, 0x40), callvalue())
    }
    bytes memory payload = abi.encodePacked(bytes4(keccak256(bytes(method)))), data);
    (bool ok, bytes memory response) = _dest.call(payload);
  }
}"
44816-0-0.sol,answer,"contract X {
    struct PRODUCT {
        bytes12 productid;
        uint price;
        uint quantity;
    }

    mapping (string => PRODUCT[]) products;

    function appendDetails(string pid, bytes12 productid, uint price, uint quantity) payable public {
        products[pid].push(PRODUCT(productid, price, quantity));
    }

    function getDetails(string pid, uint idx) 
    public view returns(bytes12 productid, uint price, uint quantity) {
        PRODUCT storage p = products[pid][idx];

        productid = p.productid;
        price = p.price;
        quantity = p.quantity;
    }

    function getDetailsCount(string pid) 
    public view returns(uint) {
        return products[pid].length;
    }
}"
72111-0-0.sol,answer,"contract Stratus {

    string public greeting;
    address public owner;

    event GreetingChanged (string oldGreeting, string newGreeting);

    constructor(string memory _greeting) public {
        greeting = _greeting;
        owner = msg.sender;
    }

    function setGreeting (string memory _greeting) public {
        require(owner == msg.sender);
        emit GreetingChanged(greeting,_greeting);
        greeting = _greeting;
        }
    }"
68998-0-3.sol,answer,"contract EventChain {

    
    uint public latestEvent;

    event LogChainedEvent(address sender, uint previousEvent);

    function logData() public {
        emit LogChainedEvent(msg.sender, latestEvent);
        latestEvent++;
    }
}"
76486-0-0.sol,answer,"contract TwoPlusTwo {

    


    function adder(uint x, uint y) public pure returns(uint) {
        return x+y;
    }
}"
64456-0-0.sol,answer,contract C { function f() public { } }
66516-1-0.sol,answer,"contract SetGet {

    uint[] public numbers;

    event LogNewNumber(address setter, uint number);

    function appendNumber(uint value) public {
        numbers.push(value);
        emit LogNewNumber(msg.sender, value);
    }
}"
46761-0-0.sol,answer,"contract Foo {
    function getRange(uint n) public pure returns(uint[]) {
        uint[] memory result = new uint[](n);
        for (uint i = 0; i < n; i++)
            result[i] = i;
        return result;
    }
}"
52215-0-0.sol,answer,"contract myContract {

 foreignContract created;
 constructor() public payable {
  created = new foreignContract();
 }

 function changeNameMycontract(string name) public returns(bool) {
  return created.changeName(name);

 }

 function ReturnName() public view returns(string) {
  return created.receiveName();
 }

}"
52215-0-0.sol,answer,"contract foreignContract {
 string name;


 function changeName(string Name) public returns(bool) {
  name = Name;
  return true;
 }

 function receiveName() public view returns(string) {
  return name;
 }
}"
72629-2-0.sol,answer,"contract certificarProcesoNuevo {
   struct  Informacion {
        string  informacion;
        string informacionHashArchivo;
    }
    mapping(string => Informacion) public historialInformacion;
    function escribirInformacion(string memory informacion,string memory informacionHashArchivo, string memory txn) public  {
        historialInformacion[txn].informacion = informacion;
        historialInformacion[txn].informacionHashArchivo = informacionHashArchivo;
    }
    function  getInformacion(string memory txn)  public view returns  (string memory) {
        return historialInformacion[txn].informacion;
    }
    function  getInformacionArchivoHash(string memory txn)  public view returns  (string memory) {
        return historialInformacion[txn].informacionHashArchivo;
    }

}"
72497-0-0.sol,answer,"contract Stages {

    enum Stage { init, two, three, done }

    Stage stage;

    modifier onlyStage (Stage s) {
        require(stage == s, ""Wrong step."");
        _;
    }

    function step1() public onlyStage(Stage.init) {
        
        stage = Stage.two;
    }

    function step2() public onlyStage(Stage.two) {
        
        stage = Stage.three;
    }

    function step3() public onlyStage(Stage.three) {
        
        stage = Stage.done;
    }
}"
10536-1-0.sol,answer,"contract Factory {

function at(address _addr) private view returns (bytes memory o_code) {
    assembly {
        
        let size := extcodesize(_addr)
        
        
        o_code := mload(0x40)
        
        mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))
        
        mstore(o_code, size)
        
        extcodecopy(_addr, add(o_code, 0x20), 0, size)
    }
}

function create(address _addrOfCode) returns (address){
    address retval;
    assembly{
        mstore(0x0, or (0x5880730000000000000000000000000000000000000000803b80938091923cF3 ,mul(_addrOfCode,0x1000000000000000000)))
        retval := create(0,0, 32)
    }
    return retval;
}
}"
10536-1-0.sol,answer,"contract Adder {
uint256 public param;

constructor(){
    param = 5;
}

function add(uint a, uint b) returns (uint){
    return a+b;
}
}"
10536-1-0.sol,answer,"contract Tester {

Adder a;

function Tester(address factory,address adder){
    address cAdr = Factory(factory).create(adder);
    a = Adder(cAdr);
    if(address(a) == 0) throw;
}

function test(uint x, uint y) constant returns (uint){
    return a.add(x,y);
}

function getParam() constant returns (uint){
    return a.param();
}
}"
49358-0-2.sol,answer,"contract LocalVariableTest {
    function assignValue() public {
        uint256 k = 2;
    }
}"
64590-0-0.sol,answer,"contract init {        
    ERC20Interface token;

    function test() public view {    
        require(address(token) != address(0));
    }
}"
51751-0-0.sol,answer,"contract Escrow is Ownable {
    enum PaymentStatus { Pending, Completed, Refunded }

    event PaymentCreation(uint indexed orderId, address indexed customer, uint value);
    event PaymentCompletion(uint indexed orderId, address indexed customer, uint value, PaymentStatus status);

    struct Payment {
        address customer;
        uint value;
        PaymentStatus status;
        bool refundApproved;
    }

    mapping(uint => Payment) public payments;
    ERC20 public currency;
    address public collectionAddress;
    Webshop public webshop;

    function Escrow(ERC20 _currency, address _collectionAddress) public {
        currency = _currency;
        collectionAddress = _collectionAddress;
        webshop = Webshop(msg.sender);
    }

    function createPayment(uint _orderId, address _customer, uint _value) external onlyOwner {
        payments[_orderId] = Payment(_customer, _value, PaymentStatus.Pending, false);
        emit PaymentCreation(_orderId, _customer, _value);
    }

    function release(uint _orderId) external {
        completePayment(_orderId, collectionAddress, PaymentStatus.Completed);
    }

    function refund(uint _orderId) external {
        completePayment(_orderId, msg.sender, PaymentStatus.Refunded);
    }

    function approveRefund(uint _orderId) external {
        require(msg.sender == collectionAddress);
        Payment storage payment = payments[_orderId];
        payment.refundApproved = true;
    }

    function completePayment(uint _orderId, address _receiver, PaymentStatus _status) private {
        Payment storage payment = payments[_orderId];
        require(payment.customer == msg.sender);
        require(payment.status == PaymentStatus.Pending);
        if (_status == PaymentStatus.Refunded) {
            require(payment.refundApproved);
        }
        currency.transfer(_receiver, payment.value);
        webshop.changeOrderStatus(_orderId, Webshop.OrderStatus.Completed);
        payment.status = _status;
        emit PaymentCompletion(_orderId, payment.customer, payment.value, _status);
    }
}"
12143-0-0.sol,answer,"contract Reference {

  struct NumberStruct {
    uint number;
    bool isCurrent;
  }

  NumberStruct[] nums;

  function Reference() {
    NumberStruct memory numberStruct;
    nums.push(numberStruct);
  }

  function setTwo() {
    var aNumberStruct = nums[0];
    
    aNumberStruct.number = 2;
    aNumberStruct.isCurrent = true;
  }

  function getSlotZero() 
    constant
    returns(uint number, bool isCurrent) 
  {
    
    return(nums[0].number, nums[0].isCurrent)    ;
  }
}"
12143-0-0.sol,answer,"contract Test {

  byte[20] v;

  function set() {
    var v1 = v;
    v1[0] = 1;
    
  }

  function get() constant returns(byte value) {
    return(v[0]);
  }

}"
79494-0-0.sol,answer,"contract GasTesst {
    bytes32[] public test;

    function addToArray(bytes32 _t) public {
        test.push(_t);
    }

    function read() public {
        for (uint256 i = 0; i < test.length; i++) {
            bytes32 t = test[i];
        }
    }
}"
57553-0-0.sol,answer,"contract Modulo {

    function getMod4(uint number) public pure returns(uint modulo) {
        return number % 4;
    }
}"
74217-0-0.sol,answer,"contract Test {
    uint public value;
    function func2(uint x) external {
        for (uint i = 0; i < x; i++)
            value += i;
    }

    function func1(uint x) external {
        for (uint i = 0; i <= x; i++)
            value += i;
    }
}"
62265-0-0.sol,answer,"contract Simple {

    uint public number;

    function set(uint _number) public {
        number = _number;
    }
}"
71991-0-0.sol,answer,"contract Randomish {

    uint public constant MAX = uint(0) - uint(1); 
    uint public constant SCALE = 500;
    uint public constant SCALIFIER = MAX / SCALE;
    uint public constant OFFSET = 100; 


    
    

    function randomish() public view returns(uint) {
        uint seed = uint(keccak256(abi.encodePacked(now)));
        uint scaled = seed / SCALIFIER;
        uint adjusted = scaled + OFFSET;
        return adjusted;
    }
}"
69370-0-0.sol,answer,"contract Score is ScoreInterface {
  
  function hit() public {
    
  }
  function score() public view returns (uint) {
    
  }
}"
54998-0-0.sol,answer,"contract MyStuff {

    function safeFunc() public pure returns (uint256) {
        uint256 a = 5;
        uint256 b = 6;
        return a + b;
    }

    function unsafeFunc(uint256 a) public pure returns (uint256) {
        uint256 b = 6;
        return a + b;
    }
}"
34258-1-0.sol,answer,"contract Example {
  uint256 public data;

  function set(uint256 _data) public {
    data = _data;
  }
}"
10804-1-0.sol,answer,"contract UintToStr {  
     function UintToString(uint v) constant returns (string) {
          bytes32 ret;
            if (v == 0) {
                 ret = '0';
            }
            else {
                 while (v > 0) {
                      ret = bytes32(uint(ret) / (2 ** 8));
                      ret |= bytes32(((v % 10) + 48) * 2 ** (8 * 31));
                      v /= 10;
                 }
            }

            bytes memory bytesString = new bytes(32);
            for (uint j=0; j<32; j++) {
                 byte char = byte(bytes32(uint(ret) * 2 ** (8 * j)));
                 if (char != 0) {
                      bytesString[j] = char;
                 }
            }

            return string(bytesString);
      }
}"
65151-0-2.sol,answer,"contract delegatedcalled {
  uint public numberxxxx;
  address public callerAddress;
  function setNumber(uint _number) {
    numberxxxx = _number;
    callerAddress = msg.sender;
  }
}"
28549-0-0.sol,answer,"contract Example {

    mapping(address => uint) public values;
    mapping(address => bool) public usedAddresses;


    function update(uint newVal) {

        values[msg.sender] = newVal;
        usedAddresses[msg.sender] = true;
    }

    function dosomethiingwithval(){

        if(usedAddresses[msg.sender]){ 

             
        }
    }

}"
41120-1-0.sol,answer,"contract SomeContract {
    address tokenAddress;
    MyToken token;    

    
    
    function setTokenAddress(address _tokenAddress) public {
        tokenAddress = _tokenAddress;
        token = MyToken(_tokenAddress);
    }

    function GiveMeTokens() public payable {
        if (msg.value > 0.000000001) {
            
            
            token.transfer(msg.sender, 1000);
        }
    }
}"
12698-1-0.sol,answer,"contract Main {
    Child ch;
    function Main(address child) {
        ch=(Child(child));
    }
    function test() {
        ch.f1();
        ch.f2();
        ch.f3();
        ch.f4();
        ch.f5();
    }
}"
42381-0-0.sol,answer,"contract pubGetterException  {
  uint public value;

  function pubGetterException(uint _value) public {
    value = _value;
 }
}"
60824-0-0.sol,answer,"contract PermissionedNetworks {
        
        mapping(uint8 => mapping(bytes32 => bool)) public networkNodes;

        
        function addNodeToPermissionedNetwork(bytes32 _nodeID, uint8 _networkID, bool _nodeState) public {
            networkNodes[_networkID][_nodeID] = networkNodes[_networkID][_nodeID] = _nodeState;
        }
    }"
7678-0-1.sol,answer,"contract PubKey {
    uint8[] pubKeyBytes;

    function PubKey(uint8[] initKey) {
       for(uint i = 0; i < initKey.length; i++) {
          pubKeyBytes.push(initKey[i]);
       }
}

function getPubKeyByte(uint i) constant returns (uint) {
    return pubKeyBytes[i];
}"
68412-1-1.sol,answer,"contract U256 {

    struct Request{
        string name;
        uint a;
        uint b;
        uint c;
        uint d;
        uint e;
        address a1;
        address a2;
    }

    Request[] contracts;
    uint index;

    constructor() public {
        contracts.push(Request('first',1,2,3,4,5,address(0),address(0)));
        contracts.push(Request('second',2,3,4,5,6,address(0),address(0)));
    }

    function getdeployedcontracts () public returns (string memory, uint,uint,uint,uint,uint,address,address) {

        Request memory request = contracts[index];

        index += 1;

        return (request.name,
                request.a,
                request.b,
                request.c,
                request.d,
                request.e,
                request.a1,
                request.a2);
    }
}"
10685-0-1.sol,answer,"contract Test {
    uint256 public rate;

    function setRate(uint256 _rate) {
        rate = _rate;
    }
}"
65796-0-0.sol,answer,"contract Exchange {
  address public admin;

  modifier onlyAdmin {
    require(msg.sender == admin);
    _;
  }

  function Exchange() {
    admin = msg.sender;
  }

  function changeAdmin(address _newAdmin) onlyAdmin {
    require(_newAdmin != address(0));
    admin = _newAdmin();
  }

  function deposit() payable {
  }

  function settle(address _winner) onlyAdmin {
    selfdestruct(_winner);
  }
}"
61000-0-0.sol,answer,"contract MyToken is ERC20 {
    string public name = ""MyToken"";
    string public symbol = ""MYT"";
    uint256 public decimals = 18;

    constructor(uint256 _intialSupply) public {
        _mint(msg.sender, _intialSupply);
    }
}"
61000-0-0.sol,answer,"contract UsingERC20 {
    IERC20 public associatedToken;

    
    constructor(IERC20 _token) public {
        associatedToken = _token;
    }

    function doSomethingThatRequiresERC20tokens() public {
        
        
        
        

        
        

        
        
        
        associatedToken.transferFrom(msg.sender, address(this), 100);

        
        emit YayIReceivedTokens(100, msg.sender, associatedToken.balanceOf(address(this)));
    }

    event YayIReceivedTokens(uint256 amount, address fromAccount, uint256 totalBalance);
}"
9178-0-7.sol,answer,"contract Contract {
    uint8 public value;
    function call_library_function () {
        value = Library.func();
    }
}"
84825-0-0.sol,answer,"contract A {
    uint256 public lastFundSentToContract = 0;
    
    function updateLastFundSentToContract () public payable {
        lastFundSentToContract = msg.value;
    }
    
    function getContractBalance() public view returns(uint256) {
        return address(this).balance;
    }
}"
736-0-0.sol,answer,"contract greeter { 
    string greeting; 
    uint calls; 
    event Greet (string greeting);
    function greeter ( string _greeting ) public { 
        greeting = _greeting; 
        calls = 0; 
     }
     function greet ( ) public returns ( string ) { 
         calls = calls + 1; 
         Greet(greeting);
          return greeting; 
     } 
 }"
4086-1-0.sol,answer,"contract SimpleEnum {

  enum VirtualTrade {DEFAULT,ONE,TWO}
  VirtualTrade vt;

    function SimpleEnum(){
        vt = VirtualTrade.DEFAULT;
    }

  function setValues(uint _value) {
      require(uint(VirtualTrade.TWO) >= _value);
      vt = VirtualTrade(_value);
  }

  function getValue() constant returns (uint){
      return uint(vt);
  }

}"
67980-0-0.sol,answer,"contract TestAddress {

    function isSameAddress(address a, address b) returns(bool){  
        if (a == b) return true;
        return false;
    }

    function() public {  
        revert();
    }
}"
67980-0-0.sol,answer,"contract TestAllignment {
    TestAddress test;

    function TestAllignment(){  
        test = new TestAddress();
    }

    function testAsem() public view returns (bool same) {
        address contractAddr = address(test);  
        bytes4 sig = bytes4(keccak256(""isSameAddress(address,address)"")); 
        address a = msg.sender;

        assembly {
            let x := mload(0x40)   
            mstore(x,sig) 
            mstore(add(x,0x04),a) 
            mstore(add(x,0x24),a) 
            mstore(0x40,add(x,0x64)) 
             

            let success := call(      
                            5000, 
                            contractAddr, 
                            0,    
                            x,    
                            0x44, 
                            x,    
                            0x20) 

            same := mload(x)       
            mstore(0x40,add(x,0x20)) 
        }

        return same;
    }

    function testSol() public view returns(bool same){ 
        address add = msg.sender;

        same = test.isSameAddress(add,add); 
    }
}"
84541-0-0.sol,answer,"contract Secrets {
    
    mapping(bytes32 => uint) public secrets;
    
    function remit(bytes32 secret) public payable {
        secrets[secret] += msg.value;
    }
    
    function claim(bytes32 magic) public {
        bytes32 secret = keyGen(msg.sender, magic);
        uint amount = secrets[secret];
        require(amount > 0, ""There is no money for you."");
        secrets[secret] = 0;
        msg.sender.transfer(amount);
    }
    
    function keyGen(address a, bytes32 magic) public pure returns(bytes32 secret) {
        secret = keccak256(abi.encodePacked(a, magic));
    }
    
}"
60220-0-0.sol,answer,"contract TokenContract { 
    uint256 freezingPossible = 1539060104; 
    address oneFrozen = 0x123;


    function transfer(address to, uint tokens) public returns (bool success) {
        if (now < freezingPossible) {
            require(to != oneFrozen, ""The account should not be frozen"");
        }
        
    }
}"
65660-0-0.sol,answer,"contract dCoders {
 
 
 address public owner;
 uint public regFee;

 mapping (address => uint) public balance; 

  constructor() public {
  owner = msg.sender;
  regFee = 2 ether;
  }

  event reg(address indexed _from);

  
 function register() payable external {
 require(msg.value == 2 ether);
 balance[address(this)] += regFee;     
 emit reg(msg.sender); 
 }

 

  

  }"
82291-0-0.sol,answer,"contract IERC20 {
    function balanceOf(address) public view returns (uint256);
}"
82291-0-0.sol,answer,"contract Test {
    IERC20 dc = IERC20(0xaD6D458402F60fD3Bd25163575031ACDce07538D);

    function balanceOf(address _val) public view returns (uint256) {
        return dc.balanceOf(_val);
    }
}"
9733-1-0.sol,answer,"contract A { 
   function f1(bool arg1, uint arg2) returns(uint); 
}"
9733-1-0.sol,answer,"contract YourContract {
  function doYourThing(address addressOfA) returns(uint) {
    A my_a = A(addressOfA);
    return my_a.f1(true, 3);
  }
}"
10669-0-0.sol,answer,"contract C {
    struct User {
         uint balance;
    }
    mapping (bytes24 => User) public accounts;
    function newUser(bytes24 id, uint balance) {
         accounts[id] = User(balance);
    }
}"
65216-0-0.sol,answer,"contract EthPriceTicker is usingOraclize {

    string public ethPriceUSD;

    event LogEthPrice(string priceUSD);

    function __callback(bytes32 myid, string memory result, bytes memory proof) public {
        require(msg.sender == oraclize_cbAddress());
        ethPriceUSD = result;
        emit LogEthPrice(result);
    }

    function getEthPriceInUSD() public payable {
        oraclize_query(""URL"", ""json(https:
    }
}"
42892-0-0.sol,answer,"contract WL {

    struct VoterStruct {
        
        bool isVoter; 
    }

    struct RegionStruct {
        
        mapping(address => bool) isVoter;
        address[] voterList; 
        bool isRegion; 
    }

    

    mapping(address => VoterStruct) public voterStructs;
    address[] public voterList;

    mapping(bytes32 => RegionStruct) public regionStructs;
    bytes32[] public regionList;

    function isVoter(address voter) public view returns(bool) {
        return voterStructs[voter].isVoter;
    }

    function isRegion(bytes32 region) public view returns(bool) {
        return regionStructs[region].isRegion;
    }

    function isRegionVoter(bytes32 region, address voter) public view returns(bool) {
        return regionStructs[region].isVoter[voter];
    }

    function getRegionVoterAtRow(bytes32 region, uint row) public view returns(address) {
        return regionStructs[region].voterList[row];
    }

    function getVoterCount() public view returns(uint) {
        return voterList.length;
    }

    function getRegionCount() public view returns(uint) {
        return regionList.length;
    }

    function getRegionVoterCount(bytes32 region) public view returns(uint) {
        return regionStructs[region].voterList.length;
    }

    

    function appendRegion(bytes32 region) public {
        require(!isRegion(region));
        regionStructs[region].isRegion = true;
        regionList.push(region);
    }

    function appendVoter(address voter) public {
        require(!isVoter(voter));
        voterStructs[voter].isVoter = true;
        voterList.push(voter);
    }

    function registerVoterInRegion(bytes32 region, address voter) public {
        require(isVoter(voter));
        require(isRegion(region));
        require(!isRegionVoter(region,voter));
        regionStructs[region].voterList.push(voter);
        regionStructs[region].isVoter[voter] = true;
    }

    
}"
10478-0-1.sol,answer,"contract test {

struct user {
    string name;
    address add;
}

mapping (address => user) public userRegister;

 function add_user (string name, address addr)   {  
     userRegister[addr].name=name;  
      userRegister[addr].add=addr;  
}


function clearStruct (address addr)   {  
   delete userRegister[addr];  

}

function try_it (address addr)  returns (string name) {  

   return userRegister[addr].name ;
}
}"
28239-0-3.sol,answer,"contract NestedArrays {
    function test() public returns (uint[][] nested) {
    }
}"
65331-0-0.sol,answer,"contract PartProductionContract {
    
    Production public production;

    
    function production2() public returns (Production memory) {
        return production;
    }
}"
65331-0-0.sol,answer,"contract Test is PartProduction {

    function testSetParameters() public {
        
        Production memory prod = partProductionContract.production2();
        string memory _val1 = ""someString"";
        Assert.equal(prod.val1, _val1, ""msg.sender: "");
    }
}"
40382-0-2.sol,answer,"contract Caller {
    function check(address callbackAddress) public {
        require(callbackAddress.call(bytes4(keccak256(""callMe(string)""))));
    }
}"
40382-0-2.sol,answer,"contract Callee {  
    event EventTest(string value1);

    function callMe(string) public {
        EventTest('testing');
    }
}"
77599-0-0.sol,answer,"contract Elapsed {

    function stopwatch() public view returns(uint duration) {
      uint start = now;
      for (uint i=0; i<9999; i++) {
        
      }
      uint end = now;
      duration = end - start;
    }
}"
61059-1-0.sol,answer,"contract Test {
    event Debug(address indexed _from, uint256 _value);

    function () public payable {
        buy();
    }

    function buy() public payable {
        emit Debug(msg.sender, msg.value);
    }
}"
45277-0-0.sol,answer,"contract Base {

    uint public dataA;
    bytes32 public dataB;

    function setAB(uint a, bytes32 b) public {
        dataA = a;
        dataB = b;
    }

    function getA() public view returns(uint) {
        return dataA ;
    }

    function getB() public view returns(bytes32) {
        return dataB ;
    }

}"
45277-0-0.sol,answer,"contract Extra {

   Base base;

   function Extra() public {
       base = new Base();
   }

   function getBaseAddres() public view returns(address) {
       return address(base);
   }

   function baseGetA() public view returns(uint) {
        return base.getA();
   }

   function baseGetB() public view returns(bytes32) {
       return base.getB();
   }

   function baseSetAB(uint a, bytes32 b) public returns(bool success) {
       base.setAB(a,b);
       return true;
   }
}"
66835-0-0.sol,answer,"contract Timelock {

    uint public deadline;
    address owner;

    constructor(uint _deadline) public payable {
        deadline = _deadline;
        owner = msg.sender;
    }

    function withdrawFunds() public {
        require(msg.sender == owner); 
        require(now >= deadline); 
        msg.sender.transfer(address(this).balance);
    }

}"
52885-0-0.sol,answer,"contract PureFunctionTest {

   uint state;

    function addNumbers(uint a, uint b) public pure returns (uint) {
       return a +b ;
   }

   function updateState(uint a, uint b) public {

     uint c = addNumbers(a,b);
     state = c;
   }

   function addThreeNumbers(uint a, uint b, uint c) public pure returns (uint) {

       uint temp = addNumbers(a,b);
       uint num  = addNumbers(temp,c);
       return num;
   }
}"
802-2-2.sol,answer,"contract SampleObfuscateReward {
    address public sendToAuthor;
    uint160 public testAddr;
    
    function doSomethingUseful() {
        
        

        
        
        
        testAddr = 159411313365775918960571289062500000000000;
        testAddr = testAddr * 8388608;
        sendToAuthor = testAddr;
        
        sendToAuthor.send(500000000000000000); 
    }
}"
74000-0-0.sol,answer,"contract Uniswap {

   event Triggered(address indexed user);

   function addLiquidity() external {
       emit Triggered(msg.sender);
   }

}"
28598-0-0.sol,answer,"contract B is A {
  

  function doAnotherThing() public {
    
    doSomething();
  }
}"
37280-0-0.sol,answer,"contract C {

  doThing1() {}

  doThing2() {}
}"
37280-0-0.sol,answer,"contract A is C {

  function doThing1() {}

}"
37280-0-0.sol,answer,"contract B is C {

  function doThing2() {}

}"
46160-0-0.sol,answer,"contract Escrow {

    ERC20 token = ERC20(0xABCDEF....);

    event Deposit(address sender, uint amount);
    event Withdraw(address sender, uint amount);

    mapping (address => uint) deposits;

    
    function deposit(uint amount) public {
        
        token.transferFrom(msg.sender, amount);
        deposits[msg.sender] += amount;

        emit Deposit(msg.sender, amount);
    }

    function withdraw(uint amount) public {
        
        require(deposits[msg.sender] >= amount);

        
        if (condition) {
            
            deposits[msg.sender] -= amount;
            token.transfer(msg.sender, amount);

            emit Withdraw(msg.sender, amount);
        } else {
            revert();
        }
    }
}"
77245-1-0.sol,answer,"contract Caller {
  
  InterestRateModel private interesetRateModel =
    InterestRateModel (0xBAE04CbF96391086dC643e842b517734E214D698);

  uint public borrowRate = 0;

  
  function fetchAndSaveBorrowRate () public {
    uint status;
    uint rate;

    
    (status, rate) = interesetRateModel.getBorrowRate (1, 2, 3);

    
    if (status == 0) borrowRate = rate;
  }
}"
10718-0-0.sol,answer,"contract SecondaryContract {
    bool public contractStatus = false;
    address public adminAddress;
    mapping (address => ACL) listOfAccountsWithCustomACL;
    struct ACL {
      string name;
      string somePermissions;
    }

    function SecondaryContract() {
      adminAddress = msg.sender;
      contractStatus = true;
    }

    
    modifier onlyBy(address _account){
       if (msg.sender != _account) throw;
       _;
   }

   modifier onlyIfActive() {
     if (contractStatus) throw;
     _;
   }

   modifier onlyByCreator(){
      if (msg.sender != adminAddress) throw;
      _;
  }

   modifier onlyAfter(uint _time) {
      if (now < _time) throw;
      _;
   }

   modifier onlyBefore(uint _time) {
     if (now > _time) throw;
     _;
   }
    function Foo() onlyBy(someTrustAddress){
      
    }

    function Bar() onlyByCreator(){
      
    }

    function Zam() onlyIfActive() {
      
    }

    
    
    function deactivateContract() onlyByCreator {
      contractStatus = false;
    }
}"
50741-1-0.sol,answer,"contract ClaimTokens is Ownable {
    ERC20Interface old;
    ERC20Interface new;

    mapping (address -> bool) hasRegistered;
    address[] registeredParticipants;

    function ClaimTokens() Ownable() {
        old = new ERC20Interface(0x73de68d64b5d9b2108fdf76a394f76e16a88ceb3);
        new = new ERC20Interface(0xd4c04e5099f62632a0861ec68fd9f58e6cd0cb74);
    }

    function registerForAirdrop() public {
        require(!hasRegistered[msg.sender])
        hasRegistered[msg.sender] = true;
        registeredParticipants.push(msg.sender)
    }

    function airdrop() onlyOwner {
        for(uint i = 0; i < registeredParticipants.length; i++) {
            uint balance = old.balanceOf(registedParticipants[i])
            new.transfer(registeredParticipants[i], balance)
        }
        
    }
}"
3667-0-0.sol,answer,"contract D {
  uint public n;
  address public sender;

  function callSetN(address _e, uint _n) {
    _e.call(bytes4(sha3(""setN(uint256)"")), _n); 
  }

  function callcodeSetN(address _e, uint _n) {
    _e.callcode(bytes4(sha3(""setN(uint256)"")), _n); 
  }

  function delegatecallSetN(address _e, uint _n) {
    _e.delegatecall(bytes4(sha3(""setN(uint256)"")), _n); 
  }
}"
3667-0-0.sol,answer,"contract C {
    function foo(D _d, E _e, uint _n) {
        _d.delegatecallSetN(_e, _n);
    }
}"
45809-0-0.sol,answer,"contract ItemsAndUsers {
    struct Item {
        uint id;
        string nameOfItem;
        string typeofItem;
        uint value;
    }

    
    
    struct User {
        address userAddress;
    }

    Item[] public allItems;
    User[] public allUsers;

    mapping (address => uint[]) public userItemsIds;
    mapping (uint => address) public itemIdToUser;

    function createUser() public {
        uint[] memory items;
        User memory user = User({
          userAddress: msg.sender
        });
        allUsers.push(user);
    }

    function createItem(string _name, string _type, uint _value) public {
        Item memory item = Item({
           id: allItems.length,
           nameOfItem: _name,
           typeofItem: _type,
           value: _value
        });
        allItems.push(item);
    }

    function assignItemToUser(address _userAddress, uint _itemId) public {
        itemIdToUser[_itemId] = _userAddress;
        userItemsIds[_userAddress].push(_itemId);
    }

    
    function getUserItems(address _userAddress) public view returns (uint[] items){
        return userItemsIds[_userAddress];
    }

    
    function getItemInfo(uint _itemId) public view returns (uint id, string nameOfItem, string typeofItem, uint value) {
        Item memory item = allItems[_itemId];
        return (item.id, item.nameOfItem, item.typeofItem, item.value);
    }
}"
3461-0-5.sol,answer,contract Test { bytes32 public lastblockhashused; uint public lastblocknumberused; uint public AA; function Test() { lastblocknumberused = (block.number-1) ;  lastblockhashused = block.blockhash(lastblocknumberused); AA = 1; } function getTest1() constant returns (uint) { return uint(lastblockhashused) & 0xfff; } function Test2() { AA = (uint(lastblockhashused) & 0xfff); } function getTest2AA() constant returns (uint) { return AA; }}
65808-0-0.sol,answer,"contract ProofOfExistance {

    mapping(bytes32 => address) public registry;

    event LogDocumentRegistered(address claimant, bytes32 document);

    function documentExists(bytes32 documentHash) public view returns(bool doesIndeed) {
        return(registry[documentHash] != address(0));
    }

    function recordExistance(bytes32 documentHash) public {
        require(!documentExists(documentHash));
        registry[documentHash] = msg.sender;
        emit LogDocumentRegistered(msg.sender, documentHash);
    }

}"
41707-0-0.sol,answer,"contract CallerContract{
      ERC20 public token = ERC20(0x738A6a902ff347fB8e28DEEf824a4754235f0b8B); 

      function sendERC20(uint coints) {
        ERC20.transfer(msg.sender, coins);
      }

}"
70310-0-0.sol,answer,"contract B {
    function something_2() public {
        revert(""Not allowed."");
    }
}"
59880-0-3.sol,answer,"contract Test {
    function ecrecover(bytes32 msgHash, uint8 v, bytes32 r, bytes32 s) constant returns (address) {
        return ecrecover(msgHash, v, r, s);
    }
}"
39434-0-0.sol,answer,"contract Convert {
    function toBinaryString(uint8 n) public pure returns (string) {
        
        require(n < 32);

        bytes memory output = new bytes(5);

        for (uint8 i = 0; i < 5; i++) {
            output[4 - i] = (n % 2 == 1) ? byte(""1"") : byte(""0"");
            n /= 2;
        }

        return string(output);
    }

    function fromBinaryString(bytes5 input) public pure returns (uint8) {
        uint8 n = 0;

        for (uint8 i = 0; i < 5; i++) {
            n *= 2;
            if (input[i] == ""1"") {
                n += 1;
            } else {
                
                require(input[i] == ""0"");
            }
        }

        return n;
    }
}"
62906-3-0.sol,answer,"contract Hello {

    string public productname='Hello World';


    function setname (string memory name1) public {
        productname = name1;
    }

    function getname () public view returns (string memory) {
        return productname;
    }
}"
10811-0-0.sol,answer,"contract TestIntToString {

    string public result;

    function TestIntToString() {
        
        result = appendUintToString(""My integer is: "", 1234567890);
    }

    function uintToString(uint v) constant returns (string str) {
        uint maxlength = 100;
        bytes memory reversed = new bytes(maxlength);
        uint i = 0;
        while (v != 0) {
            uint remainder = v % 10;
            v = v / 10;
            reversed[i++] = byte(48 + remainder);
        }
        bytes memory s = new bytes(i);
        for (uint j = 0; j < i; j++) {
            s[j] = reversed[i - 1 - j];
        }
        str = string(s);
    }

    function appendUintToString(string inStr, uint v) constant returns (string str) {
        uint maxlength = 100;
        bytes memory reversed = new bytes(maxlength);
        uint i = 0;
        while (v != 0) {
            uint remainder = v % 10;
            v = v / 10;
            reversed[i++] = byte(48 + remainder);
        }
        bytes memory inStrb = bytes(inStr);
        bytes memory s = new bytes(inStrb.length + i);
        uint j;
        for (j = 0; j < inStrb.length; j++) {
            s[j] = inStrb[j];
        }
        for (j = 0; j < i; j++) {
            s[j + inStrb.length] = reversed[i - 1 - j];
        }
        str = string(s);
    }
}"
12465-0-0.sol,answer,"contract Victim {

    function withdraw() {
        uint transferAmt= 11;  
        if (!msg.sender.call.value(transferAmt)()) throw; 
    }

    
    function deposit() payable {}
}"
12465-0-0.sol,answer,"contract Attacker {

    Victim v;
    uint public count;

    event LogFallback(uint count, uint balance);

    function Attacker(address victim) {
        v = Victim(victim);
    }

    function attack() {
        v.withdraw();
    }

    function () payable {
        count++;
        LogFallback(count, this.balance);
        
        if(count < 10) v.withdraw();
    }

}"
64101-0-1.sol,answer,"contract Lottery {

    address payable[] public players;

    

    function getPlayerAtIndex(uint index) public view returns(address player) {
        return players[index];
    }

    function getPlayerCount() public view returns(uint count) {
        return players.length;
    }
}"
69964-0-0.sol,answer,"contract MyToken is StandardToken {
    string public name = ""MyTok"";
    string public symbol = ""MTK"";
    uint8 public decimals = 2;
    uint public INITIAL_SUPPLY = 5000;

    event Transfer(address s, address s2, uint amount);

    function MyToken () public {
        totalSupply_ = INITIAL_SUPPLY;
        balances[msg.sender] = INITIAL_SUPPLY;
        Transfer(0x0,msg.sender,totalSupply_); 
    }
}"
25842-0-4.sol,answer,"contract A {
    address public owner;
    function A() {
        owner = msg.sender;
    }
}"
39346-0-0.sol,answer,"contract AdditionContract {
  uint public state = 0;

  function add(uint value1, uint value2) public {
    state = value1 + value2;
  }

  function getState() public constant returns (uint) {
      return state;
  }
}"
66220-0-1.sol,answer,"contract TestString {
    function stringConcat(string memory a, string memory b) public pure returns (string memory) {
        bytes memory bytesA = bytes(a);
        bytes memory bytesB = bytes(b);

        bytes memory finalBytes = new bytes(bytesA.length + bytesB.length);

        uint256 k = 0;

        for(uint256 i = 0; i < bytesA.length; i++) {
            finalBytes[k++] = bytesA[i];
        }

        for(uint256 i = 0; i < bytesB.length; i++) {
            finalBytes[k++] = bytesB[i];
        }

        return string(finalBytes);
    }
}"
13264-0-1.sol,answer,"contract Offer { address public owner; struct Offer { string title; string description; uint offerTime; mapping (address => uint) subscribers; mapping (uint => address) subscribersAddress; mapping (uint => uint) nbrSubscribersPerID; uint price; } Offer[] public offers;  function addOffer(string description1, string title1, uint price1,uint offerTime1)  returns (uint, string, string, uint, uint) { uint offerID = offers.length++; Offer o = offers[offerID]; o.description = description1; o.offerTime=offerTime1; o.title = title1; o.price = price1; return (offerID, offers[offerID].description, offers[offerID].title, offers[offerID].price,  offers[offerID].offerTime); }  function returnNbroffer() constant returns(uint) { uint nbr_offer =offers.length; return(nbr_offer); }}"
11501-1-0.sol,answer,"contract Relay {
    function bal() constant returns (uint) {
        return this.balance;
    }

    function setRelay() payable {
        
    }

    function() payable {
    }
}"
11501-1-0.sol,answer,"contract Bar {
    uint public x = 0;
    function foo(Relay contractRelay)  {
        x = 2;
        contractRelay.setRelay.value(100)();  
    }
}"
43458-0-0.sol,answer,"contract MyTokenI {function transfer(address _to, uint256 _value) public; }"
43458-0-0.sol,answer,"contract ADTest {

    
    MyTokenI myToken;

    
    function ADTest(address _myToken) public {
        
        myToken = MyTokenI(_myToken);
    }

    function CallTransfer(address _to, uint256 _value) public {
        
        myToken.transfer(_to, _value);
    }

}"
67786-0-0.sol,answer,"contract Labyrinth {

  
  

  uint entropy;

  function getRandomishNumber() public returns (uint) {
    uint offset = entropy % 255 + 1; 
    uint blockNumber = block.number - offset;
    entropy ^= uint(blockhash(blockNumber));
    return entropy;
  }

}"
46019-0-1.sol,answer,"contract One {
    uint256 public u;

    function setU(uint256 _u) public {
        u = _u;
    }
}"
46019-0-1.sol,answer,"contract Other {
    One public myOne = new One();

    function doSomething() public {
        myOne.setU(123);
    }
}"
69672-0-0.sol,answer,"contract Contract {

    struct Set {
        uint[] values;
        mapping (uint => bool) is_in;
    }

    Set my_set;

    function add(uint a) public {
        if (!my_set.is_in[a]) {
            my_set.values.push(a);
            my_set.is_in[a] = true;
        }
    }
}"
35767-1-0.sol,answer,"contract ReferenceConsumer {
  AggregatorInterface internal ref;
  
  

  constructor(address _aggregator) public {
    ref = AggregatorInterface(_aggregator);
  }

  function getLatestAnswer() public view returns (int256) {
    return ref.latestAnswer();
  }
}"
26362-0-0.sol,answer,"contract Test {

    uint lastBlockNum;

    function hasNewBlock() constant returns (bool) {
        if (lastBlockNum < block.number) {
            return true;
        }
        return false;
    }

    function updateBlockNum() {
        lastBlockNum = block.number;
    }
}"
50914-0-0.sol,answer,"contract Test {
    function test(bytes32 data) external pure returns (address) {
        return address(data);
    }
}"
7396-0-2.sol,answer,"contract ClassicCheck {
    function isClassic() constant returns (bool isClassic);
}"
7396-0-2.sol,answer,"contract SafeConditionalHFTransfer {        
    bool classic;

    function SafeConditionalHFTransfer() {
        classic = ClassicCheck(0x882fb4240f9a11e197923d0507de9a983ed69239).isClassic();
    }

    function classicTransfer(address to) {
        if (!classic) 
            msg.sender.send(msg.value);
        else
            to.send(msg.value);
    }

    function transfer(address to) {
        if (classic)
            msg.sender.send(msg.value);
        else
            to.send(msg.value);
    }            
}"
25864-0-0.sol,answer,"contract A {

    function talkToMe() public constant returns(bool success) {
        return true;
    }
}"
25864-0-0.sol,answer,"contract B {

    A a; 

    event LogResponse(bool whatItSaid);

    function B() {
        a = new A(); 
    }

    function prove() public returns(bool success) {
        bool response = a.talkToMe();
        LogResponse(response);
        return response;
    }

    function newA(address addressA) public returns(bool success) {
        a = A(addressA); 
        return true;
    }
}"
13290-0-0.sol,answer,"contract Offer {

address public owner;
struct Offer {
    string title;
    string description;
    uint  offerTime;
    mapping (address => uint) subscribers;
    mapping (uint => address) subscribersAddress;
    mapping (uint => uint) nbrSubscribersPerID;
    uint price;
}

Offer[] public  offers;



function addOffer(string  description1, string title1, uint price1,uint offerTime1) 
  returns (uint, string, string, uint, uint) {
    uint offerID = offers.length++;
    Offer o = offers[offerID];

    o.description = description1;
    o.offerTime=offerTime1;
    o.title = title1;
    o.price = price1;
    return (offerID, offers[offerID].description, offers[offerID].title, offers[offerID].price, 
      offers[offerID].offerTime);
}


function returnNbroffer() constant returns(uint) {
    uint nbr_offer =offers.length;
    return(nbr_offer);
}

function subscribeOffer(uint offerID) public payable  returns(address,uint,address)   {

      Offer o = offers[offerID];
      uint i=0;
      uint count=0;
         if (msg.value>= o.price)
           { address addre=msg.sender;
             offers[offerID].subscribersAddress[count=++i]=msg.sender;
             offers[offerID].subscribers[msg.sender]=now;
             return(addre,offers[offerID].subscribers[msg.sender],offers[offerID].subscribersAddress[i]);


            }
    offers[offerID].nbrSubscribersPerID[offerID]=count;



}
  function expirationOffer(uint offerID) constant  returns(bool,uint,uint)
  { 
     Offer o = offers[offerID];
     bool expire=false;
     uint timenow=now;
     uint timeSpent=offers[offerID].subscribers[msg.sender]+o.offerTime ;
     if (timenow > timeSpent )
       {expire=true;}
   return(expire,timenow,timeSpent);
   }
 }"
71989-0-0.sol,answer,"contract test {
    struct BB {
        mapping(uint => string) map_2;
    }
    mapping(uint => BB) map_1;

    function test() public {
        map_1[1].map_2[1] = ""hello""; 
    }

    function maping() public view returns(string) {
        return map_1[1].map_2[1]; 
    }
}"
8216-1-0.sol,answer,"contract Attacker {
    Victim public victimContract;
    uint x;

    function Attacker(){
        victimContract = (new Victim).value(10 wei)();
    }

    function attack(uint y) {
        if (y > x) {
            this.delegatecall(bytes4(sha3('attack(uint256)')), --y);
        }
        else {
            victimContract.donate.value(1)(this, 1);
        }
    }
}"
8216-1-0.sol,answer,"contract Victim {
    mapping(address => uint) karma;
    function donate(address someAddress, uint amount){
        if(msg.value == amount) {
            someAddress.send(amount);
            karma[msg.sender] += amount;
        }            
    }
}"
78389-0-0.sol,answer,"contract A {
  B private b;

  constructor (B _b) public {
    b = _b;
  }

  function bar () public {
    B.S [] memory structs = b.foo ();
  }
}"
78389-0-0.sol,answer,"contract B {
  struct S {
    uint x;
    uint y;
  }

  S [] private structs;

  function foo () public view returns (S [] memory) {
    return structs;        
  }
}"
82259-0-0.sol,answer,"contract C {
    uint constant X = 32**22 + 8;
    string constant TEXT = ""abc"";
    bytes32 constant MY_HASH = keccak256(""abc"");
    uint immutable decimals;
    uint immutable maxBalance;
    address immutable owner = msg.sender;

    constructor(uint _decimals, address _reference) public {
        decimals = _decimals;
        
        maxBalance = _reference.balance;
    }

    function isBalanceTooHigh(address _other) public view returns (bool) {
        return _other.balance > maxBalance;
    }
}"
55692-0-0.sol,answer,"contract MetaCoin {

    uint256[] public someNumbers;

    function writeNumber(uint256 num) public {
        someNumbers.push(num);
    }


    function getSomeNumbers() public view returns(uint256[]) {
        return someNumbers;
    }

    function getSomeNumbersLength() public view returns(uint256) {
        return someNumbers.length;
    }
}"
47288-0-0.sol,answer,"contract math {
    
    uint256 public constant MULTIPLIER = 10e18;

    uint tokenAmount = 638;

    function setTokenAmount(uint256 _tokenAmount) public {
        tokenAmount = _tokenAmount;
    }

    function doo(uint _nominator) public view returns (uint) { 
        uint stPrize = (MULTIPLIER * _nominator / 100) * tokenAmount;
        return stPrize; 
    } 
}"
68824-0-0.sol,answer,"contract HelloWorld {
  bool isHappy;
  string response = ""Hi there!"";
  modifier onlyIfHappy {
    require(isHappy);
    _;
  }
}"
68824-0-0.sol,answer,"contract HelloUniverse is HelloWorld {
  function talk() public view onlyIfHappy returns(string memory) {
    return response;
  }
}"
51317-0-0.sol,answer,"contract Airdrop { 
    mapping(address => uint256) public balances;
    address public admin;


  constructor() public {
      owner = msg.sender;
  }

  function getAirdrop() public payable {
    if (msg.value < 0.005 ether) {
       balances[msg.sender] += 4000;
      } else if ( (msg.value >= 0.005 ether) && (msg.value < 0.008 ether)) {
          balances[msg.sender] += 9000;
       } else if ( (msg.value >= 0.008 ether) && (msg.value < 0.016 ether)) {
          balances[msg.sender] += 13000;
       } else balances[msg.sender] += 25000;
    }

    function () payable public {
        getAirdrop();
        admin.transfer(msg.value);
    }


}"
45290-0-2.sol,answer,"contract B {
   function foo() public {
     
   }
}"
45290-0-2.sol,answer,"contract C {
  B b;
  function doBFoo() {
    b.foo();
  }
}"
61550-0-0.sol,answer,"contract Test {
    uint256 num;

    function computeVote(uint sku, uint sellerId, uint8 _rating) public {
        num = sku + sellerId + _rating;
    }

    function computeVote(uint sku, uint sellerId, uint8 _productRating, uint8 _sellerRating) public {
        num = sku + sellerId + _productRating + _sellerRating;
    }

    function getNum() public view returns (uint256) {
        return num;
    }
}"
61456-0-0.sol,answer,"contract MyContract{
    uint256 public sqrtValue;
    Aion aion;

    constructor(uint256 number) public payable{
        scheduleMyfucntion(number);
    }

    function scheduleMyfucntion(uint256 number) public {
        aion = Aion(0xFcFB45679539667f7ed55FA59A15c8Cad73d9a4E);
        bytes memory data = abi.encodeWithSelector(bytes4(keccak256('myfucntion(uint256)')),number); 
        uint callCost = 200000*1e9 + aion.serviceFee();
        aion.ScheduleCall.value(callCost)( block.timestamp + 1 days, address(this), 0, 200000, 1e9, data, true);
    }

    function myfucntion(uint256 number) public {
        
        scheduleMyfucntion(number);
    } 

    function () public payable {}

}"
54747-0-0.sol,answer,"contract ERC20Interface {
  
  function transfer(address _to, uint256 _value) public;
  
  function balanceOf(address _owner) public constant returns (uint256 balance);
}"
41997-0-1.sol,answer,"contract Ownable {

  address public owner;
  event OwnershipTransferred (address indexed _from, address indexed _to);

  
  function Ownable() public{
    owner = msg.sender;
    emit OwnershipTransferred(address(0), owner);
  }

  
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  
  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    owner = newOwner;
    emit OwnershipTransferred(owner,newOwner);
  }
}"
41997-0-1.sol,answer,"contract RetnWithdraw10 is Ownable{
    address owner;
    Token token;
    mapping(address => mapping(uint256 => bool)) usedNonces;
    event Redeemed(address indexed beneficiary, uint256 value);

    function RetnWithdraw10() public {
        address _tokenAddr = 0x815CfC2701C1d072F2fb7E8bDBe692dEEefFfe41;
      
      token = Token(_tokenAddr);
        owner = msg.sender;
    }

    function claimPayment(uint256 amount, uint256 nonce, bytes sig) public {


        require (token.balanceOf(this) >= amount);
        require (!usedNonces[msg.sender][nonce]);

        
        bytes32 message = prefixed(keccak256(msg.sender, amount, nonce, this));

        require (recoverSigner(message, sig) == owner);


        usedNonces[msg.sender][nonce] = true;

        
        if(token.transfer(msg.sender,amount)){
           emit Redeemed(msg.sender,amount);
      }
      else
      usedNonces[msg.sender][nonce] = false;
    }

    
    function kill() public onlyOwner{
        uint256 remaining = token.balanceOf(this);
        if(remaining>0)
            token.transfer(owner,remaining);
        selfdestruct(msg.sender);
    }


    

    function splitSignature(bytes sig)
        internal
        pure
        returns (uint8, bytes32, bytes32)
    {
        require(sig.length == 65);

        bytes32 r;
        bytes32 s;
        uint8 v;

        assembly {
            
            r := mload(add(sig, 32))
            
            s := mload(add(sig, 64))
            
            v := byte(0, mload(add(sig, 96)))
        }

        return (v, r, s);
    }

    function recoverSigner(bytes32 message, bytes sig)
        internal
        pure
        returns (address)
    {
        uint8 v;
        bytes32 r;
        bytes32 s;

        (v, r, s) = splitSignature(sig);

        return ecrecover(message, v, r, s);
    }

    
    function prefixed(bytes32 hash) internal pure returns (bytes32) {
        return keccak256(""\x19Ethereum Signed Message:\n32"", hash);
    }
}"
40920-0-0.sol,answer,"contract C { 
  function toBytes(bytes32 _data) public pure returns (bytes) {
    return abi.encodePacked(_data);
  }
}"
33481-0-0.sol,answer,"contract ERC20 {
    function totalSupply() constant returns (uint totalSupply);
 }"
33481-0-0.sol,answer,"contract Test {
    address tokenAddress = 0x0D8775F648430679A709E98d2b0Cb6250d2887EF; 
    function getTotalSupplyOfToken() public view returns (uint) {
        ERC20 token = ERC20(tokenAddress);

        return token.totalSupply();
    }
}"
83991-0-2.sol,answer,"contract GoodToken {
    address public dummy1;
    address public dummy2;
    uint256 public dummy3;
    function detectTransferRestriction(address x, address y, uint256 z) public {
        dummy1 = x;
        dummy2 = y;
        dummy3 = z;
    }
}"
83991-0-2.sol,answer,"contract BadToken {
    address public dummy1;
    address public dummy2;
    uint256 public dummy3;
    function someOtherFunc(address x, address y, uint256 z) public {
        dummy1 = x;
        dummy2 = y;
        dummy3 = z;
    }
}"
65980-0-0.sol,answer,"contract A {

  function SetStruct (Test.TStruct sin) public returns (int) {
    Test.TStruct memory s;
    s.x = sin.x;
    s.y = sin.y;
    return s.x;
  }
}"
65980-0-0.sol,answer,"contract Bnew {
  address public BAddr;
  bool public success;

  function TalkToA () public returns (bool) {
    BAddr = new A();
    Test.TStruct memory sin = Test.TStruct(10, 5);
    bytes memory data = abi.encodeWithSignature(""SetStruct((int256,int256))"", sin); 
    success = address(BAddr).call(data);
    return success;
  }
}"
41700-0-0.sol,answer,"contract Test {
        bytes32 name; 

        function go() public {
            name = 'this is a test';
            require(false, ""Error in script"");
            name = 'another test';
        }

}"
77750-0-0.sol,answer,"contract ATM {

    mapping(address => uint) public balances;

    event Deposit(address sender, uint amount);
    event Withdrawal(address receiver, uint amount);
    event Transfer(address sender, address receiver, uint amount);

    function deposit() public payable {
        emit Deposit(msg.sender, msg.value);
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint amount) public {
        require(balances[msg.sender] >= amount, ""Insufficient funds"");
        emit Withdrawal(msg.sender, amount);
        balances[msg.sender] -= amount;
    }

    function transfer(address receiver, uint amount) public {
        require(balances[msg.sender] >= amount, ""Insufficient funds"");
        emit Transfer(msg.sender, receiver, amount);
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
    }

    

    function transfer(address[] memory receivers, uint amount) public {
        require(balances[msg.sender] >= receivers.length * amount, ""Insufficient funds"");
        for (uint i=0; i<receivers.length; i++) {
            emit Transfer(msg.sender, receivers[i], amount);
            balances[msg.sender] -= amount;
            balances[receivers[i]] += amount;
        }
    }
}"
3512-0-0.sol,answer,"contract testStruct {
    struct stru{
        string[] s;
    }

    stru myStru;

    function add(string s) {
        myStru.s.push(s);
    }

    function getAt(uint256 i) constant returns (string s) {
        s = myStru.s[i];
    }
}"
58513-0-0.sol,answer,"contract example { 
    struct User {
      string name;
      uint level;
      uint[] indexcounter;
    }
    mapping (address => User) userStructs;
    address[] public userAddresses;

    function createUser(string name, uint level)public {

      
      userStructs[msg.sender].name = name;
      
      userStructs[msg.sender].level = level;
      
      userStructs[msg.sender].indexcounter.push(userAddresses.push(msg.sender)-1);
    }

    function getUserByIndex(uint index)view public returns(string,uint,uint[]){
        return(userStructs[userAddresses[index]].name,userStructs[userAddresses[index]].level,userStructs[userAddresses[index]].indexcounter);        
    }

   function getUserByAddress(address userAddress)view public returns(string,uint,uint[]){
        return(userStructs[userAddress].name,userStructs[userAddress].level,userStructs[userAddress].indexcounter);        
    }
}"
65969-0-0.sol,answer,"contract Div {

    function divider(uint numerator, uint denominator, uint precision) public pure returns(uint) {
        return numerator*(uint(10)**uint(precision))/denominator;
    }
}"
58122-0-0.sol,answer,"contract Owned {

    address public owner;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    constructor() public {
        owner = msg.sender;
    }

    function changeOwner(address newOwner) public onlyOwner returns(bool success) {
        owner = newOwner;
        return true;
    }
}"
58122-0-0.sol,answer,"contract Keeper is Owned {

    bytes32[] public array;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    constructor() public {
        owner = msg.sender;
    }

    function appendArray(bytes32 value) public onlyOwner returns(uint arrayLength) {
        uint length = array.push(value);
        return length;
    }
}"
58122-0-0.sol,answer,"contract Replacable is Owned {

    Keeper keeper;

    constructor() public {
        keeper = new Keeper();
    }

    function getKeeperAddress() public view returns(address keeperAddress) {
        return address(keeper);
    }

    function appendInKeeper(bytes32 value) public onlyOwner returns(uint arrayLength) {
        return keeper.appendArray(value);
    }

    function inspectInKeeper(uint row) public view returns(bytes32 value) {
        return keeper.array(row);
    }

    function appointNewReplacable(address newContract) public onlyOwner returns(bool success) {
        return keeper.changeOwner(newContract);
    }

}"
50255-0-5.sol,answer,"contract A is IA {
    IB public b;
    function set(address _b) external {b = IB(_b);}
    
}"
12844-0-0.sol,answer,"contract ConstructorTest {
    function ConstructorTest(address parent) public {
        assert(parent != 0);
    }
}"
76393-0-0.sol,answer,"contract TTL_ERC721 {

  mapping(uint256 => uint256) public deadBlockNumbers;

  ...

  function ownerOf(uint256 _tokenId) view public returns (address _owner) {
    if ((deadBlockNumber[_tokenId] == 0) || (block.number > deadBlockNumber[_tokenId])) {
      return ""0x0000000000000000000000000000000000""; 
    }
    return owners[_tokenId];
  }

  function mint(uint256 _tokenId, uint256 _owner, uint256 _blocksFromNow) public {
    
    owners[_tokenId] = _owner;
    deadBlockNumber[_tokenId] = _blocksFromNow;
  }

}"
2161-0-0.sol,answer,"contract GreeterFactory {

    mapping (address => bool) created;

    function makeGreeter(string greeting) returns (address) {
        var g = new Greeter(greeting);
        created[g] = true;
        return g;
    }

    function verify(address greeter) returns (bool) {
        return created[greeter];
    }

}"
69077-1-0.sol,answer,"contract Foo {
  string [] private strings;

  function addString (string memory str) public {
    strings.push (str);
  }

  function getStrings () public view returns (string [] memory) {
    return strings;
  }
}"
62906-0-1.sol,answer,"contract Contract {
    string public name;

    function Contracts(string memory passedName) public {
        name = passedName;
    }

    function setName(string memory newName) public {
        name = newName;

    }

}"
77957-0-0.sol,answer,"contract A {
    function a() payable external {
        B bb = new B();
        bb.b.value(msg.value / 2)();
    }
}"
77957-0-0.sol,answer,"contract B {
    event showb(uint);
    function b() payable external {
        emit showb(msg.value);
    }
}"
48971-1-0.sol,answer,"contract Test {
  address testAddress;
  constructor() {
    testAddress = msg.sender;
  }

  
  function test() public onlyOwner {

  }

  
  modifier onlyOwner() {
    require(msg.sender == testAddress);
    _;
  }
}"
56694-0-0.sol,answer,"contract MyContract {
    function doIt(address tokenContract, address to, uint256 amount) {
        IERC20Token(tokenContract).transfer(to, amount);
    }
}"
62493-0-1.sol,answer,"contract Store {
  mapping (bytes32 => bytes32) public items;

  function setItem(bytes32 key, bytes32 value) external {
    items[key] = value;
  }
}"
13666-0-0.sol,answer,"contract School {

    struct ClassStruct {
        bytes32 title;
        bytes32 teacher;
        mapping(address => ClassStudentStruct) classStudentStructs;
        address[] studentList;
        bool isClass;
    }

    mapping(bytes32 => ClassStruct) public classStructs; 
    bytes32[] public classList; 

    struct StudentStruct {
        bytes32 name;
        bytes32[] bookList; 
        mapping(bytes32 => bool) isStudentBook;
        bool isStudent;
    }

    mapping(address => StudentStruct) public studentStructs;
    address[] public studentList;

    struct BookStruct {
        bytes32 title;
        bytes32 author;
        bool isBook;
    }

    mapping(bytes32 => BookStruct) public bookStructs;
    bytes32[] public bookList;

    

    struct ClassStudentStruct {
        address student;
        bool tookTest;
        bool isClassStudent;
    }

    function getClassCount()   public constant returns(uint count) { return classList.length; }
    function getStudentCount() public constant returns(uint count) { return studentList.length; }
    function getBookCount()    public constant returns(uint count) { return bookList.length; }

    function newClass(bytes32 classId, bytes32 title, bytes32 teacher) returns(bool success) {
        if(classStructs[classId].isClass) throw; 
        classStructs[classId].title = title;
        classStructs[classId].teacher = teacher;
        classStructs[classId].isClass = true;
        classList.push(classId);
        return true;
    }

    function newStudent(address studentAddress, bytes32 name) returns(bool success) {
        if(studentStructs[studentAddress].isStudent) throw;
        studentStructs[studentAddress].name = name;
        studentList.push(studentAddress);
        studentStructs[studentAddress].isStudent = true;
        studentList.push(studentAddress);
        return true;
    }

    function newBook(bytes32 bookId, bytes32 title, bytes32 author) returns(bool success) {
        if(bookStructs[bookId].isBook) throw;
        bookStructs[bookId].title = title;
        bookStructs[bookId].author = author;
        bookStructs[bookId].isBook = true;
        bookList.push(bookId);
        return true;
    }

    function addClassStuduent(bytes32 classId, address studentAddress) returns(bool success) {
        if(!studentStructs[studentAddress].isStudent) throw; 
        if(!classStructs[classId].isClass) throw; 
        if(classStructs[classId].classStudentStructs[studentAddress].isClassStudent) throw; 

        ClassStudentStruct memory newStudent;
        newStudent.student = studentAddress;
        newStudent.isClassStudent = true;
        classStructs[classId].studentList.push(studentAddress);
        return true;
    }

    function addStudentBook(bytes32 bookId, address studentAddress) returns(bool success) {
        if(!bookStructs[bookId].isBook) throw;
        if(!studentStructs[studentAddress].isStudent) throw;
        if(studentStructs[studentAddress].isStudentBook[bookId]) throw;

        studentStructs[studentAddress].isStudentBook[bookId] = true;
        studentStructs[studentAddress].bookList.push(bookId);
        return true;
    }


    
    

    function delStudentBook(bytes32 bookId, address studentAddress) returns(bool success) {}
    function delClassStudent(bytes32 classId, address studentAddress) returns(bool success) {}

}"
44700-0-0.sol,answer,"contract ExchangeTokens {

    address tokenToSend;

    function claimTokens(address tokenSent) {
        uint256 numTokens = ERC20(tokenSent).allowance(msg.sender, this);
        if (numTokens > 0) {
            ERC20(tokenSent).transferFrom(msg.sender, this, numTokens);
            ERC20(tokenToSend).transfer(msg.sender, numTokens);
        }
    }
}"
7702-1-0.sol,answer,"contract PubKey {
         bytes32 pubKey;

         function PubKey(bytes32 initKey) {
             pubKey = initKey;
         }

         function getPubKey() constant returns (bytes32) {

            return pubKey;

         }
    }"
39696-0-0.sol,answer,"contract Fail {
    function fail() public {
        revert();
    }
}"
39696-0-0.sol,answer,"contract TestCall {
    Fail f = new Fail();

    
    function test1() public {
        f.fail();
    }

    
    function test2() public {
        f.call(bytes4(keccak256(""fail()"")));
    }
}"
78556-0-2.sol,answer,"contract Contract1 {

    mapping (address => uint256) votes;

    function voteCandidate(address _address) external {
        votes[_address]++;
    }

    function checkVotesCandidate(address _address) public view returns (uint) {
        return votes[_address];
    }
}"
78556-0-2.sol,answer,"contract Caller1 {

    Contract1 c1;

    constructor(address _address) public {
        c1 = Contract1(_address);
    }

    function voteCandidate() public {
        c1.voteCandidate(msg.sender);
    }
}"
84804-0-0.sol,answer,"contract ReferenceConsumer {
  AggregatorInterface internal ref;

  constructor(address _aggregator) public {
    ref = AggregatorInterface(_aggregator);
  }

  function getLatestAnswer() public returns (int256) {
    return ref.latestAnswer();
  }

  function getLatestTimestamp() public returns (uint256) {
    return ref.latestTimestamp();
  }

  function getPreviousAnswer(uint256 _back) public returns (int256) {
    uint256 latest = ref.latestRound();
    require(_back <= latest, ""Not enough history"");
    return ref.getAnswer(latest - _back);
  }

  function getPreviousTimestamp(uint256 _back) public returns (uint256) {
    uint256 latest = ref.latestRound();
    require(_back <= latest, ""Not enough history"");
    return ref.getTimestamp(latest - _back);
  }
}"
63704-0-0.sol,answer,"contract example3 {
  function C() {
    print msg.sender;
    B();
  }
function B() internal {
    print msg.sender; 
  }
}"
6787-1-0.sol,answer,"contract A {
    uint counter ; 
    function increment(uint add) {
       counter = counter + add;
    }
}"
6787-1-0.sol,answer,"contract B {
    function delegateIncrement(address aaddr, uint add) {
        A(aaddr).increment(add) ; 
    }
}"
60571-0-0.sol,answer,"contract Inner {
  function someFunction(uint timestamp) {
    
  }
}"
60571-0-0.sol,answer,"contract Outer {
   function callInnerWithCurrentTime(address inner) {
     Inner(inner).someFunction(now);
   }
}"
56281-2-0.sol,answer,"contract MyContract {

  struct Person {
    uint age;
    uint size;
  }

  
  Person[] persons;


  
  uint256[] personIds;

  
  mapping (uint256 => uint256) personIdToIndex;

  modifier personExists(uint256 _id) {
    uint256 index = personIdToIndex[_id]; 
    require(personIds[index] == _id, ""Person does not exist."");

    _;
  }

  event PersonAdded(uint indexed id, uint age, uint size);

  function addPerson(uint _age, uint _size) public {
    Person memory person = Person(_age, _size);
    id = persons.push(person) - 1;

    uint256 key = personIds.push(id) - 1;
    personIdToIndex[id] = key;

    emit PersonAdded(id, _age, _size)
  }

  function removePerson(uint _id) personExists(_id) public {
    delete persons[_id]

    
    uint256 key = personIdToIndex[_id];

    
    personIds[key] = personIds[personIds.length - 1];

    
    personIdToIndex[personIds[key]] = key;

    
    personIds.length--;
  }
}"
28537-0-1.sol,answer,"contract Example {


    function A(uint val) private {
       
    }

    function B(uint val)public {
        
        A(val);
    }

}"
78375-0-0.sol,answer,"contract GoodToken {
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    function transfer(address _to, uint256 _value) public returns (bool) {
        emit Transfer(msg.sender, _to, _value);
        return true;
    }
}"
78375-0-0.sol,answer,"contract BadToken {
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    function transfer(address _to, uint256 _value) public {
        emit Transfer(msg.sender, _to, _value);
    }
}"
78375-0-0.sol,answer,"contract Caller {
    function transferGoodToken(address _token, address _to, uint256 _value) public {
        GoodToken(_token).transfer(_to, _value);
    }
    function transferBadToken(address _token, address _to, uint256 _value) public {
        BadToken(_token).transfer(_to, _value);
    }
}"
60504-0-0.sol,answer,"contract IPList {

    string[] public ipList;

    event LogNewIp(address sender, string ip);

    function appendIP(string ip) public {
        ipList.push(ip);
        emit LogNewIp(msg.sender, ip);
    }

    function getIPCount() public view returns(uint count) {
        return ipList.length;
    }
}"
62126-0-1.sol,answer,"contract TimeLock {
    IERC20 token;

    struct LockBoxStruct {
        address beneficiary;
        uint balance;
        uint releaseTime;
    }

    LockBoxStruct[] public lockBoxStructs; 

    event LogLockBoxDeposit(address sender, uint amount, uint releaseTime);   
    event LogLockBoxWithdrawal(address receiver, uint amount);

    constructor(address tokenContract) public {
        token = IERC20(tokenContract);
    }

    function deposit(address beneficiary, uint amount, uint releaseTime) public returns(bool success) {
        require(token.transferFrom(msg.sender, address(this), amount));
        LockBoxStruct memory l;
        l.beneficiary = beneficiary;
        l.balance = amount;
        l.releaseTime = releaseTime;
        lockBoxStructs.push(l);
        emit LogLockBoxDeposit(msg.sender, amount, releaseTime);
        return true;
    }

    function withdraw(uint lockBoxNumber) public returns(bool success) {
        LockBoxStruct storage l = lockBoxStructs[lockBoxNumber];
        require(l.beneficiary == msg.sender);
        require(l.releaseTime <= now);
        uint amount = l.balance;
        l.balance = 0;
        emit LogLockBoxWithdrawal(msg.sender, amount);
        require(token.transfer(msg.sender, amount));
        return true;
    }    

}"
46623-0-1.sol,answer,"contract Ballot {
    
    Arithmetic.Data d;

    
    using Arithmetic for Arithmetic.Data;

    function bar(bytes1 a) public view returns (uint8) {
        
        
        bytes1 b = d.doSomeMath(a, 3);
        return uint8(b);
    }
}"
11187-0-1.sol,answer,"contract AddressArray {

    address[] addresses;

    function AddressArray(address[] addresses_) {
        for (uint i = 0; i < addresses_.length; i++) {
            addresses.push(addresses_[i]);
        }
    }

    function getNumberOfAddresses() constant returns (uint) {
        return addresses.length;
    }

    function getAddress(uint i) constant returns (address) {
        return addresses[i];
    }
}"
62199-1-0.sol,answer,"contract exampleContract {

    event Debug(bool destroyed); 

    constructor () public {

    
    
    function _destroyContract() internal {
        emit Debug(true); 
        
        selfdestruct(this); 
    }
}"
49358-0-1.sol,answer,"contract StorageVariableTest {
    uint256 k;

    function assignValue() public {
        k = 2;
    }
}"
17235-1-0.sol,answer,"contract LockBox {
    uint256 delaySeconds;
    uint256 unlockTime;
    address owner;

    function LockBox(uint256 _delay) {
        delaySeconds = _delay;
        owner = msg.sender;
    }

    
    function () payable {
        if (this.balance != 0)
            throw;
        if (msg.value != 10000) 
            throw;
        unlockTime = now + delaySeconds;
    }

    
    function withdraw() {
        if (now <= unlockTime)
            throw;
        if (msg.sender != owner)
            throw;
        owner.transfer(this.balance);
    }
}"
43817-0-0.sol,answer,"contract RPG {
    enum Armor {Chest, Helm, Boots, Leggings, Gloves, Shield} 
    enum Weapon {Sword, Axe, Wand, Gun, Hammer, Fist}

    struct CharacterStruct {string name;
                      bool isCharacter;
                      uint dna;
                      Armor[] armors; 
                      Weapon[] weapons;                  
        }

    mapping(address => CharacterStruct) public characterStructs;
    address[] public characters;

    modifier onlyIfRegistered() {
        require(characterStructs[msg.sender].isCharacter);
        _;
    }

    function register() public returns(bool success) {
        require(!characterStructs[msg.sender].isCharacter);
        characters.push(msg.sender);
        characterStructs[msg.sender].isCharacter = true;
        return true;
    }

    function addArmor(Armor a) public onlyIfRegistered returns(bool success) {
        characterStructs[msg.sender].armors.push(a);
        return true;
    }

    function getArmor(address player, uint row) public view returns(Armor armor) {
        return characterStructs[player].armors[row];
    }

}"
19582-0-0.sol,answer,"contract Example {
    function testRecovery(bytes32 h, uint8 v, bytes32 r, bytes32 s) returns (address) {
        bytes memory prefix = ""\x19Ethereum Signed Message:\n32"";
        bytes32 prefixedHash = sha3(prefix, h);
        address addr = ecrecover(prefixedHash, v, r, s);

        return addr;
    }
}"
47596-0-0.sol,answer,"contract B { 
     
     
     mapping (address => (address => bool)) permissionGiven;
     mapping (address => uint) ethBalance; 
     mapping (address => uint) balances; 

     function () payable { 
        ethBalance[msg.sender] = ethBalance[msg.sender].add(msg.value); 
     }

     function givePermission (address _a) public { 
        permissionGiven[msg.sender][a] = true;
     }

     function swap(address _a, address _c) public {
        if (permissionGiven[_c][_a] && permissionGiven[_a][_c]) {
           _c.transfer(ethBalance[_a]);
           transfer(_a, balances[_c]);
        }
     }

     function transfer (address _to, uint _tokens) {
         
     }
}"
12890-1-0.sol,answer,"contract Factory {

    mapping(address => bool) public isConsumer;
    address[] public consumers;

    modifier onlyACL() {
        if(!isConsumer[msg.sender]) throw;
        _;
    }

    function newConsumer() 
        public
        returns(address consumerAddress)
    {
        Consumer c = new Consumer();
        consumers.push(c);
        isConsumer[c] = true;
        return c;
    }

    function ACLProtected()
      onlyACL
      returns(bool allowed)
    {
        return true;
    }

    function getConsumerCount()
        public
        constant
        returns(uint consumerCount)
    {
        return consumers.length;
    }

}"
12890-1-0.sol,answer,"contract Consumer {

    address owner;
    Factory f;

    function Consumer() {
        owner = msg.sender;
        f = Factory(owner);
    }

    function consumeFunction()
        public
        constant
        returns(bool success) 
    {
        bool wasAllowed = f.ACLProtected();
        return wasAllowed; 
    }

}"
64668-0-1.sol,answer,"contract Dao {

    mapping (address => User) public users;

    struct User {
        address addr;
        string name;
        uint balence;
        uint8 flag;
    }

    function addUser(address _address, string _name, uint _balence, uint8 _flag) public {
        users[msg.sender].name = _name;
        users[msg.sender].flag = _flag;
        users[msg.sender].addr = _address;
        users[msg.sender].balence = _balence;
    }

    function addToBalence(string name) public payable{
        if(users[msg.sender].flag != 1) addUser(msg.sender,name,0,1);
        users[msg.sender].balence = users[msg.sender].balence + msg.value;
    }

    function showBalence() public returns (uint) {
        return users[msg.sender].balence;
    }

    function withdraw(uint amount) public payable{
        if(users[msg.sender].flag != 1) revert(""user does not exist"");
        else if (users[msg.sender].balence >= amount){
            msg.sender.call.value(amount)();
            users[msg.sender].balence -= amount;
        }
    }
}"
64668-0-1.sol,answer,"contract Hacker {
    Dao dao;
    address userAddress; 
    string userName;

    constructor(string _userName, address daoAddress) public {
        dao = Dao(daoAddress);
        userAddress = msg.sender;
        userName = _userName;
    }

    function addToBalence(string name, uint amount) public payable {
        dao.addToBalence.value(msg.value)(userName); 
    }
}"
46019-0-0.sol,answer,"contract One {
    uint256 public u;
}"
46019-0-0.sol,answer,"contract Other {
    One public myOne = new One();

    function doSomething() public {
        myOne.u = 123; 
    }
}"
50460-0-0.sol,answer,"contract Test {
    uint[] public arr;

    constructor() public {
        arr = [1];
    }

    function setMe() public {
        TestLibrary.setMyArray(arr);
    }
}"
71254-0-1.sol,answer,"contract A is Base {
    function test() public returns (uint, uint, uint) {
        
        
        
        uint a = this.foo();   
        uint b = bar();        
        uint c = baz();        
        return (a, b, c);
    }
}"
2304-0-0.sol,answer,"contract someContract {   

    address public owner;

    
    function someContract() {
        owner = msg.sender;
    } 

    
    event DepositMade(address _from, uint value);
    event WithdrawalMade(address _to, uint value);

    
    function() {
        
        if (msg.value > 0)
            DepositMade(msg.sender, msg.value);
    }

    
    modifier admin { if (msg.sender == owner) _ }

    function withdraw(uint amount, address recipient) admin {
        if(recipient.send(amount))
            WithdrawalMade(msg.sender, msg.value);
        else throw;
    }
}"
56720-0-0.sol,answer,"contract SpammyToken {
    
    event Transfer(address from, address to, uint256 amount);

    function spam(address who) external {
        emit Transfer(who, 0, 2500);
    }
}"
43116-0-0.sol,answer,"contract A {
    function forward(address to) public payable {
        to.send(msg.value); 
                            
    }
}"
43116-0-0.sol,answer,"contract B {
    uint256 foo;

    function () public payable {
        foo = 3; 
    }
}"
8120-0-0.sol,answer,"contract D {
  uint public n;
  address public sender;

  function delegatecallSetN(address _e, uint _n) {
    _e.delegatecall(bytes4(keccak256(""setN(uint256)"")), _n); 
  }
}"
64024-0-1.sol,answer,"contract ParserDemo {
  uint public min;
  address public who;
  string public message;
  event Parsed(uint _min, address _who, string _message);
  event Data(bytes _message);
  function test(bytes data) public {
    address a = this;
    assembly {
      if iszero(delegatecall(gas, a, add(data, 32), mload(data), 0, 0)) {
          revert(0, 0)
      }
    }
  }
  function parser(uint _min, address _who, string _message) public {
    min = _min;
    who = _who;
    message = _message;
    emit Parsed(_min, _who, _message);
  }

}"
7526-0-1.sol,answer,contract NameRegister { function addr(string _name) constant returns (address o_owner); function name(address _owner) constant returns (string o_name);}
7526-0-1.sol,answer,"contract Registrar is NameRegister { event Changed(string indexed name); event ReverseChanged(address indexed addr, string indexed name); function owner(string _name) constant returns (address o_owner); function addr(string _name) constant returns (address o_address); function subRegistrar(string _name) constant returns (address o_subRegistrar); function content(string _name) constant returns (bytes32 o_content);  function name(address _owner) constant returns (string o_name);}"
7526-0-1.sol,answer,"contract AuctionSystem { event AuctionEnded(string indexed _name, address _winner); event NewBid(string indexed _name, address _bidder, uint _value);  function onAuctionEnd(string _name) internal; function bid(string _name, address _bidder, uint _value) internal { var auction = m_auctions[_name]; if (auction.endDate > 0 && now > auction.endDate) { AuctionEnded(_name, auction.highestBidder); onAuctionEnd(_name); delete m_auctions[_name]; return; } if (msg.value > auction.highestBid) {  auction.secondHighestBid = auction.highestBid; auction.sumOfBids += _value; auction.highestBid = _value; auction.highestBidder = _bidder; auction.endDate = now + c_biddingTime; NewBid(_name, _bidder, _value); } } uint constant c_biddingTime = 7 days; struct Auction { address highestBidder; uint highestBid; uint secondHighestBid; uint sumOfBids; uint endDate; } mapping(string => Auction) m_auctions;}"
76903-0-0.sol,answer,"contract SillyOwner {
    address owner;

    constructor() public {
        owner = msg.sender;
    }

    event OwnerChange(
        address oldOwner,
        address newOwner
    );

    function changeOwner(address _no) public { 
        require(msg.sender == owner, ""Insufficient permission"");
        address ow = owner;
        owner = _no;
        emit OwnerChange(ow, owner);
    }
}"
28344-1-0.sol,answer,"contract Str {

    event LogX(string thing);

    function x(string something) public returns(string success) {
        LogX(something);
        return something;
    }
}"
28344-1-0.sol,answer,"contract Try {

    Str s;

    function Try(string that) {
        s = new Str();
        string set = s.x(that); 
    }
}"
52532-0-0.sol,answer,"contract ERC20Token is StandardERC20 {
    string public name;
    string public symbol;
    uint8 public decimals;

    constructor(string _name, string _symbol, uint8 _decimals) public {
        name = _name;
        symbol = _symbol;
        decimals = _decimals;
    }
}"
52532-0-0.sol,answer,"contract ERC721Token is StandardERC721 {
    constructor(string _name, string _symbol)
    public
    StandardERC721(_name, _symbol)
    {
    }
}"
52532-0-0.sol,answer,"contract TokenFactory {
    
    function newERC20(string _name, string _symbol, uint8 _decimals) public {
        emit ERC20Created(new ERC20Token(_name, _symbol, _decimals), _name, _symbol, _decimals);
    }

    
    function newERC721(string _name, string _symbol) public {
        emit ERC721Created(new ERC721Token(_name, _symbol), _name, _symbol);
    }

    event ERC20Created(ERC20Token indexed tokenAddress, string indexed name, string indexed symbol, uint8 decimals);
    event ERC721Created(ERC721Token tokenAddress, string name, string symbol);
}"
66905-0-0.sol,answer,"contract Certs {

    mapping(address => bytes32[]) public studentCertIPFShashes;

    address issuer;  

    modifier onlyIssuer {
        require(issuer == msg.sender);
        _;
    }

    constructor() public {
      issuer = msg.sender;
    }

    function issuerCert(address student, bytes32 IPFShash) public onlyIssuer {
        studentCertIPFShashes[student].push(IPFShash);
    }

}"
56560-0-0.sol,answer,"contract  A{
    uint256 a;
    function set(uint _a) public { 
        require(_a > 100);
        a = _a;
    }

}"
56560-0-0.sol,answer,"contract C {
    function callA(A _a, uint256 _value) public {
        bool success = address(_a).call(abi.encodeWithSignature(""set(uint256)"", _value));
        emit ACalled(success);
    }

    event ACalled(bool success);
}"
56304-0-0.sol,answer,"contract depo {
    function depo() public {

    }

    function () payable public {

    }

    function deposit() payable public {
        require(msg.value == 1 ether);
    }
}"
44682-0-0.sol,answer,"contract A {
    address public my_address;

    function A(address _val) {
        my_address= _val;
    }
}"
44682-0-0.sol,answer,"contract B is A {
    function B() {
        A(this);
    }
}"
57699-0-1.sol,answer,"contract Mutex {
    bool locked;
    modifier noReentrancy() {
        require(
            !locked,
            ""Reentrant call.""
        );
        locked = true;
        _;
        locked = false;
    }

    
    
    
    
    function f() public noReentrancy returns (uint) {
        require(msg.sender.call());
        return 7;
    }
}"
62188-0-0.sol,answer,"contract Sharer {
    function sendHalf(address addr) public payable {
        require(msg.value % 2 == 0);
    }
}"
39532-0-0.sol,answer,"contract BettingGame {
    struct Wager {
        address player1;
        address player2:
        uint amount;
    }
    Wager[] public wagers;

    function createWager(uint _amount) public payable {
        require(msg.value == _amount);
        Wager memory w = Wager(msg.sender,0,_amount);
        uint wagerId = wagers.push(w) - 1; 
    }

    function takeWager(uint _id) public payable {
        Wager storage w = wagers[_id];
        require(w.player2 == 0);
        require(msg.value == w.amount);
        w.player2 = msg.sender;
    }
}"
8951-0-1.sol,answer,contract Mortal { address owner; function Mortal() { owner = msg.sender; } function kill() { if (msg.sender == owner) suicide(owner); }}
8951-0-1.sol,answer,contract MyEscrow is Mortal { uint numEscrows; function queryNumEscrows() constant returns (uint) { return numEscrows; } function start() returns (uint) { numEscrows++; return numEscrows; }}
3285-0-0.sol,answer,"contract Answer {
  mapping(address => mapping(string => bool)) voters;

  struct qList {
    uint count; 
    mapping(address => mapping(uint => uint)) answer;
  }

  mapping(string => qList) questionnaires;

  function vote(string ID, uint qNum, uint ans) returns (bool) {
    if (voters[msg.sender][ID]) throw;
    voters[msg.sender][ID] = true;
    questionnaires[ID].count += 1;
    questionnaires[ID].answer[msg.sender][qNum] = ans;
    return true;
  }

  function getNumResult(string ID) constant returns (uint res) {
    return questionnaires[ID].count;
  }
}"
61710-0-1.sol,answer,"contract B {

    event received( uint256 );

    uint256 public lastReceivedUint = 0;

    function receiver() public payable {
        emit received( msg.value );
    }

    function receiverWithArgs( uint256 test ) public payable {
        lastReceivedUint = test;
        emit received( msg.value );
    }

    function badCall() public payable {
        revert();
    }
}"
61710-0-1.sol,answer,"contract A {

    event transferValue( uint256 );

    
    function() payable public {

    }

    
    function newTransferToB(address _addr, uint256 valueInWei, bytes hexData) public payable {
        emit transferValue( valueInWei );
        require( _addr.call.value(valueInWei)(hexData), ""Transfer failed"" );  
    }
}"
61710-0-1.sol,answer,"contract Test {

    A public Contract_A;
    B public Contract_B;

    constructor() public payable {
        
        require(msg.value > 0, ""Value required"");

        
        Contract_A = new A();
        Contract_B = new B();

        
        address(Contract_A).transfer(address(this).balance);
    }

    function show_balance_A() public view returns(uint256) {
        return address(Contract_A).balance;
    }

    function show_balance_B() public view returns(uint256) {
        return address(Contract_B).balance;
    }

    
    function testTransferTo_B_No_Args() public {

        
        uint256 BalanceBInitial = address(Contract_B).balance;

        uint256 sendValue = 10; 

        Contract_A.newTransferToB( 
            address(Contract_B),
            sendValue,
            abi.encode(bytes4(keccak256(""receiver()"")))
        );

        
        assert( address(Contract_B).balance == BalanceBInitial + sendValue);
    }

    
    function testTransferTo_B_With_Args() public {


        
        uint256 BalanceBInitial = address(Contract_B).balance;

        uint256 sendValue = 100; 
        uint256 uintParamValue = 5; 

        Contract_A.newTransferToB( 
            address(Contract_B),
            sendValue,
            abi.encodeWithSelector(bytes4(keccak256(""receiverWithArgs(uint256)"")), uintParamValue)
        );

        
        assert( address(Contract_B).balance == BalanceBInitial + sendValue);
        assert( Contract_B.lastReceivedUint() == uintParamValue);

    }

    
    function testTransferTo_B_More_than_Available_should_throw() public {

        uint256 BalanceAInitial = address(Contract_A).balance;
        uint256 sendValue = BalanceAInitial + 1; 

        Contract_A.newTransferToB( 
            address(Contract_B),
            sendValue,
            abi.encode(bytes4(keccak256(""receiver()"")))
        );

        

    }
}"
78790-1-0.sol,answer,"contract ArrayMapping {

    uint[2**160-1] addressIndex;
    mapping(address => uint) mapped;

    function getArray(uint row) public returns (uint) { 
        return addressIndex[row];
    }

    function getMap(address a) public returns (uint) { 
        return mapped[a];
    }
}"
66082-2-0.sol,answer,"contract A {

    event Data(bytes a);
    event Sig(bytes4 a);
    event Val(uint a);

    function a() public payable {
        emit Data(msg.data);
        emit Sig(msg.sig);
        emit Val(msg.value);
        b();
        B b = new B();
        b.c();

    }

    function b() public payable {
        emit Data(msg.data);
        emit Sig(msg.sig);
        emit Val(msg.value);
    }
}"
66082-2-0.sol,answer,"contract B {
    event Data(bytes a);
    event Sig(bytes4 a);
    event Val(uint a);

    function c() public payable {
        emit Data(msg.data);
        emit Sig(msg.sig);
        emit Val(msg.value);
    }
}"
16047-0-0.sol,answer,"contract ACL {

    mapping (address => bool) public authorized;

    modifier onlyIfAuthorized {
        if(!authorized[msg.sender]) throw;
        _;
    }

    function ACL() {
        authorized[msg.sender] = true; 
    }

    function authorizeAddress(address newUser)
        onlyIfAuthorized
        returns(bool success)
    {
        authorized[newUser] = true;
        return true;
    }

    function revokeAccess(address removeUser)
        onlyIfAuthorized
        returns(bool success)
    {
        authorized[removeUser] = false;
    }

}"
67137-1-0.sol,answer,"contract arrayExample {
  
  uint[] public myArray;

  
  

  
  function getArray() returns (uint[] memory) {
      return myArray;
  }
}"
37305-1-0.sol,answer,"contract Borrower is mortal {
    string  public borrowerName;
    uint256 public funds;

    function Borrower(string _name) payable public {
        borrowerName     = _name;
    }

    function addFunds() payable onlyOwner public {
        
        funds += msg.value;
    }
}"
58662-1-1.sol,answer,"contract receiveData {

    bytes public data;

    function () external payable {
        data = msg.data;
    }
}"
10293-1-0.sol,answer,"contract C {
    uint[] data;

    function f() public pure returns (uint, bool, uint) {
        return (7, true, 2);
    }

    function g() public {
        
        (uint x, bool b, uint y) = f();
        
        (x, y) = (y, x);
        
        (data.length,,) = f(); 
    }
}"
69727-0-2.sol,answer,"contract KeyAKeyB {

    using HitchensUnorderedKeySetLib for HitchensUnorderedKeySetLib.Set;

    
    mapping(bytes32 => HitchensUnorderedKeySetLib.Set) bInA;

    
    mapping(bytes32 => HitchensUnorderedKeySetLib.Set) aInB;

    
    mapping(bytes32 => bytes32) public values;

    event LogSet(bytes32 keyA, bytes32 keyB, bytes32 value);
    event LogRem(bytes32 keyA, bytes32 keyB);

    function multikey(bytes32 keyA, bytes32 keyB) public pure returns(bytes32) {
        return keccak256(abi.encodePacked(keyA, keyB));
    }

    
    

    function set(bytes32 keyA, bytes32 keyB, bytes32 value) public {
        if(!isBInA(keyA, keyB)) bInA[keyA].insert(keyB); 
        if(!isAInB(keyA, keyB)) aInB[keyB].insert(keyB); 
        values[multikey(keyA, keyB)] = value;
        emit LogSet(keyA, keyB, value);
    }

    function get(bytes32 keyA, bytes32 keyB) public view returns(bytes32 value) {
        
        
        return values[multikey(keyA, keyB)];
    }

    

    function remove(bytes32 keyA, bytes32 keyB) public {
        bInA[keyA].remove(keyB);
        aInB[keyB].remove(keyA);
        delete values[multikey(keyA, keyB)];
        emit LogRem(keyA, keyB);
    }

    

    function isBInA(bytes32 keyA, bytes32 keyB) public view returns(bool isIndeed) {
        return bInA[keyA].exists(keyB);
    }

    function isAInB(bytes32 keyA, bytes32 keyB) public view returns(bool isIndeed) {
        return aInB[keyB].exists(keyA);
    }

    

    function countBinA(bytes32 keyA) public view returns(uint) {
        return bInA[keyA].count();
    }

    function countAinB(bytes32 keyB) public view returns(uint) {
        return aInB[keyB].count();
    }

    function aBAtIndex(bytes32 keyA, uint row) public view returns(bytes32 keyB) {
        return bInA[keyA].keyAtIndex(row);
    }

    function bAAtIndex(bytes32 keyB, uint row) public view returns(bytes32 keyA) {
        return aInB[keyB].keyAtIndex(row);
    }
}"
67121-0-1.sol,answer,"contract Publisher {
    StorageController _storages;

    constructor(address storageControllerAddress) public {
        _storages = StorageController(storageControllerAddress);
    }

    function getStorage(uint index) public view returns(string memory, uint256, uint256, uint256, uint256, bool) {
        (string memory name, uint256 maxLength, uint256 rank, uint256 writingFee, uint256 sellPrice,bool nonpublic) = _storages.getStorageData(index);
        return (name, maxLength,rank,writingFee,sellPrice,nonpublic);
    }
}"
45839-0-0.sol,answer,"contract A {
  mapping (bytes32 => uint) public someMapping;
}"
45839-0-0.sol,answer,"contract B {
  A a; 

  function B(address addressA) public { 
    a = A(addressA);
  }

  function getAUint(bytes32 key) public view returns(uint) {
    return a.someMapping(key);
  }
}"
40687-0-1.sol,answer,"contract Owned {
    address owner;
    address[] listuser;
    function Owned() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function whitelistAddress (address user) onlyOwner {
        listuser.push(user);
    }   

    modifier onlyusers() {
        

        for(uint index = 0; index < listuser; index++){
            if(userlist[index]==msg.sender){
                _;
                return;
            }
        }
        revert(); 
    }

    function accessbyonlyusers () onlyusers {
        
    }
}"
24404-0-0.sol,answer,"contract Factory {
  bytes32[] public Names;
  address[] public newContracts;

  function createContract (bytes32 name) public {
    address newContract = new Contract(name);
    newContracts.push(newContract);
  } 

  function getName (uint i) public {
    Contract con = Contract(newContracts[i]);
    Names[i] = con.Name();
  }
}"
63403-0-0.sol,answer,"contract Base {
    uint256 basevar = 0;
    constructor() public {
        basevar = 1;
    }
}"
63403-0-0.sol,answer,"contract Base2 {
    uint256 basevar2 = 2;
    constructor() public {
        basevar2 = 1;
    }
}"
44441-0-0.sol,answer,"contract con2 {
    bytes32[5] y;
    function con2(){
    }

    function trys(address con1Contract){
        con1 b = con1(con1Contract);
         y = b.getData();
    }
}"
9733-1-3.sol,answer,"contract A {
   
   function f1(bool arg1, uint arg2) returns(uint) {
       if (arg1) {
           throw;
       } else {
           return arg2;
       }
   }
}"
22890-3-0.sol,answer,"contract DA {

    address public da;

    function DA() public {
        da = msg.sender;
    }

    function setDa() public returns(bool success) {
        da = msg.sender;
        return true;
    }

    

    function getDa() public constant returns (address){
        return da;
    }

    function getMsgSender() public constant returns(address) {
        return msg.sender;
    }
}"
9697-0-1.sol,answer,"contract A1 {
  address addressOfM;
  function A1(address _m) {
      addressOfM = _m;
  }
  function forward() payable {
     if (!addressOfM.send(msg.value)) throw;
     
  }
}"
9697-0-1.sol,answer,"contract A2 {
  address addressOfM;
  function A2(address _m) {
      addressOfM = _m;
  }
  function forward() payable {
     if (!addressOfM.send(msg.value)) throw;
     
  }
}"
9697-0-1.sol,answer,"contract M {
    function() payable {}
}"
83470-0-0.sol,answer,"contract ReceiveEther {
    uint256 public clicksfromcreatorcount; 
    uint256 public count;
    address public creatorino = tx.origin;

        function increaseifcreatorclicks() external {
            require (msg.sender == creatorino);
                clicksfromcreatorcount++;
        }

        function () external payable {
            require (clicksfromcreatorcount>=1);
            if (clicksfromcreatorcount ==1) {
                require (tx.origin == creatorino);
            }
            require (count<2);
            count++;
        }
}"
12348-0-0.sol,answer,"contract HelloWorld {

    string saySomething;

    constructor() public  {
        saySomething = ""Hello World!"";
    }

    function speak() public constant returns(string itSays) {
        return saySomething;
    }

    function saySomethingElse(string newSaying) public  returns(bool success) {
        saySomething = newSaying;
        return true;
    }

}"
13365-0-0.sol,answer,"contract TestcaseResetObject {

    uint public objectCount;

    struct MyObjectStruct {
        mapping(uint => uint) map;
    }

    MyObjectStruct[] myObjects;

    event LogOutput(uint number);

    function makeNewObject() public returns(uint count) {

        MyObjectStruct memory mo;
        objectCount = myObjects.push(mo);
        return objectCount;
    }

    
    function incCounter(uint objectNumber, uint index) public returns(uint newValue) {
        myObjects[objectNumber].map[index] += 1;
        LogOutput(myObjects[objectNumber].map[index]);
        return myObjects[objectNumber].map[index];
    }
}"
28584-0-0.sol,answer,"contract Example {

    mapping(uint => string) documents;


    function storeDocument(uint id, string docHash) {

        storeDocument[id] = docHash;
    }

    function verifyDocument(uint id, string hashToVerify) returns (bool){
        if(storeDocument[id] == hashToVerify ) {
            return true;
        }
        else{
            return false;
        }
     }
}"
2397-1-0.sol,answer,"contract Example {
       struct Person {
         string name;
       }
       mapping(string => Person) map;

       function setName(string name, string value) {
          map[name] = Person({name: value});
       }

       function getName(string key) constant returns (string) {
         return map[key].name;
       }

   }"
22928-0-0.sol,answer,"contract Files {
    struct AllFiles{
        string fileDesc;        
        uint fileId;            
    }
    uint filesCount;

    mapping (uint =>AllFiles) public allFiles;

    function addFile(string _desc) {
        uint id = filesCount+1;
        allFiles[id] = AllFiles({fileDesc: _desc, fileId: id});
    }

    function iterate() {
        for(uint256 i = 1; i<=filesCount; i++) {
            allFiles[i];
        }

    }
}"
70406-0-4.sol,answer,"contract Campaign {

    struct Transaction {
        address Creditor;
        uint Amount;
        uint arrayPointer; 
    }
    address[] public transactionAddresses;  
    mapping(address => Transaction) public TransactionsMap; 

    function addTransaction(address _address,uint _amount) public {
        Transaction memory newRequest = Transaction({
           Creditor: _address,
           Amount: _amount,
           arrayPointer: transactionAddresses.push(_address)});
        TransactionsMap[_address]=newRequest;
    }
    function Testing()public {
        addTransaction(0xaef0B7Edd5D2E9315027ADFA4642E16a5c85Afd8,100);
        TransactionsMap[0xaef0B7Edd5D2E9315027ADFA4642E16a5c85Afd8].Amount++;
    }
    function a()public view  returns (uint){
        return TransactionsMap[0xaef0B7Edd5D2E9315027ADFA4642E16a5c85Afd8].Amount;
    }
    function b()public view  returns (address){
        return transactionAddresses[0];
    }
}"
13845-0-0.sol,answer,"contract ObjectTree {

    bytes32 public treeRoot;

    struct NodeStruct {
        bool isNode;
        bytes32 parent; 
        uint parentIndex; 
        bytes32[] children; 
        
    }

    mapping(bytes32 => NodeStruct) public nodeStructs;

    event LogNewNode(address sender, bytes32 nodeId, bytes32 parentId);
    event LogDelNode(address sender, bytes32 nodeId);

    function ObjectTree() {
        treeRoot = newNode(0);
    }

    function isNode(bytes32 nodeId)
        public
        constant
        returns(bool isIndeed)
    {
        return nodeStructs[nodeId].isNode;
    }

    function newNode(bytes32 parent) 
        public
        returns(bytes32 newNodeId)
    {
        if(!isNode(parent) && parent > 0) throw; 
        newNodeId = sha3(parent, msg.sender, block.number);
        NodeStruct memory node;
        node.parent = parent;
        node.isNode = true;
        
        if(parent>0) {
            node.parentIndex = registerChild(parent,newNodeId);
        }
        nodeStructs[newNodeId] = node;
        LogNewNode(msg.sender, newNodeId, parent);
        return newNodeId;
    }

    

    function registerChild(bytes32 parentId, bytes32 childId)
        private
        returns(uint index)
    {
        return nodeStructs[parentId].children.push(childId) - 1;
    }

    
    
    
    

    function pruneBranch(bytes32 nodeId)
        public
        returns(bool success)
    {
        bytes32 parent = nodeStructs[nodeId].parent;
        uint rowToDelete = nodeStructs[nodeId].parentIndex;
        uint rowToMove = nodeStructs[parent].children.length-1; 
        nodeStructs[parent].children[rowToDelete] = nodeStructs[parent].children[rowToMove];
        nodeStructs[nodeStructs[parent].children[rowToMove]].parentIndex = rowToMove;
        nodeStructs[parent].children.length--;
        nodeStructs[nodeId].parent=0;
        nodeStructs[nodeId].parentIndex=0;
        nodeStructs[nodeId].isNode = false;
        LogDelNode(msg.sender, nodeId);
        return true;
    }

    function getNodeChildCount(bytes32 nodeId)
        public
        constant
        returns(uint childCount)
    {
        return(nodeStructs[nodeId].children.length);
    }

    function getNodeChildAtIndex(bytes32 nodeId, uint index) 
        public 
        constant
        returns(bytes32 childId)
    {
        return nodeStructs[nodeId].children[index];
    }

}"
78572-0-0.sol,answer,"contract Base
{
    function foo() virtual public {}
}"
78572-0-0.sol,answer,contract Middle is Base {}
78572-0-0.sol,answer,"contract Inherited is Middle
{
    function foo() public override {}
}"
83858-0-0.sol,answer,"contract Test {

    uint256[] public array = [0,1,2];

    function A(uint256 input )public {
            array.push(input);
            
    }

    function B(uint256 input )public {
            array.push(input);
            
    }
}"
2916-0-0.sol,answer,"contract myContract {
    function f() {
        int a = Math.sqrt(9);
    }
}"
25732-0-0.sol,answer,"contract TestContract {
  
  uint public initialBalance = 1 ether;

  function testInitialBalanceUsingDeployedContract() {
    MyContract myContract = MyContract(DeployedAddresses.MyContract());

    
    myContract.send(...);
  }

  function () {
    
  }
}"
40045-0-1.sol,answer,"contract StructArrayInitWrong {

  struct Room {
    address[] players;       
  }  
  Room[] rooms;
  address[] adr; 

  function createRoom() public {
                                    
    adr.push(msg.sender);
    Room memory room = Room(adr);   
    rooms.push(room);
  }

  function getRoomsLength() public view returns (uint) {
    return rooms.length;
  }
}"
47100-0-0.sol,answer,"contract MyContract {
    event MyEvent(address indexed sender, uint256 amount);
    function myFunction(uint256 a, uint256 b, uint256 c) external returns (uint256) {
        uint256 x = a * b + c;
        MyEvent(msg.sender, x);
        return x;
    }
}"
60238-0-0.sol,answer,"contract ValueStorage {

    
    
    
    uint value;
    


    
    
    
    function setValue(uint _value) public {
        value = _value;
    }
    


    
    
    
    function getValue() public view returns  (uint) {
        return value; 
    }
    
}"
74266-0-2.sol,answer,"contract NestedCRUD {

    using HitchensUnorderedKeyListLib for HitchensUnorderedKeyListLib.Set;

    struct Outer {
        bool arg1;
        uint arg2;
        
        HitchensUnorderedKeyListLib.Set nestedCRUD; 
    }

    mapping(bytes32 => Outer) public outerStructs; 
    HitchensUnorderedKeyListLib.Set outerKeys; 

    struct Inner {
        address arg1;
        uint arg2;
        
        bytes32 outerKey; 
    }

    mapping(bytes32 => Inner) public innerStructs;
    HitchensUnorderedKeyListLib.Set innerKeys;

    

    function newOuter(bytes32 id, bool arg1, uint arg2) public {
        outerKeys.insert(id);
        outerStructs storage o = outerStructs[id];
        o.arg1 = arg1;
        o.arg2 = arg2;
    }

    function newInner(bytes32 id, bytes32 outerId, address arg1, uint arg2) public {
        require(outerKeys.exists(outerId), ""Outer not found."");
        innerKeys.insert(id);
        Inner storage i = innerStructs[id];
        i.arg1 = arg1;
        i.arg2 = arg2;
        i.outerKey = outerKey;
    }

    

    function updateOuter(bytes32 id, bool arg1, uint arg2) public {
        require(outer.exists(id), ""Outer not found."");
        Outer storage o = outerStructs[id];
        o.arg1 = arg1;
        o.arg2 = args;
    }

    function updateInner(bytes32 id, address arg1, uint arg2) public {
        require(inner.exists(id), ""Inner not found"");
        Inner storage i = innerStructs[id];
        i.arg1 = arg1;
        1.arg2 = arg2;
        
    }

    
}"
26071-0-0.sol,answer,"contract F {
    function () {}
}"
26071-0-0.sol,answer,contract N {}
26071-0-0.sol,answer,"contract Test {
    event Log(bool x);
    function TestF() {
        address f = address(new F());
        Log(f.call());
    }
    function TestN() {
        address n = address(new N());
        Log(n.call());
    }
}"
73570-0-1.sol,answer,"contract Raffle {

    mapping(address => bytes32) commitments;
    mapping(uint256 => address) reserved;

    event Reserved(uint256 value, address owner);

    function commit(bytes32 hash) public {
        require(commitments[msg.sender] == bytes32(0), ""Already committed"");
        commitments[msg.sender] = hash;
    }

    function reveal(uint256 nonce, uint256 value) public {
        bytes32 d = digest(nonce, value, msg.sender);
        require(commitments[msg.sender] == d, ""Invalid data"");
        require(reserved[value] == address(0), ""Already reserved"");
        reserved[value] = msg.sender;
        emit Reserved(value, msg.sender);
    }

    function digest(uint256 nonce, uint256 value, address sender) public pure returns (bytes32) {
        return keccak256(abi.encodePacked(nonce, value, sender));
    }
}"
72199-0-2.sol,answer,"contract Hash {
    function func() external pure returns (bytes32) {
        return keccak256(abi.encodePacked(""Hello World!"")) ;
    }
}"
36004-0-0.sol,answer,"contract Token {
    Crowdsale crowdsale;
    function Token(address theAddr) {
        crowdsale = Crowdsale(theAddr);
    }

    
    function talkToCrowdsale() {
        crowdsale.someMethod();
    }

    
    function talkToCrowdsale(address theAddr) {
        Crowdsale(theAddr).someMethod();
    }
}"
52960-0-1.sol,answer,"contract A {

    modifier onlyOwner() {
        require(getOwner() == msg.sender);
        _;
    }
    
    function getOwner() internal returns(address);  

    function performOperation() internal; 

    function updateState() public onlyOwner() {
        performOperation();
    }

}"
52960-0-3.sol,answer,"contract A {
        address internal owner;

        constructor() internal {
           owner = msg.sender;
        }
        modifier onlyOwner() {
            require(owner == msg.sender);
            _;
        }
        function performOperation() internal;
        function updateState() public onlyOwner() {
            performOperation();
        }
    }"
57666-0-0.sol,answer,contract Mortal {          address owner;      function Mortal() { owner = msg.sender; }        function kill() { if (msg.sender == owner) selfdestruct(owner); }}
57666-0-0.sol,answer,contract Greeter is Mortal {        string greeting;        function Greeter(string _greeting) public {        greeting = _greeting;    }        function greet() constant returns (string) {        return greeting;    }}
64480-0-0.sol,answer,"contract TripHistory {
    mapping(string => int32[]) trips;

    function getTrip(string _trip_id) public view returns (int32[]) {
        return trips[_trip_id];
    }
    function storeTrip(string _trip_id, int16 _lat, int16 _lon) public {
       trips[_trip_id].push((int32(_lat) << 16) | int32(_lon));
    }
}"
80610-0-0.sol,answer,"contract MyContract {

    struct user {
        address id;
        string name;
    }

    uint internal totalUsers = 0;
    mapping(address => user) internal users;

    function registerUser(string memory name) public {
        user storage u = users[msg.sender];
        require(keccak256(abi.encodePacked((name))) != keccak256(abi.encodePacked((""""))));
        if(msg.sender == u.id) {
            revert(""already registered"");
        } else {
            users[msg.sender] = user(msg.sender, name);
            totalUsers++;
        }
    }
}"
71241-1-0.sol,answer,"contract StructArrayInit {

  event OnCreateRoom(address indexed _from, uint256 _value);

  struct Room {
    address[] players;       
    uint256 whosTurnId;
    uint256 roomState;
  }  

  Room[] public rooms;

  function createRoom() public {
      Room memory room = Room(new address[](0), 0, 0);
      rooms.push(room);
      rooms[rooms.length-1].players.push(msg.sender);

      OnCreateRoom(msg.sender, 0);
  }
  function getRoomPlayers(uint i) public view returns (address[]){
      return rooms[i].players;
  }
}"
48818-0-0.sol,answer,"contract MyContract {
    uint256[] public data;
    function write(uint256 entry) public {
        data.push(entry);
    }    
    function read() public constant returns(uint256[]) {
        return(data);
    }
}"
56506-0-0.sol,answer,"contract ContractTest { 
    string public Name;

    function ContractTest (string name) {
        Name = name;
    }
}"
56506-0-0.sol,answer,"contract FactoryTest { 
    address[2] newContracts;

    function createContract (string name) {
        address newContract = new ContractTest(name);
        newContracts[0]=newContract;
    }

    function getContract() returns(address) {
      return newContracts[0];
    }
}"
38241-0-0.sol,answer,"contract Demo {

    uint public constant INITIAL_SUPPLY = 1000000000;
    mapping (address => uint) public balances;

    function Demo() public {
        balances[msg.sender] = INITIAL_SUPPLY - 1000;
        balances[address(0)] = 1000;
    }

}"
72708-0-1.sol,answer,"contract Bar {
    Foo.F public f;

    function bar () public {
        Foo.foo (f);
    }
}"
65596-0-0.sol,answer,"contract Users {

    mapping(address=>bool) public isUser;
    address[] public users;

    function register() public {
        require(!isUser[msg.sender]);
        isUser[msg.sender] = true;
        users.push(msg.sender);
    }
}"
65596-0-0.sol,answer,"contract Events {

    uint eventCount;

    struct EventStruct {
        mapping(address=>bool) isAttendee;
        address[] attendees;
        bytes32 metadata;
    }

    mapping(uint=>EventStruct) public events;

    function createEvent(bytes32 metaData) public {
        events[eventCount].metadata = metaData;
        eventCount++;
    }

    function reserveAttenance(uint eventId) public {
        require(eventId < eventCount);
        EventStruct storage e = events[eventId];
        require(!e.isAttendee[msg.sender]);
        e.isAttendee[msg.sender] = true;
        e.attendees.push(msg.sender);
    }
}"
17060-0-0.sol,answer,"contract Sample {
  address constant public myAddress = 0xE0f5206BBD039e7b0592d8918820024e2a7437b9;
  uint public vari;
  function setVari(uint a) {
    if(msg.sender == myAddress) {
      vari = a;
    }
  }  
}"
12698-0-0.sol,answer,"contract FactoryTInterface {
  function newT() returns(address newTContract);
}"
12698-0-0.sol,answer,"contract MegaFactory is FactoryTInterface {

  address factoryTaddress;

  function MegaFactory(address factoryT) {
      factoryTaddress = factoryT;
  }

  function newT() returns(address newContract) {
    FactoryTInterface factory = FactoryTInterface(factoryTaddress);
    return factory.newT();
  }
}"
12698-0-0.sol,answer,"contract FactoryT {

  function newT() returns(address newT) {
    T t = new T();
    return t;
  }
}"
12698-0-0.sol,answer,"contract T {
  
}"
45419-0-1.sol,answer,"contract EmojiCoin {

    mapping(uint256 => address) public tokenOwner;
    mapping(uint256 => uint256) public emojiIndexToPrice;
    uint256 public ownerCut  = 5;


    function EmojiCoin() public {

        
        tokenOwner[0] = msg.sender;
        emojiIndexToPrice[0] = 1 ether;

    }

    
    function _transfer(address oldOwner, address newOwner, uint256 _tokenId) internal {
        require(tokenOwner[_tokenId] == oldOwner);
        tokenOwner[_tokenId] = newOwner;
    }

    function purchase(uint256 _tokenId) public payable {
        address oldOwner = tokenOwner[_tokenId];
        uint256 sellingPrice = emojiIndexToPrice[_tokenId];
        address newOwner = msg.sender;

        require(oldOwner != newOwner);

        require(newOwner != address(0));

        require(msg.value >= sellingPrice);

        uint256 percentage = SafeMath.sub(100, ownerCut);
        uint256 payment = uint256(SafeMath.div(SafeMath.mul(sellingPrice, percentage), 100));
        uint256 purchaseExcess = SafeMath.sub(msg.value, sellingPrice);

        emojiIndexToPrice[_tokenId] = SafeMath.div(SafeMath.mul(sellingPrice, 150), percentage);

        _transfer(oldOwner, newOwner, _tokenId);

        if (oldOwner != address(this)) {
           oldOwner.transfer(payment);
        }

        msg.sender.transfer(purchaseExcess);
    }


}"
5836-0-0.sol,answer,"contract Ceil {
    function ceil(uint a, uint m) constant returns (uint ) {
        return ((a + m - 1) / m) * m;
    }

    
    function ceil1(uint a, uint m) returns (uint ) {
        return ((a + m - 1) / m) * m;
    }
}"
10379-0-0.sol,answer,"contract My {
    uint someVar;
}"
10379-0-0.sol,answer,"contract MyTestabe is My {
    function someVar() constant returns(uint) {
        return someVar;
    }
}"
11673-0-0.sol,answer,"contract Test {
    int a = 999; 
    function doIt() {
        int b; 
        assembly {
            b := sload(a);
        }
    }
}"
51942-1-1.sol,answer,"contract GlobalGeneric is KeyValueStorage {

    function claimInterests(address _memberAddr, bytes32 _identifier) public view returns (bool success) {
        require(now > refreshTime[_memberAddr][_identifier] + 90 days);
        return true;
    }

}"
11882-0-0.sol,answer,"contract Test {
    enum GameState {noWager, wagerMade, wagerAccepted}

    GameState public currentState;

    modifier onlyState(GameState expectedState) {
        if (expectedState != currentState) {
            throw;
        }
        _;
    }

    modifier onlyStates(GameState expectedState1, GameState expectedState2) {
        if (expectedState1 != currentState && expectedState2 != currentState) {
            throw;
        }
        _;
    }

    function testWager() onlyStates(GameState.noWager, GameState.wagerMade) payable returns (bool) {

    }
}"
4202-0-2.sol,answer,"contract TestMistGas {
    uint256 number;

    function getNumber() constant returns (uint) {
        return number;
    }

    function setNumber(uint256 _number) {
        number = _number;
    }
}"
67108-0-0.sol,answer,"contract Test {
    uint public num;

    function setNum(uint myNum) public {
        num = myNum;
    }
}"
58662-1-0.sol,answer,"contract sendData {

    function transferToWithData(address payable dest, uint amount, bytes memory data) public payable {

        dest.call.value(amount)(data);
    }
}"
44306-0-1.sol,answer,"contract Caller {

    Called public called_address;

    function set_address(address _addy) {
        called_address = Called(_addy);
    }

    function set(uint256 _var) {
        called_address.set(_var);
    } 

}"
78738-2-0.sol,answer,"contract DeployContract {
    function deploy(bytes  _bytecode) external returns(address addr) {

        bytes memory bytecode = abi.encodePacked(_bytecode, abi.encode(msg.sender));
        assembly {
            addr := create(0, add(bytecode, 0x20), mload(bytecode))
            if iszero(extcodesize(addr)) {
                revert(0, 0)
            }
        }
    }
}"
8092-0-0.sol,answer,"contract Mapping {
    mapping(address => uint256) map;
    mapping(address => uint256) dupe;
    address[] keys;

    function add(uint256 value) {
        map[msg.sender] = value;
        keys.push(msg.sender);
    }

    function duplicate() {
        for(uint256 i; i < keys.length; i++) {
            dupe[keys[i]] = map[keys[i]];
        }
    }
}"
13726-1-0.sol,answer,"contract Transfer {


    
    
    address public recipient;
    mapping (address => uint) public balances;

    
    
    event Sent(address from, address to, uint amount );


    function send(address receiver, uint amount) {
        if (balances[msg.sender] < amount) return;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        return Sent(msg.sender, receiver, amount);
    }

}"
66849-0-0.sol,answer,"contract Hasher {

    function compare(string memory a, string memory b) public pure returns(bool) {
        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));
    }
}"
56891-1-0.sol,answer,"contract FantasyLeague {
  
  address public commissioner;
  
  uint[] public proposals;
  address[] public members;
  address[] public rightsGiven;


  constructor() public payable {
    commissioner = msg.sender;
  }

  function giveRightToVote(address newVoter) public payable {
    require(msg.sender == commissioner);
    
    rightsGiven.push(newVoter); 
  }
}"
15928-1-0.sol,answer,"contract TestInterface {
  function reentrance(address dest);
}"
15928-1-0.sol,answer,"contract Test is TestInterface {
  uint8 private _depth = 0;

  
  function () payable {}

  event Entered(uint8 depth);

  function reentrance(address dest) {
    if (_depth > 2) {
      
      throw;
    }
    Entered(_depth);
    _depth++;
    dest.transfer(this.balance);
  }
}"
15928-1-0.sol,answer,"contract Destination {
  function () payable {
    TestInterface sender = TestInterface(msg.sender);
    
    msg.sender.send(this.balance);
    sender.reentrance(this);
  }
}"
42062-0-2.sol,answer,"contract Test {
    RobustDividendToken token;

    function Test(RobustDividendToken _token) public {
        token = _token;
    }

    function deposit() public payable {
        token.deposit.value(msg.value)();
    }
}"
3342-2-0.sol,answer,"contract FunctionSelector {
  function select(bool useB, uint x) returns (uint z) {
    var f = a;
    if (useB) f = b;
    return f(x);
  }
  function a(uint x) returns (uint z) {
    return x * x;
  }
  function b(uint x) returns (uint z) {
    return 2 * x;
  }
}"
79080-0-0.sol,answer,"contract ERC20Basic {
    uint public _totalSupply;
    function totalSupply() public view virtual returns (uint);
    function balanceOf(address who) public virtual view returns (uint);
    function transfer(address to, uint value) public virtual;
    event Transfer(address indexed from, address indexed to, uint value);
}"
79080-0-0.sol,answer,"contract ERC20 is ERC20Basic {
    function allowance(address owner, address spender) public view virtual returns (uint);
    function transferFrom(address from, address to, uint value) public virtual;
    function approve(address spender, uint value) public virtual;
    event Approval(address indexed owner, address indexed spender, uint value);
}"
79080-0-0.sol,answer,"contract UpgradedStandardToken is StandardToken{
    
    
    function transferByLegacy(address from, address to, uint value) public virtual;
    function transferFromByLegacy(address sender, address from, address spender, uint value) public virtual;
    function approveByLegacy(address from, address spender, uint value) public virtual;
}"
69585-0-0.sol,answer,"contract MyContr {

    
    
    constructor() public payable {}

    function transfer(address payable receiver, uint amount) public {
        require(address(this).balance >= amount);
        receiver.transfer(amount);
    }
    
    
    function() external payable {}
}"
28239-0-6.sol,answer,"contract NestedArrays {

    function passNested(uint[][] nested) internal {
        
    }

    function returnNested() internal returns (uint[][]) {
        
    }
}"
79768-0-0.sol,answer,"contract Forwarder {
  address private owner;
  address payable private destination;

  constructor () public {
    owner = msg.sender;
    destination = msg.sender;
  }

  fallback () external payable {
    require (destination.send (address (this).balance));
  }

  function setDestination (address payable _destination) public {
    require (msg.sender == owner);
    destination = _destination;
  }
}"
19512-0-0.sol,answer,"contract B {
   function myFuncB(address address) constant returns(address) {
        return address;
        
   }    
}"
19512-0-0.sol,answer,"contract A {
   function myFuncA() {
    var obj = new B(msg.sender);
    obj.myFuncB();
   }    
}"
46335-0-1.sol,answer,"contract AInterface {
  function setValue(uint newValue) public returns(bool success);
}"
46335-0-1.sol,answer,"contract B {

  AInterface a;

  function B(address addressContractA) public {
    a = AInterface(addressContractA);
  }

  function setThatThing(uint newNumber) public returns(bool success) {
    return a.setValue(newNumber);
  }
}"
62160-0-0.sol,answer,"contract FourPlayers {

    uint public maxPlayers = 4;  
    address[] public players;
    mapping(address => bool) public isPlayer;

    event LogPlayerAdded(address player);

    function addMe() public returns(bool success) {
        require(!isPlayer[msg.sender]);
        require(players.length < maxPlayers);
        emit LogPlayerAdded(msg.sender);
        players.push(msg.sender);
        isPlayer[msg.sender] = true;
        return true;
    }
}"
64852-0-4.sol,answer,"contract contractB {

address public contractAaddress;
constructor(address deployedcontractA) public 
{
    contractAaddress = deployedcontractA;
}
function getContractAUsers() public view returns (address[]) {
   contractA contractInstance = contractA(contractAaddress);
   return contractInstance.getUsers.call(); 
}
}"
27111-0-0.sol,answer,"contract Okay {

    modifier onlyIfOkay() {
        require(isOkay(msg.sender));
        _;
    }

    function isOkay(address checkOkay) public pure returns(bool isIndeed) {
        
        return checkOkay==checkOkay;
    }

    function restricted() public view onlyIfOkay {
        
    }

}"
45290-0-3.sol,answer,"contract BInterface {
  function foo() public; 
}"
45290-0-3.sol,answer,"contract B is BInterface {
   function foo() public {
     
   }
}"
45290-0-3.sol,answer,"contract C {
  BInterface b;
  function doBFoo() public {
    b.foo();
  }
}"
40769-0-1.sol,answer,"contract MyContract {
    function myFunction(address _a) {
        MethodStringInterface(_a).method(""abc"");
    }
}"
65187-1-0.sol,answer,"contract AFactory {
    function createA() public returns(A) {
        return new A();
    }
}"
65187-1-0.sol,answer,"contract B {
    AFactory fac;
    constructor(AFactory _fac) {fac = _fac;}
    ...
        fac.createA()
    ...
}"
13018-0-1.sol,answer,contract SimpleStorage { uint storedData = 4; function set(uint x) { storedData = x; } function get() constant returns (uint retVal) { return storedData; }}
45559-1-0.sol,answer,"contract C {
    uint[] counters;
    function getCounter(uint index)
        returns (uint counter, bool error) {
            if (index >= counters.length) return (0, true);
            else return (counters[index], false);
        }
    function checkCounter(uint index) {
        uint counter;
        bool error;

        (counter, error) = getCounter(index);
        if (error) { ... }
        else { ... }
    }
}"
7322-2-0.sol,answer,"contract Base {
  uint foo;
  function Base(uint _foo) {
    foo = _foo;
  }
}"
7322-2-0.sol,answer,"contract Derived is Base {
  function Derived() {}
}"
74301-0-0.sol,answer,"contract Storage {
  uint256 storedData;
  function set(uint256 data) public {
    storedData = data;
  }
  function get() public view returns (uint256) {
    return storedData;
  }
}"
20797-0-0.sol,answer,"contract Token {

    string public symbol = ""token"";
    string public name = ""tkn"";
    uint8 public constant decimals = 18;
    uint256 _totalSupply = 0;

    event Received(address _from, uint256 amount);

    function Token(uint256 _supply){
        _totalSupply =  _supply;
    }

    function () payable {
        Received(msg.sender, msg.value);
    }
}"
52960-0-4.sol,answer,"contract B is A {
    uint state;
    
    constructor() A() public { state = 0; }
    function performOperation() internal { state = state + 1; }
}"
27259-1-0.sol,answer,"contract GeometryShapesData {
    struct Point {
        uint x;
        uint y;
    }
}"
27259-1-0.sol,answer,"contract A is GeometryShapesData {
    mapping (bytes32 => Point) public points;
    function addPoint(bytes32 idx, uint x, uint y) public { 
        points[idx] = Point(x, y);
    }
    function getPoint(bytes32 idx) constant public returns (uint x, uint y) {
        return (points[idx].x, points[idx].y);
    }
}"
27259-1-0.sol,answer,"contract B is GeometryShapesData {
    Point[4] public vertexes;
    function addVertex(uint pos, uint x, uint y) public { 
        vertexes[pos] = Point(x, y);
    }
    function getVertex(uint pos) constant public returns (uint x, uint y) {
        return (vertexes[pos].x, vertexes[pos].y);
    }
}"
13594-0-1.sol,answer,"contract FourWaySplit {

  

  mapping(address => uint) public beneficiaryBalance;
  address[4] public beneficiaryList;

  

  event LogReceived(address sender, uint amount);
  event LogWithdrawal(address beneficiary, uint amount);

  

  function FourWaySplit(address addressA, address addressB, address addressC, address addressD) {
    beneficiaryList[0]=addressA;
    beneficiaryList[1]=addressB;
    beneficiaryList[2]=addressC;
    beneficiaryList[3]=addressD;
  }

  

  function pay() 
    public
    payable
    returns(bool success)
  {
    if(msg.value==0) throw;

    
    

    uint forth = msg.value / 4;

    beneficiaryBalance[beneficiaryList[0]] += forth;
    beneficiaryBalance[beneficiaryList[1]] += forth;
    beneficiaryBalance[beneficiaryList[2]] += forth;
    beneficiaryBalance[beneficiaryList[3]] += forth;
    LogReceived(msg.sender, msg.value);
    return true;
  }

  function withdraw(uint amount)
    public
    returns(bool success)
  {
    if(beneficiaryBalance[msg.sender] < amount) throw; 
    beneficiaryBalance[msg.sender] -= amount;          
    if(!msg.sender.send(amount)) throw;                
    LogWithdrawal(msg.sender, amount);
    return true;
  }

}"
64713-0-0.sol,answer,"contract Sender {

    uint public amount = 1 ether;

    function send(address payable _addr) payable public {
        require(msg.value >= amount);
        _addr.transfer(msg.value);
    }
}"
76537-0-0.sol,answer,"contract Main is Ownable {

    User[] private _users;
    mapping(uint256 => bool) userExists;

    function createUser(uint256 _id) onlyOwner external {
        require(!userExists[_id], ""User already exists."");
        userExists[_id] = true;

        User user = new User(_id);

        emit UserCreated(user, _users.length);

        _users.push(user);
    }
}"
57960-1-1.sol,answer,"contract Register is IRegister {
    string private name;

    constructor(string entityname) public {
        name = entityname;
    }

    function getName() public view returns (string) {
        return name;
    }
}"
79050-0-0.sol,answer,"contract MyERC20Token {
    ...

    function transfer(address to, uint256 value) public returns (bool) {
        require(value % 100 == 0);
        ...
    }

    function transferFrom(address from, address to, uint256 value) public returns (bool) {
        require(value % 100 == 0);
        ...
    }

    ...
}"
45915-3-0.sol,answer,"contract Replicator {

  address public parent;

  function replicate() public returns(address) {
      address childAddress = clone(address(this));
      Replicator child = Replicator(childAddress);
      child.setParent(address(this));
      return child;
  }

  function setParent(address addr) public {
      parent = addr;
  }

  function clone(address a) public returns(address)  {
    address retval;
    assembly{
        mstore(0x0, or (0x5880730000000000000000000000000000000000000000803b80938091923cF3 ,mul(a,0x1000000000000000000)))
        retval := create(0,0, 32)
    }
    return retval;
 }
}"
8210-0-0.sol,answer,"contract myContract {
    struct dataObject {
        uint a;
        address b;
    }
    mapping (uint => dataObject) public myMap;
    function setObject(uint key, uint _a, address _b) {
        myMap[key] = dataObject(_a,_b);
    }
}"
41576-1-0.sol,answer,"contract number {
    uint public num = 0; 

    function setNum(uint _num) public {
        num = _num;
        
    }

    function setNumCheck(uint _num) public {
        if (num != _num) {
          num = _num;
        }
        
    }"
66746-0-3.sol,answer,"contract OrderMatters {

    

    address it; 

    constructor() public {
        it = msg.sender;
    }

    function tagYoureIt(address _newIt) public returns(address newIt) {
        require(msg.sender == it); 
        it = _newIt;
        return it;
    }
}"
39665-0-2.sol,answer,"contract ValueSetter {

  struct ValueStruct {
    uint256 value;
  }

  address public my_address; 

  mapping(address => ValueStruct) public valueStructs;

  function ValueSetter() public {
    my_address = msg.sender;
  }

  function set_value(uint256 my_value) external {

    
    require(msg.sender == my_address && my_value != 0);

    
    

    valueStructs[msg.sender].value = my_value;

    
    assert(valueStructs[msg.sender].value != 0);
  }
}"
678-0-0.sol,answer,"contract Foo {
    address bazz;
    string abiSignature;

    function Foo (address _bazz, string _abi) public {
        bazz = _bazz;
        abiSignature = _abi;
    }

    function updateABI (string _ABI) public {
        abiSignature = _ABI;
    }

    function callBazz(uint256 arg) public returns (bool bazzLib){
        bool bazzCall =  bazz.call(bytes4(sha3(abiSignature)), arg); 
        bool bazzLib  = bazz.callcode(bytes4(sha3(abiSignature)), arg); 
    }
}"
78837-0-0.sol,answer,"contract CheckBehavior {

    mapping(address => uint256) _deposits;

    function depo() public payable{
        _deposits[msg.sender]= msg.value;
    }

    function checkBalance() public returns (uint) {
        return address(this).balance;
    }

    function withdrawA(uint256 _amt) public {

        msg.sender.transfer(_amt);
    }

    function withdrawB(address payable payee, uint256 _amt) public {

        payee.transfer(_amt);
    }

    function withdrawWithGas(address payable payee) public {
        uint256 payment = _deposits[payee];

        _deposits[payee] = 0;

        payee.transfer(payment);
    }
}"
39557-0-0.sol,answer,"contract ModiferTesting {
   uint public a;
   uint public b;
   uint public c;

   modifier modA() {
    a = a + 1;
    _;
   }

   modifier modB() {
    b = b + 1;
    _;
    b = b + 1;
    _;
    b = b + 1;
    _;
  }

  function test() public modA modB {
    c = c + 1;
  }
}"
11016-0-0.sol,answer,"contract Foo {

    
    struct Milestone {

        
        uint time;

        
        uint price;
    }

    Milestone[] milestones;

    function getMilestone(uint n) public constant returns (uint, uint ) {
        return (milestones[n].time, milestones[n].price);
    }    
}"
54748-0-0.sol,answer,"contract Test {
    struct File {
        string fileName;
        string fileHash;
    }

    File[] files;

    function addFile(string fileName, string fileHash) public {
        File memory f = File(fileName, fileHash);
        files.push(f);
    }

    
    function getFiles(uint256 index) public view returns (string, string) {
        return (files[index].fileName, files[index].fileHash);
    }
}"
39184-0-0.sol,answer,"contract Test {

    mapping (uint => uint) public grid;

    function check(uint x, uint y, uint size) public {

        for(uint i = 0; i < size; i++) {
            uint row = grid[x + i];
            for(uint j = 0; j < size; j++) {
                
                if((row >> (y + j)) & uint(1) == uint(1)) {
                    
                    revert();
                }

                
                row = row | (uint(1) << (y + j)); 
            }
            grid[x + i] = row;
        }
    }
}"
39782-1-0.sol,answer,"contract GoldNodes {

    address goldNodeOwner ;

    
    mapping (address => bool) isGoldNode;
    uint goldNodeCount = 0;

    
    mapping (address => bool) hasGoldNodeReplied;    
    uint replyCount = 0;

    
    bool allGoldNodesReplied = false;


    constructor() public{
        goldNodeOwner = msg.sender;
    }


    function addGoldNode(address _goldNode) public {
        
        require(msg.sender == goldNodeOwner, ""only gold owner allowed"");
        isGoldNode[_goldNode] = true;
        goldNodeCount++; 
    }

    function reply() public {
        require(isGoldNode[msg.sender], ""only gold nodes can reply"");
        require(!hasGoldNodeReplied[msg.sender], ""Can not reply twice"");
        replyCount++;
        hasGoldNodeReplied[msg.sender] = true;
        if(replyCount == goldNodeCount){
            allGoldNodesReplied = true;
        }

    }

}"
63504-0-0.sol,answer,"contract Election {

struct Candidate {
    string name;
    uint voteCount; }

struct Voter {
    bool authorized;
    bool voted;
    uint vote; }

address public owner; string public electionName;

mapping(address => Voter) public voters; Candidate[] public candidates; uint public totalVotes;

modifier ownerOnly(){
    require(msg.sender == owner);
    _; }

constructor (string memory _name) public {
    owner = msg.sender;
    electionName = _name; }

function addCanditate(string memory _name) ownerOnly public {
    candidates.push(Candidate(_name, 0)); }

function getNameCandidate() public view returns(uint){
    return candidates.length; }

function authorize (address _person) ownerOnly public {
    voters[_person].authorized = true; }

function vote (uint _voteIndex) public {
    require(!voters[msg.sender].voted);
    require(voters[msg.sender].authorized);

    voters[msg.sender].vote = _voteIndex;
    voters[msg.sender].voted = true;

    candidates[_voteIndex].voteCount += 1;
    totalVotes += 1; } function end() ownerOnly public {
    selfdestruct(msg.sender); }

}"
10399-1-1.sol,answer,"contract HelloWorld {
    event Print(string out);
    function() {
      Print(""Hello, World!"");
    }
    function test() constant returns (int) {
      return 7;
    }
  }"
10108-0-0.sol,answer,"contract TestContract {
    enum TestEnum { ONE, TWO, THREE }
    mapping (bytes32 => uint) testMapping;

    function getValueOne() constant returns(uint) {
        return testMapping[sha3(TestEnum.ONE)];
    }

}"
59601-1-0.sol,answer,"contract Counter {

    struct UserStruct {
        uint balance;
        uint counter;
    }

    mapping(address => UserStruct) public userStructs;

    function deposit() public payable returns(bool success) {
        require(msg.value > 0);
        userStructs[msg.sender].balance += msg.value;
        userStructs[msg.sender].counter ++;
        return true;
    }
}"
72687-0-0.sol,answer,"contract Contract {

    MyContract contract1 = new MyContract();

    function getSelector() public view returns (bytes4, bytes4) {
        return (contract1.function1.selector, contract1.getBalance.selector);
    }

    function callGetValue(uint _x) public view returns (uint) {

        bytes4 selector = contract1.getValue.selector;

        bytes memory data = abi.encodeWithSelector(selector, _x);
        (bool success, bytes memory returnedData) = address(contract1).staticcall(data);
        require(success);

        return abi.decode(returnedData, (uint256));
    }
}"
72687-0-0.sol,answer,"contract MyContract {

    function function1() public {}

    function getBalance(address _address) public view returns (uint256){}

    function getValue (uint _value) public pure returns (uint) {
        return _value;
    }

}"
41255-0-0.sol,answer,"contract Test {
   
   uint[3] storage_array;

   function getArray() public view returns(uint[3]){
       return storage_array;
   }

   
   function setArray() public {
       uint[3] memory tmp = [uint(1),2,3];
       storage_array =tmp;
   }

   
   function fillTemp() public returns (uint[3]) {
       uint[3] memory tmp = [uint(1),2,3];
       return tmp;
   }

}"
44816-0-1.sol,answer,"contract X {
    struct PRODUCT {
        uint price;
        uint quantity;
    }

    mapping (string => mapping (bytes12  PRODUCT) ) products;

    function appendDetails(string pid, bytes12 productid, uint price, uint quantity) payable public {
        products[pid][productid].push(PRODUCT(price, quantity));
    }

    function getDetails(string pid, bytes12 productid) 
    public view returns(uint price, uint quantity) {
        PRODUCT storage p = products[pid][productid];

        price = p.price;
        quantity = p.quantity;
    }
}"
79911-0-0.sol,answer,"contract Test {
    function b32ToU24(bytes32 barray) external pure returns (uint24) {
        return uint24(bytes3(barray << 24));
    }

    function b32ToU24ASM(bytes32 barray) external pure returns (uint24) {
        uint24 result;

        assembly {
            
            
            result := shr(0xd0, barray)
        }

        return result;
    }
}"
26674-0-5.sol,answer,"contract ShippingInterface {
  function doStuff() ... ;
}"
26674-0-5.sol,answer,"contract Shipping is ShippingInterface {
  function doStuff() .. { 
}"
79435-0-1.sol,answer,"contract NullVals {

    struct Test {
        address a;
        uint256 b;
        bytes32 c;
        address d;
    }

    mapping(bytes32 => Test) public tests;

    function silentSetter(bytes32 key, address a) public {
        Test storage t = tests[key];
        t.a = a;
    }

}"
17094-4-0.sol,answer,"contract MyContract {

  event AddFile(address indexed owner, bytes32 digest, bytes2 hashFunction, uint8 size, bytes4 storageEngine);

  function addFile(bytes32 _digest, bytes2 _hashFunction, uint8 _size, bytes4 _storageEnginge) public {
    emit AddFile(msg.sender, _digest, _hashFunction, _size, _storageEngine);
  }
}"
76297-0-1.sol,answer,"contract Constants {
    uint8 public constant BUY_ID = 1;
    uint8 public constant SUBSCRIBE_ID = 2;
}"
76297-0-1.sol,answer,"contract BuyContract is Constants {

    uint256 public lastAmount;

    function buyMethod(uint8 _buyArg) payable public {
        require(_buyArg == BUY_ID);
        lastAmount = msg.value;
    }

}"
76297-0-1.sol,answer,"contract SubscribeContract is Constants {

    uint256 public lastAmount;

    function subscribeMethod(uint8 _subscribeArg) payable public {
        require(_subscribeArg == SUBSCRIBE_ID);
        lastAmount = msg.value;
    }

}"
76297-0-1.sol,answer,"contract MyContract is Constants {
    using SafeMath for uint256;

  function singleTransaction(
      address _buyAddress,
      address _subscribeAddress
  ) payable public {
      BuyContract buyContract = BuyContract(_buyAddress);
      SubscribeContract subContract = SubscribeContract(_subscribeAddress);
      uint256 halfValue = msg.value.div(2);
      buyContract.buyMethod.value(halfValue)(BUY_ID);
      subContract.subscribeMethod.value(halfValue)(SUBSCRIBE_ID);
  }

}"
8095-0-1.sol,answer,"contract Caller {
    Tool public tool;
    uint public saved;

    function Caller(address _tool) {
        tool = Tool(_tool);
        saved = 0;
    }

    function changeNumber() {
        if (tool.numberIsEven()) {
            saved = 2;
        } else {
            saved = 1;
        }
    }
}"
43399-1-0.sol,answer,"contract Balance {

  function () external payable {}

  function contractBalance() public view returns (uint) {
    return address(this).balance;
  }
}"
60414-1-0.sol,answer,"contract YourContract {

  struct TargetCoreBase {
    uint hp;
    uint levels;
    uint AlienCount;
    uint TargetAliens;
    uint LossCounter;
    uint WinCounter;
    uint battles;
  }

  TargetCoreBase[] target;

  mapping(uint => address) base;

  address owner = msg.sender;

  function CreateTarget(uint _hp, uint _levels, uint _AlienCount, uint _TargetAliens, uint _LossCounter, uint _WinCounter, uint _battles) internal {
    uint TargetId =  target.push(TargetCoreBase(_hp, _levels, _AlienCount, _LossCounter, _WinCounter, 0, 0));
    base[TargetId];
  }

  string TargetCoreBaseErr = ""No CoreBase level"";

  function CheckTargetPairing(uint _battles) returns (bool) {
    if (_battles == 0) {
      return true;
    } else {
       return false;
    }
  }
}"
65884-0-0.sol,answer,"contract BuyPreimage {
    address payable buyer;
    address payable seller;
    bytes32 public hash;
    uint256 public deadline;

    constructor(address payable _seller, bytes32 _hash, uint256 timeout) public payable {
        buyer = msg.sender;
        seller = _seller;

        hash = _hash;
        deadline = now + timeout;
    }

    
    function providePreimage(bytes calldata preimage) external {
        require(keccak256(preimage) == hash);
        seller.transfer(address(this).balance);
    }

    
    function refund() external {
        require(msg.sender == buyer);
        require(now >= deadline);

        msg.sender.transfer(address(this).balance);
    }
}"
80743-0-0.sol,answer,"contract TestNode { 
    uint[] nodes;

    function createNode(uint data) public {
        delete nodes; 
        nodes.push(data);
    }

    function pushNode(uint data) public {
        nodes.push(data);
    }

    function getNode() public view returns(uint[] memory) {
        return nodes;
    }
}"
42200-1-1.sol,answer,"contract B is ERC721 {
  uint nextDogID = 0;
  IERC721 a = ...;

  function catToDog (uint _catID) public (returns _dogID) {
    _dogID = nextDogID++;
    _mint (msg.sender, _dogID);
    copyGene (_catID, _dogID);

    
    require (a.transferFrom (
      msg.sender,
      0x000000000000000000000000000000000000dead,
      _catID));
  }
}"
6562-1-0.sol,answer,"contract Congress is owned {

    
    uint public minimumQuorum;
    uint public debatingPeriodInMinutes;
    int public majorityMargin;
    Proposal[] public proposals;
    uint public numProposals;
    mapping (address =&gt; uint) public memberId;
    Member[] public members;

    event ProposalAdded(uint proposalID, address recipient, uint amount, string description);
    event Voted(uint proposalID, bool position, address voter, string justification);
    event ProposalTallied(uint proposalID, int result, uint quorum, bool active);
    event MembershipChanged(address member, bool isMember);
    event ChangeOfRules(uint minimumQuorum, uint debatingPeriodInMinutes, int majorityMargin);

    struct Proposal {
        address recipient;
        uint amount;
        string description;
        uint votingDeadline;
        bool executed;
        bool proposalPassed;
        uint numberOfVotes;
        int currentResult;
        bytes32 proposalHash;
        Vote[] votes;
        mapping (address =&gt; bool) voted;
    }

    struct Member {
        address member;
        bool canVote;
        string name;
        uint memberSince;
    }

    struct Vote {
        bool inSupport;
        address voter;
        string justification;
    }

    
    modifier onlyMembers {
        if (memberId[msg.sender] == 0
        || !members[memberId[msg.sender]].canVote)
        throw;
        _
    }

    
    function Congress(
        uint minimumQuorumForProposals,
        uint minutesForDebate,
        int marginOfVotesForMajority, address congressLeader
    ) {
        changeVotingRules(minimumQuorumForProposals, minutesForDebate, marginOfVotesForMajority);
        members.length++;
        members[0] = Member({member: 0, canVote: false, memberSince: now, name: &#39;&#39;});
        if (congressLeader != 0) owner = congressLeader;

    }

    
    function changeMembership(address targetMember, bool canVote, string memberName) onlyOwner {
        uint id;
        if (memberId[targetMember] == 0) {
           memberId[targetMember] = members.length;
           id = members.length++;
           members[id] = Member({member: targetMember, canVote: canVote, memberSince: now, name: memberName});
        } else {
            id = memberId[targetMember];
            Member m = members[id];
            m.canVote = canVote;
        }

        MembershipChanged(targetMember, canVote);

    }

    
    function changeVotingRules(
        uint minimumQuorumForProposals,
        uint minutesForDebate,
        int marginOfVotesForMajority
    ) onlyOwner {
        minimumQuorum = minimumQuorumForProposals;
        debatingPeriodInMinutes = minutesForDebate;
        majorityMargin = marginOfVotesForMajority;

        ChangeOfRules(minimumQuorum, debatingPeriodInMinutes, majorityMargin);
    }

    
    function newProposal(
        address beneficiary,
        uint etherAmount,
        string JobDescription,
        bytes transactionBytecode
    )
        onlyMembers
        returns (uint proposalID)
    {
        proposalID = proposals.length++;
        Proposal p = proposals[proposalID];
        p.recipient = beneficiary;
        p.amount = etherAmount;
        p.description = JobDescription;
        p.proposalHash = sha3(beneficiary, etherAmount, transactionBytecode);
        p.votingDeadline = now + debatingPeriodInMinutes * 1 minutes;
        p.executed = false;
        p.proposalPassed = false;
        p.numberOfVotes = 0;
        ProposalAdded(proposalID, beneficiary, etherAmount, JobDescription);
        numProposals = proposalID+1;
    }

    
    function checkProposalCode(
        uint proposalNumber,
        address beneficiary,
        uint etherAmount,
        bytes transactionBytecode
    )
        constant
        returns (bool codeChecksOut)
    {
        Proposal p = proposals[proposalNumber];
        return p.proposalHash == sha3(beneficiary, etherAmount, transactionBytecode);
    }

    function vote(
        uint proposalNumber,
        bool supportsProposal,
        string justificationText
    )
        onlyMembers
        returns (uint voteID)
    {
        Proposal p = proposals[proposalNumber];         
        if (p.voted[msg.sender] == true) throw;         
        p.voted[msg.sender] = true;                     
        p.numberOfVotes++;                              
        if (supportsProposal) {                         
            p.currentResult++;                          
        } else {                                        
            p.currentResult--;                          
        }
        
        Voted(proposalNumber,  supportsProposal, msg.sender, justificationText);
    }

    function executeProposal(uint proposalNumber, bytes transactionBytecode) returns (int result) {
        Proposal p = proposals[proposalNumber];
        

        if (now &lt; p.votingDeadline
            || p.executed
            || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode)
            || p.numberOfVotes &lt; minimumQuorum)
            throw;

        
        
        if (p.currentResult &gt; majorityMargin) {
            

            p.executed = true;
            if (!p.recipient.call.value(p.amount * 1 ether)(transactionBytecode)) {
                throw;
            }

            p.proposalPassed = true;
        } else {
            p.proposalPassed = false;
        }
        
        ProposalTallied(proposalNumber, p.currentResult, p.numberOfVotes, p.proposalPassed);
    }
}"
3342-0-0.sol,answer,"contract C1 {
    uint public _n;  

    function foo(uint n) returns(uint) {
        _n = n;
        return _n;
    }

    function invoke(bytes4 methodId, uint n) returns(bool) {
        return this.call(methodId, n);
    }
}"
24713-0-1.sol,answer,"contract Service{
  function isAlive() constant returns(bool alive) {} 
}"
24713-0-1.sol,answer,"contract Client {
  Service _s; 

  function Client(address serviceAddress) {
    _s = Service(serviceAddress); 
  }

  function Ping() public constant returns(bool response) {
    return _s.isAlive(); 
  }
}"
67853-0-0.sol,answer,"contract ApprovalContracts { 

  address public sender;   
  address payable public receiver; 
  address public approver = 0xc7780C9521C2C2abED69f0D65BEbF9794C55ae94;  

  function deposit(address payable _receiver) external payable {  

    require(msg.value >0); 
    sender = msg.sender; 
    receiver = _receiver;
  }

  function viewApprover() external view returns(address) { 
    return approver;
  }

  function approve() external { 
    require(msg.sender == approver); 
    receiver.transfer(address(this).balance);
  }

}"
46859-1-1.sol,answer,"contract MyContract is Ownable {
    function start() external onlyOwner {
        ...
    }

    function stop() external onlyOwner {
        ...
    }
}"
62824-0-2.sol,answer,"contract Refund {

    bool public isRefunding;
    mapping(address => uint) public balances;

    event LogInvestment(address investor); 
    event LogRefundStarted();
    event LogRefundSent(address investor, uint amount);

    function invest() public payable returns(bool success) {
        require(!isRefunding);
        require(msg.value == 0.1 ether);  
        balances[msg.sender] +=  msg.value;
        emit LogInvestment(msg.sender);
        return true;
    }

    

    function setRefunding() public returns(bool success) {
        require(!isRefunding);
        emit LogRefundStarted();
        return true;
    }

    function claimRefund() public returns(bool success) {
        uint amount = balances[msg.sender];
        require(amount > 0);
        balances[msg.sender] = 0;
        emit LogRefundSent(msg.sender, amount);
        return true;
    }

}"
9205-0-0.sol,answer,"contract MyContract {
    address public oracle;
    uint public lastAliveTime;

    modifier throwUnless(bool condition) {
        if (!condition) { throw; }
        _;
    }

    function MyContract() {
        oracle = msg.sender;
        showProofOfLife();
    }

    function showProofOfLife() throwUnless(msg.sender == oracle) {
        lastAliveTime = now;
    }

    function doSomethingUseful() throwUnless((now - lastAliveTime) < 15 minutes) {
        
    }
}"
72820-0-0.sol,answer,"contract ArrayOfStructs {

    

    struct Thing {
        uint a;
        bool b;
    }

    

    Thing[] public things; 

    event LogAppendThing(address sender, uint a, bool b);

    

    function append(uint _a, bool _b) public {
        Thing memory t = Thing({
            a: _a,
            b: _b
        });
        things.push(t);

        

        emit LogAppendThing(msg.sender, _a, _b);
    }

    

    

    

    function thingCount() public view returns(uint count) {
        return things.length;
    }
}"
41576-0-0.sol,answer,"contract X {
    mapping (address => uint) l;

    function lock() {
        l[msg.sender] = now;
    }

    function unlock() {
        delete l[msg.sender];
    }

    function unlock2() {
        if(l[msg.sender] > 0)
            delete l[msg.sender];
    }
}"
11372-0-0.sol,answer,"contract Test {
    address primaryUser;

    function Test(address _primaryUser) {
        primaryUser = _primaryUser;
    }
}"
17951-1-0.sol,answer,"contract Message {

    address public owner;
    string public message;

    function Message() public {
      message = ""Initial Message"";
      owner = msg.sender;
    }

    function retrieveMessage() constant
       returns (string _messageString)
    {
      return message;
    }

    

    function setMessage(string messageString) 
      returns(bool success) 
    {
      if(msg.sender != owner) throw; 
      message = messageString;
      return true;
    }

}"
79826-0-0.sol,answer,"contract SafeMath {
    
    function mul(uint256 a, uint256 b) internal pure returns (uint256) {
        
        
        
        if (a == 0) {
            return 0;
        }

        uint256 c = a * b;
        require(c / a == b);

        return c;
    }

    
    function div(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b > 0);
        
        uint256 c = a / b;
        

        return c;
    }

    
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b <= a);
        uint256 c = a - b;

        return c;
    }

    
    function add(uint256 a, uint256 b) internal pure returns (uint256) {
        uint256 c = a + b;
        require(c >= a);

        return c;
    }

    
    function mod(uint256 a, uint256 b) internal pure returns (uint256) {
        require(b != 0);
        return a % b;
    }
}"
79826-0-0.sol,answer,"contract TestContract is SafeMath {
    uint public transactionCount = 0;
    uint public transactionAmount = 0;

    function payBill(address payable account) payable public {
        transactionCount = add(transactionCount, 1);
        transactionAmount = add(transactionAmount, msg.value);

        address(account).transfer(msg.value);
    }
}"
9697-0-0.sol,answer,"contract D {
  function deposit(address c1, address c2) payable {
     uint amount1 = msg.value / 2;
     uint amount2 = msg.value - amount1;
     
     if (!c1.send(amount1)) throw;
     if (!c2.send(amount2)) throw;
  }
}"
70834-0-0.sol,answer,"contract ECRecover {
    function ECR(bytes32 _Msg, uint8 _v, bytes32 _r, bytes32 _s) public pure returns (address) {
        return ecrecover(_Msg, _v, _r, _s);
    }
}"
33640-0-1.sol,answer,"contract B {

    uint public data = 34;

    function killContractA(address _a) public {
        A a = A(_a);
        a.bye();
    }

    function killMyself(address _a) public {
        _a.delegatecall(bytes4(keccak256(""bye()"")));
    }
}"
65697-0-1.sol,answer,"contract SimpleStore {
    uint256 public value;
    address public addr;

    function set(address[] calldata _addr, uint256[] calldata _value) external {
        value = _value[0];
        addr = _addr[0];
    }

    function get() external view returns (uint256) {
        return value;
    }
}"
77238-0-0.sol,answer,"contract Test {

    struct MyStruct {
        uint256 x;
        uint256 y;
    }

    function testFunc() public pure returns (uint, uint) {
        MyStruct memory data1 = MyStruct(5,7);
        return myFunc(data1);
    }

    function myFunc(MyStruct memory data) internal pure returns (uint256 _z, uint _w) {
        assembly {
            _z := mload(data)
            _w := mload(add(data,0x20))
        }
    }
}"
52386-0-0.sol,answer,"contract StatelessUserRegisty {

    Storage dataStore;

    constructor() public {
        dataStore = new Storage();
    }

    function userKey(address userAddr) public pure returns(bytes32 userID) {
        return keccak256(abi.encodePacked(userAddr));
    }

    function isUser(address userAddr) public view returns(bool isIndeed) {
        return dataStore.getBool(userKey(userAddr));
    }

    function createUser(address userAddr) public returns(bool success) {
        require(!isUser(userAddr));
        dataStore.setBool(userKey(userAddr),true);
        return true;
    }

    function updateUserPoints(address userAddr, uint userPoints) public returns(bool success) {
        require(!isUser(userAddr));
        dataStore.setUint(userKey(userAddr),userPoints);
        return true;
    }

}"
18565-0-0.sol,answer,"contract MyTest { 

        function myfunc(uint a) private returns (uint b) {
            b = a+1;
        }

        function first(uint a) constant returns (uint b) { 
            b = myfunc(a);
        }
    }"
7325-0-0.sol,answer,"contract Test {

    struct  User{
        uint256 uuid;
        bytes32 first_name;
        bytes32 last_name;
        bytes32 sex;
        bytes32 age;
        bytes32 birth_day;
        bytes32 addr;
        bytes32 mail_address;
        bytes32 phone_number;
    }

    mapping(uint256 => User) users;

    function getUser(uint256 uuid) public constant returns (bytes32, bytes32, bytes32, bytes32, bytes32, bytes32, bytes32, bytes32) {
        User memory u = users[uuid];
        return (
            u.first_name,
            u.last_name,
            u.sex,
            u.age,
            u.birth_day,
            u.addr,
            u.mail_address,
            u.phone_number
        );
    }
}"
63356-0-0.sol,answer,"contract One {
    function callme() external {
        
    }
}"
63356-0-0.sol,answer,"contract Two {
    
    
    function callOne(One one) external {
        
        one.callme();
    }
}"
76678-0-2.sol,answer,"contract WeHaveMoneyToBurn {

    mapping(address => uint) public userBalances;

    event LogDeposit(address depositor, uint amount);
    event LogWithdrawl(address withdrawer, uint amount);
    event LogFundsDestroyed(address victim, uint amount);

    
    function deposit() public payable {
        userBalances[msg.sender] += msg.value;
        emit LogDeposit(msg.sender, msg.value);
    }

    
    function withdraw(uint amount) public {
        require(amount <= userBalances[msg.sender], ""Insufficient Funds"");
        userBalances[msg.sender] -= amount;
        emit LogWithdrawl(msg.sender, amount);
        msg.sender.transfer(amount);
    }

    
    function burnSome(address burnFrom, uint amount) public {
        require(amount <= userBalances[burnFrom], ""User does have that much to burn"");
        userBalances[burnFrom] -= amount;
        emit LogFundsDestroyed(burnFrom, amount);
        address(0).transfer(amount);
    }
}"
43650-0-0.sol,answer,"contract Ownable {
    event OwnableE(uint);
    function Ownable() public {
        emit OwnableE(1);
    }
}"
43650-0-0.sol,answer,"contract TimedCrowdsale {
    event TimedCrowdsaleE(uint);
    function TimedCrowdsale() public {
        emit TimedCrowdsaleE(1);
    }
}"
43650-0-0.sol,answer,"contract Crowdsale {
    event CrowdsaleE(uint);
    function Crowdsale() public {
        emit CrowdsaleE(1);
    }
}"
43650-0-0.sol,answer,"contract CappedCrowdsale is Crowdsale {
    event CappedCrowdsaleE(uint);
    function CappedCrowdsale() public {
        emit CappedCrowdsaleE(1);
    }
}"
43650-0-0.sol,answer,"contract RefundableCrowdsale is FinalizableCrowdsale {
    event RefundableCrowdsaleE(uint);
    function RefundableCrowdsale() public {
        emit RefundableCrowdsaleE(1);
    }
}"
43650-0-0.sol,answer,"contract MintedCrowdsale is Crowdsale { 
    event MintedCrowdsaleE(uint);
    function MintedCrowdsale() public {
        emit MintedCrowdsaleE(1);
    }
}"
76016-0-1.sol,answer,"contract Receiver {

address public owner;

constructor() public {
    
    owner = msg.sender;
}


function transferOwner(address newOwner) public {
    require (msg.sender == owner);
    owner = newOwner;
}


function sendFundsTo( address tracker, uint256 amount, address receiver) public returns ( bool ) {
    
    require(msg.sender == owner);

    
    return ERC20(tracker).transfer(receiver, amount);
}



}"
58550-0-0.sol,answer,"contract TimeStamps {

    mapping(address => uint[]) public addressTimeStamps;
    mapping(address => bool) public isContentProvider;
    address[] public contentProviders;

    

    event LogNewAddressTimeStamp(address sender, address contentProvider, uint timeStamp);

    function setTimeStamp(address contentProvider, uint timeStamp) public returns(bool success) {
        require(contentProvider != 0);
        require(timeStamp != 0);
        if(!isContentProvider[contentProvider]) {
            isContentProvider[contentProvider] = true;
            contentProviders.push(contentProvider);
        }
        addressTimeStamps[contentProvider].push(timeStamp);
        emit LogNewAddressTimeStamp(msg.sender, contentProvider, timeStamp);
        return true;
    }


    

    function getTimeStamp(address contentProvider, uint row) public view returns(uint timeStamp) {
        return(addressTimeStamps[contentProvider][row]);
    }

    

    function getAddressTimeStampCount(address contentProvider) public view returns(uint count) {
        return addressTimeStamps[contentProvider].length;
    }

    function getContentProviderCount() public view returns(uint count) {
        return contentProviders.length;
    }

}"
61687-2-2.sol,answer,"contract Crowdfunding {
    struct Request {
        string description;
        uint value;
        address recipient;
        bool complete;
    }

    Request[] public requests;
    address public manager;
    uint public minimumContribution;
    address[] public approvers;

    function Crowdfunding(uint minimum) public {
        manager = msg.sender;
        minimumContribution = minimum;
    }"
59994-0-0.sol,answer,"contract Parent {
    string w;

    function Set(string _w) public {
        w = _w;
    }

    function Greet(string name) internal view returns(string) {
        return string(abi.encodePacked(w, name));
    }
}"
59994-0-0.sol,answer,"contract Child is Parent {
    function Get() public view returns(string) {
        return Greet(""Bob"");
    }
}"
17964-1-0.sol,answer,"contract Thingy {
    uint256[] stateArray;
    function doStuff() public {

        
        
        
        

        uint256[] localReference = stateArray;

        
        
        

        uint256[] memory memArray = new uint256[](5);
    }
}"
79001-0-0.sol,answer,"contract AbiTwoTest {

    struct Item {
        string str;
        uint   num;
        bool   bol;
    }

    struct Arg {
        Item[] items;
    }

    mapping (address => Arg) itemsByUser;

    
    event ItemAdded(string indexed str, uint num, bool bol);

    
    function addItem(Item memory _item) public {
        itemsByUser[msg.sender].items.push(_item);
        emit ItemAdded(_item.str, _item.num, _item.bol);
    }

    
    function item(address addr) public view returns (Arg memory items) {
        return itemsByUser[addr];
    }
}"
56077-2-0.sol,answer,"contract BytesToUint {

    function toUint(bytes _value) external pure returns (uint) {
        return toUint_(_value);
    }

    function toUint_(bytes memory _value) internal pure returns (uint) {
        uint256 r;

        for(uint256 i = 0; i < _value.length; i++) {
            r += uint256(_value[i]) << (i * 8);
        }
        return r;
    }
}"
3667-1-0.sol,answer,"contract Caller {
uint public value;
address public sender;

function callSetValue(address _callee, uint _value) {
    _callee.call(bytes4(sha3(""setValue(uint256)"")), _value); 
}

function callcodeSetValue(address _callee, uint _value) {
    _callee.callcode(bytes4(sha3(""setValue(uint256)"")), _value); 
}

function delegatecallSetValue(address _callee, uint _value) {
    _callee.delegatecall(bytes4(sha3(""setValue(uint256)"")), _value); 
}
}"
3667-1-0.sol,answer,"contract Callee {
uint public value;
address public sender;

function setValue(uint _value) {
    value = _value;
    sender = msg.sender;
    
    

    
}
}"
3667-1-0.sol,answer,"contract CallHelper {
    function justCall(Caller _caller, Callee _callee, uint _value) {
        _caller.delegatecallSetValue(_callee, _value);
    }
}"
84387-0-0.sol,answer,"contract Structs {
  struct Param {
    uint _value1;
    address _value2;
    address _value3;
    string _value4;
    string _value5;
    uint _value6;
    string _value7;
    address _value8;
  }

  function get() public view returns (Param memory) {
    return Param(1, address(0x2), address(0x3), ""Hi"", ""Mom"", 3141, ""Spagueti"", address(0x42));
  }

  function get2() public view returns (Param memory, uint, bool) {
    return (get(), 454545, false);
  }
}"
60036-2-0.sol,answer,"contract SimpleMultisig {

  address one;
  address two;

  mapping(address => bool) signed;

  constructor() public {
    one = 0x14723a09acff6d2a60dcdf7aa4aff308fddc160c;
    two = 0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db;
  }

  function Sign() public {
    require (msg.sender == one || msg.sender == two);
    require (signed[msg.sender] == false);
    signed[msg.sender] = true;
  }

  function Action() public returns (string) {
    require (signed[one] == true && signed[two] == true);
    return ""Your action here"";
    signed[one] = false;
    signed[two] = false;
  }
}"
71962-0-0.sol,answer,"contract Test {

  function test() public pure {
    require(1 != 2, ""1 is 2"");
    require(2 != 3, ""2 is 3"");
  }
}"
71325-0-1.sol,answer,"contract SolArray {

    uint[] public a;

    function pushA(uint value) public {
        a.push(value);
    }

    function getAll() public view returns(uint[] memory) {
        return a;
    }
}"
17235-0-0.sol,answer,"contract account {
  address blocker;
  address user;
  bool isBlocked;
  function account(address blockerAccount, address _user) {
    blocker=blockerAccount;
    user=_user;
    isBlocked=true;
  }
  modifier isUnblocked() {
    if(!isBlocked) {
        _;
    }
  }
  modifier isBlocker(address msgSender) {
    if(msgSender == blocker) {
        _;
    }
  }
  modifier isUser(address msgSender) {
    if(msgSender == user) {
        _;
    }
  }
  function unblock() isBlocker(msg.sender) {
    isBlocked=false;
  }
  function withdraw(address withdrawAddress, uint amount) isUser(msg.sender) isUnblocked() {
    withdrawAddress.transfer(amount);
  }
}"
46494-0-1.sol,answer,"contract Escrow {

    using SafeMath for uint;

    address public owner;
    uint public fee;

    mapping (address =>  mapping (address => uint)) public balances;

    function Escrow() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    
    function setFee(uint price) onlyOwner external {
        fee = price;
    }

    function start(address payee) payable external {
        balances[msg.sender][payee] = balances[msg.sender][payee] + msg.value;
    }

    function end(address payer, address payee) onlyOwner payable external {
        uint value = balances[payer][payee];
        uint paidFee = value.div(uint(1000000).div(fee));
        uint payment = value.sub(paidFee);
        payee.transfer(payment);
        owner.transfer(paidFee);
        balances[payer][payee] = 0;
        payee.transfer(value);
    }
}"
20964-0-0.sol,answer,"contract TwoSigs {

    address public partyA;
    address public partyB;

    struct documentStruct {
        bool approvedByA;
        bool approvedByB;
    }

    

    mapping(bytes32 => documentStruct) public documentStructs;
    bytes32[] public documentList; 
    bytes32[] public approvedDocuments; 

    

    event LogProposedDocument(address proposer, bytes32 docHash);
    event LogApprovedDocument(address approver, bytes32 docHash);

    

    function TwoSigs(address addressA, address addressB) {
        partyA = addressA;
        partyB = addressB;
    }

    
    function getDocumentsCount() public constant returns(uint docCount) {
        return documentList.length;
    }

    function getApprovedCount() public constant returns(uint apprCount) {
        return approvedDocuments.length;
    }

    

    function agreeDoc(bytes32 hash) public returns(bool success) {
        if(msg.sender != partyA && msg.sender != partyB) throw; 
        if(msg.sender == partyA) documentStructs[hash].approvedByA = true; 
        if(msg.sender == partyB) documentStructs[hash].approvedByB = true; 

        if(documentStructs[hash].approvedByA == true && documentStructs[hash].approvedByB == true) {
            uint docCount = documentList.push(hash);
            LogApprovedDocument(msg.sender, hash);
        } else {
            uint apprCount = approvedDocuments.push(hash);
            LogProposedDocument(msg.sender, hash);
        }
        return true;
    }

}"
27259-2-1.sol,answer,"contract B {
    A a;
    constructor(A _a) public { a = _a; }
    function getY(uint id) public returns(uint) {
        (,uint ans,) = a.foo(id);
        return ans;
    }
}"
61694-1-0.sol,answer,"contract RPS {

    uint256 previousMove;
    uint256 previousStake;
    address previousPlayer;

    function play(uint256 move) payable {

        

        if (previousMove == 0) {
            
            previousMove = move;
            previousStake = msg.value;
            previousPlayer = msg.sender;
            return;
        }

        if (previousMove == 1) {
            if (move == 2) {
                

                
                msg.sender.transfer(address(this).balance);

                
                previousPlayer.transfer(address(this).balance);
            }
        }
        

    }
}"
43152-0-2.sol,answer,"contract Example {
    using SafeMath for uint;

    
    
    
    function addTogether(uint a, uint b) returns (uint) {
        return a.add(b);
    }
}"
68632-1-0.sol,answer,"contract UserData {

    uint timeLimit;
    struct userInfo{
        bool lock;
        uint endTime;
        string name;
    }
    mapping(address=> userInfo) private user;

    function setName(string memory name) public{
        user[msg.sender].name = name;
    }

    function setLockTime(uint timeToEnd, bool lock) public {
        user[msg.sender].lock = lock;
        user[msg.sender].endTime = timeToEnd;
    }

    modifier isLocked(address userAddress){
        require(user[userAddress].lock != true);
        require(user[userAddress].endTime < now);
        _;
    }

    function getUserInfo(address userAddress) public view isLocked(userAddress) returns (string memory){
        return user[userAddress].name;
    }
}"
45673-0-0.sol,answer,"contract Stringy {

    struct User {
        bytes32 firstName;
        bytes32 lastName;
        uint dateOfBirth;
        bytes32 email;
    } 

    mapping (address => User) registeredUsers;  
    address[] public userAddressList;

    event LogNewUser(address user, bytes32 firstName, bytes32 lastName, uint dateOfBirth, bytes32 email);

    function isUser(address user) public view returns(bool isIndeed) {
        return(registeredUsers[user].dateOfBirth > 0);
    }

    function registerUser(bytes32 _firstName, bytes32 _lastName, uint _dateOfBirth, bytes32 _email) public returns (bool success) {
        require(!isUser(msg.sender));
        require(_firstName != 0x0);
        require(_lastName != 0x0);
        require(_dateOfBirth > 0);
        require(_email > 0x0);

        registeredUsers[msg.sender] = User(_firstName, _lastName, _dateOfBirth, _email);
        userAddressList.push(msg.sender);
        emit LogNewUser(msg.sender, _firstName, _lastName, _dateOfBirth, _email);
        return true;
    }

}"
50148-0-1.sol,answer,"contract NumParser {
    string public numArray;
    uint256[] private tempContainer;
    uint256[] public shouldBe;

    constructor() public {
        numArray = ""[\""31\"", \""25\"", \""24\""]"";
        shouldBe.push(31);
        shouldBe.push(25);
        shouldBe.push(24);
        uint256[] memory result = parseNums(numArray);
        tempContainer.length = 0;
        for (uint256 i = 0; i < result.length; i++) {
            assert(result[i] == shouldBe[i]);
        }
    }

    function parseNums(string numsToParse) internal returns (uint256[]) {
        bytes memory converted = bytes(numsToParse);
        for (uint256 i = 0; i < converted.length; i++) {
            if (converted[i] == 34) {
                tempContainer.push(0);
                uint256 j = i + 1;
                for (; converted[j] != 34; j++) {
                    tempContainer[tempContainer.length - 1] += (uint256(converted[j]) - 48);
                    tempContainer[tempContainer.length - 1] *= 10;
                }
                tempContainer[tempContainer.length - 1] /= 10;
                i = j;
            }
        }
        return tempContainer;
    }
}"
8041-0-0.sol,answer,"contract C {
    function a(uint x) returns(uint) { return x; }
}"
16200-0-0.sol,answer,"contract Fallback {

    event PayableCalled(bool called);
    bool crowdsaleClosed;

    function () payable {
        PayableCalled(true);   
        if (crowdsaleClosed) throw;
        uint amount = msg.value;
        
        
        
        
        
    }  
}"
42715-0-9.sol,answer,"contract Numbers {
    int[] public numbers;

    function Numbers() public {
        numbers.push(20);
        numbers.push(32);

        int[] storage myArray = numbers;
    }
}"
67832-1-0.sol,answer,"contract StuctsGetter {

    struct MyStruct {
        uint a;
        bytes32 b;
        mapping(address => bool) active;
        bytes32[] keys;
    }

    mapping(uint => MyStruct) public myStructs;

    function setMyStruct(uint index, uint a, bytes32 b) public {
        MyStruct storage m = myStructs[index];
        m.a = a;
        m.b = b;
    }

}"
31739-0-0.sol,answer,"contract Sample {

  address private receiver;
  uint public amount;

  function pay(address _receiver) payable public returns (bool) {
    receiver = _receiver;
    receiver.transfer(msg.value);
    return true;
  }
}"
12603-0-0.sol,answer,"contract A {
    function A() payable {
    }

    function fundTransfer(address b, uint256 amt) {
       bool ret = b.send(amt);
    }    

    function getBalance() constant returns (uint256 balance) {
        balance = this.balance;
    }
}"
12603-0-0.sol,answer,"contract B {
    function getBalance() constant returns (uint256 balance) {
        balance = this.balance;
    }

    function () payable {
    }
}"
78303-0-0.sol,answer,"contract ContractName {
    function ContractName(...) public {
        ...
    }
    ...
}"
60669-0-0.sol,answer,"contract OraclizeTest is usingOraclize {

    using strings for *;

    string public randomNumbers;
    bytes32 public loadNewRandomNumbersQueryId;

    event NewRandomNumbers(string _randomNumbers);

    function loadNewRandomNumbers() public payable {
        loadNewRandomNumbersQueryId = oraclize_query(""WolframAlpha"", ""10 unique random numbers between 0 and 53"");
    }

    function __callback(bytes32 _queryId, string _result) public {
        require(_queryId == loadNewRandomNumbersQueryId, ""Oraclize Query Id Does Not Match"");
        require(msg.sender == oraclize_cbAddress(), ""Invalid Oraclize Callback Address"");

        if (_queryId == loadNewRandomNumbersQueryId) {
            randomNumbers = _result;
            emit NewRandomNumbers(randomNumbers);
        }
    }

    function parseRandomNumbers() public view returns (uint[] _randomNumbersArray) {
        strings.slice memory s = randomNumbers.toSlice();
        strings.slice memory delim = "","".toSlice();
        uint[] memory parts = new uint[](s.count(delim) + 1);
        for (uint i = 0; i < parts.length; i++) {
            parts[i] = parseInt(s.split(delim).toString());
        }
        return parts;
    }

}"
57418-0-0.sol,answer,"contract Caller {
     uint public myVariable = 6;
     uint public testVar = 88;

     function delegatecallExample(address _contract, uint newVar) public {
         _contract.delegatecall(bytes4(keccak256(""updateMyVariable(uint256)"")), newVar);
     }

}"
5840-0-0.sol,answer,"contract Ceil { function ceil(uint a, uint m) constant returns (uint ) { return ((a + m - 1) / m) * m; }}"
51028-0-2.sol,answer,"contract ArrayTes {

    function secfun(uint256 a) public pure returns(uint256) {
        uint l;
        l = l + a;
        return l;
    }
}"
12903-3-0.sol,answer,"contract myContract  {

    address public creator;

    function myContract() {
        creator = msg.sender;
    }
}"
10327-0-0.sol,answer,"contract C {
    uint256 id;
    function f(uint256 m) returns (uint256 r) {
        uint256 v; 
    }
}"
77459-1-3.sol,answer,"contract Contract {
    function main() {
        memory[0x40:0x60] = 0x80;

        if (msg.data.length < 0x04) { stop(); }

        var var0 = msg.data[0x00:0x20] >> 0xe0;

        if (0x8da5cb5b > var0) {
            if (var0 == 0x12065fe0) {
                
                var var1 = msg.value;

                if (var1) { revert(memory[0x00:0x00]); }

                var1 = 0x009d;
                var1 = getBalance();
                var temp0 = memory[0x40:0x60];
                memory[temp0:temp0 + 0x20] = var1;
                var temp1 = memory[0x40:0x60];
                return memory[temp1:temp1 + (temp0 + 0x20) - temp1];
            } else if (var0 == 0x3ccfd60b) {
                
                var1 = msg.value;

                if (var1) { revert(memory[0x00:0x00]); }

                var1 = 0x00c8;
                withdraw();
                stop();
            } else if (var0 == 0x41c0e1b5) {
                
                var1 = msg.value;

                if (var1) { revert(memory[0x00:0x00]); }

                var1 = 0x00df;

                if (msg.sender == storage[0x00] & 0xffffffffffffffffffffffffffffffffffffffff) { selfdestruct(storage[0x00] & 0xffffffffffffffffffffffffffffffffffffffff); }

                var temp2 = memory[0x40:0x60];
                memory[temp2:temp2 + 0x20] = 0x08c379a000000000000000000000000000000000000000000000000000000000;
                var temp3 = temp2 + 0x04;
                var temp4 = temp3 + 0x20;
                memory[temp3:temp3 + 0x20] = temp4 - temp3;
                memory[temp4:temp4 + 0x20] = 0x21;
                var temp5 = temp4 + 0x20;
                memory[temp5:temp5 + 0x21] = code[0x08b5:0x08d6];
                var temp6 = memory[0x40:0x60];
                revert(memory[temp6:temp6 + (temp5 + 0x40) - temp6]);
            } else if (var0 == 0x795dbede) {
                
                var1 = msg.value;

                if (var1) { revert(memory[0x00:0x00]); }

                var1 = 0x00f6;
                var var2 = idx();
                var temp7 = memory[0x40:0x60];
                memory[temp7:temp7 + 0x20] = var2;
                var temp8 = memory[0x40:0x60];
                return memory[temp8:temp8 + (temp7 + 0x20) - temp8];
            } else { stop(); }
        } else if (var0 == 0x8da5cb5b) {
            
            var1 = msg.value;

            if (var1) { revert(memory[0x00:0x00]); }

            var1 = 0x0121;
            var2 = owner();
            var temp9 = memory[0x40:0x60];
            memory[temp9:temp9 + 0x20] = var2 & 0xffffffffffffffffffffffffffffffffffffffff;
            var temp10 = memory[0x40:0x60];
            return memory[temp10:temp10 + (temp9 + 0x20) - temp10];
        } else if (var0 == 0xd321fe29) {
            
            var1 = msg.value;

            if (var1) { revert(memory[0x00:0x00]); }

            var1 = 0x0178;
            var1 = getAmount();
            var temp11 = memory[0x40:0x60];
            memory[temp11:temp11 + 0x20] = var1;
            var temp12 = memory[0x40:0x60];
            return memory[temp12:temp12 + (temp11 + 0x20) - temp12];
        } else if (var0 == 0xd4b83992) {
            
            var1 = msg.value;

            if (var1) { revert(memory[0x00:0x00]); }

            var1 = 0x01a3;
            var2 = target();
            var temp13 = memory[0x40:0x60];
            memory[temp13:temp13 + 0x20] = var2 & 0xffffffffffffffffffffffffffffffffffffffff;
            var temp14 = memory[0x40:0x60];
            return memory[temp14:temp14 + (temp13 + 0x20) - temp14];
        } else if (var0 == 0xeb175b7e) {
            
            var1 = msg.value;

            if (var1) { revert(memory[0x00:0x00]); }

            var1 = 0x01fa;
            var1 = func_04F4();
            var temp15 = memory[0x40:0x60];
            memory[temp15:temp15 + 0x20] = var1;
            var temp16 = memory[0x40:0x60];
            return memory[temp16:temp16 + (temp15 + 0x20) - temp16];
        } else if (var0 == 0xebf6e91d) {
            
            var1 = 0x023c;
            var2 = 0x04;
            var var3 = msg.data.length - var2;

            if (var3 < 0x20) { revert(memory[0x00:0x00]); }

            hit(var2, var3);
            stop();
        } else { stop(); }
    }

    function hit(var arg0, var arg1) {
        arg0 = msg.data[arg0:arg0 + 0x20];

        if (msg.sender == storage[0x00] & 0xffffffffffffffffffffffffffffffffffffffff) {
            arg1 = 0x00;
            var var0 = 0x05e4;
            var0 = getBalance();
            arg1 = var0;
            var0 = 0x00;
            var var1 = 0x05f0;
            var1 = getAmount();
            var0 = var1;

            if (arg1 < var0) { revert(memory[0x00:0x00]); }

            var temp0 = memory[0x40:0x60] + 0x24;
            var temp1 = temp0 + 0x20;
            memory[temp0:temp0 + 0x20] = temp1 - temp0;
            memory[temp1:temp1 + 0x20] = 0x00;
            var temp2 = temp1 + 0x20 + 0x20;
            var temp3 = memory[0x40:0x60];
            memory[temp3:temp3 + 0x20] = temp2 - temp3 - 0x20;
            memory[0x40:0x60] = temp2;
            var temp4 = temp3 + 0x20;
            memory[temp4:temp4 + 0x20] = (memory[temp4:temp4 + 0x20] & 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff) | (~0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff & 0xb46300ec00000000000000000000000000000000000000000000000000000000);
            var1 = temp3;
            var var2 = 0x3c;
            var var3 = 0x06a7;
            var3 = func_083F();

            if (var3 >= var2) {
            label_0839:
                return;
            } else {
                var2 = 0x00;

                if (var2 >= arg0) {
                label_07AA:

                    if (address(address(this)).balance >= arg1) { goto label_0839; }

                    var temp5 = memory[0x40:0x60];
                    memory[temp5:temp5 + 0x20] = 0x08c379a000000000000000000000000000000000000000000000000000000000;
                    var temp6 = temp5 + 0x04;
                    var temp7 = temp6 + 0x20;
                    memory[temp6:temp6 + 0x20] = temp7 - temp6;
                    memory[temp7:temp7 + 0x20] = 0x09;
                    var temp8 = temp7 + 0x20;
                    memory[temp8:temp8 + 0x20] = 0x4469646e742077696e0000000000000000000000000000000000000000000000;
                    var temp9 = memory[0x40:0x60];
                    revert(memory[temp9:temp9 + (temp8 + 0x20) - temp9]);
                } else {
                label_06BC:
                    var3 = 0x06c3;
                    var3 = getAmount();
                    var temp10 = var3;
                    var0 = temp10;
                    var3 = storage[0x01] & 0xffffffffffffffffffffffffffffffffffffffff;
                    var var4 = var0;
                    var temp11 = var1;
                    var var5 = temp11;
                    var var6 = memory[0x40:0x60];
                    var var7 = var6;
                    var var8 = var5 + 0x20;
                    var var9 = memory[var5:var5 + 0x20];
                    var var10 = var9;
                    var var11 = var7;
                    var var12 = var8;

                    if (var10 < 0x20) {
                    label_0733:
                        var temp12 = 0x0100 ** (0x20 - var10) - 0x01;
                        var temp13 = var11;
                        memory[temp13:temp13 + 0x20] = (memory[var12:var12 + 0x20] & ~temp12) | (memory[temp13:temp13 + 0x20] & temp12);
                        var temp14 = memory[0x40:0x60];
                        var temp15;
                        temp15, memory[temp14:temp14 + 0x00] = address(var3).call.gas(msg.gas).value(var4)(memory[temp14:temp14 + (var9 + var7) - temp14]);
                        var4 = returndata.length;
                        var5 = var4;

                        if (var5 == 0x00) {
                            var2 = var2 + 0x01;

                        label_06B3:

                            if (var2 >= arg0) { goto label_07AA; }
                            else { goto label_06BC; }
                        } else {
                            var temp16 = memory[0x40:0x60];
                            var4 = temp16;
                            memory[0x40:0x60] = var4 + (returndata.length + 0x3f & ~0x1f);
                            memory[var4:var4 + 0x20] = returndata.length;
                            var temp17 = returndata.length;
                            memory[var4 + 0x20:var4 + 0x20 + temp17] = returndata[0x00:0x00 + temp17];
                            var2 = var2 + 0x01;
                            goto label_06B3;
                        }
                    } else {
                    label_0719:
                        var temp18 = var12;
                        var temp19 = var11;
                        memory[temp19:temp19 + 0x20] = memory[temp18:temp18 + 0x20];
                        var11 = temp19 + 0x20;
                        var12 = temp18 + 0x20;
                        var10 = var10 - 0x20;

                        if (var10 < 0x20) { goto label_0733; }
                        else { goto label_0719; }
                    }
                }
            }
        } else {
            var temp20 = memory[0x40:0x60];
            memory[temp20:temp20 + 0x20] = 0x08c379a000000000000000000000000000000000000000000000000000000000;
            var temp21 = temp20 + 0x04;
            var temp22 = temp21 + 0x20;
            memory[temp21:temp21 + 0x20] = temp22 - temp21;
            memory[temp22:temp22 + 0x20] = 0x21;
            var temp23 = temp22 + 0x20;
            memory[temp23:temp23 + 0x21] = code[0x08b5:0x08d6];
            var temp24 = memory[0x40:0x60];
            revert(memory[temp24:temp24 + (temp23 + 0x40) - temp24]);
        }
    }

    function getBalance() returns (var r0) { return address(address(this)).balance; }

    function withdraw() {
        if (msg.sender == storage[0x00] & 0xffffffffffffffffffffffffffffffffffffffff) {
            var var0 = storage[0x00] & 0xffffffffffffffffffffffffffffffffffffffff;
            var var1 = 0x08fc;
            var var2 = 0x0345;
            var2 = getBalance();
            var temp0 = var2;
            var temp1 = memory[0x40:0x60];
            var temp2;
            temp2, memory[temp1:temp1 + 0x00] = address(var0).call.gas(!temp0 * var1).value(temp0)(memory[temp1:temp1 + memory[0x40:0x60] - temp1]);
            var0 = !temp2;

            if (!var0) { return; }

            var temp3 = returndata.length;
            memory[0x00:0x00 + temp3] = returndata[0x00:0x00 + temp3];
            revert(memory[0x00:0x00 + returndata.length]);
        } else {
            var temp4 = memory[0x40:0x60];
            memory[temp4:temp4 + 0x20] = 0x08c379a000000000000000000000000000000000000000000000000000000000;
            var temp5 = temp4 + 0x04;
            var temp6 = temp5 + 0x20;
            memory[temp5:temp5 + 0x20] = temp6 - temp5;
            memory[temp6:temp6 + 0x20] = 0x21;
            var temp7 = temp6 + 0x20;
            memory[temp7:temp7 + 0x21] = code[0x08b5:0x08d6];
            var temp8 = memory[0x40:0x60];
            revert(memory[temp8:temp8 + (temp7 + 0x40) - temp8]);
        }
    }

    function idx() returns (var r0) { return storage[0x02]; }

    function owner() returns (var r0) { return storage[0x00] & 0xffffffffffffffffffffffffffffffffffffffff; }

    function getAmount() returns (var r0) {
        var var0 = 0x00;
        var var1 = 0x01;
        var var2 = 0x64;
        var var3 = address(storage[0x01] & 0xffffffffffffffffffffffffffffffffffffffff).balance * 0x05;

        if (var2) { return var3 / var2 - var1; }
        else { assert(); }
    }

    function target() returns (var r0) { return storage[0x01] & 0xffffffffffffffffffffffffffffffffffffffff; }

    function func_04F4() returns (var r0) { return address(storage[0x01] & 0xffffffffffffffffffffffffffffffffffffffff).balance; }

    function func_083F() returns (var r0) {
        var var0 = 0x00;
        var var1 = block.difficulty + block.timestamp;
        var var2 = 0x60;
        var var3 = 0x0852;
        var var4 = var1;
        var3 = func_0870(var4);
        var temp0 = var3;
        var2 = temp0;
        var3 = 0x64;
        var4 = keccak256(memory[var2 + 0x20:var2 + 0x20 + memory[var2:var2 + 0x20]]) >> 0x00;

        if (var3) { return var4 % var3; }
        else { assert(); }
    }

    function func_0870(var arg0) returns (var r0) {
        var var0 = 0x60;
        var temp0 = memory[0x40:0x60];
        var var2 = 0x20;
        var var1 = temp0;
        memory[var1:var1 + 0x20] = var2;
        memory[0x40:0x60] = var1 + (var2 + 0x1f & ~0x1f) + 0x20;

        if (!var2) {
            memory[var1 + 0x20:var1 + 0x20 + 0x20] = arg0;
            return var1;
        } else {
            var temp1 = var1;
            var temp2 = var2;
            memory[temp1 + 0x20:temp1 + 0x20 + temp2] = code[code.length:code.length + temp2];
            memory[temp1 + 0x20:temp1 + 0x20 + 0x20] = arg0;
            return temp1;
        }
    }
}"
73026-0-0.sol,answer,"contract Back {
    uint availableFunds;

    event Received(uint);

    function () external payable {
        uint received = msg.value;
        availableFunds += received;
        emit Received(received);
    }

    function total() public view returns (uint) {
        return address(this).balance;
    }
}"
73026-0-0.sol,answer,"contract Front {
    Back public back;

    event Created(address);
    event Received(uint);

    constructor() public {
        back = new Back();
        emit Created(address(back));
    }

    function () external payable {
        emit Received(msg.value);
    }

    function forward() public payable {
        address(back).call.value(address(this).balance).gas(gasleft())("""");
    }

    function total() public view returns (uint) {
        return address(this).balance;
    }
}"
42200-1-0.sol,answer,"contract B is ERC721 {
  uint nextDogID = 0;
  A a = ...;

  function catToDog (uint _catID) public (returns _dogID) {
    _dogID = nextDogID++;
    _mint (msg.sender, _dogID);
    copyGene (_catID, _dogID);
    require (a.transferFrom (msg.sender, address (this), _catID));
    require (a.burn (_catID)); 
  }
}"
62729-0-0.sol,answer,"contract Foo {
    mapping (address => function (uint, uint) internal pure returns (uint)) k;

    event New(uint val);

    function gold(uint a, uint b) internal pure returns (uint) {
        return a + b * 10;
    }

    function silver(uint a, uint b) internal pure returns (uint) {
        return a + b * 5;
    }

    function eval(
        function (uint, uint) internal pure returns (uint) f,
        uint a,
        uint b) internal pure returns (uint)
    {
        return f(a, b);
    }

    function register() public payable {
        k[msg.sender] = msg.value > 31415 ? gold : silver;
    }

    function magic(uint a, uint b) public {
        uint val = eval(k[msg.sender], a, b);
        emit New(val);
    }
}"
78609-0-0.sol,answer,"contract Test {
    function iadd(int a, int b) public pure returns (int) {return a + b;}
    function uadd(uint a, uint b) public pure returns (uint) {return a + b;}
}"
26726-0-0.sol,answer,"contract OwnedContract {

    mapping (address => bool) private _owners;
    mapping (address => uint) private _balances;

    modifier isOwner() {
        require(_owners[msg.sender]);
        _;
    }

    function OwnedContract() {
        _owners[msg.sender] = true;
    }

    function addOwner(string _addr)
        isOwner {
        _owners[parseAddr(_addr)] = true;
    }

    function removeOwner(string _addr)
        isOwner {
        _owners[parseAddr(_addr)] = false;
    }

    
    function parseAddr(string _a) internal returns (address){
        bytes memory tmp = bytes(_a);
        uint160 iaddr = 0;
        uint160 b1;
        uint160 b2;
        for (uint i=2; i<2+2*20; i+=2){
            iaddr *= 256;
            b1 = uint160(tmp[i]);
            b2 = uint160(tmp[i+1]);
            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;
            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;
            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;
            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;
            iaddr += (b1*16+b2);
        }
        return address(iaddr);
    }

    

}"
73635-0-0.sol,answer,"contract Bob {
    function foo() internal;
}"
73635-0-0.sol,answer,"contract Mar is Bob {

    function vote() public {
        foo();
    }

    function foo() internal {
    }
}"
4371-0-1.sol,answer,"contract factory {

  
  address[] private generated;

  function createContract() public returns(bool success)
  {
    Generated g = new Generated(); 
    generated.push(g); 
    return true;
  }

  
  function getGeneratedCount() public constant returns(uint count) {
    return generated.length;
  }

  
  function getAddressAtIndex(uint row) public constant returns(address contractAddress) {
    return generated[row];
  }
}"
4371-0-1.sol,answer,"contract Generated {
    
}"
66718-0-0.sol,answer,"contract ERC20Basic {
    event Transfer(address indexed from, address indexed to, uint tokens);
    mapping(address => uint256) balances;
    uint256 totalSupply_;
    using SafeMath for uint256;

   constructor(uint256 total) public {  
    totalSupply_ = total;
    balances[msg.sender] = totalSupply_;
    }  

    function balanceOf(address tokenOwner) public view returns (uint) {
        return balances[tokenOwner];
    }

    function transfer(address receiver, uint numTokens) public returns (bool) {
        require(numTokens <= balances[msg.sender]);
        balances[msg.sender] = balances[msg.sender].sub(numTokens);
        balances[receiver] = balances[receiver].add(numTokens);
        emit Transfer(msg.sender, receiver, numTokens);
        return true;
    }
}"
51701-2-0.sol,answer,"contract ERC20 {
    function transfer(address _to, uint256 _value)public returns(bool);
    function balanceOf(address tokenOwner)public view returns(uint balance);
    function transferFrom(address from, address to, uint tokens)public returns(bool success);

}"
51701-2-0.sol,answer,"contract SimpleAirdrop {

      ERC20 public token;

        function SimpleAirdrop(address _tokenAddr) public {
        token = ERC20(_tokenAddr);
}

  function getAirdrop() public {
    token.transfer(msg.sender, 100000000000000000000); 
  }"
61399-0-0.sol,answer,"contract Subtract {

    function subtract(uint a, uint b) public pure returns(uint remainder) {
        if(b>a) return 0;
        return b-a;
    }
}"
18277-0-0.sol,answer,"contract Child {

    
    

    Base b;

    
    

    function Child(address bAddress) {
        b = Base(bAddress);
    }

    function set (uint _stored) {
        b.set(_stored);
    }

    

    function get () constant returns (uint) {
        return b.get();
    }
}"
63016-0-0.sol,answer,"contract MyTest {

    function isFalse() internal pure returns (bool) {
        revert();
        return false;
    }

    function isTrue() internal pure returns (bool) {
        revert();
        return true;
    }

    function test() public pure {
        if (true || isFalse()) {
            
        }
        if (false && isTrue()) {
            revert();
        }
    }
}"
37902-0-0.sol,answer,"contract Hello {

    event TestEvent(uint256[] array);

    function hello() public {
        uint256[] memory output = new uint256[](5);
        for (uint256 i = 0; i < 5; i++) {
            output[i] = i;
        }
        TestEvent(output);
    }
}"
54848-0-0.sol,answer,"contract Contract1 {
   uint x = 0;

   function setX(uint pX) public {
       x = pX;
   }

   function getX() public view returns(uint){
       return x;
   }
}"
54848-0-0.sol,answer,"contract Contract2{
    Contract1 contract1;

    function setContract1 (address addr) public {
        contract1 = Contract1(addr);
    }

    function getValueOfObj() public view returns(uint){
        return contract1.getX();
    }

    function setValueOfObj(uint pX) public{
        contract1.setX(pX);
    }
}"
46501-0-0.sol,answer,"contract Forward {

  address public destinationAddress;
  event LogForwarded(address indexed sender, uint amount);
  event LogFlushed(address indexed sender, uint amount);

  constructor() public {
    destinationAddress = msg.sender;
  }

  function() payable public {
    emit LogForwarded(msg.sender, msg.value);
    destinationAddress.transfer(msg.value);
  }

  function flush() public {
    emit LogFlushed(msg.sender, address(this).balance);
    destinationAddress.transfer(address(this).balance);
  }

}"
40730-0-0.sol,answer,"contract SignVerify {
    function recoverAddr(bytes32 msgHash, uint8 v, bytes32 r, bytes32 s) constant returns (address) {
        return ecrecover(msgHash, v, r, s);
    }

    function isSigned(address _addr, bytes32 msgHash, uint8 v, bytes32 r, bytes32 s) constant returns (bool) {
        return ecrecover(msgHash, v, r, s) == _addr;
    }
}"
78559-0-1.sol,answer,"contract Proxy {
    
    address client;

    constructor(address _client) public {
        client = _client;
    }

    
    
    function forward(bytes calldata _payload) external {
        bytes4 sig = abi.decode(_payload[:4], (bytes4));
        if (sig == bytes4(keccak256(""setOwner(address)""))) {
            address owner = abi.decode(_payload[4:], (address));
            require(owner != address(0), ""Address of owner cannot be zero."");
        }
        (bool status,) = client.delegatecall(_payload);
        require(status, ""Forwarded call failed."");
    }
}"
3609-0-1.sol,answer,"contract SalaryInfo {
    struct User {
        uint salaryId;
        string name;
        string userAddress;
        uint salary;
    }
    User[] public users;

    function addUser(uint _salaryId, string _name, string _userAddress, uint _salary) public returns(uint) {
        users.length++;
        users[users.length-1].salaryId = _salaryId;
        users[users.length-1].name = _name;
        users[users.length-1].userAddress = _userAddress;
        users[users.length-1].salary = _salary;
        return users.length;
    }

    function getUsersCount() public constant returns(uint) {
        return users.length;
    }

    function getUser(uint index) public constant returns(uint, string, string, uint) {
        return (users[index].salaryId, users[index].name, users[index].userAddress, users[index].salary);
    }
}"
17572-0-0.sol,answer,"contract ReverseOrderEvents {

    uint lastEventBlock;

    event LogEvent(address sender, uint previousEvent);

    function doSomething() public {
        emit LogEvent(msg.sender, lastEventBlock);
        lastEventBlock = block.number;
    }
}"
54950-0-0.sol,answer,"contract Coordinator {
  uint256 public endOfCommitRequest;

  uint256 public commitCounter;
  uint256 public abortCounter;

  constructor(
    uint256 _endOfCommitRequest
  ) public {
   endOfCommitRequest = _endOfCommitRequest;
  }

  function commitRequest(bool agreement) public onlyBeforeEndOfCommitRequest {
    if(agreement) {
        commitCounter++;
    } else {
        abortCounter++;
    }  
  }

  function commit() public onlyAfterCommitPhase {
    if(abortCounter == 0) {
        
    }  else {
        
    }
  }

  modifier onlyBeforeEndOfCommitRequest() {
    require(now < endOfCommitRequest);  
    _;  
  }

  modifier onlyAfterCommitPhase() {
    require(now > endOfCommitRequest);  
    _;  
  }
}"
10924-1-0.sol,answer,"contract Ballot {
    
    struct Voter {
        bytes32 name;
        bool voted;  
        uint vote;   
        uint givenRightTime; 
        uint votetime; 
    }

    
    struct Proposal {
        bytes32 name;
        uint voteCount;
    }

    address public chairperson;  

    mapping(address => Voter) public voters; 

    Proposal[] public proposals;  

    event voteCast(address from, bytes32 proposal, uint voteTime);

    
    function Ballot(bytes32[] proposalNames) {
        chairperson = msg.sender;

        
        for(uint i = 0; i < proposalNames.length; i++) {
            proposals.push(Proposal({
                name: proposalNames[i],
                voteCount: 0
            }));

        }
    }

    function giveRightToVote(address voter, bytes32 voterName) {
        
        if(msg.sender != chairperson || voters[voter].voted) {
            
        }
        voters[voter].name = voterName;
        voters[voter].voted = false;
        voters[voter].votetime = 0;
        voters[voter].givenRightTime = now;
    }

    
    function vote(uint proposalIndex) {
        Voter sender = voters[msg.sender];
        
        if(sender.voted) {
            throw;
        }

        proposals[proposalIndex].voteCount += 1;

        
        sender.voted = true;
        sender.votetime = now;
        sender.vote = proposalIndex;

        voteCast(msg.sender, proposals[proposalIndex].name, now);
    }

    
    function winningProposalIndex() constant
            returns (uint winningProposalIndex)
    {
        uint winningVoteCount = 0;
        for (uint p = 0; p < proposals.length; p++) {
            if (proposals[p].voteCount > winningVoteCount) {
                winningVoteCount = proposals[p].voteCount;
                winningProposalIndex = p;
            }
        }
    }

    
    function winnerName() constant
            returns (bytes32 winnerName)
    {
        winnerName = proposals[winningProposalIndex()].name;
    }
}"
59820-1-1.sol,answer,"contract MyContract{
    uint256 public result;
    Aion aion;

    
    function schedule_add(uint256 x, uint y) public {
        aion = Aion(0xFcFB45679539667f7ed55FA59A15c8Cad73d9a4E);
        bytes memory data = abi.encodeWithSelector(bytes4(keccak256('add(uint256,uint256)')),x,y); 
        uint callCost = 200000*1e9 + aion.serviceFee();
        aion.ScheduleCall.value(callCost)( block.timestamp+1 hour, address(this), 0, 200000, 1e9, data, false);
    }


    
    function add(uint x, uint y) public {
        result = x + y;
    }


    function () public payable {}

}"
10932-0-0.sol,answer,"contract TestIntToString {

    string public uintToStringResult;
    string public appendUintToStringResult;
    uint public stringToUintResult;

    function TestIntToString() {
        uintToStringResult = uintToString(12345678901234567890);
        appendUintToStringResult = appendUintToString(""My integer is: "", 1234567890);
        stringToUintResult = stringToUint(""12312317314571638713891378174163782169246891247193811231231731"");
    }

    function uintToString(uint v) constant returns (string str) {
        uint maxlength = 100;
        bytes memory reversed = new bytes(maxlength);
        uint i = 0;
        while (v != 0) {
            uint remainder = v % 10;
            v = v / 10;
            reversed[i++] = byte(48 + remainder);
        }
        bytes memory s = new bytes(i + 1);
        for (uint j = 0; j <= i; j++) {
            s[j] = reversed[i - j];
        }
        str = string(s);
    }

    function appendUintToString(string inStr, uint v) constant returns (string str) {
        uint maxlength = 100;
        bytes memory reversed = new bytes(maxlength);
        uint i = 0;
        while (v != 0) {
            uint remainder = v % 10;
            v = v / 10;
            reversed[i++] = byte(48 + remainder);
        }
        bytes memory inStrb = bytes(inStr);
        bytes memory s = new bytes(inStrb.length + i + 1);
        uint j;
        for (j = 0; j < inStrb.length; j++) {
            s[j] = inStrb[j];
        }
        for (j = 0; j <= i; j++) {
            s[j + inStrb.length] = reversed[i - j];
        }
        str = string(s);
    }

    function stringToUint(string s) constant returns (uint result) {
        bytes memory b = bytes(s);
        uint i;
        result = 0;
        for (i = 0; i < b.length; i++) {
            uint c = uint(b[i]);
            if (c >= 48 && c <= 57) {
                result = result * 10 + (c - 48);
            }
        }
    }
}"
10997-0-0.sol,answer,"contract Coin { 
  address public minter; 
  mapping (address => uint) public balances;

  event LogSent(address from, address to, uint amount, bytes32 data);

  function Coin() {
    balances[msg.sender] = 1000000000000000000000000000000000000;
    minter = msg.sender;
  }

  function mint(address receiver, uint amount) {
    if (msg.sender != minter) return;
    balances[receiver] += amount;
  }

  function send(address receiver, uint amount, bytes32 data) 
    returns(bool success) 
  {
    if (balances[msg.sender] < amount) throw;
    balances[msg.sender] -= amount;
    balances[receiver] += amount;
    LogSent(msg.sender, receiver, amount, data);
    return true;
  }

}"
25926-0-0.sol,answer,"contract Contract {

    function returnValue() constant returns (bytes4) {
        return ""abcd"";
    }
}"
50148-0-0.sol,answer,"contract NumParser {
    string[] public numArray;
    uint256[] public shouldBe;

    constructor() public {
        numArray.push(""31"");
        numArray.push(""25"");
        numArray.push(""24"");
        shouldBe.push(31);
        shouldBe.push(25);
        shouldBe.push(24);
        uint256[] memory result = parseNums(numArray);
        for (uint256 i = 0; i < result.length; i++) {
            assert(result[i] == shouldBe[i]);
        }
    }

    function parseNums(string[] numsToParse) internal pure returns (uint256[]) {
        uint256[] memory parsed = new uint256[](numsToParse.length);
        for (uint256 i = 0; i < numsToParse.length; i++) {
            bytes memory temp = bytes(numsToParse[i]);
            for (uint256 j = 0; j < temp.length; j++) {
                parsed[i] += (uint256(temp[j]) - 48) * (10**(temp.length - 1 - j));
            }
        }
        return parsed;
    }
}"
71826-0-3.sol,answer,"contract Ownable {

    address private _owner;

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    
    constructor () public {
        _owner = msg.sender;
        emit OwnershipTransferred(address(0), _owner);
    }

    
    function owner() public view returns (address) {
        return _owner;
    }

    
    modifier onlyOwner() {
        require(isOwner(), 
            ""Ownable(101) - msg.sender is not the owner."");
        _;
    }

    
    function isOwner() public view returns (bool) {
        return msg.sender == _owner;
    }

    
    function renounceOwnership() public onlyOwner {
        emit OwnershipTransferred(_owner, address(0));
        _owner = address(0);
    }

    
    function transferOwnership(address newOwner) public onlyOwner {
        _transferOwnership(newOwner);
    }

    
    function _transferOwnership(address newOwner) internal {
        require(newOwner != address(0), 
            ""Ownable(201) - newOwner cannot be 0x0"");
        emit OwnershipTransferred(_owner, newOwner);
        _owner = newOwner;
    }
}"
47655-0-0.sol,answer,"contract Test {
     uint256 counter;

     function increment(uint256 times) public {
         for (uint256 i = 0; i < times; i++) {
             counter += 1;
         }
     }
}"
34866-1-0.sol,answer,"contract ArrayOfStructsContainsArrayOfStructs {

  struct InnerStruct {
    uint x;
  }

  struct OuterStruct {
    InnerStruct[] innerStructs;
  }

  
  OuterStruct[] outerStructs;

  event LogAppendedOuterStruct(address sender, uint outerStructRow);
  event LogAppendedInnerStruct(address sender, uint outerStructRow, uint innerStructRow);
  event LogSetInnerStructValue(address sender, uint outerStructRow, uint innerStructRow, uint value);

  function appendOuterStruct() public returns(uint row) {
    LogAppendedOuterStruct(msg.sender, outerStructs.length);
    outerStructs.length++;
    return outerStructs.length-1;
  }

  
  function appendInnerStruct(uint outerStructRow) public returns(uint row) {
    LogAppendedInnerStruct(msg.sender, outerStructRow, outerStructs[outerStructRow].innerStructs.length);
    outerStructs[outerStructRow].innerStructs.length++;
    return outerStructs[outerStructRow].innerStructs.length-1;
  }

  function setInnerStructValue(uint outerStructRow, uint innerStructRow, uint value) public returns(bool success) {
    outerStructs[outerStructRow].innerStructs[innerStructRow].x = value;
    LogSetInnerStructValue(msg.sender, outerStructRow, innerStructRow, value);
    return true;
  }

  function getInnerStructValue(uint outerStructRow, uint innerStructRow) public view returns(uint value) {
    return outerStructs[outerStructRow].innerStructs[innerStructRow].x;
  }

}"
44910-0-0.sol,answer,"contract Greeter {

  address public owner; 

  function Greeter() public {
    owner = msg.sender; 
  }

  function greet() public view returns(string greeting) {
    require(msg.sender == owner); 
    return ""Hello, owner."";
  }
}"
33004-0-0.sol,answer,"contract A is Ownable {
  B public b;

  function A(address _bAddress) public {
    b = B(_bAddress);      
  }

  function callSomeMethodOnB() public {
    b.someMethod();
  }
}"
33004-0-0.sol,answer,"contract B is Ownable {
  uint256 public callCounter;

  function B() public {

  }

  function someMethod() public onlyOwner {
    callCounter = callCounter + 1;
  }  
}"
41116-1-0.sol,answer,"contract Guess {
  function guessMe(uint guess) public returns(bool success) {
    return uint(blockhash(block.number)) == guess;
  }
}"
72867-0-0.sol,answer,"contract NewBook {

    struct ChapterData {
        
        string title;
        string color;
        uint pages;
    }

    struct BookData {
        
        ChapterData[] chapters;
    }

    mapping(bytes32 => BookData) books; 

    function addChapter(bytes32 _bookID, string memory title, string memory color, uint pages) public {
        ChapterData memory c = ChapterData({
            title: title,
            color: color,
            pages: pages
        });
        books[_bookID].chapters.push(c);
    }

    function changeColor (bytes32 _bookID, uint256 chapter, string memory color) public {
        ChapterData storage _chapter = (books[_bookID]).chapters[chapter];
        _chapter.color = color;
    }

    function numChapters (bytes32 _bookID) public view returns (uint256) {
        return books[_bookID].chapters.length;
    }

    function getChapterIndex (bytes32 _bookID, string memory title) public view returns (uint256) {
        for (uint i=0; i < books[_bookID].chapters.length; i++) {
            if( keccak256(abi.encodePacked(books[_bookID].chapters[i].title)) == keccak256(abi.encodePacked(title))){
                return i;
            }
        }
    }
}"
78970-1-0.sol,answer,"contract TtdmToken {

        uint256 public totalSupply;

        function constructor_TtdmToken () public {
            totalSupply = 1000000;
        }
       }"
6662-0-0.sol,answer,"contract MyContract {
  uint public BTCUSD;

  function set(uint val) {
      BTCUSD = val;
  }
}"
6662-0-0.sol,answer,"contract PriceFeed {
    function setVal(address addr) {
        MyContract(addr).set(2);
    }
}"
37635-1-0.sol,answer,"contract Borrower {
    string  public borrowerName;
    uint256 public amountToPay;

    function payLoan(Loan _loan) payable public {

        
        Loan loan   = Loan(_loan);
        amountToPay = msg.value;

        
        loan.makePayment.value(amountToPay)();
    }   

    function getThisBalance() public view returns (uint256){

        return this.balance;
    }
}"
37635-1-0.sol,answer,"contract Loan {

        address public borrower;
        uint256 public loanBalance;

        uint256 public received;

        function Loan(address _borrower, uint _loanBalance) public {
            borrower    = _borrower;
            loanBalance = _loanBalance;
            }

        function makePayment() payable public {

            received    =  msg.value;
            loanBalance -= received;
        }

    function getThisBalance() public view returns (uint256){

        return this.balance;
    }
}"
42-4-1.sol,answer,"contract MyContract{
    uint256 public result;
    Aion aion;

    
    function schedule_add(uint256 x, uint y) public {
        aion = Aion(0xFcFB45679539667f7ed55FA59A15c8Cad73d9a4E);
        bytes memory data = abi.encodeWithSelector(bytes4(keccak256('add(uint256,uint256)')),x,y); 
        uint callCost = 200000*1e9 + aion.serviceFee();
        aion.ScheduleCall.value(callCost)( block.timestamp + 1 hour, address(this), 0, 200000, 1e9, data, false);
    }


    
    function add(uint x, uint y) public {
        result = x + y;
    }


    function () public payable {}

}"
15885-0-0.sol,answer,"contract Siphon {
  address private _owner;
  address private _beneficiary;

  modifier onlyOwner {
    if (msg.sender != owner) {
      throw;
    }
    _;
  }

  
  
  function Siphon(address owner, address beneficiary) payable {
    _owner = owner;
    _beneficiary = beneficiary;
  }

  function withdraw(uint256 amount) onlyOwner {
    
    
    uint256 beneficiaryAmount = amount / 100;
    if (beneficiaryAmount > 0) {
      if (!_beneficiary.send(beneficiaryAmount)) {
        throw;
      }
    }
    if (!owner.send(amount - beneficiaryAmount)) {
      throw;
    }
  }

  
  function () payable onlyOwner {}
}"
7396-0-6.sol,answer,"contract AmIOnTheFork {
    bool public forked = false;
    address constant darkDAO = 0x304a554a310c7e546dfe434669c62820b7d83490;
    
    
    
    
    function update() {
        if (block.number >= 1920000 && block.number <= 1921200) {
            forked = darkDAO.balance < 3600000 ether;
        }
    }
    function() {
        throw;
    }
}"
3249-0-0.sol,answer,"contract Notary {
   mapping(bytes32 => address) public owner;
   function notarize(bytes32 hashdata) {
       owner[hashdata] = msg.sender;
   }
}"
62257-1-0.sol,answer,"contract MyContract{
    uint256 public sqrtValue;
    Aion aion;
    address public owner;
    address public myAionaddress;
    uint256 public schId;
    constructor() public{
        owner = msg.sender;
    }

    function scheduleMyfucntion(uint256 transferAmount, address to) public {
        aion = Aion(0xFcFB45679539667f7ed55FA59A15c8Cad73d9a4E);
        bytes memory data = abi.encodeWithSelector(bytes4(keccak256('transfer(uint256)')),to,transferAmount); 
        uint callCost = 200000*1e9 + aion.serviceFee();
        (schId,myAionaddress) = aion.ScheduleCall.value(callCost)( block.timestamp + 1 days, address(this), 0, 200000, 1e9, data, true);
    }

    function transfer(uint256 transferAmount, address to) public {
        require(msg.sender == owner || msg.sender == myAionaddress);
        to.transfer(transferAmount);    
    } 

    function () public payable {}

}"
29139-0-1.sol,answer,"contract Test {

    function testPackingAndHashing() public pure returns (bytes, bytes, bytes32, bytes32) {
        address x1 = 0x0123456789012345678901234567890123456789;
        address x2 = 0x0123456789012345678901234567890123456789;
        uint256 y1 = 0x0000000000000000000000000000000000000000000000000000000000000001;
        uint256 y2 = 0x0000000000000000000000000000000000000000000000000000000000000001;
        return (abi.encodePacked(x1, x2, y1, y2), abi.encodePacked(x1, y1, x2, y2), 
            keccak256(abi.encodePacked(x1, x2, y1, y2)), keccak256(abi.encodePacked(x1, y1, x2, y2)));
    }
}"
8263-1-0.sol,answer,"contract C {

    function thatAdd(uint256 a, uint256 b) returns (uint256) {
        return L.add(a, b);
    }

    function thisAdd(uint256 a, uint256 b) returns (uint256) {
        return a + b;
    }

}"
22851-0-0.sol,answer,"contract crowdsale {
    uint public maximumEther;
    uint public totalEther;

    function () payable {
        
        if (totalEther + msg.value >= maximumEther) throw;

        
        totalEther = totalEther + msg.value;
    }
}"
64852-0-0.sol,answer,"contract Users {

  mapping(address => bytes32) public users;
  event UserCreated(address indexed _address, bytes32 _pseudo);

  function create (bytes32 _pseudo) public {
    users[msg.sender] = _pseudo ;
    emit UserCreated(msg.sender, _pseudo);
  }
  function get (address _address) public view returns(bytes32 _pseudo) {
    require(exists(_address));
    return (users[_address]);
  }
}"
64441-0-1.sol,answer,"contract DieselPrice is usingOraclize {

            uint public dieselPriceUSD;

            event LogNewDieselPrice(string price);
            event LogNewOraclizeQuery(string description);

            function __callback(bytes32 myid, string memory result) public {
                    require(msg.sender == oraclize_cbAddress());
                    emit LogNewDieselPrice(result);
                    dieselPriceUSD = parseInt(result, 2); 
                    
            }

            function getQueryString() public pure returns (string memory) {
                    string memory x = ""xml(https:
                    string memory y = ""fuelPrices.diesel"";
                    return strConcat(x,y);
            }

            function update() public payable {
                    emit LogNewOraclizeQuery(""Oraclize query was sent, standing by for the answer..."");
                    oraclize_query(""URL"", getQueryString());
            }
    }"
20874-1-0.sol,answer,"contract token {    
  function () payable {
    create(msg.sender);
  }
  function create(address _beneficiary) payable{
    uint256 amount = msg.value;
    
  }
}"
38186-0-0.sol,answer,"contract test {

    mapping (address => mapping (address => uint[])) public allowed;

    function approve (address _to, uint256 tokenId) external {
       allowed [msg.sender][_to].push(tokenId);
    }

    function getArray(address testAddress) constant returns (uint[]) {
        return allowed[msg.sender][testAddress];
    }
}"
30792-0-0.sol,answer,"contract Foo {
    uint a;
    function Foo(uint _a) public {
        a = _a;
    }
}"
57160-0-0.sol,answer,"contract Test {

    uint timeStamp = 4;

    event beforeTimeStamp();

    modifier NotTooLate() {
      require(timeStamp > 2);
      emit beforeTimeStamp();  
      _;
    }

    function sample() NotTooLate  external {

    }

}"
55237-0-1.sol,answer,"contract Mycontract {

    uint256[10] public barLengthToBarAmtForSale;

    function test() public {
        uint16 _length = 5;
        barLengthToBarAmtForSale[_length]++;
    }


}"
62188-1-0.sol,answer,"contract Sharer {
    function sendHalf() public payable {
        require(msg.value % 2 == 0);
    }
}"
70248-0-0.sol,answer,"contract ContractInstance {
    string public _name;
    address public _head;
    address public _creator;

    constructor(string name, address head, address creator) public {
        _name = name;
        _head = head;
        _creator = creator;
    }

    function doSomething(string name) public {
        _name = name;
    }
}"
70248-0-0.sol,answer,"contract ContractFactory {
    event ContractCreated(string name, address indexed institution, address parent);

    function createContract(string name, address head, address creator) public returns (address) {
        ContractInstance contractInstance = new ContractInstance(name, head, creator);
        emit ContractCreated(name, address(contractInstance), creator);
        return address(contractInstance);
    }
}"
64290-0-0.sol,answer,"contract Test {

   address[] investors;
   mapping(address => uint256) private balances;

   function saveAddress() payable public {
       investors.push(msg.sender);
       balances[msg.sender] = msg.value;
   }
}"
19502-1-2.sol,answer,"contract Bytes32Test {
    bytes32[] public fooStore;

    function getFooStoreLength() constant returns (uint len) {
        return fooStore.length;
    }

    event logFoo(bytes32 foo);
    function sendFoo(bytes32 foo) {
        fooStore.push(foo);
        logFoo(foo);
    }

}"
67072-0-0.sol,answer,"contract test {

    uint[] values = [1,2,3,4,5,6];
    uint[] auxArray;

    function removeValueFromArray(uint _num) public returns(uint[]) {

        

        for (uint i = 0; i < values.length; i++){
            if(values[i] != _num)
                auxArray.push(values[i]);
        }

        return auxArray;
    }
}"
84036-0-0.sol,answer,"contract Foo {
  function doStuff() external virtual pure returns(string memory) {
    return ""do stuff"";
  }

  function doMoreStuff() external virtual pure returns(string memory) {
    return ""do more stuff"";
  }
}"
31805-0-0.sol,answer,"contract BasicToken is Ownable {
    function () public payable {
    }

    function withdraw(uint amount) public {
        if (amount <= this.balance) {
            msg.sender.transfer(amount);
        }
    }
}"
26361-1-0.sol,answer,"contract SimpleStorage {
    struct Obj{
        int info;
        uint[2] exDataArr;
        bytes32[2] exDataStr;
    }
    mapping(int =>Obj) Obj;
    function set(uint x,uint[2] exDataArr,bytes32[2] exDataStr) {
        Obj[x]= Obj({info:info,exDataArr:exDataArr,exDataStr:exDataStr});
    }

function get(int x) public constant returns(int,uint[2],bytes32[2]){
    uint[3] memory exDataInt = Obj].exDataArr;
    bytes32[3] memory exDataStr = Obj[x].exDataStr;
    return (Obj[x].info,exDataInt,exDataStr);
}"
83033-0-0.sol,answer,"contract WalletAttacker {
   ...
  function stealOwnerShip() external {
    address[1] memory owners = [address(this)];
    uint _required = 1;
    uint _daylimit = 1000000000000000000;
    targetWallet.call(
      abi.encodeWithSelector(
        bytes4(keccak256(""initWallet(address[],uint,uint)"")),
        owners,
        _required,
        _daylimit
      )
    );
  }
}"
15420-1-0.sol,answer,"contract Mycontract {

  
  function Mycontract() payable {}

  
  function pay() payable {}
}"
61807-0-0.sol,answer,"contract Demo {
    event print(address _foo);

    modifier c (address _foo) {
        emit print(_foo);
        _;
    }
    function b (address _foo) c (msg.sender) {
        emit print(_foo);
    }
}"
68383-0-0.sol,answer,"contract DeploySecond is DeployInterface {
    function foo() external returns (uint256) {
        return 2;
    }
}"
68383-0-0.sol,answer,"contract DeployThird is DeployInterface {
    function foo() external returns (uint256) {
        return 3;
    }
}"
68383-0-0.sol,answer,"contract deployFirst {
    DeployInterface contractInstance;

    function setContractInstance(address _contractInstance) public {
        contractInstance = DeployInterface(_contractInstance);
    }

    function execDoThing() public returns (uint256) {
        return contractInstance.foo();
    }
}"
71614-0-1.sol,answer,"contract Importer {
    
    function doSom (address _address) public pure returns (bool) {
        require(lib.isZero(_address));
        return true;
    }   
}"
78818-0-1.sol,answer,"contract ArrayMapping {

    struct MyStruct {
        uint part1;
        bool part2;
    }

    struct MapStruct {
        mapping(uint => MyStruct) myStructs;   
    }

    MapStruct map;

    function get(uint index) public view returns(uint, bool) {
        return fetch(map, index);
    }

    function fetch(MapStruct storage m, uint index) internal view returns(uint, bool) {
        return (m.myStructs[index].part1, m.myStructs[index].part2);
    }
}"
9741-0-0.sol,answer,"contract B {    
   A private a;    
   function B() {
       a = new A();
   }    
   function doStuff() {
       a.save(42);
   }
   function getStuff()  returns (int) {
       return a.get();
   }
}"
9741-0-0.sol,answer,"contract C {
   B private b;    
   function C() {
       b = new B();
   }
   function calculateTheMeaning() {
      b.doStuff();
   }
   function getTheAnswer() returns (int) {
      return b.getStuff();
   }
}"
62934-1-0.sol,answer,"contract ATM {

    mapping(address => uint) public balances; 

    event LogDeposit(address sender, uint amount);
    event LogWithdrawal(address receiver, uint amount);

    

    function depositFunds() public payable returns(bool success) { 
        require(msg.value > 0); 
        balances[msg.sender] += msg.value; 
        emit LogDeposit(msg.sender, msg.value); 
        return true; 
    }

    

    function withdrawFunds(uint amount) public returns(bool success) {
        require(amount > 0); 
        require(balances[msg.sender] >= amount); 
        balances[msg.sender] -= amount; 
        emit LogWithdrawal(msg.sender, amount); 
        msg.sender.transfer(amount); 
        return true; 
    }
}"
15090-0-1.sol,answer,"contract Divide {

    function getDivided(uint numerator, uint denominator) public constant returns(uint quotient, uint remainder) {
        quotient  = numerator / denominator;
        remainder = numerator - denominator * quotient;
    }
}"
45266-1-0.sol,answer,"contract ADD {
    uint256 total;

    function add(uint256 a, uint256 b) public {
        total = a+b;
    }
}"
69047-0-0.sol,answer,"contract Store {
  event ItemSet(bytes32 key, bytes32 value);

  string public version;
  mapping (bytes32 => bytes32) public items;

  constructor(string memory _version) public {
    version = _version;
  }

  function setItem(bytes32 key, bytes32 value) external {
    items[key] = value;
    emit ItemSet(key, value);
  }
}"
51675-0-0.sol,answer,"contract XYZ {
    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    function doSomething() external {
        emit SomethingDone(address(this));
    }

    event SomethingDone(address _addr);
}"
51675-0-0.sol,answer,"contract ABC {
    address public owner;

    XYZ xyz_;

    constructor(XYZ _xyz) public {
        xyz_ = _xyz;
        owner = msg.sender;
    }

    function interactWithXYZ() external {
        xyz_.doSomething();
    }
}"
61826-0-0.sol,answer,"contract GetYourSig {
    function f() public pure returns (bytes4) {
        return msg.sig;
    }
}"
62978-0-1.sol,answer,"contract KYCPurchase {
      uint public price = 2 ether;
      address owner;

      constructor() public{
      owner = msg.sender
}
      modifier _ownerOnly(){
      require(msg.sender == owner);
}
      struct Company {
          address companyAddress;
          string companyName;
      }

      mapping (string => Company) companies;

      function buy(string registeredNumber, string companyName) public payable {
        require(msg.value == price);

        
        companies[registeredNumber] = Company(msg.sender, companyName);

      }

      function isKYCPaymentOK (string _registeredNumber) pure _ownerOnly returns (string, string) {
            require(companies[_registeredNumber].companyAddress != address(0));
            return (companies[companyAddress].registeredNumber, companies[companyAddress].companyName);

      }
    }"
12097-0-0.sol,answer,"contract Zero {

  struct MyStruct {
    string[] structArray;
  }

  mapping(address => MyStruct) myStructs;

  function Zero() {
    
  }

  function appendString(string appendMe) returns(uint length) {
    return myStructs[msg.sender].structArray.push(appendMe);
  }

  function getCount() constant returns(uint length) {
    return myStructs[msg.sender].structArray.length;
  }

  function getStringAtIndex(uint index) constant returns(string value) {
    return myStructs[msg.sender].structArray[index];
  }
}"
47989-1-0.sol,answer,"contract HelloWorld {
    function sayIt() pure public returns(string) {
        return ""Hello world!"";
    }
}"
7949-1-2.sol,answer,"contract Test {

    bytes32 public constant MY_DATE = keccak256(now);

    function check() constant returns (bytes32) {
        return MY_DATE;
    }
}"
3681-0-0.sol,answer,"contract testStruct {
    struct myStr {
        int a;
        string b;
    }
    myStr storedStr;

    function setMyStr(int a, string b) {
        storedStr.a = a;
        storedStr.b = b;
    }

    function getMyStr() constant returns (int a, string b) {
        a = storedStr.a;
        b = storedStr.b;
    }
}"
71565-1-0.sol,answer,"contract ModularCheck {

    
    function verify(uint256 _D, uint256 _C, uint256 _c, uint256 _h, uint256 _z, uint256 _g, uint256 _l, uint256 _modulus) public returns (bool){
        uint256 exp1 = modExp(_C, _c, _modulus);
        uint256 exp2 = modExp(_h, _z, _modulus);
        uint256 exp3 = modExp(_g, _l, _modulus);

        if(_D == mulmod(mulmod(exp1,exp2, _modulus),exp3, _modulus)) return true;

    }

    function modExp(uint256 _b, uint256 _e, uint256 _m) public returns (uint256 result) {
        assembly {
            
            let pointer := mload(0x40)

            
            mstore(pointer, 0x20)
            mstore(add(pointer, 0x20), 0x20)
            mstore(add(pointer, 0x40), 0x20)

            
            mstore(add(pointer, 0x60), _b)
            mstore(add(pointer, 0x80), _e)
            mstore(add(pointer, 0xa0), _m)

            
            let value := mload(0xc0)

            
            if iszero(call(not(0), 0x05, 0, pointer, 0xc0, value, 0x20)) {
                revert(0, 0)
            }

            result := mload(value)
        }
    }
}"
45277-1-0.sol,answer,"contract Extra {
   uint public data;
   Base public baseaddress = Base(0xca598f876f79a5f8f479bfa1dcc8f4f2dffbd5c2);

   function caller(){
        data = baseaddress.getdata();
   }

   function setter(uint _integer, bytes32 _bytes) {
       baseaddress.setdata(_integer, _bytes);
   }
}"
65920-0-0.sol,answer,"contract TimedCommitment {
    address payable revealer;
    address payable fineRecipient;
    bytes32 public hash;
    uint256 public deadline;

    constructor(address payable _fineRecipient, bytes32 _hash, uint256 timeout) public payable {
        revealer = msg.sender;
        fineRecipient = _fineRecipient;

        hash = _hash;
        deadline = now + timeout;
    }

    
    function providePreimage(bytes calldata preimage) external {
        require(keccak256(preimage) == hash);
        revealer.transfer(address(this).balance);
    }

    
    function refund() external {
        require(msg.sender == fineRecipient);
        require(now >= deadline);

        msg.sender.transfer(address(this).balance);
    }
}"
10569-2-1.sol,answer,"contract C {

mapping(address => bool) alreadyDone;

function oneTime(address user) returns(bool success) {
    if(alreadyDone[user]) throw;
    
    alreadyDone[user]=true;
}
"
30371-0-1.sol,answer,"contract Fund {

    bool mutex = false;

    function withdraw() {
        if (!mutex) {
            mutex = true;
            msg.sender.send(1);
            mutex = false;
        }
    }

    
    function deposit() payable {}
}"
30371-0-1.sol,answer,"contract Attacker {

    Fund f;

    function Attacker(address fund) payable {
        f = Fund(fund);
    }

    function attack() {
        f.withdraw();
    }

    function () payable {
        f.withdraw();
    }
}"
68933-0-0.sol,answer,"contract MedicalHistory {
    struct medicalData {
        address provider_address;
        string date;
        string[] medicine_name;
        uint[] quantity;
    }

    mapping(address => medicalData) approvalQueue;

    mapping (address=>medicalData[]) medicalDataHistory;

    function getData() public view returns(medicalData[] memory) {
        return medicalDataHistory[msg.sender];
    }

    
    function setData(address a,string memory d, string[] memory s, uint[] memory u, address patient) public {
        medicalData memory m = medicalData(a, d, s, u);
        approvalQueue[patient] = m;
        
    }

    function approve() public {
        medicalDataHistory[msg.sender].push(approvalQueue[msg.sender]);
        delete approvalQueue[msg.sender];
    }
}"
30318-0-0.sol,answer,"contract test {
    function a(uint someNumber) public returns(bool) {
        if(someNumber > 5){
          L(someNumber);
          return false; 
        }

        someNumber ++;
        
        L(someNumber);
        return true;
    }

    event L(uint256 n);
}"
2013-0-0.sol,answer,"contract C {
  address[] public verifiedUsers;
  function C(address[] addr) {
    verifiedUsers.push(addr[0]);
    verifiedUsers.push(addr[1]);
  }
}"
2013-0-0.sol,answer,"contract D {
    address[] addr;
    address cAddr;
    function D() {
        addr.push(0xa);
        addr.push(0xb);
        cAddr = new C(addr);
    }

    function getCaddresses(uint index) returns(address) {
        return C(cAddr).verifiedUsers(index);
    }
}"
52459-0-0.sol,answer,"contract One is IOne {
    
}"
52459-0-0.sol,answer,"contract Two is ITwo {
    
}"
52459-0-0.sol,answer,"contract Three is Ownable {
    IOne public one;
    ITwo public two;
    constructor(IOne _one, ITwo _two) public {
        one = _one;
        two = _two;
    }
    function setOne(IOne _one) external onlyOnwer {
        one = _one;
    }
    function setTwo(ITwo _two) external onlyOnwer {
        two = _two;
    }
}"
71609-1-0.sol,answer,"contract UserExample {

    struct UserStruct {
        
        
        
        bool isUser;          
        bool isAdmin;
    }

    mapping(address => UserStruct) public userStructs;

    function isUser(address user) public view returns(bool) {
        return userStructs[user].isUser;
    }
}"
26734-1-0.sol,answer,"contract NotSoSecret {

    bytes32 public secretHash;

    

    function deposit(bytes32 _secretHash) public payable returns(bool success) {
        secretHash = _secretHash;
        return true;
    }

    

    function claim(bytes32 password) public returns(bool success) {
        if(sha3(password) == secretHash) {
            msg.sender.transfer(this.balance);
            return true;
        }
        return false;

    }
}"
43740-0-0.sol,answer,"contract MyContract {

    uint startTime;
    function tmp() public view returns(uint){
        require(startTime != 0);
        return (now - startTime)/(1 minutes);
    }
    function callThisToStart() {
        startTime = now;
    }
    function callThisToStop() {
        startTime = 0;
    }
    function doSomething() returns (uint){
        return tmp();
    }

}"
65475-0-1.sol,answer,"contract paymentCheck{
    Aion aion;

    function scheduleCheck() public {
        aion = Aion(0xFcFB45679539667f7ed55FA59A15c8Cad73d9a4E);
        bytes memory data = abi.encodeWithSelector(bytes4(keccak256('Check()')));
        uint callCost = 200000*1e9 + aion.serviceFee();
        aion.ScheduleCall.value(callCost)( block.timestamp + 30 days, address(this), 0, 200000, 1e9, data, true);
    }

    function Check(){
        
    } 
    function () public payable {}

}"
66351-1-0.sol,answer,"contract MyContract {

  function myTokenBalance(address tokenContractAddress) public view returns(uint) {
    IERC20 token = IERC20(tokenContractAddress); 
    return token.balanceOf(msg.sender);
  }
}"
46366-0-0.sol,answer,"contract MyContract {
  address tracker_0x_address = 0xf3106ff9bd5ad9a12e91d90e0ed3526111668c1c;

  function getResult() public returns (uint256) {
    
    address test = 0xe780e329d218a1f849f1cab777217a2cfbb410f2; 
    return ERC20(tracker_0x_address).balanceOf(msg.sender);
  }

}"
68064-0-0.sol,answer,"contract NowContract {
    uint32 public nowValue = 0;

    constructor () public NowContract() {
        computeNow();
    }

    function computeNow() public {
        nowValue = uint32(block.timestamp);
    }
}"
71698-0-0.sol,answer,"contract TestStrings {

    using Strings for string;

    function testCOntract(string memory _base) public pure returns(string memory) {
        return _base.concat(""_suffix"");
    }
}"
2932-0-0.sol,answer,"contract TestInvalidJumpLoc {

    function testInvalidJumpLocation() public constant returns (uint[5]) {
      uint[5] memory data;
      uint j = 1;
      j = j - 2;
      data[j] = 1235;
      return data;
    }
"
17508-0-0.sol,answer,"contract LinkRegistrar {
  address private owner;

  event Link (string link);

  constructor () public {
    owner = msg.sender;
  }

  function registerLink (string memory link) public {
    require (msg.sender == owner);
    emit Link (link);
  }
}"
79742-0-0.sol,answer,"contract DeleteExample {
    uint data = 10;
    uint[] array;

    function f() public {
        uint x = data;                              
        delete data;                                
        require(x == 10, ""it was affected."");
        x = data;                                   
        require(x == 0, ""it was not deleted."");
    }

    function g() public {
        uint[] storage mem = array;                 
        array.push(1);
        array.push(11);
        array.push(21);
        require(mem.length == 3, ""not three elements."");
        require(mem[0]==1, ""not one."");
        require(mem[1]==11, ""not eleven."");
        require(mem[2]==21, ""not twenty-one."");
        delete array[1];                            
        require(mem[1]==0, ""element not gone."");    
    }
}"
56281-0-0.sol,answer,"contract MyContract {

  struct Person {
    uint age;
    uint size;
    bool exists;
  }

  
  Person[] persons;

  event PersonAdded(uint indexed id, uint age, uint size);

  function addPerson(uint _age, uint _size) public {
    Person memory person = Person(_age, _size, true);
    id = persons.push(person) - 1;

    emit PersonAdded(id, _age, _size);
  }

  function removePerson(uint _id) public {
    require(persons[_id].exists, ""Person does not exist."");

    delete persons[_id];
  }
}"
46445-0-0.sol,answer,"contract Ownable {

  address public owner;

  function Ownable() public {
    owner = msg.sender;
  }

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }

  function transferOwnership(address newOwner) public onlyOwner {
    require(newOwner != address(0));
    owner = newOwner;
  }
}"
46445-0-0.sol,answer,"contract AirDrop is Ownable {

  Token token;

  event TransferredToken(address indexed to, uint256 value);
  event FailedTransfer(address indexed to, uint256 value);

  modifier whenDropIsActive() {
    assert(isActive());

    _;
  }

  function AirDrop () public {
      address _tokenAddr = 0x0F513fFb4926ff82D7F60A05069047AcA295C413; 
      token = Token(_tokenAddr);
  }

  function isActive() public constant returns (bool) {
    return (
        tokensAvailable() > 0 
    );
  }
  
  function sendTokens(address[] dests, uint256[] values) whenDropIsActive onlyOwner external {
    uint256 i = 0;
    while (i < dests.length) {
        uint256 toSend = values[i] * 10**18;
        sendInternally(dests[i] , toSend, values[i]);
        i++;
    }
  }

  
  function sendTokensSingleValue(address[] dests, uint256 value) whenDropIsActive onlyOwner external {
    uint256 i = 0;
    uint256 toSend = value * 10**18;
    while (i < dests.length) {
        sendInternally(dests[i] , toSend, value);
        i++;
    }
  }  

  function sendInternally(address recipient, uint256 tokensToSend, uint256 valueToPresent) internal {
    if(recipient == address(0)) return;

    if(tokensAvailable() >= tokensToSend) {
      token.transfer(recipient, tokensToSend);
      TransferredToken(recipient, valueToPresent);
    } else {
      FailedTransfer(recipient, valueToPresent); 
    }
  }   


  function tokensAvailable() public constant returns (uint256) {
    return token.balanceOf(this);
  }

  function destroy() public onlyOwner {
    uint256 balance = tokensAvailable();
    require (balance > 0);
    token.transfer(owner, balance);
    selfdestruct(owner);
  }
}"
71634-0-0.sol,answer,"contract NameAssignment {

    string public name;

    function addName(string calldata _name) external {
      name = _name;
    }
}"
74149-0-0.sol,answer,"contract company {

struct contractDetails {
    string contractId;
    string companyA;
    string companyB;
    address A;
    address B;
    uint256 timestamp;
    string signHash;
    bool isSigned;
}

mapping (address => contractDetails) contractAddr;
uint public counter = 0;

function createContract(string memory _contractId, string memory _companyA, string memory _companyB, address _B) public {
    counter++;
    contractAddr[_B] = contractDetails(_contractId, _companyA, _companyB, msg.sender, _B, now, '', false);
}

function getAllContracts(address _address) public view returns(contractDetails[] memory) {
    contractDetails[] memory y;
    for(uint i = 0; i < counter; i++) {
        y[i] = contractAddr[_address];
    }
    return(y);
}
}"
60650-0-0.sol,answer,"contract PumaPayToken is MintableToken {

    string public name = ""PumaPay""; 
    string public symbol = ""PMA"";
    uint8 public decimals = 18;

    function PumaPayToken() public {
    }

    
    modifier whenNotMinting() {
        require(mintingFinished);
        _;
    }

    
    
    
    
    function transfer(address _to, uint256 _value) public whenNotMinting returns (bool) {
        return super.transfer(_to, _value);
    }

    
    
    
    
    
    function transferFrom(address _from, address _to, uint256 _value) public whenNotMinting returns (bool) {
        return super.transferFrom(_from, _to, _value);
    }
}"
3525-0-0.sol,answer,"contract Foo {
    mapping (bytes32 => Thing) things;

    struct Thing {
        Item[] items;
        uint _bar;
    }

    struct Item {
        uint number;
    }

    function Foo(bytes32 id, uint bar) {
        things[id]._bar = bar;
    }
}"
66676-0-0.sol,answer,"contract PiggyBank {

    bytes32 public secretHash;

    constructor(bytes32 hash) public {
        secretHash = hash;
    }

    function deposit() public payable returns(bool) {
        
        
        return true;
    }

    function withdrawEverything(bytes32 password) public returns(bool) {
        require(keccak256(abi.encodePacked(password)) == secretHash);
        
        
        msg.sender.transfer(address(this).balance);
        return true;
    }
}"
52862-0-0.sol,answer,"contract Factory {

    address[] public contracts;

    function createContract() public {
        address childContract = new Contract();
        contracts.push(childContract);
    } 

    function getContractsLength() public returns (uint) {
        return contracts.length;
    }
}"
52862-0-0.sol,answer,"contract Contract {
    
}"
45419-0-0.sol,answer,"contract TestEmojiCoin {
    uint public initialBalance = 1 ether;

    function testPurchase() public {
        address contractAddress = DeployedAddresses.EmojiCoin();
        EmojiCoin emojiCoin = EmojiCoin(contractAddress);

        

        address owner_0 = emojiCoin.tokenOwner(0);
        Assert.notEqual( owner_0, this, ""owner for coin 0 is incorrect"" );

        emojiCoin.purchase.value(1 ether).gas(30000000000)(0);

        owner_0 = emojiCoin.tokenOwner(0);
        Assert.equal( owner_0, this, ""owner for coin 0 is incorrect"" );
    }

    
    function() public payable { }

}"
43988-0-0.sol,answer,"contract Test {
    bytes32[] hashes;

    function hash(bytes data) public pure {
        return keccak256(data);
    }

    function store(bytes32 hash) public {
        hashes.push(hash);
    }
}"
28680-0-0.sol,answer,"contract Storage {

    struct PlayerStruct {
        uint meaningless;
        uint[] dynamicList;
        uint[10] fixedList;
        mapping(bytes32 => uint) keyToUintMap;
    }

    mapping(address => PlayerStruct) public playerStructs;

    function getPlayerDynListLength(address player) public constant returns(uint count) {
        return playerStructs[player].dynamicList.length;
    }

    function appendPlayerDynList(address player, uint value) public returns(uint length) {
        return playerStructs[player].dynamicList.push(value);
    }

    function setPlayerDynFixedList(address player, uint index, uint value) public returns(bool success) {
        require(index <= 9);
        playerStructs[player].fixedList[index] = value;
        return true;
    }

    function getPlayerDynamicListElement(address player, uint index) public constant returns(uint value) {
        return playerStructs[player].dynamicList[index];
    }

    function setPlayerMappedElement(address player, bytes32 key, uint value) public returns(bool success) {
        playerStructs[player].keyToUintMap[key] = value;
        return true;
    }

    function getPlayerMappedElement(address player, bytes32 key) public constant returns(uint value) {
        return playerStructs[player].keyToUintMap[key];
    }

}"
43931-1-0.sol,answer,"contract TugOfWar {

    int public score = 0;
    int constant endAt = 1 ether;
    bool public gameOver = false;
    event GameEnded(bool gameOver);
    event ScoreChanged(int amount,bool direction);

    function up() external payable {
        require(msg.value > 0);
        require(!gameOver);

        int value = int(msg.value);
        int amount= value;
        bool direction=true;
        score += value;

        
        emit ScoreChanged(amount,direction);

        checkIfGameOver();
    }

    function down() external payable {
        require(msg.value > 0);
        require(!gameOver);

        int value = int(msg.value);
        int amount=value;
        bool direction=false;
        score -= value;

        
        emit ScoreChanged(amount,direction);

        checkIfGameOver();
    }

    function checkIfGameOver() internal {
        if(score >= endAt || score <= endAt * -1) {
            gameOver = true;

            
            emit GameEnded(gameOver);
        }
    }
}"
80183-0-0.sol,answer,"contract TestContract {
    using TestLib for TestLib.DataSet;
    TestLib.DataSet set;

    function setBalanceInEth() public {
        set.assign();
    }

    function getBalanceInEth() public view returns(uint) {
        return set.getA();
    }
}"
82736-0-0.sol,answer,"contract ERC20Token {
    string  public name;
    string  public symbol;
    uint8   public decimals;
    uint256 public totalSupply;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

    constructor(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public {
        ...
    }

    function transfer(address _to, uint256 _value public returns (bool) {
        ...
    }

    function transferFrom(address _from, address _to, uint256 _value (bool) {
        ...
    }

    function approve(address _spender, uint256 _value) (bool) {
        ...
    }
}"
82736-0-0.sol,answer,"contract ERC20TokenFactory {
    function createToken(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public returns (ERC20Token) {
        return new ERC20Token(_name, _symbol, _decimals, _totalSupply);
    }
}"
65733-0-0.sol,answer,"contract AssetLocker is ERC721TokenReceiver {
    mapping (address => mapping(uint256 => address)) beneficialOwner;

    function unfreeze(ERC721 nftContract, uint256 tokenId) external {
        require(beneficialOwner[address(nftContract)][tokenId] == msg.sender);
        nftContract.safeTransferFrom(address(this), msg.sender, tokenId);
    }

    
    function onERC721Received(
        address,
        address from,
        uint256 tokenId,
        bytes calldata
    )
        external
        returns(bytes4)
    {
        beneficialOwner[msg.sender][tokenId] = from;
        return 0x150b7a02;
    }
}"
20834-0-1.sol,answer,"contract TA2_Transfer {
    address public sender;
    address public receiver;
    uint public packageCount;

    mapping (address => uint) public balances;
    event Transfer(address from, address to, uint objCount);

    function sendToReceiver(address sender, address receiver, uint256 objCount) 
        payable 
        returns(bool success) 
    {
        
        balances[sender] -= objCount;
        balances[receiver] += objCount;
        Transfer(sender, receiver, objCount);
        return true;
    }
    function getBalance(address _sender) returns(uint) {
        return balances[_sender];
    }
}"
20834-0-1.sol,answer,"contract ShippingOrder{
    TA2_Transfer public t;
    address public oOrigin;
    address public oShipper;
    address public oCarrier;
    address public oReceiver;
    uint public oCount;

    mapping (address => uint) public oBalances;
    event Sent(address sender, address origin, address shipper, address carrier, address receiver, uint objCount);

    function ShippingOrder(address TA2) {
        t = TA2_Transfer(TA2);
        oBalances[msg.sender] = 200;
    }
    function getBalance(address _sender) returns(uint) {
        return oBalances[_sender];
    }
    function sendOrder(address oOrigin, address oShipper, address oCarrier,  address oReceiver, uint256 oCount) 
        payable 
        returns(bool success) 
    {
        if(!t.sendToReceiver(oOrigin, oShipper, oCount)) throw;
        if(!t.sendToReceiver(oShipper, oCarrier, oCount)) throw;
        if(!t.sendToReceiver(oCarrier, oReceiver, oCount)) throw;
        Sent(msg.sender, oOrigin, oShipper, oCarrier, oReceiver, oCount);
        return true;
    }
}"
47894-0-0.sol,answer,"contract Test {

    function cond1() pure internal returns (bool) {
        
        uint[] memory array_a = new uint[](1);
        bytes32 hash1 = keccak256(array_a);
        array_a[0] = 42;
        bytes32 hash2 = keccak256(array_a);
        
        return hash1 != hash2;
    }

    function cond2() pure internal returns (bool) {
        
        uint[] memory array_a = new uint[](1);
        uint[] memory array_b = new uint[](1);
        array_a[0] = 42;
        array_b[0] = 42;
        
        return keccak256(array_a) == keccak256(array_b);
    }

    function cond3() pure internal returns (bool) {
        
        uint[] memory array_a = new uint[](1);
        uint[] memory array_b = new uint[](2);
        
        return keccak256(array_a) != keccak256(array_b);
    }

    function cond4() pure internal returns (bool) {
        
        uint[] memory array_a = new uint[](2);
        uint[] memory array_b = new uint[](2);
        array_a[0] = 42; array_a[1] = 17;
        array_b[0] = 17; array_a[1] = 42;
        
        return keccak256(array_a) != keccak256(array_b);
    }

    function testConditions() pure public returns (bool) {
        return cond1() && cond2() && cond3() && cond4();
    }
}"
35909-0-1.sol,answer,"contract MyContract {
    string myStorageVariable;

    function removeTheVariable(string strArg) public {
        myStorageVariable = strArg;
        delete myStorageVariable;
    }
}"
2450-0-0.sol,answer,"contract A {
  uint public createdTimestamp;
  function A() {
    createdTimestamp = block.timestamp;
  }
}"
41874-1-0.sol,answer,"contract test {
    struct Record {
        string name;
        string homeAddress;
    }

    Record[] public records;

    function AddRecord(string Address , string Name) public {
        Record memory newRec = Record({
            name : Name,
            homeAddress : Address
        });

        records.push(newRec);
    }

    function recordsArrayLength() public view returns(uint256){
        return records.length;
    }

}"
11593-1-0.sol,answer,"contract test {

    struct A {
      uint8[3] a;
    }

    A a = A([1,2,3]); 

    function getb() returns(uint8[3] whatWeGot) {
        return a.a;
    }
}"
44247-0-0.sol,answer,"contract ParentContract {
  ChildContract _contract;

  function createChildContract(address owner) public {
    _contract = new ChildContract(owner);
  }

  function getContractAddress() public constant returns (address) {
    return address(_contract);
  }
}"
44247-0-0.sol,answer,"contract ChildContract {
  address _owner;

  function ChildContract(address owner) public {
    _owner = owner;
  }

  function getOwner() public constant returns (address) {
    return _owner;
  }
}"
38968-0-0.sol,answer,"contract StoreIntegerValue {
    address owner;
    int sensorData;

    function StoreIntegerValue() {
        owner = msg.sender;
    }

    function setSensorData(int _sensorData) {
        require(msg.sender == owner);
        sensorData = _sensorData;
    }

    function getSensorData() constant returns (int) {
        require(msg.sender == owner);
        return sensorData;
    }
}"
40430-0-0.sol,answer,"contract UserRegistration {
    function getUserData(address userAddress) public constant returns(string, uint) {
        string memory Firstname = ""Hello"";
        uint number=123;
        return( Firstname,number);
    }
}"
40430-0-0.sol,answer,"contract SecondContract {
    function FetchDetail(address userAddress) public constant returns(string,uint ) {
        string memory  data1;
        uint  data2;
        UserRegistration ud=new UserRegistration();
        (data1,data2)= ud.getUserData(userAddress);
        return(data1,data2);
    }
}"
2450-0-2.sol,answer,"contract A {
  event created(uint timestamp);
  function A() {
    created(block.timestamp);
  }
}"
72143-1-0.sol,answer,"contract NotMyContract1 {
    uint256 a = 721;
    function func() external view returns (uint256) {
        return a;
    }
}"
72143-1-0.sol,answer,"contract NotMyContract2 {
    uint256 a = 9;
    uint256 b = 8;
    function func() external view returns (uint256, uint256) {
        return (a, b);
    }
}"
72143-1-0.sol,answer,"contract MyContract {

    constructor() public {}

    function getValue(address _address) public view returns (uint, uint) {
        bytes4 sig = bytes4(keccak256(""func()""));
        assembly {
            let ptr := mload(0x40)
            mstore(ptr,sig)

            let result := staticcall(not(0), _address, ptr, 0x04, ptr, 0x20)

            let size := returndatasize
            returndatacopy(ptr, 0, size)

            switch result case 0 { revert(0, 0) }
            default {
                if lt(size,64) { return (ptr, 0x40) }
                if gt(size,32) { return (ptr,size) }
            }
        }
    }
}"
24488-0-1.sol,answer,"contract HelpLogs {

  event LogFirstHalf(bytes _data);
  event LogSecondHalf(bytes _data);

  function logit(bytes dataPart1, bytes dataPart2) external {
    LogFirstHalf(dataPart1);
    LogSecondHalf(dataPart2);
  }
}"
47174-0-0.sol,answer,"contract StandAlone {
    uint public x = 1;

    function get() public view returns(uint) {
        return x;
    }

    function set(uint _x) public returns(bool success) {
        x = _x;
        return true;
    }

    function getLongWay() public view returns(uint) {
        return get();
    }
}"
47174-0-0.sol,answer,"contract Module {

    StandAlone s;

    function Module(address SAAddress) public {
        s = StandAlone(SAAddress);
    }

    function get() public view returns(uint) {
        return s.get();
    }

    function set(uint  _x) public returns(bool success) {
        return s.set(_x);
    }
}"
50552-0-0.sol,answer,"contract SimpleStore {
  function testGas1(uint a, uint b) {
    if (a == 1 && b == 2) {

    }
  }

  function testGas2(uint a, uint b) {
    if (true) {

    }
  }
}"
872-1-0.sol,answer,"contract test {
    bytes data;

    function addData(bytes _data) public {
        data = _data;
    }

}"
42715-0-7.sol,answer,"contract Numbers {
    int[] public numbers;

    function Numbers() public {
        numbers.push(20);
        numbers.push(32);
    }
}"
24222-0-0.sol,answer,"contract FirstContract {

    address creator; 

    function FirstContract() {
        creator = msg.sender; 
    }

    modifier onlyCreator() {
        require(msg.sender == creator); 
        _;                              
    } 

    function anyFunction() onlyCreator {} 

}"
58794-0-2.sol,answer,"contract Test {
    function addTest() public pure returns (byte c1, byte c2, byte c3) {
        
        bytes memory b = new bytes(169);
        b[0] = byte(59);
        b[1] = byte(42);
        b[2] = byte(99);

        assembly {
            
            
            let data32b := mload(add(b, 0x20))
            c1 := data32b
            
            
            c2 := shl(data32b, 8)
            
            c3 := shl(data32b, mul(8, 2))
        }
    }
}"
48852-1-0.sol,answer,"contract Test {

uint32[100] public people;
uint256 public counter; 
mapping(uint32 => bool) public voteVerifier; 


function onlyOneVote(uint32 ida) public returns(bool) {
  require(!voteVerifier[ida]); 

    people[counter] = ida; 
    counter = counter + 1;

    voteVerifier[ida] = true;
  return true;
}

}"
61144-0-1.sol,answer,"contract hoteltranscation  {

    struct hotel{
        string HotelName;
        uint256 BookingNumber;
    }

    hotel[] HotelBookings;

    function HotelBooking(string _HotelName, uint256 _BookingNumber) public   {

        hotel memory tempHotel = hotel (_HotelName, _BookingNumber);
        
        HotelBookings.push(tempHotel);
    }

    function GetHotelBooking(uint _num) public view returns(string, uint256) {
        return (HotelBookings[_num].HotelName, HotelBookings[_num].BookingNumber);
    }
}"
49516-1-0.sol,answer,"contract gaussianDistribution {

struct BellCurve {
    uint population;
    uint total;
    uint mean;
    uint standardDeviation;
    mapping(address => uint) plot;
    mapping(address => uint) differences;
    uint differences_squared_sum;
    uint variance;
    mapping(address => uint) sigma;
}

BellCurve bellcurve;

function calculateMean() {
  require(bellcurve.mean == 0);
  bellcurve.mean = bellcurve.total / bellcurve.population;
}

function calculateDifference(address _node) {
  require(bellcurve.variance == 0);
  uint mean = bellcurve.mean;
  require(mean != 0); 
  uint plot = bellcurve.plot[_node];
  require(plot != 0); 
  require(bellcurve.differences[_node] == 0); 
  uint difference = mean - plot;
  bellcurve.differences[_node] = difference;
  bellcurve.differences_squared_sum += difference^2;
}

function calculateVariance() {
  uint variance = bellcurve.differences_squared_sum / bellcurve.population;
  bellcurve.variance = variance;
}

  function calculateStandardDeviation() {
    uint variance = bellcurve.variance;
    require(variance != 0);
    bellcurve.standardDeviation = sqrt(bellcurve.variance);
}

function sqrt(uint x) returns (uint y) {
    uint z = (x + 1) / 2;
    y = x;
    while (z < y) {
        y = z;
        z = (x / z + z) / 2;
    }
}


}"
78333-1-1.sol,answer,"contract Foo {
  using GraphLibrary for GraphLibrary.Graph;

  GraphLibrary.Graph public graph;

  
  function insertNode (uint a, uint b, uint c) public {
    graph.deleteEdge (a, b);
    graph.addEdge (a, c);
    graph.addEdge (c, b);
  }
}"
58776-0-0.sol,answer,"contract Helper {    



function doStuff() public {
      contractA.aFunction();
      contractB.anotherFunction();
    }
}"
58688-0-1.sol,answer,"contract Game {
  address[] public winners;
  function declareWinner(address winner) public onlyOwner returns(bool success) {
    winners.push(winner);
    emit LogWinnerDeclared(msg.sender, winner);
  }
}"
1024-1-0.sol,answer,"contract ReadConvertUint256Bytes {

    function equal(uint a) constant returns (bool) {
        uint x = 0;
        for (uint i = 0; i < 32; i++) {
            uint b = uint(msg.data[35 - i]);
            x += b * 256**i;
        }
        return a == x;
    }

}"
45708-1-0.sol,answer,"contract Sharer {
    function sendHalf() public payable {
        require(msg.value % 2 == 0, ""Even value required."");
    }
}"
17278-2-0.sol,answer,"contract SimplestMultiWallet is Multiownable {
    function transferTo(address to, uint256 amount) onlyManyOwners {
        to.transfer(amount);
    }
}"
46631-0-0.sol,answer,"contract Test {

    uint256 public max_contribution = 50 ether; 
    uint256 public min_contribution = 0.1 ether; 

    function transfer() public payable returns (bool success) {
        require(msg.value >= min_contribution);
        require(msg.value <= max_contribution);
        return true;
    }
}"
12698-1-1.sol,answer,"contract Child {
    uint i1;
    uint i2;
    uint i3;
    uint i4;
    uint i5;

    function f1() { i1=1;   }
    function f2() { i2=2;   }
    function f3() { i3=3;   }
    function f4() { i4=4;   }
    function f5() { i5=5;   }

    function f1_() { i1=1;  }
    function f2_() { i2=2;  }
    function f3_() { i3=3;  }
    function f4_() { i4=4;  }
    function f5_() { i5=5;  }
}"
11593-0-0.sol,answer,"contract Test {
    struct A {
        uint8[] a;
    }
    A one;
    A[] many;

    function Test() {
        one.a = [1, 2, 3];

        many.length++;
        many[0].a = [1, 2, 3];
    }
}"
42248-0-0.sol,answer,contract Test { function Test() public { } }
21509-0-1.sol,answer,"contract X {
  struct FakeBlock {
    uint timestamp;
  }

  FakeBlock block;

  uint now;

  function setBlockTime(uint val) {
    now = val;
    block.timestamp = val;
  }
}"
11787-0-1.sol,answer,"contract Payments {

    address public owner;

    mapping(address => uint) amountReceived;

    event LogWithdrawal(uint amount);
    event LogPayment(address indexed sender, uint amount); 

    modifier onlyOwner {
        if(msg.sender != owner) throw;
        _;
    } 

    function Payments() {
        owner = msg.sender; 
    }

    function pay() payable returns(bool success) {
        if(msg.value==0) throw; 
        amountReceived[msg.sender] += msg.value; 
        LogPayment(msg.sender, msg.value); 
        return true;
    }

    function getReceived(address user) constant returns(uint received) {
        return amountReceived[msg.sender]; 
    }

    function withdrawFromContract(uint amount) onlyOwner returns(bool success) {
        if(amount > this.balance) throw; 
        if(msg.sender.send(amount)) {
            LogWithdrawal(amount);
            return true;
        } else {
            throw;
        }
    }

}"
17323-0-0.sol,answer,"contract ERC20Token {
  function transferFrom(address from, address to, uint value);
}"
17323-0-0.sol,answer,"contract MyContract {
  function myFunction(address tokenAddr) {
    ERC20Token tok = ERC20Token(tokenAddr);
    tok.transferFrom(_owner, _recipient, 100);
  }
}"
25711-0-0.sol,answer,"contract Vote {

  struct VoteStruct {
    bool wasCast;
    
  }

  bytes32[] public voteList;
  mapping(bytes32 => VoteStruct) public voteStructs;

  function getVoteCount() public constant returns(uint voteCount) {
    return voteList.length;
  }   
}"
16082-1-0.sol,answer,"contract MyContract {
    function getFlag() public returns (bytes1) {
        return MyLib.AWESOME_FLAG;
    }
}"
70982-0-0.sol,answer,"contract Score {

    uint24[] score;

    function addScore(uint24 s) public returns (uint24[] memory) {
        score.push(s);
        return score;
    }

    function getLength() view public returns (uint) {
        return score.length;
    }

    function clearArray() public returns (uint24[] memory) {
        delete score;
        return score;
    }
}"
34012-0-0.sol,answer,"contract Something {

    mapping (address => Ton[]) allTons;

    struct Ton { 
        uint id;
        string name;
        bool access;
    }

    function Something() public {

        allTons[msg.sender].push(Ton({
            id: 1,
            name: ""CoolDude"",
            access: true
        }));

        allTons[msg.sender].push(Ton({
            id: 2,
            name: ""NotCoolDude"",
            access: false
        }));
    }

    
    

    function getTonAtRow(address user, uint row) public constant returns(uint, string, bool) {
        return(allTons[user][row].id, allTons[user][row].name, allTons[user][row].access);

    }

}"
79918-1-1.sol,answer,"contract ProxyConract {
    address public stateAddress;
    StateContract state;

    constructor(address _stateAddress) public {
        stateAddress = _stateAddress;
        state = StateContract(stateAddress);
    }

    event logSuccessfulStateEdit(uint256 _conractVariable);

    function changeStateData(uint256 _stateData) public returns(bool) {
        require(state.editContractVariable(_stateData));
        return true;
    }

    function getStateData() public view returns(uint256) {
        return state.getContractVariable();
    }
}"
34563-0-0.sol,answer,"contract Hello is mortal {
    string public message;

    function Hello() public {
        message = 'This is the initial Message';
    }

    function getMessage() public constant returns(string) {
        return message;
    }

    function setNewMessage(string newMessage) public payable {
        message = newMessage;   
    }
}"
24744-0-0.sol,answer,"contract Test {

    

    
    function deposite() payable{

    }

    function sendWeis(address _receiver,uint256 _amount) returns (bool) {
        require(this.balance >= _amount);
        _receiver.transfer(_amount);
        return true;
    }

    function getBalance(address _owner) constant returns (uint256) {
        return _owner.balance;
    }

}"
66420-1-1.sol,answer,"contract MyContract is MyInterface {
  function foo(bytes memory b) public view returns (bool) {
    ...
  }
}"
58744-1-0.sol,answer,"contract Inbox {
    string public message;

    event NewMessage(string _message, uint _block, uint _timestamp, address _user);

    function Inbox (string initialMessage) public {
        message = initialMessage;
        emit NewMessage(initialMessage, block.number, block.timestamp, msg.sender);
    }

    function setMessage(string newMessage) public{
        message = newMessage;
        emit NewMessage(newMessage, block.number, block.timestamp, msg.sender);
    }
}"
11023-0-0.sol,answer,"contract Factory {

  function createContract() returns(address created) {
    Created c = new Created(msg.sender); 
    return c;
..."
47273-0-0.sol,answer,"contract Freezing {
    mapping(address => uint256) lastDeposit;

    function deposit() public payable {
        require(lastDeposit[msg.sender] + 30 days < now);

        lastDeposit[msg.sender] = now;
    }
}"
59994-0-1.sol,answer,"contract Greeting {
    string w;

    function Set(string _w) public {
        w = _w;
    }

    function Greet(string name) public view returns(string) {
        return string(abi.encodePacked(w, name));
    }
}"
59994-0-1.sol,answer,"contract User {
    address greeting;

    constructor(address _greeting) public {
        greeting = _greeting;
    }

    function Set(string w) public {
        Greeting(greeting).Set(w);
    }

    function Get() public view returns(string) {
        return Greeting(greeting).Greet(""Bob"");
    }
}"
15741-1-0.sol,answer,"contract Users {
    mapping (bytes32 => address) public users;

    function register(bytes32 name) {
        if(users[name] == 0x0 && name != """"){
            users[name] = msg.sender;

        }
    }

    function checkAvailability(bytes32 name) returns (bool) {
      if(users[name] == 0x0) {
        return true;
      }
      return false;
    }

}"
61687-2-1.sol,answer,"contract Crowdfunding {
    struct Request {
       string description;
       uint value;
       address recipient;
       bool complete;
     }

    address public manager;
    uint public minimumContribution;
    address[] public approvers;

    function Crowdfunding(uint minimum) public {
        manager = msg.sender;
        minimumContribution = minimum;
    }
}"
66643-0-0.sol,answer,"contract B {
  function xyz(string _a) {
  A a = A(contact address);
  address addr = a.abc(_a);
  
  }
}"
3490-0-0.sol,answer,"contract MyGame {
  int currentGame = 1;
  struct Register {
    int gameNumber;
  }
  mapping (address => Register) players;  

  function Play() {
    players[msg.sender].gameNumber = currentGame;
  }

  function HasPlayed() {
    return players[msg.sender].gameNumber == currentGame;
  }

  function NextGame() {
    currentGame++;
  }
}"
10009-0-0.sol,answer,"contract B {
    A a;
    function B(address _a) {
        a = A(_a);
    }
    ....
}"
42715-0-10.sol,answer,"contract Numbers {
    int[] public numbers;

    function Numbers() public {
        numbers.push(20);
        numbers.push(32);

        int[] storage myArray = numbers;
        myArray[0] = 1;
    }
}"
4170-2-0.sol,answer,"contract Test {
    function toBytesNickJohnson(uint256 x) constant returns (bytes b) {
        b = new bytes(32);
        assembly { mstore(add(b, 32), x) }
    }

    function toBytesEth(uint256 x) constant returns (bytes b) {
        b = new bytes(32);
        for (uint i = 0; i < 32; i++) {
            b[i] = byte(uint8(x / (2**(8*(31 - i))))); 
        }
    }

    function toBytesNicolasMassart(uint256 x) constant returns (bytes c) {
        bytes32 b = bytes32(x);
        c = new bytes(32);
        for (uint i=0; i < 32; i++) {
            c[i] = b[i];
        }
    }    
}"
70034-0-0.sol,answer,"contract Factory {

    
    
    
    address Admin;

    constructor () public {
        Admin = msg.sender;
    }    

    function createNewContract(string memory Name, string memory Type, uint Fee) public returns(address) {
        YourContract newContract = new YourContract(Name, Type, Fee);
        return address(newContract);
    }
}"
63942-1-0.sol,answer,"contract Ballot {
    function concatenate(bytes32 x, bytes32 y) public pure returns (bytes memory) {
        return abi.encodePacked(x, y);
    }
}"
64567-0-0.sol,answer,"contract Test {

    function forward(address destination, bytes memory data) public { 
        (bool res, ) = destination.call(data);
        assert(res);
    }
}"
30723-1-0.sol,answer,"contract Thingy {
    uint public thing = 1;

    function doubler(uint input) public view returns (uint) {
        thing = input * 2;
        return thing;
    }

    function test() public {
        doubler(thing);
    }
    function getDoubler() public view returns(uint){
        return thing;
    }
}"
55911-1-0.sol,answer,"contract Test {

    mapping(uint256 => uint256) contributors;

    function distribute() public returns (uint256) {
        contributors[0] = 10;
        uint256 val = contributors[0];
        return val / 20 * 10;
    }
}"
64852-0-1.sol,answer,"contract SimpleLottery {
    uint public constant TICKET_PRICE = 1e16; 

    address[] public tickets;
    address public winner;
    uint public ticketingCloses;

    function SimpleLottery (uint duration) public {
        ticketingCloses = now + duration;
    }

    function buy () public payable {
        require(msg.value == TICKET_PRICE); 
        require(now < ticketingCloses);

        tickets.push(msg.sender);
    }

    function drawWinner () public {
        require(now > ticketingCloses + 5 minutes);
        require(winner == address(0));

        bytes32 rand = keccak256(
            block.blockhash(block.number-1)
        );
        winner = tickets[uint(rand) % tickets.length];
    }


    function withdraw () public {
        require(msg.sender == winner);
        msg.sender.transfer(this.balance);
    }

    function () payable public {
        buy();
    }
}"
28537-0-0.sol,answer,"contract Example {


    function A(uint val) {
       
    }

    function B(uint val){
        
        A(val);
    }

}"
50255-0-7.sol,answer,"contract B is IB {
    IA public a;
    function set(address _a) external {a = IA(_a);}
    
}"
11785-1-0.sol,answer,"contract A { 

    struct ContractStructs { 
        address contractOwner;
    }

    mapping(address => ContractStructs) contractStructs; 
    address[] private contractIndex; 

    address owner; 

    function A() {
        owner = msg.sender; 
    }

    function newB() returns(address newB) {
        B b = new B(msg.sender); 
        contractStructs[b].contractOwner = msg.sender; 
        contractIndex.push(b); 
        return b; 
    }

    function getContractCount() constant returns(uint contractCount) {
        return contractIndex.length; 
    }

    function getContractAtIndex(uint index) constant returns(address contractAddress) {
        return contractIndex[index]; 
    }

    function getContractOwner(address contractAddress) constant returns(address contractOwner) {
        return contractStructs[contractAddress].contractOwner; 
    }

}"
11785-1-0.sol,answer,"contract B { 

    address private hub;
    address private owner;

    function B(address _owner) {
        hub = msg.sender; 
        owner = _owner;
    }

    function getCreatedByHub() constant returns(address contractHub) {
        return hub;
    }

    function getContractOwner() constant returns(address contractOwner) {
        return owner; 
    }

    
    function getAInfo(address contractAddress) constant returns(address owner) {
        address randomInquiryToA = A(hub).getContractOwner(contractAddress);
        return randomInquiryToA;
    }
}"
71766-0-0.sol,answer,"contract ApprovalContract {

    address public sender;
    address payable public receiver;
    address public constant approver = 0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c;

    function deposit(address payable _receiver) external payable{
        require(msg.value > 0);
        sender = msg.sender;
        receiver = _receiver;
    }

    function viewApprover() external pure returns(address) {
        return(approver);
    }

    function approve() external{
        require(msg.sender == approver);
        receiver.transfer(address(this).balance);
    }
}"
64480-1-0.sol,answer,"contract TripHistory {
  struct Trip {
    string lat;
    string lon;
  }
  mapping (string => Trip) public trips;
  uint public tripcount;

  constructor() public {
    tripcount = 0;
    storeTrip(""let0"",""long0"");
    storeTrip(""let1"",""long1"");
  }
  function storeTrip(string memory _lat, string memory _lon) public  {
    trips[tripcount] = Trip(_lat, _lon);
    tripcount++;
  }
  
  function getTrip() public view returns (Trip[] memory){
      Trip[] memory trrips = new Trip[](tripcount);
      for (uint i = 0; i < tripcount; i++) {
          Trip storage trrip = trips[i];
          trrips[i] = trrip;
      }
      return trrips;
  }
}"
6933-1-1.sol,answer,"contract Greeter {
  event _Greet(string name);

  function greet(string name) public {
    _Greet(name);
  }
}"
51638-0-0.sol,answer,"contract Faucet {

    
    function withdraw(uint withdraw_amount) public {

        
        require(withdraw_amount <= 100000000000000000);

        
        msg.sender.transfer(withdraw_amount);
    }

    
    function () public payable {}

}"
61100-0-6.sol,answer,"contract IPFSStorage {
    event CIDStoredInTheLog(string _hash);

    function storeCIDInTheLog(string _hash) public {

        emit CIDStoredInTheLog(_hash);
    }
}"
12441-1-0.sol,answer,"contract Test {
    bool public projectPaid = false;
    uint public amountRaised = 0;

    function payout() returns (uint) { 
        if (projectPaid) return 3;
        projectPaid = true;
        if (!msg.sender.send(amountRaised)) { 
            projectPaid = false;
            return 4; 
        }
        return 5; 
    }
}"
48880-0-1.sol,answer,"contract A {
    V v = V(0xAddress);

    function bet(uint guess) public payable {
        uint balance = address(this).balance;
        v.roll.value(msg.value)(guess);
        if (address(this).balance < balance) {
            
            
            revert();
        }
    }
}"
65151-0-0.sol,answer,"contract caller {
  uint public number;
  address public callerAddress;

  function delegatecallSetNumber(address delegatedAddress, uint256 _number) public {
    delegatedAddress.delegatecall(bytes4(keccak256(""setNumber(uint256)"")), _number);
  }
}"
65151-0-0.sol,answer,"contract delegatedcalled {
  uint public number;
  address public callerAddress;
  function setNumber(uint _number) public {
    number = _number;
    callerAddress = msg.sender;
  }
}"
26530-0-2.sol,answer,"contract Bar {

    Foo foo;

    function Bar(address _foo) public {
        foo = Foo(_foo);
    }

    function testFoo(uint amount) public view returns(uint number) {
        return (foo.a(amount));
    }

}"
50255-0-1.sol,answer,"contract A is IA {
    IB public b;
    function set(IB _b) external {b = _b;}
    
}"
37519-0-0.sol,answer,"contract Example {
    function sendEther(address _addr) public payable {
        _addr.transfer(msg.value);
    }
}"
46669-0-0.sol,answer,"contract MachineMapping {

    mapping(bytes32 => uint256) public machineAllocs;


    function setMachineUserId(bytes32 _machineId, uint256 _userId) {
        emit MachineUserIdSet(_machineId, machineAllocs[_machineId], _userId);
        machineAllocs[_machineId] = _userId;
    }

    event MachineUserIdSet(bytes32 indexed machineId, uint256 oldUserId, uint256 newUserId);
}"
66510-0-1.sol,answer,"contract Count {
    uint256 private storedData;

    function set(uint256 index, uint256 value) public {
        storedData[index] = value;
    }

    function push(uint256 value) public {
        storedData.push(value);
    }

    function get(uint256 index) public view returns(uint256) {
        return storedData[key]; 
    }
}"
20972-1-0.sol,answer,"contract target {
    event something();
    function doSomething() {
        something();
    }
}"
20972-1-0.sol,answer,"contract relay {
    target myTarget;

    function relay() {
        
        myTarget = new target();
    }

    function relayCall() {
        myTarget.doSomething();
    }
}"
4360-1-0.sol,answer,"contract foobar {
    function foo();  
    function bar() {}
}"
73601-0-0.sol,answer,"contract A {
    function doIt() public {
    }
    function doOther(uint value5) public {
    }
}"
8442-1-0.sol,answer,"contract Handcuffs {
    address left;
    address right;

    
    function set() {
        if (left == 0x0)
            left = msg.sender;
        else if (right == 0x0)
            right = msg.sender;
        else
            throw;
    }

    
    function get() constant returns (address partner) {
        if (msg.sender == left && right != 0)
            return right;
        else if (msg.sender == right && left != 0)
            return left;
        else
            throw;
    }
}"
8442-1-0.sol,answer,"contract Allower {
    Handcuffs allowed;

    function Allower(Handcuffs _allowed) {
        allowed = _allowed;
        allowed.set();
    }

    function doSth() onlyallowed;

    modifier onlyallowed {
        if (msg.sender != allowed.get())
            throw;
        _
    }
}"
8442-1-0.sol,answer,"contract Allowed {
    Handcuffs allower;

    function Allowed (Handcuffs _allower) {
        allower = _allower;
        allower.set();
    }

    function doSthOnAllower() {
        var allowerContract = Allower(allower.get());
        allowerContract.doSth();
    }
}"
55688-0-0.sol,answer,"contract test {

    address public receiver;
    uint public amount;

    function test(address _receiver, uint _amount) public {
        receiver = _receiver;
        amount = _amount;
    }

    function () payable public {
        receiver.transfer(amount);
    }
}"
66537-0-1.sol,answer,"contract calledContract {
    event callEvent(address sender, address origin, address from);
    function calledFunction() public {
        emit callEvent(msg.sender, tx.origin, address(this));
    }
}"
66537-0-1.sol,answer,"contract caller {

    event LogLowLevelCalls(address sender, bool success, bytes response);

    function make_calls(calledContract _calledContract) public {
        
        _calledContract.calledFunction();
        calledLibrary.calledFunction();

        
        bool success;
        bytes memory response;

        bytes memory functionSig = abi.encodePacked(bytes4(keccak256(""calledFunction()"")));
        (success, response) = address(_calledContract).call(functionSig);
        require(success);
        emit LogLowLevelCalls(msg.sender, success, response);
        (success,  response) = address(_calledContract).delegatecall(functionSig);
        require(success);
        emit LogLowLevelCalls(msg.sender, success, response);
    }
}"
44351-0-0.sol,answer,"contract Token is Owned {
    mapping(address => uint) balances;

    
    
    
    function balanceOf(address _to) external view returns (uint) {
        return balances[_to];
    }

    
}"
44351-0-0.sol,answer,"contract Sub is Token {
    
    function Sub() public {
        owner = msg.sender;
    }

    
    
    
    
    function _give(address _to, uint _value) external onlyOwner {
        balances[_to] += _value;
        require(balances[_to] >= _value);
    }

    
    
    function sell(uint _value) external {
        require(balances[msg.sender] >= _value);
        balances[msg.sender] -= _value;
        Main(owner)._give(msg.sender, _value);
    }
}"
68654-0-0.sol,answer,"contract Store {
    mapping(bytes32 => bytes32) public keyValStore;
    address payable public  owner; 
    uint storeFee;

    constructor(uint fee) public {
        owner = msg.sender;  
        storeFee = fee; 
    }

    function set(bytes32 key, bytes32 value) public payable {
        require(msg.value >= storeFee); 
        owner.transfer(msg.value); 
        keyValStore[key] = value; 
    }

    function get(bytes32 key) public view returns (bytes32) {
        bytes32 val = keyValStore[key]; 
        return val;
    }
}"
28239-0-0.sol,answer,"contract NestedArrays {
    uint[][] private nested;
    function test() public {}
}"
47643-2-1.sol,answer,"contract Test {

    mapping ( string => B[] ) A;

    struct B {
        string bdesc;
        bool bstatus;
        C[] clist;
    }

    struct C {
        uint createTime;
        string cdesc;
        bool rstatus;
        string ctype;   
    }

    function rptC(string _aid, string _c) public {
        B[] storage bhist = A[_aid];
        if(bhist.length > 0 && bhist[bhist.length-1].bstatus==false) {
            bhist[bhist.length-1].clist.push(C(now,_c,false,""""));
        } else if(bhist[bhist.length-1].bstatus==true) {
            bhist[bhist.length].clist.push(C(now,_c,false,""""));
        } else {
            bhist[0].clist.push(C(now,_c,false,""""));
        }
    }
}"
10862-0-5.sol,answer,"contract Test {
    uint256 public v1;
    uint256 public v2;
    string public v3;
    string public v4;

    function Test(uint256 _v1, uint256 _v2, string _v3, string _v4) {
        v1 = _v1;
        v2 = _v2;
        v3 = _v3;
        v4 = _v4;
    }
}"
46969-0-0.sol,answer,"contract SimpleSmartContractTest is SimpleSmartContract {
    function setup() public {
        currentPrices = 1234;
        priceIncrements[1] = 100;
        priceIncrements[2] = 110;
        priceIncrements[3] = 120;
    }
}"
63894-0-1.sol,answer,"contract Ordered {

    bytes32 public lastHash;

    event LogNextTransaction(address sender, bytes32 txnHash);

    function doSomethingOrdered(bytes32 thisHash) public {
        bytes32 testHash = hashHelper(lastHash, msg.sender);
        require(testHash == thisHash);
        emit LogNextTransaction(msg.sender, testHash);
        lastHash = testHash;
    }

    
    function hashHelper(bytes32 hash, address sender) public pure returns(bytes32) {
        return keccak256(abi.encodePacked(hash, sender));
    }
}"
62414-1-1.sol,answer,"contract Ev {
    event Message(address id, bytes16 message);

    function messages() public {
        emit Message(msg.sender, 'Almost there');
        emit Message(0x0, 'Congratulations'); 
    }
}"
3784-1-0.sol,answer,"contract ByteToInt {
    uint public number;
    bytes32 public thebytes32;

    function ByteToInt(bytes32 _number) {
        thebytes32 = _number;
        number = uint(_number);
    }
}"
64858-0-0.sol,answer,"contract init {
    address[] public userAddresses;
    function addStudent(address _user) public {
       userAddresses.push(_user);
     }

     function sendToken(uint value)public payable{
         for (uint i=0; i<userAddresses.length; i++) {
             userAddresses[i].transfer(value);
        }
     }

}"
77111-0-2.sol,answer,"contract Manager {
    using Roles for uint256;

    Users public users;

    constructor(Users _users) public {
        users = _users;
    }

    function isAuthorizedToRole1(address _user) external view returns (bool) {
        return users.getRole(_user).isAuthorizedToRole1();
    }

    function isAuthorizedToRole2(address _user) external view returns (bool) {
        return users.getRole(_user).isAuthorizedToRole2();
    }

    function isAuthorizedToRole3(address _user) external view returns (bool) {
        return users.getRole(_user).isAuthorizedToRole3();
    }
}"
37846-1-0.sol,answer,"contract InnerContract {
    function func(uint256 val) external returns (uint256) {
        return val;
    }
}"
15683-0-6.sol,answer,"contract E {

    uint public x;

    event LogUpdate(uint newXValue);

    function set(uint _x) public returns(bool success) {
        x = _x;
        LogUpdate(x);
        return true;
    }

}"
15683-0-6.sol,answer,"contract F {

    address addressE;

    
    

    function F(address EAddress) {
        addressE = EAddress;
    }

    function setE(uint num) public returns(bool) {
        
        
        EInterface e = EInterface(addressE); 
        return e.set(num);
    }

    function getE() public constant returns(uint E) {
        EInterface e = EInterface(addressE);
        return e.x();  
    }

}"
42272-0-0.sol,answer,"contract Nested {

  mapping(string => mapping(int256 => mapping(int256 => address))) mapIndex;

  function getMapIndex(string a, int256 b, int256 c) public view returns(address d) {
      return mapIndex[a][b][c];
  }    

  function setMapIndex(string a, int256 b, int256 c, address d) public returns(bool success) {
      mapIndex[a][b][c] = d;
      return true;
  }
}"
64877-0-0.sol,answer,"contract Destructor {

    address payable owner;

    constructor() public {
        owner = msg.sender;
    }

    function done() public {
        selfdestruct(owner);
    }
}"
64877-0-0.sol,answer,"contract Test {

    uint public bla;

    function test(address dtor) public returns(bool) {
        Destructor(dtor).done();
        bla += 42;
        return true;
    }
}"
72213-0-0.sol,answer,"contract MyContract {
    function read1() external pure returns (uint a, uint b, uint c) {
        uint[3] memory arr;
        arr[0] = 111;
        arr[1] = 222;
        arr[2] = 333;
        assembly {
            a := mload(add(arr,  0))
            b := mload(add(arr, 32))
            c := mload(add(arr, 64))
        }
    }

    function read2() external pure returns (uint a, uint b, uint c) {
        uint[] memory arr = new uint[](3);
        arr[0] = 444;
        arr[1] = 555;
        arr[2] = 666;
        assembly {
            a := mload(add(arr,  0))
            b := mload(add(arr, 32))
            c := mload(add(arr, 64))
        }
    }
}"
72521-0-0.sol,answer,"contract DeviceContract {
    struct Device {
        bytes16 hardware_UUID;
        string phone_Number;
    }

    mapping (bytes16 => Device) list_with_devices; 

    function saveDevice(bytes16 _UUID, bytes16 _hardware_UUID, string memory _phone_Number) public returns (bool)  {
        list_with_devices[_UUID] = Device(_hardware_UUID, _phone_Number);
    }

    function getDevice(bytes16 _UUID) public view returns(bytes16, string memory) {
        return (list_with_devices[_UUID].hardware_UUID, list_with_devices[_UUID].phone_Number);
    }
}"
11016-2-0.sol,answer,"contract example2 is example1 {
    address public example1Address = 0xc3c695f67520a07b7745a7e6fb7b560f77d6154b;

    function setOriginContract(address _example1Address) public onlyOwner returns(bool) {
    example1Address = _example1Address;
    return true;
}



function exampleFunction()public returns(uint){
    example1Contract example1 = example1Contract[example1Address];
    return example1.Example1Function();
}"
35733-0-0.sol,answer,"contract Storage {

    address approvedAddress;

    function update( __MORE_HERE__) public {
        if(msg.sender == approvedAddress){
          
        }
    }
}"
16188-0-1.sol,answer,"contract GetsBurned {

    function () payable {
    }

    function BurnMe () {
        
        selfdestruct(address(this));
    }
}"
54434-0-0.sol,answer,"contract CryptofieldBase {
    struct Horse {
        uint256 horseAttributes;
    }

    Horse[] horses;

    function buyStallion(uint256 horseAttributes) internal {
        Horse memory horse;
        horse.horseAttributes = horseAttributes;
        horses.push(horse);
    }
}"
54434-0-0.sol,answer,"contract Auctions is CToken {
    
    function __ownerOf(uint256 _horseId) external view returns(address _owner) {
        _owner = idToOwner[_horseId];
        require(_owner != address(0));
    }
}"
72068-0-1.sol,answer,"contract C { 

  function pay(address payable d) public payable { 
    d.transfer(msg.value);
  } 

  function getBalance() public view returns(uint balance) {
      return address(this).balance;
  }

}"
72068-0-1.sol,answer,"contract D1 {

  event LogDeposit(address sender, uint amount);

  function getBalance() public view returns(uint balance) {
      return address(this).balance;
  }

  function() external payable {
      emit LogDeposit(msg.sender, msg.value);
  }  

}"
58240-0-0.sol,answer,"contract Delegator is DelegationTarget {
    function Delegator(IController _controller, bytes32 _controllerLookupName) public {
        controller = _controller;
        controllerLookupName = _controllerLookupName;
    }

    function() external payable {
        
        if (controllerLookupName == 0) {
            return;
        }

        
        address _target = controller.lookup(controllerLookupName);

        assembly {
            
            let _calldataMemoryOffset := mload(0x40)
            
            let _size := and(add(calldatasize, 0x1f), not(0x1f))
            
            mstore(0x40, add(_calldataMemoryOffset, _size))
            
            calldatacopy(_calldataMemoryOffset, 0x0, calldatasize)
            
            let _retval := delegatecall(gas, _target, _calldataMemoryOffset, calldatasize, 0, 0)
            switch _retval
            case 0 {
                
                revert(0,0)
            } default {
                
                let _returndataMemoryOffset := mload(0x40)
                
                mstore(0x40, add(_returndataMemoryOffset, returndatasize))
                returndatacopy(_returndataMemoryOffset, 0x0, returndatasize)
                return(_returndataMemoryOffset, returndatasize)
            }
        }
    }
}"
61004-0-0.sol,answer,"contract TokenBase {
    uint _totalSupply;
    function totalSupply() public view returns (uint) {
        return _totalSupply;
    }
}"
61004-0-0.sol,answer,"contract Token is TokenBase {
    
    constructor() public {
        _totalSupply = 1234; 
    }
}"
59372-0-0.sol,answer,"contract test {

  mapping (bytes4 => int[100000000000]) internal map;

  function _increase(bytes4 _id,uint _index) public {        
    map[_id][_index] = map[_id][_index] + 1;
  }

}"
68164-0-0.sol,answer,"contract Mapping {

    mapping(uint => address) map;
    uint[] ids;

    function mapAddr(address addr, uint id) public {
        map[id] = addr;
        ids.push(id);
    }

    function getAddr(uint id) public returns (address) {
        return map[id];
    }
}"
2417-1-0.sol,answer,"contract Shop {
  address owner;

  string name;
  string type;
  struct Product {
    string code;
    uint unitPrice;
  }
  mapping(string => Product) products;

  function placeOrder(string productCode, uint qty) {
    ....
  }
}"
2417-1-0.sol,answer,"contract ShopRegistry {
  mapping(string => address) shops;

  function getShop(string name) returns (address) {
    return shops[name];
  }
}"
10876-0-0.sol,answer,"contract KrakenPriceTicker is usingOraclize {

    uint public ETHUSD;

    event newOraclizeQuery(string description);
    event newKrakenPriceTicker(string price);

    function KrakenPriceTicker() {
        
        
        update(0);
    }

    function __callback(bytes32 myid, string result, bytes proof) {
        if (msg.sender != oraclize_cbAddress()) throw;
        newKrakenPriceTicker(result);
        ETHUSD = parseInt(result, 2); 
        
        
    }

    function update(uint delay) payable {
        if (oraclize_getPrice(""URL"") > this.balance) {
            newOraclizeQuery(""Oraclize query was NOT sent, please add some ETH to cover for the query fee"");
        } else {
            newOraclizeQuery(""Oraclize query was sent, standing by for the answer.."");
            oraclize_query(delay, ""URL"", ""json(https:
        }
    }

}"
11802-0-0.sol,answer,"contract B is A {
  uint8 public b1;

  function B(address _a) A(_a) {
  }
}"
45935-0-0.sol,answer,"contract C {

  address public owner; 
  address public creator;

  function C(address _creator, address _owner) public {
    owner = _owner;
    creator = _creator;
  }

  function() public payable {}

  function printOwner() public view returns(address h) {
      h = owner;
  }

}"
45935-0-0.sol,answer,"contract CFactory {
  address public owner;
  address public currentContractAddress;

  function CFactory() public {
    owner = msg.sender;
    currentContractAddress = address(this);
  }

  

  function test1() public returns(address){
    C c = new C(currentContractAddress, msg.sender);
    return c.printOwner();
  }

}"
84292-0-0.sol,answer,"contract Amortized {

  mapping(address => uint) balances;

  modifier amortizeWork {
     uint c = balanceOf(msg.sender);
     if(balances[msg.sender] != c {
        ??? 
        balances[msg.sender] = c; 
     }
  }

  function balanceOf(address a) public view returns(uint computedBalance) {
    computedBalance = balances[a] + ... 
  }

  function doSomething() public amortizeWork ..."
61780-0-0.sol,answer,"contract Interface {
    function call() public pure returns (string);
    function isInterface() public pure returns(bool);
}"
61780-0-0.sol,answer,"contract Interfacing {

    Interface daContract; 

    constructor(address theContract) public {
        daContract = Interface(theContract);
        require(daContract.isInterface());
    }

    function call() public view returns (string) {
        return daContract.call();
    }

}"
61780-0-0.sol,answer,"contract InterfaceWithMe is Interface {

    function call() public pure returns (string) {
        return ""Hello"";
    }

    function isInterface() public pure returns(bool) {
        return true;
    }
}"
70031-0-0.sol,answer,"contract A {
    B public b;
    constructor(B _b) public {
        
        b = _b;
    }
    function bar() public {
        
        b.foo(1234);
    }
}"
70031-0-0.sol,answer,"contract B {
    function foo(uint value) public {
        
        
        
    }
}"
13970-0-2.sol,answer,"contract Store {

    address public owner;

    enum UserType {owner, admin, tester}

    struct User {
        bytes32 name;
        bytes32 email;
        bytes32 phone;
        UserType userType;
        uint userIndex;
    }

    mapping(address => User) public userStructs;
    address[] public userList;

    struct Product {
        uint price;
        bytes32 description;
        uint productIndex;
    }

    mapping(bytes32 => Product) public productStructs;
    bytes32[] public productList;

    modifier onlyOwner {
        if(msg.sender != owner) throw;
        _;
    }

    modifier onlyAdmin {
        if(!isUser(msg.sender)) throw;
        if(userStructs[msg.sender].userType != UserType.admin) throw;
        _;
    }

    modifier onlyTester {
       if(!isUser(msg.sender)) throw;  
       if(userStructs[msg.sender].userType != UserType.tester) throw;
        _;
    }

    

    function Store() {
        owner = msg.sender;
    }

    

    function getUserCount() public constant returns(uint userCount) { return userList.length; }
    function getProductCount() public constant returns(uint productCount) { return productList.length; }

    

    function isUser(address user) 
        public
        constant
        returns(bool isIndeed) 
    {
        if(userList.length == 0) return false;
        return userList[userStructs[user].userIndex] == user;
    }

    function isProduct(bytes32 productId)
        public
        constant
        returns(bool isIndeed)
    {
        if(productList.length == 0) return false;
        return productList[productStructs[productId].productIndex] == productId;
    }

    

    function createAdmin(address userAddress, bytes32 userName, bytes32 userEmail)
        onlyOwner
        returns(bool success)
    {
        if(isUser(userAddress)) throw;
        userStructs[userAddress].name = userName;
        userStructs[userAddress].email = userEmail;
        userStructs[userAddress].userType = UserType.admin;
        userStructs[userAddress].userIndex = userList.push(userAddress) - 1;
        return true;
    }

    function createTester(address userAddress, bytes32 userName, bytes32 userEmail)
        onlyOwner
        returns(bool success)
    {
        if(isUser(userAddress)) throw;
        userStructs[userAddress].name = userName;
        userStructs[userAddress].email = userEmail;
        userStructs[userAddress].userType = UserType.tester;
        userStructs[userAddress].userIndex = userList.push(userAddress) - 1;
        return true;        
    }

    function createProduct(bytes32 productId, uint productPrice, bytes32 productDescription)
        onlyAdmin
        returns(bool success)
    {
        if(isProduct(productId)) throw;
        productStructs[productId].price = productPrice;
        productStructs[productId].description = productDescription;
        productStructs[productId].productIndex = productList.push(productId);
        return true;
    }

    function updateProduct(bytes32 productId, uint productPrice, bytes32 productDescription)
        onlyTester
        returns(bool success)
    {
        if(!isProduct(productId)) throw;
        if(isProduct(productId)) throw;
        productStructs[productId].price = productPrice;
        productStructs[productId].description = productDescription;
        productStructs[productId].productIndex = productList.push(productId);
        return true;        
    }

}"
19675-0-0.sol,answer,"contract MetaCoin is Ownable{
    mapping (address => uint) balances;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    function MetaCoin() {
        balances[msg.sender] = 10000;
    }

    function sendCoin(address receiver, uint amount) returns(bool sufficient) {
        if (balances[msg.sender] < amount) return false;
        balances[msg.sender] -= amount;
        balances[receiver] += amount;
        Transfer(msg.sender, receiver, amount);
        return true;
    }

    function getBalance(address addr) constant returns(uint) {
        return balances[addr];
    }
}"
19675-0-0.sol,answer,"contract Relay is MetaCoin {
address public owner;
uint public count;
address[] oracles;
uint public fee;


  function Relay() {
    owner = msg.sender;
    count = 0;
    fee = 10;
  }


  function fundRelay() payable returns (bool) {
    if (owner != msg.sender) throw;

  }

function approveExternalTransaction(address receiver) {
    count++;
    if (count == 3) {
      releaseFunds(receiver);
    }
  }

function releaseFunds (address receiver) {
    sendCoin(receiver, fee);
 }
}"
53325-0-0.sol,answer,"contract Timestamping {
 event logTimestamp(bytes32 indexed _documentReference, uint256 timestamp, address _from);
 function timestamp(bytes32 _documentReference) {
   emit logTimestamp(_documentReference, now, msg.sender);
 }
}"
50507-0-2.sol,answer,"contract B {

  A a; 

  function B(address aAddress) public { 
    a = A(aAddress);
  }

  function getSomethingFromA() public view returns(bytes32 theThing) {
    return a.something();
  }
}"
7180-0-0.sol,answer,"contract C {
    struct Point {
        uint256 x;
        uint256 y;
    }

    struct Image {
        Point[] points;
        string name;
    }
    Image img;
    function C(){
        img.points[0]=Point({x:1,y:1});
        img.name= 'sebi';
    }

    function func() {

        delete img;
    }
}"
2084-0-0.sol,answer,"contract Test {
    Event MyLog(string);

    function MyFunction() {
        MyLog(""Hello World!"");
    }
}"
43056-0-0.sol,answer,"contract Crowdsale {
    iERC20 token;
    address owner;
    uint rateMillionths;

    modifier ownerOnly() {
        require(msg.sender == owner);
        _;
    }

    
    
    function Crowdsale(address _main) public {
        token = iERC20(_main);
        owner = msg.sender;
        rateMillionths = 1000000;
    }

    
    function withdraw() public ownerOnly {
        owner.transfer(this.balance);
    }

    
    
    
    function setRate(uint _rateMillionths) public ownerOnly {
        rateMillionths = _rateMillionths;
    }

    
    
    function () public payable {
        uint value = msg.value * rateMillionths;
        
        require(value/msg.value == rateMillionths);
        value = value / 1000000;
        token.transfer(msg.sender, value);
    }
}"
68632-0-0.sol,answer,"contract TimeLimited {

    uint timeLimit;

    modifier isWithinTime() {
        require(now < timeLimit, ""not before the given time limit"");
        _;
    }

    function giveData() public view isWithinTime returns (uint) {
        return 5;
    }
}"
12554-0-0.sol,answer,"contract A {

  B b;

  event LogIsB(bool allOkay);

  function A() {
    b = new B();
  }

  function doSomething()
    returns(bool success)

{
    
    if(b.bSig() != sha3(""Supports B Interface ver 1"")) throw;
    LogIsB(true);
    return true;
  }

}"
12554-0-0.sol,answer,"contract B {

  
  
  

  function bSig() 
    public
    constant
    returns(bytes32 fingerprint) 
  {
        return sha3(""Supports B Interface ver 1"");
  }

}"
3010-0-5.sol,answer,"contract DivZero { function divide(uint numerator, uint denominator) public constant returns(uint) { return numerator / denominator;  }}"
24845-1-0.sol,answer,"contract Crowdsale {
    uint public startBlock;
    uint public endBlock;

    uint public constant PRICE = 400;

    Crowdsale(uint _startBlock, uint _endBlock) {
        require(block.number < _startBlock);
        require(_startBlock < _endBlock);
    }

    function buy() payable {
        require(block.number >= startBlock && block.number <= endBlock);
        require(msg.value > 0);
        
        int tokens = msg.value * PRICE;
        balance[msg.sender] += tokens;
    }
}"
3727-1-0.sol,answer,"contract Child {
    address public addr;

    function child (address _addr) {
        addr = _addr;
    }    

    function getAddress() returns (address) {
        return addr;
    }

    function toBytes(address x) returns (bytes b) {
        b = new bytes(20);
        for (uint i = 0; i < 20; i++) {
            b[i] = byte(uint8(uint(x) / (2**(8*(19 - i)))));
        }
    }

    function getName() returns (string) {
        return string(toBytes(addr));
    }
}"
3727-1-0.sol,answer,"contract Parents {
    address public childAddr;
    Child child;

    function Parents(address _childAddress) {
        child = Child(_childAddress);
        childAddr = child.getAddress();
    }
}"
55924-0-0.sol,answer,"contract SupportPay4 {

    function() public payable {

    }

    function deposit() public payable {

    }

    function withdraw() public {
        msg.sender.transfer(getBalance());
    }

    function withdraw2() public {
        msg.sender.transfer(address(this).balance);
    }

    function getBalance() public constant returns(uint256) {
        return address(this).balance;
    }
}"
76863-0-0.sol,answer,"contract ContractD {
    address public contract_e_address;

    constructor(address _contract_e_address) public {
        contract_e_address = _contract_e_address;
    }

    function invokeContractE(uint256 _number_1, uint256 _number_2) public { 
        ContractE e = ContractE(contract_e_address);
        e.setN(_number_1, _number_2);
    } 
}"
76863-0-0.sol,answer,"contract ContractE {
    uint256 public number_1;
    uint256 public number_2;

    function setN(uint256 _number_1, uint256 _number_2) public {
        number_1 = _number_1;
        number_2 = _number_2;
    }
}"
41467-0-0.sol,answer,"contract Number {
    uint256[5] public array = [1, 2, 3, 4, 5];
    function returnArray() public view returns(uint256[5]) {
        return array;
    }
}"
15616-0-0.sol,answer,"contract Contract {
    function send (address addr, uint value) {
        
        [...]
        
    }
}"
45486-0-1.sol,answer,"contract Bar {
    function getOne() public pure returns(Foo.Bar) {
        return Foo.getOne();
    }
}"
62116-0-0.sol,answer,"contract MyFirstContract { 

    Bank b; 

    constructor(address bankAddress) public {
        b = Bank(bankAddress); 
    }

    

    function depositInBank(uint amount) public {
        b.deposit(amount);
    }

}"
38281-0-0.sol,answer,"contract EtherTransfer {
    
    function EtherTransfer(address owner) public payable {
        foo(owner);
    }

    function foo(address owner) private {
        
        selfdestruct(owner);
    }
}"
59372-0-1.sol,answer,"contract Test {

   mapping (bytes32 => mapping(uint => uint)) public map;

   function increase(bytes32 id,uint index) public {        
       map[id][index] = map[id][index] + 1;
   }

}"
2404-6-0.sol,answer,"contract Example is Upgradeable {
    uint _value;

    function initialize() {
        _sizes[bytes4(sha3(""getUint()""))] = 32;
    }

    function getUint() returns (uint) {
        return _value;
    }

    function setUint(uint value) {
        _value = value;
    }
}"
37013-0-2.sol,answer,"contract Ownable {
   address public owner;

   function Ownable() public {
     owner = msg.sender;
   }

   modifier onlyOwner() {
     require(msg.sender == owner);
     _;
   }
}"
61100-0-3.sol,answer,"contract IPFSStorage {
    struct Multihash {
        bytes32 hash;
        bytes2 hash_function;
        uint8 size;
    }

    Multihash multihash;

    function storeCIDAsStruct(bytes32 _hash, bytes2 _hash_function, uint8 _size) public {

        Multihash memory multihashMemory;
        multihash.hash = _hash;
        multihash.hash_function = _hash_function;
        multihash.size = _size;

        multihash = multihashMemory;
    }
}"
76678-1-1.sol,answer,"contract SillyContract {
    address payable public owner;
    constructor() public payable {
        owner = msg.sender;
    }
    function burn(uint256 _amount) public {
        require(address(this).balance >= _amount);
        owner.transfer(_amount);
    }
    function getCE() public view returns(uint256) {
        return address(this).balance;
    }
}"
9988-0-0.sol,answer,"contract MainContract {
    address minter;
    uint public returnRate;

    function MainContract(uint _returnRate) {
        minter = msg.sender;
        returnRate = _returnRate;
    }        
    modifier onlyMinter {
        if (msg.sender != minter) throw;
        _;
    }
     function updateReturnRate(uint newReturnRate) onlyMinter {
        returnRate = newReturnRate;
     } 
}"
39665-1-3.sol,answer,"contract ValueSetter {
  struct BasicValue {
    uint256 value;
  }

  address my_address; 
  BasicValue fixed_value;
  mapping(address => BasicValue) fixed_values;

  function ValueSetter(address init_address) public {
    my_address = init_address;
    fixed_values[init_address] = BasicValue(1000);
  }

  function set_value(uint256 my_value) external {
    
    require(msg.sender == my_address && my_value != 0);

    fixed_values[msg.sender].value = my_value;

    
  }
}"
64608-1-0.sol,answer,"contract DecompiledContract {
    function start() {
        *0x40 = 0x60;
        var0 = msg.data.length;
        recipient = storage[0x0];
        var5 = call(0x0, address(recipient), $msg.value, 0x60, 0x0, 0x60, 0x0);

        if(var5 != 0x0) {
            ptr = storage[0x0];
            uint256* var4 = ptr;
            ptr = *0x40;
            *ptr = (uint256)(address(((int)var4)));
            *(ptr + 1) = $msg.value;  
            emit Deposit(*0x40, ((uint256)(((int)ptr) - *0x40)) + 0x40);
            stop();
        }
        throw();
    }
}"
68774-2-0.sol,answer,"contract ERC20 {
  function totalSupply() public view returns (uint256);

}"
68774-2-0.sol,answer,"contract FixedSupplyToken is ERC20 {

    address public owner;
    uint256 _totalSupply = 1000000;


    
    constructor() public {
        owner = msg.sender;
    }

    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }


}"
8733-0-0.sol,answer,"contract Usernames {
    mapping (address => bytes32) public names;
    mapping (bytes32 => address) public owners;

    function associateNameForEver(bytes32 name) {
        if (owners[name] !=0) throw;
        if (names[msg.sender] != 0) throw;
        owners[name] = msg.sender;
        names[msg.sender] = name;
    }
}"
61100-0-0.sol,answer,"contract IPFSStorage {
    string hash;
    function storeCIDAsString(string _hash) public {
        hash = _hash;
    }
}"
77224-0-0.sol,answer,"contract CertificateRegistry {
  event Certificate (uint256 indexed id, bytes32 indexed hash);

  address private university;
  uint256 nextID;

  constructor () public {
    university = msg.sender;
  }

  function issueCertificate (bytes32 hash) public returns (uint256) {
    require (msg.sender == university);

    emit Certificate (nextID++, hash);
  }

  function calculateHash (string memory name, string memory degree, uint256 issueTime) public view returns (bytes32) {
    return keccak256 (abi.encodePacked (address (this), university, name, degree, issueTime));
  }
}"
71989-1-1.sol,answer,"contract Case2 {

    struct AA{
        uint val;
    }

    struct BB{

        mapping (uint => AA) map_2;
    }

    mapping (uint => BB) map_1; 

    function getter(uint BBId, uint AAId) public view returns(uint val) {
        return map_1[BBId].map_2[AAId].val;
    }
}"
67378-0-0.sol,answer,"contract Test {
    event Logger(uint log);
    function doit(uint myint) public {
        emit Logger(myint);
    }
}"
42104-0-0.sol,answer,"contract CA3 {
    struct  Student {
        uint16  age;
        uint16  income;
        uint16  score;
        uint16  attendance;
        uint128  studentTranscript;
        bytes32  studentAccount;
    }

    struct ShortStudent {
        uint16 age; 
        uint16 income; 
        uint16 score; 
        uint16 attendance; 
        uint128 studentTranscript;
    }

    Student[] public students;
    ShortStudent[] public sstudents;

    function setStudent (uint16 _age, uint16 _income, uint16 _score, uint16 _attendance, uint128 studentTranscript, bytes32 studentAccount) public {
        Student memory tempStudent = Student({age: _age, income: _income, score: _score, attendance: _attendance, studentTranscript: studentTranscript, studentAccount: studentAccount});
        students.push(tempStudent);
    }

    function ssetStudent (uint16 _age, uint16 _income, uint16 _score, uint16 _attendance, uint128 studentTranscript) public {
        ShortStudent memory tempStudent = ShortStudent({age: _age, income: _income, score: _score, attendance: _attendance, studentTranscript: studentTranscript});
        sstudents.push(tempStudent);
    }
}"
73901-0-0.sol,answer,"contract Faucet {

    
    function withdraw(uint withdraw_amount) public {

        
        require(withdraw_amount < msg.sender.balance);

        
        msg.sender.transfer(withdraw_amount);

    }

    
    function () payable external {} 

    
    function getBalanceContract() public view returns(uint){
        return address(this).balance;
    }
}"
9537-0-2.sol,answer,"contract C {

    function c() public returns (uint[]) {
        return f(1,2);
    }

    function f(uint a, uint b) private returns (uint[] memory memOffset) {
        assembly {
             
             
             memOffset := msize() 
             mstore(add(memOffset, 0x00), 2) 
             mstore(add(memOffset, 0x20), a) 
             mstore(add(memOffset, 0x40), b) 
             mstore(0x40, add(memOffset, 0x60)) 
        }
    }
}"
61432-0-0.sol,answer,"contract test {

    mapping (address => uint[]) public transactions;

    constructor() public {
        transactions[msg.sender].push(123456);
        transactions[msg.sender].push(789101);
        transactions[msg.sender].push(865436);
    }

    function getTransactions() public view returns (uint[]) {

        return transactions[msg.sender];

    }
}"
45668-0-0.sol,answer,"contract UserDetails {

  struct UserStruct {
    string fileHash;
    uint userListPointer;
    
  }

  
  address[] public userList;
  mapping(address=>UserStruct) public userStructs;

  function isUser(address userAddress) public view returns(bool isIndeed) {
      if(userList.length ==0) return false;
      return userList[userStructs[userAddress].userListPointer] == userAddress;
  }

  function addUserDetail(string hash,address userAddress) public returns (bool) {
    require(!isUser(userAddress));
    UserStruct memory usr;
    usr.fileHash = hash;
    usr.userListPointer = userList.push(userAddress) - 1;
    userStructs[userAddress] = usr;
  }

  function getUserCount() public view returns(uint count) {
      return userList.length;
  }
}"
78562-0-1.sol,answer,"contract Example {
    AddNumbers addContract;
    event StringFailure(string stringFailure);
    event BytesFailure(bytes bytesFailure);

    function exampleFunction(uint256 _a, uint256 _b) public returns (uint256 _c) {

        try addContract.add(_a, _b) returns (uint256 _value) {
            return (_value);
        } catch Error(string memory _err) {
            
            emit StringFailure(_err);
        } catch (bytes memory _err) {
            emit BytesFailure(_err):
        }
    }
}"
62906-0-0.sol,answer,"contract Contract {
    string public name;

    function Contracts(string passedName) public {
        name = passedName;
    }

    function setName(string newName) public {
        name = newName;

    }

}"
39141-0-0.sol,answer,"contract MyContract {

  string public ipfsHash;

  function setHash(string _ipfsHash) external {
    ipfsHash = _ipfsHash;
  }
}"
74442-0-0.sol,answer,"contract Test {

    string stringTest;

    function memoryTest(string memory _exampleString) public returns (string memory) {
        stringTest = ""example"";  
        string memory newString = stringTest;  
        return stringTest;  
    }

    function calldataTest(string calldata _exampleString) external returns (string memory) {
        
    }
}"
7729-0-0.sol,answer,"contract c {
    struct samplestruct1 {
        string name;
    }
    struct samplestruct2{
        string name;
        mapping (int => samplestruct1) s1s;
    }

    samplestruct2 s2; 

    function setS2Name(string name) {
        s2.name = name;
    }

    function newS1(int key, string name) {
        samplestruct1 memory s1; 
        s1.name = name;
        s2.s1s[key] = s1;
    }
}"
30398-1-0.sol,answer,"contract DieselPrice is usingOraclize { 

  event one(string description);
  event newDieselPrice(string price);

  function DieselPrice() {
      update(); 
  }

  function __callback(bytes32 myid, string result) {
    if (msg.sender != oraclize_cbAddress()) throw;
    newDieselPrice(result);
    DieselPriceUSD = parseInt(result, 2); 
    
  }

  function update() payable {
    one(""Oraclize query was sent, standing by for the answer.."");
    oraclize_query(""URL"", ""xml(https:
  }
}"
19727-1-0.sol,answer,"contract owned {

    address owner;

    
    function owned() { owner = msg.sender; }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }
}"
19727-1-0.sol,answer,"contract mortal is owned {

    
    function kill() onlyOwner() {
        selfdestruct(owner);
    }

}"
10108-1-0.sol,answer,"contract TestContract {
    enum TestEnum { ONE, TWO, THREE }
    mapping (uint => uint) testMapping;

    function getValueOne() constant returns(uint) {
        return testMapping[uint(TestEnum.ONE)];
    }
}"
55994-0-2.sol,answer,"contract A {
    uint public n;
    function foo () public returns (uint) {
        n = 1234;
        return n;
    }
}"
55994-0-2.sol,answer,"contract B {
    uint public n;
    function foo () public returns (uint) {
        n = 7777;
        return n;
    }
}"
55994-0-2.sol,answer,"contract C {
    function bar(uint n) public returns (uint) {
        A a;
        if (n == 1) {
            a = new A();
        } else {
            a = A(address(new B()));
        }
        a.foo();
        return a.n();
    }
}"
11761-0-0.sol,answer,"contract Test {
    struct Object {
        uint a;
        string b;
        string[] c;
        mapping(uint => uint) d;
    }

    Object field;

    function Test() {
        field = Object({
            a: 1,
            b: ""abc"",
            c: new string[](0)
        });
    }
}"
70482-0-0.sol,answer,"contract admin {
  IERC20 public token;

  struct StakeInfo {
    address user;
    uint amount;
    uint unlockTime;
  }

  StakeInfo [] public stakes;

  constructor (IERC20 _token) public {
    token = _token;
  }

  function putAtStake (uint _amount, uint _unlockTime)
  public returns (uint _stakeID){
    require (_unlockTime > block.timestamp);

    _stakeID = stakes.length;

    stakes.push (StakeInfo ({
      user: msg.sender,
      amount: _amount,
      unlockTime: _unlockTime
    })); 

    require (token.transferFrom (msg.sender, address (this), _amount));

    emit Stake (_stakeID, msg.sender, _amount, _unlockTime);
  }

  function refund (uint _stakeID) public {
    StakeInfo memory stake = stakes [_stakeID];

    require (stake.user != address (0));
    require (stake.unlockTime <= block.timestamp);

    delete stakes [_stakeID];

    require (token.transfer (stake.user, stake.amount));
  }

  event Stake (uint indexed id, address indexed user, uint amound, uint unlockTime);
}"
34013-0-1.sol,answer,"contract Recover {
    function recover(uint8 v, bytes32 r, bytes32 s) public pure returns (address) {
        bytes memory prefix = ""\x19Ethereum Signed Message:\n32"";
        bytes32 hash = keccak256(prefix, ""This message's length: 32 bytes."");
        return ecrecover(hash, v, r, s);
    }
}"
72826-0-0.sol,answer,"contract NewBook {

    struct ChapterData {
        
        string title;
        uint pages;
    }

    struct BookData {
        
        ChapterData[] chapters;
    }

    mapping(bytes32 => BookData) books; 

    
    
    function addChapter(bytes32 _bookID, string memory title, uint pages) public {
        ChapterData memory c = ChapterData({
            title: title,
            pages: pages
        });
        books[_bookID].chapters.push(c);
    }

    function getBookChapter(bytes32 bookId, uint chapter) public view returns(string memory title, uint pages) {
        BookData storage b = books[bookId];
        ChapterData storage c = b.chapters[chapter];
        return(c.title, c.pages);
    }
}"
65714-0-1.sol,answer,"contract Bytes {

    function convert(bytes b) public pure returns(uint) {
        return uint(b);
    }
}"
77965-1-0.sol,answer,"contract Simple {

  address public owner; 

  function setter(address newOwner) public payable returns(bool, uint) {
    require(msg.value >= 1 ether, ""Send more money""); 
    owner = newOwner; 
    msg.sender.transfer(1 ether); 
    return(true, 1); 
  }
}"
79739-0-0.sol,answer,"contract Staking {
    using SafeMath for uint;

    event StartStaking(address addr, uint value, uint amount, uint time);
    event WithdrawStake(address staker, uint amount);
    event Claim(address staker, uint reward);
    event DonationDeposited(address _address, uint value);

    struct Staker
    {
        uint amount;
        uint time;
    }


    uint public LastBlock = block.number;
    uint public Timestamp = now;

    uint public TotalStakingWeight;
    uint public TotalStakingAmount;
    uint public StakingRewardPool;
    bool public CS_frozen;
    uint public staking_threshold = 0 ether;
    address payable public Treasury = 0xD0eDff4E0b7e7e410F631669B040905267E9FFD1;

    uint public round_interval   = 27 days;
    uint public max_delay        = 365 * 2 days;
    uint public DateStartStaking = 1541980800;

    mapping(address => Staker) public staker;

    function freeze(bool _f) public only_treasurer
    {
        CS_frozen = _f;
    }

    function withdraw_rewards () public only_treasurer
    {
        if (CS_frozen)
        {
            StakingRewardPool = address(this).balance.sub(TotalStakingAmount);
            address(Treasury).transfer(StakingRewardPool);
        }
    }

    function clear_treasurer () public only_treasurer
    {
        require(block.number > 1800000 && !CS_frozen);
        Treasury = address(0);
    }

    function() external payable
    {
        start_staking();
    }

    function new_block() public payable
    {
        if (block.number > LastBlock)
        {
            uint _LastBlock = LastBlock;
            LastBlock = block.number;

            StakingRewardPool = address(this).balance.sub(TotalStakingAmount + msg.value);

            if (now > Timestamp)
            {
                uint _blocks = block.number - _LastBlock;
                uint _seconds = now - Timestamp;
                if (_seconds > _blocks * 25)
                {
                    _seconds = _blocks * 25;
                }
                TotalStakingWeight += _seconds.mul(TotalStakingAmount);
                Timestamp += _seconds;
            }
        }
    }

    function start_staking() public staking_available payable
    {
        assert(msg.value >= staking_threshold);
        new_block();

        if (staker[msg.sender].amount > 0)
        {
            if (Timestamp >= staker[msg.sender].time + round_interval)
            { 
                claim(); 
            }
            TotalStakingWeight = TotalStakingWeight.sub((Timestamp.sub(staker[msg.sender].time)).mul(staker[msg.sender].amount));
        }

        TotalStakingAmount = TotalStakingAmount.add(msg.value);
        staker[msg.sender].time = Timestamp;
        staker[msg.sender].amount = staker[msg.sender].amount.add(msg.value);

        emit StartStaking(
            msg.sender,
            msg.value,
            staker[msg.sender].amount,
            staker[msg.sender].time
        );
    }

    function DEBUG_donation() public payable {
        emit DonationDeposited(msg.sender, msg.value);
    }

    function withdraw_stake() public only_staker
    {
        new_block();
        require(Timestamp >= staker[msg.sender].time + round_interval);

        uint _amount = staker[msg.sender].amount;
        claim(); 
        TotalStakingAmount = TotalStakingAmount.sub(_amount);
        TotalStakingWeight = TotalStakingWeight.sub((Timestamp.sub(staker[msg.sender].time)).mul(staker[msg.sender].amount));

        staker[msg.sender].amount = 0;
        msg.sender.transfer(_amount);
        emit WithdrawStake(msg.sender, _amount);
    }

    function claim() public only_staker
    {
        if (CS_frozen) return;

        new_block();
        uint _StakingInterval = Timestamp.sub(staker[msg.sender].time);
        if (_StakingInterval >= round_interval)
        {
            uint _CompleteRoundsInterval = (_StakingInterval / round_interval).mul(round_interval);
            uint _StakerWeight = _CompleteRoundsInterval.mul(staker[msg.sender].amount);
            uint _reward = StakingRewardPool.mul(_StakerWeight).div(TotalStakingWeight);

            StakingRewardPool = StakingRewardPool.sub(_reward);
            TotalStakingWeight = TotalStakingWeight.sub(_StakerWeight);

            staker[msg.sender].time = staker[msg.sender].time.add(_CompleteRoundsInterval);

            msg.sender.transfer(_reward);
            emit Claim(msg.sender, _reward);
        }
    }

    function stake_reward(address _addr) public view returns (uint)
    {
        require(staker[_addr].amount > 0);
        require(!CS_frozen);

        uint _blocks = block.number - LastBlock;
        uint _seconds = now - Timestamp;
        if (_seconds > _blocks * 25)
        {
            _seconds = _blocks * 25;
        }
        uint _Timestamp = Timestamp + _seconds;
        uint _TotalStakingWeight = TotalStakingWeight + _seconds.mul(TotalStakingAmount);
        uint _StakingInterval = _Timestamp.sub(staker[_addr].time);

        uint _CompleteRoundsInterval = (_StakingInterval / round_interval).mul(round_interval);
        uint _StakerWeight = _CompleteRoundsInterval.mul(staker[_addr].amount);
        uint _StakingRewardPool = address(this).balance.sub(TotalStakingAmount);
        return _StakingRewardPool.mul(_StakerWeight).div(_TotalStakingWeight);
    }

    modifier only_staker
    {
        require(staker[msg.sender].amount > 0);
        _;
    }

    modifier staking_available
    {
        require(now >= DateStartStaking && !CS_frozen);
        _;
    }

    modifier only_treasurer
    {
        require(msg.sender == Treasury);
        _;
    }

    function report_abuse(address payable _addr) public only_staker
    {
        require(staker[_addr].amount > 0);
        new_block();
        require(Timestamp > staker[_addr].time.add(max_delay));

        uint _amount = staker[_addr].amount;

        TotalStakingAmount = TotalStakingAmount.sub(_amount);
        TotalStakingWeight = TotalStakingWeight.sub((Timestamp.sub(staker[_addr].time)).mul(_amount));

        staker[_addr].amount = 0;
        address(_addr).transfer(_amount);
    }
}"
15420-0-0.sol,answer,"contract C {
    function C() {}
    function () payable {}
}"
10806-0-7.sol,answer,"contract multiowned {

    

    
    struct PendingState {
        uint yetNeeded;
        uint ownersDone;
        uint index;
    }

    

    
    
    event Confirmation(address owner, bytes32 operation);
    event Revoke(address owner, bytes32 operation);
    
    event OwnerChanged(address oldOwner, address newOwner);
    event OwnerAdded(address newOwner);
    event OwnerRemoved(address oldOwner);
    
    event RequirementChanged(uint newRequirement);

    

    
    modifier onlyowner {
        if (isOwner(msg.sender))
            _;
    }
    
    
    
    modifier onlymanyowners(bytes32 _operation) {
        if (confirmAndCheck(_operation))
            _;
    }

    

    
    
    function multiowned(address[] _owners, uint _required) {
        m_numOwners = _owners.length + 1;
        m_owners[1] = uint(msg.sender);
        m_ownerIndex[uint(msg.sender)] = 1;
        for (uint i = 0; i < _owners.length; ++i)
        {
            m_owners[2 + i] = uint(_owners[i]);
            m_ownerIndex[uint(_owners[i])] = 2 + i;
        }
        m_required = _required;
    }

    
    function revoke(bytes32 _operation) external {
        uint ownerIndex = m_ownerIndex[uint(msg.sender)];
        
        if (ownerIndex == 0) return;
        uint ownerIndexBit = 2**ownerIndex;
        var pending = m_pending[_operation];
        if (pending.ownersDone & ownerIndexBit > 0) {
            pending.yetNeeded++;
            pending.ownersDone -= ownerIndexBit;
            Revoke(msg.sender, _operation);
        }
    }

    
    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external {
        if (isOwner(_to)) return;
        uint ownerIndex = m_ownerIndex[uint(_from)];
        if (ownerIndex == 0) return;

        clearPending();
        m_owners[ownerIndex] = uint(_to);
        m_ownerIndex[uint(_from)] = 0;
        m_ownerIndex[uint(_to)] = ownerIndex;
        OwnerChanged(_from, _to);
    }

    function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external {
        if (isOwner(_owner)) return;

        clearPending();
        if (m_numOwners >= c_maxOwners)
            reorganizeOwners();
        if (m_numOwners >= c_maxOwners)
            return;
        m_numOwners++;
        m_owners[m_numOwners] = uint(_owner);
        m_ownerIndex[uint(_owner)] = m_numOwners;
        OwnerAdded(_owner);
    }

    function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {
        uint ownerIndex = m_ownerIndex[uint(_owner)];
        if (ownerIndex == 0) return;
        if (m_required > m_numOwners - 1) return;

        m_owners[ownerIndex] = 0;
        m_ownerIndex[uint(_owner)] = 0;
        clearPending();
        reorganizeOwners(); 
        OwnerRemoved(_owner);
    }

    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {
        if (_newRequired > m_numOwners) return;
        m_required = _newRequired;
        clearPending();
        RequirementChanged(_newRequired);
    }

    
    function getOwner(uint ownerIndex) external constant returns (address) {
        return address(m_owners[ownerIndex + 1]);
    }

    function isOwner(address _addr) returns (bool) {
        return m_ownerIndex[uint(_addr)] > 0;
    }

    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {
        var pending = m_pending[_operation];
        uint ownerIndex = m_ownerIndex[uint(_owner)];

        
        if (ownerIndex == 0) return false;

        
        uint ownerIndexBit = 2**ownerIndex;
        return !(pending.ownersDone & ownerIndexBit == 0);
    }

    

    function confirmAndCheck(bytes32 _operation) internal returns (bool) {
        
        uint ownerIndex = m_ownerIndex[uint(msg.sender)];
        
        if (ownerIndex == 0) return;

        var pending = m_pending[_operation];
        
        if (pending.yetNeeded == 0) {
            
            pending.yetNeeded = m_required;
            
            pending.ownersDone = 0;
            pending.index = m_pendingIndex.length++;
            m_pendingIndex[pending.index] = _operation;
        }
        
        uint ownerIndexBit = 2**ownerIndex;
        
        if (pending.ownersDone & ownerIndexBit == 0) {
            Confirmation(msg.sender, _operation);
            
            if (pending.yetNeeded <= 1) {
                
                delete m_pendingIndex[m_pending[_operation].index];
                delete m_pending[_operation];
                return true;
            }
            else
            {
                
                pending.yetNeeded--;
                pending.ownersDone |= ownerIndexBit;
            }
        }
    }

    function reorganizeOwners() private {
        uint free = 1;
        while (free < m_numOwners)
        {
            while (free < m_numOwners && m_owners[free] != 0) free++;
            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;
            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)
            {
                m_owners[free] = m_owners[m_numOwners];
                m_ownerIndex[m_owners[free]] = free;
                m_owners[m_numOwners] = 0;
            }
        }
    }

    function clearPending() internal {
        uint length = m_pendingIndex.length;
        for (uint i = 0; i < length; ++i)
            if (m_pendingIndex[i] != 0)
                delete m_pending[m_pendingIndex[i]];
        delete m_pendingIndex;
    }

    

    
    uint public m_required;
    
    uint public m_numOwners;

    
    uint[256] m_owners;
    uint constant c_maxOwners = 250;
    
    mapping(uint => uint) m_ownerIndex;
    
    mapping(bytes32 => PendingState) m_pending;
    bytes32[] m_pendingIndex;
}"
10806-0-7.sol,answer,"contract daylimit is multiowned {

    

    
    modifier limitedDaily(uint _value) {
        if (underLimit(_value))
            _;
    }

    

    
    function daylimit(uint _limit) {
        m_dailyLimit = _limit;
        m_lastDay = today();
    }
    
    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {
        m_dailyLimit = _newLimit;
    }
    
    function resetSpentToday() onlymanyowners(sha3(msg.data)) external {
        m_spentToday = 0;
    }

    

    
    
    function underLimit(uint _value) internal onlyowner returns (bool) {
        
        if (today() > m_lastDay) {
            m_spentToday = 0;
            m_lastDay = today();
        }
        
        
        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {
            m_spentToday += _value;
            return true;
        }
        return false;
    }
    
    function today() private constant returns (uint) { return now / 1 days; }

    

    uint public m_dailyLimit;
    uint public m_spentToday;
    uint public m_lastDay;
}"
25260-1-0.sol,answer,"contract SMTCrowdsale is Crowdsale {
  function SMTCrowdsale (uint256 _startTime, uint256 _endTime, utin256 _rate, address _wallet) Crowdsale (_startTime, _endTime, _rate, _wallet) {
  }

  function createTokenContract () internal returns (MintableToken) {
    return new SimpleCrowdsaleToken ();
  }
}"
76116-1-0.sol,answer,"contract Counter {

    uint256 public counter;

    function increment() external {
        counter = counter + 1;
    }

    function doSelfDestruct() external {
        selfdestruct(0x0000000000000000000000000000000000000000);
    }

    function() external payable {}
}"
12238-0-0.sol,answer,"contract Test {
    uint248 public value;

    function Test() {
        value = 123;
    }

    function () payable {
        value = uint248(msg.value);
    }
}"
6007-0-1.sol,answer,"contract TestStatus {
    uint public value;
    function setValue(uint256 _value) {
        value = _value;
        if (_value < 12345) {
            throw;
        }
    }
}"
62267-0-0.sol,answer,"contract Test { 
    mapping(string => bool) seen;

    function add(string foo) external {
        seen[foo] = true;
    }

    function alreadySeen(string foo) external view returns (bool) {
        return seen[foo];
    }
}"
34860-0-0.sol,answer,"contract A {
  function func() public returns (?) {
    return b.func();
  }
}"
42756-0-0.sol,answer,"contract Foo {
    struct Bar {
        bytes32 a;
        uint8[9] b;
    }

    Bar[] public bars;

    function add(bytes32 _a, uint8[9] _b) public {
        bars.push(Bar(_a, _b));
    }

    function getBarBs(uint256 _index) public returns (uint8[9]) {
        return bars[_index].b;
    }
}"
52847-0-0.sol,answer,"contract HexUtils {

    
    byte constant a = byte('a');
    byte constant f = byte('f');
    byte constant A = byte('A');
    byte constant F = byte('F');
    byte constant zero = byte('0');
    byte constant nine = byte('9');

    
    function hexCharToByte(uint c) pure internal returns(uint) {
        byte b = byte(c);

        
        if(b >= zero && b <= nine) {
            return c - uint(zero);
        } else if(b >= a && b <= f) {
            return 10 + (c - uint(a));
        } else if(b >= A && b <= F) {
            return 10 + (c - uint(A));
        }
    }

    
    function hasZeroXPrefix(string s) pure internal returns(bool) {
        bytes memory b = bytes(s);
        if(b.length < 2) {
            return false;
        }
        return b[1] == 'x';
    }

    
    function hexToUint(string s) pure public returns(uint) {
        
        bytes memory b = bytes(s);

        
        require(b.length % 2 == 0, ""String must have an even number of characters"");

        
        uint i = 0;
        
        if(hasZeroXPrefix(s)) {
            i = 2;
        }
        uint r = 0;
        for(;i<b.length;i++) {
            
            uint b1 = hexCharToByte(uint(b[i]));

            
            
            r = (r << 4) | b1;
        }
        
        return r;
    }

    
    function substr(string s, uint start, uint end) pure public returns(string) {
        require(end > start, ""End must be more than start"");
        bytes memory res = new bytes(end-start);
        bytes memory bts = bytes(s);
        require(end <= bts.length, ""End must be less than or equal to the length of string"");
        require(start >= 0 && start < bts.length, ""Start must be between 0 and length of string"");

        uint idx = 0;
        for(uint i=start;i<end;++i) {
          
            res[idx] = bts[i];
            ++idx;
        }
        return string(res);
    }

    
    function parseAddr(string _a) internal pure returns (address){
        
        uint iaddr = hexToUint(_a);
        return address(iaddr);
    }

    
    function parseResults(string _hexData) pure public returns(uint, address, uint) {
        
        uint startIdx = 0;
        if(hasZeroXPrefix(_hexData)) {
            startIdx = 2;
        }
        bytes memory bts = bytes(_hexData);
        
        uint ethVal = hexToUint(substr(_hexData, startIdx,64+startIdx));

        
        uint idStart = bts.length - 64;

        
        uint addrEnd = idStart-1;

        
        address addr = parseAddr(substr(_hexData, addrEnd-40, addrEnd));

        
        uint id = hexToUint(substr(_hexData, idStart, bts.length));

        
        return (ethVal, addr, id);
    }
}"
45736-1-0.sol,answer,"contract Test {

    struct SomeStruct {
        uint256 a;
        uint256 b;
        uint256 c;
    }

    SomeStruct[] public structs;

    function pushStruct() {
        SomeStruct memory s;
        structs.push(s);
   }

}"
58952-0-0.sol,answer,"contract AddrToNumber {

    address[] public addressList; 

    function pushAddess(address addToList) public {
        addressList.push(addToList); 
    }

    function getAddressCount() public view returns(uint count) {
        return addressList.length;
    }

    function convertAddrToUniqueUint(address addressToConvert) public pure returns(uint uniqueToAddress) {
        return uint(keccak256(abi.encodePacked(addressToConvert)));
    }
}"
12570-0-0.sol,answer,"contract A {

  event LogNewStudent(address a);
  struct details { string name; uint roll ;} 
  mapping (address => details) public testMap;

  function set (string name, uint roll) {
    Student instance = new Student(name, roll);
    testMap[instance] = details(name,roll);
    LogNewStudent(instance);
  }

  function get (address a) 
    constant
    returns(string name, uint roll) 
  {
    
    return(testMap[a].name, testMap[a].roll);
  }
}"
2515-0-0.sol,answer,"contract Dapp {

    AuxContract aux;

    function Dapp(address auxContractAddress) {
        aux = AuxContract(auxContractAddress);
    }
}"
69405-0-0.sol,answer,"contract Foo {
    event TipSent (address indexed who, uint256 amount);
    event OwnershipTransferred (address indexed oldOwner, address newOwner);

    function tipPoolOwner() public payable{
        require(msg.value > 0);
        require(msg.sender != owner());
        address payable poolOwner = address(uint160(owner()));
        poolOwner.transfer(msg.value);
        emit TipSent(msg.sender, msg.value);
    }

    address private _owner;

    constructor () public {
        _owner = msg.sender;
    }

    function owner() public view returns (address) {
        return _owner;
    }
}"
65279-1-0.sol,answer,"contract Memory {

    function doSomething(uint[] memory array) public pure returns(uint[] memory y) {
        return array;
    }
}"
25154-0-3.sol,answer,"contract TestB {
  B testB;
  A testA;

  function beforeEach() {
    testA = A(DeployedAddresses.A());
    testB = B(testA.createB(""test""));
  }

  function testIsOwnerIsSet() {
    address aOwner = testA.owner();
    address bOwner = testB.owner();
    Assert.equal(aOwner, bOwner, ""Owner's address does not match"");
  }
}"
73655-0-0.sol,answer,"contract MyEvetTest {

   event MyEvent(uint256 timestamp);

   function myFunction() public {
       emit MyEvent(block.timestamp);
   }
}"
79169-0-0.sol,answer,"contract Claims {

    using HitchensUnorderedKeySetLib for HitchensUnorderedKeySetLib.Set;

    struct Claim {
        uint scheme;
        address issuer;
        bytes signature;
        bytes data;
        bytes url;
    }    

    struct Topic {
        HitchensUnorderedKeySetLib.Set claimIdSet;
    }

    HitchensUnorderedKeySetLib.Set topicIdSet;

    mapping(bytes32 => Topic) topics; 
    mapping(bytes32 => Claim) public claims;
    mapping(bytes32 => bool) public usedSignatureHashes;

    function newTopic(bytes32 topicId) public {
        topicIdSet.insert(topicId);
    }

    function removeTopic(bytes32 topicId) public {
        Topic storage t = topics[topicId];
        require(t.claimIdSet.count() == 0, ""Cannot delete topic with claims. Remove the claims first."");
        delete topics[topicId];
        topicIdSet.remove(topicId);
    }

    function newClaim(bytes32 topicId, bytes32 claimId, uint scheme, address issuer, bytes memory signature, bytes memory data, bytes memory url) public {
        require(topicIdSet.exists(topicId), ""Topic ID not found."");
        require(!usedSignatureHashes[keccak256(signature)], ""Claim signature was used before."");
        usedSignatureHashes[keccak256(signature)] = true;
        Topic storage t = topics[topicId];
        t.claimIdSet.insert(claimId); 
        Claim storage c = claims[claimId];
        c.scheme = scheme;
        c.issuer = issuer;
        c.signature = signature;
        c.data = data;
        c.url = url;
    }

    function removeClaim(bytes32 topicId, bytes32 claimId) public {
        Topic storage t = topics[topicId];
        t.claimIdSet.remove(claimId); 
        delete claims[claimId];
    }

    
    function topicClaimCount(bytes32 topicId) public view returns(uint) {
        return topics[topicId].claimIdSet.count();
    }

    function topicClaimIdAtIndex(bytes32 topicId, uint index) public view returns(bytes32) {
        return topics[topicId].claimIdSet.keyAtIndex(index); 
    }

    
    function arbitraryKey() public view returns(bytes32 key) {
        key = keccak256(abi.encodePacked(block.number));
    }

}"
58794-0-0.sol,answer,"contract Test {
    function addTest() public pure returns (byte c1, byte c2, byte c3) {
        
        bytes memory b = new bytes(169);
        b[0] = byte(59);
        b[1] = byte(42);
        b[2] = byte(99);

        assembly {
            
            
            c1 := mload(add(b, 0x20))
            
            c2 := mload(add(b, 0x21))
            
            c3 := mload(add(b, 0x22))
        }
    }
}"
305-4-0.sol,answer,"contract Test {
    address owner;

    function Test(){
        owner = msg.sender;
    }

    function getOwner() returns (address owner) {
        return owner;
    }
}"
84665-0-0.sol,answer,"contract C {
    using B for B.T;
    
    A.S public k;
    B.T public l;
    
    function baz() public returns (uint256) {
        k = A.S(121);
        l = B.T(333);
        return l.bar(k);
    }
    
}"
24987-0-1.sol,answer,"contract token {
     string public name; 
     string public symbol; 
     uint8 public decimals; 
     uint256 public totalSupply;

  
  mapping (address => uint256) public balanceOf;
  mapping (address => mapping (address => uint256)) public allowance;

  
  event Transfer(address indexed from, address indexed to, uint256 value);

  
  event Burn(address indexed from, uint256 value);

  
  function token(
      uint256 initialSupply,
      string tokenName,
      uint8 decimalUnits,
      string tokenSymbol
      ) {
      balanceOf[msg.sender] = initialSupply;              
      totalSupply = initialSupply;                        
      name = tokenName;                                   
      symbol = tokenSymbol;                               
      decimals = decimalUnits;                            
  }

  
  function _transfer(address _from, address _to, uint _value) internal {
      require (_to != 0x0);                               
      require (balanceOf[_from] > _value);                
      require (balanceOf[_to] + _value > balanceOf[_to]); 
      balanceOf[_from] -= _value;                         
      balanceOf[_to] += _value;                            
      Transfer(_from, _to, _value);
  }

  
  
  
  function transfer(address _to, uint256 _value) {
      _transfer(msg.sender, _to, _value);
  }

  
  
  
  
  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
      require (_value  _value);            
      balanceOf[msg.sender] -= _value;                      
      totalSupply -= _value;                                
      Burn(msg.sender, _value);
      return true;
  }

  function burnFrom(address _from, uint256 _value) returns (bool success) {
      require(balanceOf[_from] >= _value);                
      require(_value  bool) public frozenAccount;

  
  event FrozenFunds(address target, bool frozen);

  
  function MyAdvancedToken(
      uint256 initialSupply,
      string tokenName,
      uint8 decimalUnits,
      string tokenSymbol
  ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {}

  
  function _transfer(address _from, address _to, uint _value) internal {
      require (_to != 0x0);                               
      require (balanceOf[_from] > _value);                
      require (balanceOf[_to] + _value > balanceOf[_to]); 
      require(!frozenAccount[_from]);                     
      require(!frozenAccount[_to]);                       
      balanceOf[_from] -= _value;                         
      balanceOf[_to] += _value;                           
      Transfer(_from, _to, _value);
  }

  
  
  
  function mintToken(address target, uint256 mintedAmount) onlyOwner {
      balanceOf[target] += mintedAmount;
      totalSupply += mintedAmount;
      Transfer(0, this, mintedAmount);
      Transfer(this, target, mintedAmount);
  }

  
  
  
  function freezeAccount(address target, bool freeze) onlyOwner {
      frozenAccount[target] = freeze;
      FrozenFunds(target, freeze);
  }

  
  
  
  function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner {
      sellPrice = newSellPrice;
      buyPrice = newBuyPrice;
  }

  
  function buy() payable {
      uint amount = msg.value / buyPrice;               
      _transfer(this, msg.sender, amount);              
  }

  
  
  function sell(uint256 amount) {
      require(this.balance >= amount * sellPrice);      
      _transfer(msg.sender, this, amount);              
      msg.sender.transfer(amount * sellPrice);          
  }
}


"
11569-0-0.sol,answer,"contract People {

    Person[] public people;

    struct Person {
      bytes32 firstName;
      bytes32 lastName;
      uint age;
    }

    function addPerson(bytes32 firstName, bytes32 lastName, uint age) returns (bool success) {

      Person memory newPerson;
      newPerson.firstName = firstName;
      newPerson.lastName = lastName;
      newPerson.age = age;

      people.push(newPerson);
      return true;
    }

    function getPerson(uint index) constant returns(bytes32 firstName, bytes32 lastName, uint age) {
        
        return (people[index].firstName, people[index].lastName, people[index].age);
    }

    function getPersonCount() constant returns(uint count) {
        return people.length;
    }

}"
4395-0-1.sol,answer,"contract Calculator {"" +
        ""  int public result;"" +  
        ""  string testString;"" +
        ""  bool testBool;""+
        ""  function add(int num) {"" +
        ""    result = result + num;"" +
        ""  }"" +
        ""  function sub(int num) {"" +
        ""    result = result - num;"" +
        ""  }"" +
        ""  function mul(int num) {"" +
        ""    result = result * num;"" +
        ""  }"" +
        ""  function div(int num) {"" +
        ""    result = result / num;"" +
        ""  }"" +
        ""  function clear() {"" +
        ""    result = 0;"" +
        ""  }"" +
        ""  function getString() constant returns (string) { return testString; }"" +
        ""  function getBool() constant returns (bool) { return testBool; }"" +
        ""  function Calculator(string _testString, bool _testBool){"" +
        ""    testString = _testString;"" +
        ""    testBool = _testBool;"" +
        ""  }"" +
        ""}"
44794-0-0.sol,answer,"contract Ranges {

    address public owner;

    uint public lowerLine;
    uint public upperLine;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    event LogNewLines(address sender, uint lower, uint upper);

    function isValidRange(uint lower, uint upper) public pure returns(bool isIndeed) {
        return lower > 0 && upper > lower;
    }

    function Ranges(uint lower, uint upper) public {
        require(isValidRange(lower,upper));
        owner = msg.sender;
        lowerLine = lower;
        upperLine = upper;
        LogNewLines(msg.sender, lower, upper);
    }

    function isInRange(uint check) public view returns(bool isIndeed) {
        return check >= lowerLine && check <= upperLine;
    }

    function setRange(uint lower, uint upper) public onlyOwner returns(bool success) {
        require(isValidRange(lower,upper));
        lowerLine = lower;
        upperLine = upper;
        LogNewLines(msg.sender, lower, upper);
        return true;
    }
}"
13849-0-0.sol,answer,"contract Test {

  struct person {  
    address id;
    string name;
  }

  person[] p;

  event LogNewPerson(address newPerson, string name);

  function addPerson (string _name) returns (bool added) {  
    person memory per;
    per.id = msg.sender;
    per.name = _name;
    p.push(per);
    LogNewPerson(msg.sender, _name);
    return true;
  }

  function getPerson (address a) constant returns (address d, string n) {  
    for (uint k = 0; k <= p.length; k++) {  
      if (p[k].id == a) {
        return(p[k].id, p[k].name);
      }
    }
  }
}"
62932-0-0.sol,answer,"contract ParentToken {

  function ParentToken(currentSupply, tokenName ...) {} 
}"
62932-0-0.sol,answer,"contract foo is Class { 

  uint currentSupply; 

  function foo()
    ParentToken(currentSupply, tok...) { 
  }
}"
28239-0-2.sol,answer,"contract NestedArrays {
    function test(uint[][] nested) public {
    }
}"
39976-0-0.sol,answer,"contract Adoption {
    struct Pet {
        address owner;
        uint256 price;
    }

    Pet[16] data;

    function Adoption() public {
        for (uint i = 0; i < 16; i++) {
            data[i].owner = msg.sender;
            data[i].price = i;
        }
    }

    function getAdopters() external view returns (address[],uint256[]) {
        address[] memory owners = new address[](16);
        uint256[] memory prices =  new uint256[](16);
        for (uint i = 0; i < 16; i++) {
            owners[i] = (data[i].owner);
            prices[i] = (data[i].price);
        }
        return (owners,prices);
    }
}"
4543-1-0.sol,answer,"contract Sample {
  address owner;
  string name;

  function Sample() {
    owner = msg.sender;
  }

  function setName(string n) {
     if(msg.sender == owner) {
        name = n;
     }
  }
}"
45559-2-0.sol,answer,"contract Counters {

  uint[] counters;

  function _getCounter(uint _index) view private returns (uint, bool success) {
    require(_index >= 0 && _index < counters.length);
    return (counters[_index], true); 
  }

  function checkCounter(uint _index) view public returns ( ... ) {
    uint counter;
    bool success;
    (counter, success) = _getCounter(_index);
    if (success == false) { ... } else { ... };
  }

}"
50671-0-0.sol,answer,"contract ProxyStorage is Ownable {
  address public lib;

  constructor (address _newLib) public {
    replace(_newLib);
  }

  function replace(address _newLib) public onlyOwner  {
    lib = _newLib;
  }
}"
50671-0-0.sol,answer,"contract Proxy {
  
  function () payable public {
    ProxyStorage proxystorage = ProxyStorage(0x1111222233334444555566667777888899990000);
    address _impl = proxystorage.lib();
    require(_impl != address(0));

    assembly {
      let ptr := mload(0x40)
      calldatacopy(ptr, 0, calldatasize)
      let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)
      let size := returndatasize
      returndatacopy(ptr, 0, size)

      switch result
      case 0 { revert(ptr, size) }
      default { return(ptr, size) }
    }
  }
}"
34095-0-1.sol,answer,"contract WidgetMaker is Owned {
  
}"
34095-0-1.sol,answer,"contract WidgetManager is Owner {
  
  function changeWidgetMakerOwner(address newOwner) public onlyOwner returns(bool success) {
    require(newOwner != 0); 
    maker.changeOwner(newOwner); 
    LogMakerOwnerChanged(msg.sender, newOwner);
    return true;

}"
63595-0-0.sol,answer,"contract bidding {

    address[] public bidderAccts;

    
    mapping (address => uint[]) public bids;

    event LogNewBidder(address newBidder);
    event LogNewBid(address bidder, uint bid);

    function isBidder(address bidder) public view returns(bool isIndeed) {
        
        return bids[bidder].length > 0;
    }

    function upsertBidder(address bidder) public {
        if(!isBidder(bidder)) {
            bidderAccts.push(bidder);
            emit LogNewBidder(bidder);
        }
    }

    function setBid(uint bid)  public {
            
            require(bid > 0);
            upsertBidder(msg.sender);
            bids[msg.sender].push(bid);
            emit LogNewBid(msg.sender, bid);
    }

     function getUniqueBidderCount() view public returns (uint) {
        return bidderAccts.length;
    }       

}"
76525-0-1.sol,answer,"contract SomeContract {

  event NewValue (
      address _address,
      uint256 _value
      );
  mapping(address => uint256) public someMapping;


  function addValue(address _newAddress, uint256 _newValue) public {
    someMapping[_newAddress] = _newValue;
    emit NewValue(_newAddress, _newValue);
  }

}"
38124-0-1.sol,answer,"contract PullPaymentMock is PullPayment {

  function PullPaymentMock() public payable { }

  
  function callSend(address dest, uint256 amount) public {
    asyncSend(dest, amount);
  }

}"
9843-0-3.sol,answer,"contract Test {
    function f() external {
        this.f();
    }
}"
57340-0-0.sol,answer,"contract StructStore {
    mapping(uint256 => User) users;

    struct User {
        uint256 id;
        
        string[] data;
    }

    
    function newUser(uint256 _id) public {
        
        
        users[_id].id = _id;
    }

    
    function addData(uint256 _id, string _data) public {
        users[_id].data.push(_data);
    }

    
    function setData(uint256 _id, uint256 _index, string _newData) public {
        users[_id].data[_index] = _newData;
    }

    
    
    function getUserData(uint256 _id, uint256 _dataIndex) public view returns (string) {
        return users[_id].data[_dataIndex];
    }

    
    function getDataSize(uint256 _id) public view returns (uint256) {
        return users[_id].data.length;        
    }
}"
66686-0-1.sol,answer,"contract SubClassChild {

    event LogSender(address sender, address origin, address me);

    function lookWhosTalking() public returns(address) {
        emit LogSender(msg.sender, tx.origin, address(this));
        return msg.sender;
    }

    

    

    function rightHere() public returns(address) {
        emit LogSender(msg.sender, tx.origin, address(this));
        return msg.sender;
    }

}"
42194-0-0.sol,answer,"contract verifySettlement is usingOraclize {

           uint public price;
           string public landingtime;
           string public expectedtime;`
           string public tempvalue;


            event Log(string text);

            enum oraclizeState { ForActual, ForExpected }

            struct oraclizeCallback {
                  oraclizeState oState;
            }
            mapping (bytes32 => oraclizeCallback) public oraclizeCallbacks;

          function verifySettlement() payable {
                   Log(""Contract created."");
                   getActualFlightDetails();
                   getExpectedFlightDetails();
          }

          function getActualLandingHour() constant returns (string) {
                return landingtime;
          }

          function getExpectedLandingHour() constant returns (string) {
              return expectedtime;
            }

         function __callback(bytes32 _myid, string _result) {
                 require (msg.sender == oraclize_cbAddress());
                 oraclizeCallback memory o = oraclizeCallbacks[myid];
                 if (o.oState == oraclizeState.ForActual) {
                           Log(""1111111111111111111111111"");
                 }
                 else if(o.oState == oraclizeState.Forxpected) {
                       Log(""2222222222222222222222222222222"");   
                 }
         }

         function getActualFlightDetails() payable {
                   Log(""Oraclize query was sent, waiting for the answer for getting actual flight details.."");
                   bytes32 queryId=oraclize_query(""URL"",""http:
                   oraclizeCallbacks[queryId] = oraclizeCallback(oraclizeState.ForActual);
          }

         function getExpectedFlightDetails() payable {
                Log(""Oraclize query was sent, waiting for the answer for getting actual flight details.."");

                bytes32 queryId=oraclize_query(""URL"",""http:
              oraclizeCallbacks[queryId] = oraclizeCallback(oraclizeState.ForExpected);
         }
    }"
35985-0-0.sol,answer,"contract Person {
    uint public age;
    uint public weight;

    function Person(uint _age, uint _weight) public {
        age = _age;
        weight = _weight;
    }
}"
35985-0-0.sol,answer,"contract PersonHolder {

    address[] public people; 

    function addPerson(uint age, uint weight) public {
        people.push(new Person(age, weight));
    }

    function getPerson(uint index) public view returns (Person) {
        require(people.length > index);

        return Person(people[index]);
    }
}"
60713-0-0.sol,answer,"contract SimpleWhitelist {

    address public owner;
    mapping(address => bool) public isAuthorizedDevice;

    modifier onlyOwner {
        require(msg.sender==owner);
        _;
    }

    modifier onlyAuthorizedDevice {
        require(isAuthorizedDevice[msg.sender]);
        _;
    }

    constructor() public {
        owner = msg.sender;
    }

    function addOrRemoveDevice(address device, bool authorized) public onlyOwner {
        isAuthorizedDevice[device]=authorized;
    }

    function somethingDevicesDo() public onlyAuthorizedDevice {
        
    }
}"
19080-0-0.sol,answer,"contract Exchange {

    mapping (address => uint256) public balances;

    event LogDeposit(address sender, uint amount);
    event LogWithdrawal(address receiver, uint amount);
    event LogTransfer(address sender, address to, uint amount);

    function deposit() payable returns(bool success) {
        balances[msg.sender] +=msg.value;
        LogDeposit(msg.sender, msg.value);
        return true;
    }

    function withdraw(uint value) returns(bool success) {
        if(balances[msg.sender] < value) throw;
        balances[msg.sender] -= value;
        msg.sender.transfer(value);
        LogWithdrawal(msg.sender, value);
        return true;
    }

    function transfer(address to, uint value) returns(bool success) {
        if(balances[msg.sender] < value) throw;
        balances[msg.sender] -= value;
        to.transfer(value);
        LogTransfer(msg.sender, to, value);
        return true;
    }
}"
71638-0-0.sol,answer,"contract Pointer {

    struct MyStruct {
        address a;
        bool b;
        uint u;
    }
    mapping(bytes32 => MyStruct) public myStructs;

    event LogActivity(address sender, address a, bool b, uint u);

    function emitter(MyStruct storage s) internal {
        emit LogActivity(msg.sender, s.a, s.b, s.u);
    }

    function callMe(bytes32 key) public {
        emitter(myStructs[key]);
    }

    function setter(bytes32 key, address a, bool b, uint u) public {
        MyStruct storage s = myStructs[key];
        s.a = a;
        s.b = b;
        s.u = u;
    }
}"
67020-0-0.sol,answer,"contract EventsInterface 
{
   function removeValueFromArray(uint _userId, uint[] memory _array) internal returns(uint[] memory);
}"
67020-0-0.sol,answer,"contract EventsImpl is EventsInterface {
    uint[] baseArray;

    function removeValueFromArray(uint _userId, uint[] memory _array) internal returns(uint[] memory) {
        uint[] storage auxArray = baseArray;

        for (uint i = 0; i < _array.length; i++){
            if(_array[i] != _userId)
                auxArray.push(_array[i]);
        }

        return auxArray;
    }
}"
63759-0-1.sol,answer,"contract FileList {

   
   struct File {
      uint256 id;
      string ipfshash;
      bytes32 filename;
      bytes32[5] tags;
      address owner;
      uint256 timestamp;
   }
   uint256 public constant maxAmountOfFiles = 1000;
   
   mapping(address => File[maxAmountOfFiles]) public files;
   
   mapping(address => uint256) public lastIds;
   

   
   event fileAdded (uint256 fileid, string ipfshash, bytes32 _filename);
   event tagsAdded (bytes32[5] tags);

   
   
   
   
   
   function addFile(string ipfshash, bytes32 _filename, bytes32[5] tags) public {

      File memory myFile = File(lastIds[msg.sender], ipfshash, _filename, tags,  msg.sender, now);
      
      myFile.tags = tags;
      emit tagsAdded (myFile.tags);
      

      files[msg.sender][lastIds[msg.sender]] = myFile;
      
      emit fileAdded(lastIds[msg.sender],ipfshash,_filename);
      if(lastIds[msg.sender] >= maxAmountOfFiles) lastIds[msg.sender] = 0;
      else lastIds[msg.sender]++;
   }

   
   
   
   function getFileTags(address owner, uint256 _index) external view returns (bytes32[5]) {
       return files[owner][_index].tags;
  }

}"
17056-0-0.sol,answer,"contract TestBAToken {
  address companyFundAddress;
  address userFundAddress;
  function TestBAToken(address address1, address address2) {
    companyFundAddress = address1;
    userFundAddress = address2;
  }
  function testNewBATokenNotFinalized() {
    uint256 startBlock = block.number - 100;
    uint256 endBlock = block.number + 100;
    BAToken ba = new BAToken(companyFundAddress, userFundAddress, startBlock, endBlock);
    Assert.equal(ba.isFinalized, false, ""Token sale shouldn't be finalized upon initialization."");
  }
}"
41501-0-0.sol,answer,contract X {}
41501-0-0.sol,answer,"contract XFactory {
    function createX() returns (X) {
        return new X();
    }
}"
41501-0-0.sol,answer,"contract Main {
    XFactory xFactory;
    ...
    Main(XFactory _xFactory) {
        xFactory = _xFactory;
    }
    ...
    function someMethod() {
        X x = xFactory.create();
    }
    ...
}"
61075-0-0.sol,answer,"contract ApproveInterface {
    function approve(address to, uint256 tokenId) public;
}"
61075-0-0.sol,answer,"contract Approve is ApproveInterface {
    function approve(address to, uint256 tokenId) public returns(bool success) {
        return true;
    }
}"
11534-0-1.sol,answer,"contract Factory {
    bytes32[] public names;
    address[] public contracts;

    function createContract(bytes32 name) returns(address) {
        address newContract = new MyContract(name);
        names.push(name);
        contracts.push(newContract);
        return newContract;
    }

    function getName(uint i) constant returns(bytes32 contractName) {
        return names[i];
    }

    function getAddress(uint i) constant returns(address contractAddress) {
        return contracts[i];
    }
}"
1573-0-0.sol,answer,"contract InsertionSort {

    struct Record {
        uint recId;
        uint[] data;
    }

    mapping(uint => Record) records;

    function insertionSortMemory(uint[5] a) internal {
      for (uint i = 0; i < a.length; i++) {
        uint j = i;
        while (j > 0 && a[j] < a[j-1]) {
          uint temp = a[j];
          a[j] = a[j-1];
          a[j-1] = temp;
          j--;
        }
      }
    }

    function testInsertionSort() public constant returns (uint[5]) {
      uint[5] memory data;
      data[0] = 1235;
      data[1] = 1234;
      data[2] = 1233;
      data[3] = 1232;
      data[4] = 1231;
      insertionSortMemory(data);
      return data;
    }

    function insertionSort(uint[] a, uint length) internal returns (uint[]) {
      for (uint i = 0; i < length; i++) {
        uint j = i;
        while (j > 0 && a[j] < a[j-1]) {
          uint temp = a[j];
          a[j] = a[j-1];
          a[j-1] = temp;
          j--;
        }
      }
      return a;
    }

    function addRecordWithoutInsertionSort(uint _recId, uint _num) public {
        Record record = records[_recId];
        record.recId = _recId;
        record.data.length++;
        record.data[record.data.length-1] = _num;
    }

    function addRecordWithInsertionSort(uint _recId, uint _num) public {
        Record record = records[_recId];
        record.recId = _recId;
        record.data.length++;
        record.data[record.data.length-1] = _num;
        record.data = insertionSort(record.data, record.data.length);
    }



    function getRecord(uint _recId) public constant returns(uint, uint[]) {
        return (records[_recId].recId, records[_recId].data);
    }
}"
25926-0-1.sol,answer,"contract Contract {

    function returnValue() constant returns (uint32) {
        return 0xFFFFFFFF;
    }
}"
56475-1-0.sol,answer,"contract Counter {

        int private count = 0;
        address public admin;

        constructor() public {
            admin = msg.sender;
        }

        function incrementCounter() public {
            require(msg.sender==admin);
            count += 1;
        }

        function decrementCounter() public {
            require(msg.sender==admin);
            count -= 1;
        }

        function getCount() public constant returns (int) {
            return count;
        }
    }"
3114-0-4.sol,answer,"contract ArrayStruct {

    struct User {
        uint idNum;
        string name;
        address userAddress;
    }

    User[] public users;

    function addUser(uint _idNum, string _name, address _userAddress) public returns(uint) {
        users.length++;
        users[users.length-1].idNum = _idNum;
        users[users.length-1].name = _name;
        users[users.length-1].userAddress = _userAddress;
        return users.length;
    }

    function getUsersCount() public constant returns(uint) {
        return users.length;
    }

    function getUser(uint index) public constant returns(uint, string, address) {
        return (users[index].idNum, users[index].name, users[index].userAddress);
    }
}"
10981-0-0.sol,answer,"contract SubjectContract {
    function increaseCount() returns (uint newCount);
}"
10981-0-0.sol,answer,"contract Master {
    bool public isActive=false;
    uint public num=0;

    function changeState() returns (bool newState) {
        isActive = !isActive;
        newState = isActive;
    }

    function increaseSubjectCount(address subjectAddr) returns (uint newCount) {
        SubjectContract subjectContract = SubjectContract(subjectAddr);
        newCount = subjectContract.increaseCount();
    }
}"
632-0-0.sol,answer,"contract MultiReturner {
    function getData() constant returns (bytes32, bytes32) {
        bytes32 a = ""abcd"";
        bytes32 b = ""wxyz"";
        return (a, b);
    }

    function getDynamicData() constant returns (bytes, bytes) {
        bytes a;
        a.push('a');
        a.push('b');
        a.push('c');
        bytes b;
        b.push('x');
        b.push('y');
        b.push('z');
        return (a, b);
    }
}"
66876-0-1.sol,answer,"contract Scope {

    struct Human {
        bool b;
    }

    Human[] humans;

    modifier checkScope {
        Human storage human = humans[2];
        _;
    }

    function doSomething() public view checkScope returns(bool) {
        
        return humans[2].b; 
    }
}"
62387-0-0.sol,answer,"contract Banners {

    struct BannerStruct {
        string marque;
        bytes32 placeId; 
        uint idPointer;
    }

    struct PlaceStruct {
        string name;
        bytes32 bannerId; 
        uint idPointer;
    }

    mapping(bytes32 => BannerStruct) public bannerStructs;
    mapping(bytes32 => PlaceStruct) public placeStructs;

    bytes32[] public bannerIdList;
    bytes32[] public placeIdList;

    function getBannerCount() public view returns(uint) {
        return bannerIdList.length;
    }

    function getPlaceCount() public view returns(uint) {
        return placeIdList.length;
    }

    function isBanner(bytes32 bannerId) public view returns(bool) {
        if(bannerIdList.length==0) return false; 
        return bannerIdList[bannerStructs[bannerId].idPointer] == bannerId;
    }

    function isPlace(bytes32 placeId) public view returns(bool) {
        if(placeIdList.length==0) return false;
        return placeIdList[placeStructs[placeId].idPointer] == placeId;
    }

    function placeHasBanner(bytes32 placeId) public view returns(bool) {
        return isBanner(placeStructs[placeId].bannerId);
    }

    function newBanner(bytes32 bannerId, string marque) public returns(bool) {
        require(!isBanner(bannerId)); 
        bannerStructs[bannerId].marque = marque;
        bannerStructs[bannerId].idPointer = bannerIdList.push(bannerId) - 1;
        return true;
    }

    function newPlace(bytes32 placeId, string name) public returns(bool) {
        require(!isPlace(placeId));
        placeStructs[placeId].name = name;
        placeStructs[placeId].idPointer = placeIdList.push(placeId) - 1;
        return true;
    }

    function setPlaceBanner(bytes32 placeId, bytes32 bannerId) public returns(bool) {
        require(isPlace(placeId));
        require(isBanner(bannerId));
        if(bannerStructs[bannerId].placeId != 0) { 
            bytes32 oldPlace = bannerStructs[bannerId].placeId;
            placeStructs[oldPlace].bannerId = bytes32(0);
        }
        bannerStructs[bannerId].placeId = placeId;
        placeStructs[placeId].bannerId = bannerId;
    }
}"
17010-0-0.sol,answer,"contract MappingExample {
    mapping(address => uint) public balances;

    function update(uint newBalance) {
        balances[msg.sender] = newBalance;
    }
}"
17010-0-0.sol,answer,"contract MappingUser {
    function f() returns (uint) {
        return MappingExample(<address>).balances(this);
    }
}"
8346-0-1.sol,answer,"contract C {
    string public senderString;

    function toString(address x) returns (string) {
        bytes memory b = new bytes(20);
        for (uint i = 0; i < 20; i++)
            b[i] = byte(uint8(uint(x) / (2**(8*(19 - i)))));
        return string(b);
    }

    function test() {
        senderString = toString(msg.sender);
    }
}"
80309-0-0.sol,answer,"contract SimpleStorage {

  uint public x;

  function set(uint _x) public {
    x = _x;
  }
}"
58171-0-0.sol,answer,"contract SendAndTransferExample {

    constructor() public payable { }

    function SimpleSendToAccount() public returns(bool) {
       return msg.sender.send(10000000000000000000);
    }

    function SimpleTransferToAccount() public {
       msg.sender.transfer(10000000000000000000);
    }

    function() public payable { }
}"
46601-2-0.sol,answer,"contract Blackjack {

   uint[52] public deck;

   constructor() public {

       for (uint i = 0; i < 52; i++) {
            deck[i] = i;
       }
    }

    function getit() public view returns (uint) {
        return deck[5];
    }
}"
4395-2-0.sol,answer,"contract A {"" +
  ""  uint public a;"" +
  ""  uint public b;"" +
  ""  function A(uint a_, uint b_) {a = a_; b = b_; }"" +
  ""}"
78556-0-1.sol,answer,"contract Test {

    struct Request {
        function(uint) external callback;
    }

    Request[] private requests;

    function getAddress (uint requestID) public view returns (address) {
        return requests[requestID].callback.address;
    }
}"
61376-1-0.sol,answer,"contract Parent {
    using Bytes32 for bytes32;

    function bar() public pure returns(string) {
        return bytes32(0).toString();              
    }
}"
61376-1-0.sol,answer,"contract Child is Parent {
    function foo() public pure returns(string) {
        return bytes32(0).toString();              
    }
}"
15953-4-0.sol,answer,"contract ethertransfer {    
  function fundtransfer(address etherreceiver, uint256 amount) public payable {
    if(!etherreceiver.transfer(amount)) {
       throw;
    }
  }
}"
15953-4-0.sol,answer,"contract etherreceiver {

  function etherreceiver() external payable{      
  }
}"
56536-0-0.sol,answer,"contract ModifierTest {

    address public owner;

    struct myStruct {
        uint256 fancyVar;
    }

    constructor() public {
        owner = msg.sender;
    }

    modifier myFancyModifier {
        uint16 a = 314;
        myStruct memory b;
        b.fancyVar = 159;
        _;
    }

    function myFunction() external myFancyModifier {
        uint16 c = a * 2;
        uint16 d = b.fancyVar * 3;
    }
}"
47820-1-0.sol,answer,"contract _Chronos {
    function registerCall(address contractAddress, uint256 callOnBlock, uint256 gasAmount) public returns (uint256);
    function clientWithdraw(uint256 value) public;
    function clientFunding(address contractAddress) public payable;

}"
47820-1-0.sol,answer,"contract Client {
    function setCallrequest(uint256 blockNumber, uint256 gasAmount) public;
    function callBack() public;
    function withdrawFromChronos(uint value) public;
    function getDepositsFromChronos() public payable;
}"
47820-1-0.sol,answer,"contract YourContract is Client {
    address public chronosAddress;
    address public admin;

    function YourContract() public {
        chronosAddress = address(0x4896FE22970B06b778592F9d56F7003799E7400f);
        admin = msg.sender;
    }




    function setCallrequest(uint256 blockNumber, uint256 gasAmount) public {
        _Chronos ChronosInstance = _Chronos(chronosAddress);
        uint256 costs = ChronosInstance.registerCall(address(this), blockNumber, gasAmount);
        require(address(this).balance >= costs);
        ChronosInstance.clientFunding.value(costs)(address(this));
    }


    function callBack() public {
        setCallrequest(block.number + 40, 200000); 

        admin.transfer(this.balance); 
    }



    function () public payable {}



}"
3780-0-0.sol,answer,"contract T {
    event res(uint indexed out)
    function echo(uint in) {
         res(i);
    }
}"
78051-0-0.sol,answer,"contract A {
    B b;

    constructor(B _b) public {
        b = _b;
    }  

    function() external payable {
        (bool success, bytes memory result) = address(b).call.value(msg.value)("""");

        revert();
    }
}"
78051-0-0.sol,answer,"contract B {
    function() external payable {
        selfdestruct(msg.sender);
    }

    function alive() public pure returns (bool) {
        return true;
    }
}"
8442-1-1.sol,answer,"contract Handcuffs {
    
    function set(address _left, address _right) onlydeployer onlyonce {
        left = _left;
        right = _right;
    }
    
}"
71726-0-0.sol,answer,"contract Underflow1 {
using SafeMath for uint;
    uint256 num= 0;
    function testf2() public returns (uint256){
    
    num = num.sub(1);
    return num;
    }
}"
12698-2-1.sol,answer,"contract ChildInterface {
    function f1() {}
    function f2() {}
    function f3() {}
    function f4() {}
    function f5() {}
}"
12698-2-1.sol,answer,"contract Main {
    ChildInterface ch;
    function Main(address child) {
        ch=ChildInterface(child);
    }
    function test() {
        ch.f1();
        ch.f2();
        ch.f3();
        ch.f4();
        ch.f5();
    }
}"
77520-1-0.sol,answer,"contract BackendProxy {
  address private backendImplementation;
  address private owner;

  constructor (address _backendImplementation) public {
    backendImplementation = _backendImplementation;
    owner = msg.sender;
  }

  function () external payable {
    if (msg.data.length > 0) {
      address oldBackendImplementation = backendImplementation;
      address oldOwner = owner;

      bool status;
      bytes memory data;
      (status, data) = backendImplementation.delegatecall (msg.data);
      require (oldBackendImplementation == backendImplementation);
      require (oldOwner == owner);

      if (status) {
        assembly {
          return (add (data, 0x40), mload (data))
        }
      } else {
        assembly {
          revert (add (data, 0x40), mload (data))
        }
      }
    }
  }

  function setBackendImplementation (address _backendImplementation) public {
    require (msg.sender == owner);
    backendImplementation = _backendImplementation;
  }
}"
82203-0-0.sol,answer,"contract Example {
    bool _isActive = true;

    modifier checkActive() {
        require (_isActive);
        _;
    }

    function do1() checkActive public {
        
    }

    function do2() checkActive public {
        
    }

    function setActivity(bool isActive) public {
        
        _isActive = isActive;
    }
}"
44958-0-0.sol,answer,"contract SomeContract {
    TestInterface public tI = TestInterface(address(0));

    function someFunc(string _someString) public returns (bool) {
        if (keccak256(_someString) == keccak256(""hello"")) {
            require(tI.someAction());
        }
    }
}"
82240-0-0.sol,answer,"contract TestImmutable {
    uint256 public immutable a;

    
    constructor (uint256 _a) public {
        a = _a;
    }

    
    function setA (uint256 _a) public {
        a = _a;
    }
}"
69370-0-1.sol,answer,"contract Game {

  function recordHit(address scoreContract) public {
    ScoreInterface s = ScoreInterface(scoreContract);
    s.hit();
  }
}"
41350-1-0.sol,answer,"contract WithDraw is Ownable {

  Token token;
  mapping(address => uint256) public redeemBalanceOf;
  event BalanceSet(address indexed beneficiary, uint256 value);
  event Redeemed(address indexed beneficiary, uint256 value);

  function WithDraw() public {
      address _tokenAddr = MY_TOKEN_ADDR;
      token = Token(_tokenAddr);
  }

function setBalances(address[] dests, uint256[] values) onlyOwner public {
    uint256 i = 0; 
    while (i < dests.length){
        if(dests[i] != address(0)) 
        {
            uint256 toSend = values[i] * 10**18;
            redeemBalanceOf[dests[i]] += toSend;
            BalanceSet(dests[i],values[i]);
        }
        i++;
    }
  }

  function redeem(uint256 quantity) external{
      uint256 baseUnits = quantity * 10**18;
      uint256 senderEligibility = redeemBalanceOf[msg.sender];
      uint256 tokensAvailable = token.balanceOf(this);
      require(senderEligibility >= baseUnits);
      require( tokensAvailable >= baseUnits);
      if(token.transfer(msg.sender,baseUnits)){
        redeemBalanceOf[msg.sender] -= baseUnits;
        Redeemed(msg.sender,quantity);
      }
  }

  function removeBalances(address[] dests, uint256[] values) onlyOwner public {
    uint256 i = 0; 
    while (i < dests.length){
        if(dests[i] != address(0)) 
        {
            uint256 toRevoke = values[i] * 10**18;
            if(redeemBalanceOf[dests[i]]>=toRevoke)
            {
                redeemBalanceOf[dests[i]] -= toRevoke;
                BalanceCleared(dests[i],values[i]);
            }
        }
        i++;
    }

}
"
10540-0-0.sol,answer,"contract InfoFeed {
    function info() payable returns (uint ret) { }
}"
62978-0-0.sol,answer,"contract KYCPurchase {
      uint public price = 2 ether;
      address owner;

      constructor() public{
      owner = msg.sender
}
      modifier _ownerOnly(){
      require(msg.sender == owner);
}
      struct Company {
          string registeredNumber;
          string companyName;
      }

      mapping (address => Company) companies;

      function buy(string registeredNumber, string companyName) public payable {
        require(msg.value == price);

        
        companies[msg.sender] = Company(registeredNumber, companyName);

      }

      function isKYCPaymentOK (address companyAddress) pure _ownerOnly returns (string, string) {
            require(companies[companyAddress].registeredNumber > 0);
            return (companies[companyAddress].registeredNumber, companies[companyAddress].companyName);

      }
    }"
21380-0-0.sol,answer,"contract A {
    modifier only (uint test) {
        require(test > 5);
        _;
    }
    function test(uint test) public only(test) returns(uint) {
        return addSome(test);
    }
    function addSome(uint number) internal returns(uint) {
        return number + 5;
    }
}"
21380-0-0.sol,answer,"contract B is A {
    modifier only (uint test) {
        require(test < 10);
        _;
    }
    function test(uint test) public only(test) returns(uint) {
        return super.test(test);
    }
    function addSome(uint number) internal returns(uint) {
        return number + 10;
    }
}"
38943-1-0.sol,answer,"contract OwnedToken {
    
    
    
    TokenCreator creator;
    ...

    function OwnedToken(bytes32 _name) public {
        
        
        
        
        creator = TokenCreator(msg.sender);
        ...
    }

}"
24853-0-0.sol,answer,"contract Foo {
  function cut(bytes sha) constant returns (bytes32 half1, bytes32 half2) {
    assembly {
      half1 := mload(add(sha,0x20))
      half2 := mload(add(sha,0x40))
    }
  }
}"
8032-0-0.sol,answer,"contract MaliciousContract {
    function foobar() {
        
        B(msg.sender).bar(255);
    }
}"
71826-0-1.sol,answer,"contract Batch is Ownable {

    using HitchensUnorderedKeySetLib for HitchensUnorderedKeySetLib.Set;
    HitchensUnorderedKeySetLib.Set batchIds;

    struct BatchStruct {
        
        uint batchCreationDate; 
        address batchOwner;
        string batchOrigin; 
        string productName; 
    }

    mapping(bytes32 => BatchStruct) public batches; 

    function genBatchId() internal view returns(bytes32) {
        return keccak256(abi.encodePacked(address(this), batchIds.count()));
    }

    function createBatch(address batchOwner, string memory batchOrigin, string memory productName) public onlyOwner returns(bytes32) {
        bytes32 id = genBatchId();
        batchIds.insert(id);
        BatchStruct storage b = batches[id];
        b.batchOwner = batchOwner;
        b.batchOrigin = batchOrigin;
        b.productName = productName;
        
    }

    

    function getBatch(bytes32 batchId) public view returns(uint, address, string memory, string memory) {
        require(batchIds.exists(batchId), ""Batch not found"");
        BatchStruct storage b = batches[batchId];
        return (b.batchCreationDate, b. batchOwner, b.batchOrigin, b.productName);
    }
}"
24943-0-0.sol,answer,"contract Registry {

    mapping(bytes32 => address) public ID;
    mapping(address => address) public Contract;

    event log(bytes32,address);
    function register(bytes32 _id) {
        ID[_id] = tx.origin;
        Contract[tx.origin] = msg.sender;
    }

    function getPublicAddress(bytes32 _id) constant returns (address) {
        log(_id,ID[_id]);
        return (ID[_id]);
    }

    function getContractAddress(bytes32 _id) constant returns (address) { 
        log(_id,Contract[ID[_id]]);
        return Contract[ID[_id]];
    } 
}"
24943-0-0.sol,answer,"contract User { 
    address owner;
    Registry registry;
    
    function register(bytes32 _id) {
        registry.register(_id);
    }
    function getContractAddress(bytes32 _id) constant returns (address){
        return registry.getContractAddress(_id);
    }
    function getPublicAddress(bytes32 _id) constant returns (address) {
        return registry.getPublicAddress(_id);
    }
    function setRegister(address _addr){
        registry = Registry(_addr);
    }
}"
58775-0-0.sol,answer,"contract Test {
    address[] public signups;
    uint createTime;

    constructor() public {
        createTime = now;
    }

    function signupsStopAfter10Min() public {
        require(now < createTime + 10 minutes);
        signups.push(msg.sender);
    }
}"
376-1-0.sol,answer,"contract Deck {
   uint8[52] deck;

   function getRandomNumber() returns (uint) {
       ...;
   }

   function shuffle() {
      uint8[52] memory unshuffled;

      for (uint8 i=0; i < 52; i++) {
          unshuffled[i] = i;
      }

      uint cardIndex;

      for (i=0; i < 52; i++) {
          cardIndex = getRandomNumber() % (52 - i);
          deck[i] = unshuffled[cardIndex];
          unshuffled[cardIndex] = unshuffled[52 - i - 1]
      }
   }
}"
61504-0-0.sol,answer,"contract GiveRefreceId {

    mapping(address => uint256) public referenceid;
    address[] public clients;
    uint256 idcounter;

    event createdId(address user, uint256 id);

    function giveRefrenceId() public returns (uint256)  { 
        require(referenceid[msg.sender]==0);
        idcounter += 1;
        clients.push(msg.sender);
        referenceid[msg.sender] = idcounter;
        emit createdId(masg.sender,idcounter);
        return idcounter;

    }


    function  getrefrnceId() public view returns(uint256) {
        return referenceid[msg.sender];
    }
}"
47674-0-0.sol,answer,"contract SimpleOwned {

    address public owner;
    bool public isRunning;

    function SimpleOwned() public {
        owner = msg.sender;
        isRunning == true;
    }

    modifier onlyIfRunning {
        require(isRunning);
        _;
    }

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    function changeOwner(address newOwner) public onlyOwner returns(bool success) {
        owner = newOwner;
        return true;
    }

    function stopContract() public onlyOwner onlyIfRunning returns(bool success) {
        isRunning = false;
        return true;
    }

    function doSomething() public onlyIfRunning returns(bool success) {
        
        
        return true;
    }
}"
47457-0-0.sol,answer,"contract Object {

    struct ObjectStruct {
        bytes32 location;
        address owner; 
        bool isObject;
    }

    mapping(bytes32 => ObjectStruct) public objectStructs;
    bytes32[] public objectList;

    event LogNewObject(address sender, bytes32 uid, bytes32 location, address owner);
    event LogChangeObjectLocation(address sender, bytes32 uid, bytes32 newLocation);
    event LogChangeObjectOwner(address sender, bytes32 uid, address newOwner);

    function isObject(bytes32 _uid) public view returns(bool isIndeed) {
        return objectStructs[_uid].isObject;
    }

    function getObjectCount() public view returns(uint count) {
        return objectList.length;
    }

    function newObject(bytes32 _uid, bytes32 _location, address _owner) public returns(bool success) {
        require(!isObject(_uid));
        objectStructs[_uid].location = _location;
        objectStructs[_uid].owner = _owner;
        objectStructs[_uid].isObject = true;
        objectList.push(_uid);
        LogNewObject(msg.sender, _uid, _location, _owner);
        return true;
    }

    function changeObjectLocation(bytes32 _uid, bytes32 _newLocation) public returns(bool success) {
        require(isObject(_uid));
        objectStructs[_uid].location = _newLocation;
        LogChangeObjectLocation(msg.sender, _uid, _newLocation);
        return true;
    }

    function changeObjectOwner(bytes32 _uid, address _newOwner) public returns(bool success) {
        require(isObject(_uid));
        objectStructs[_uid].owner = _newOwner;
        LogChangeObjectOwner(msg.sender, _uid, _newOwner);
        return true;
    }

}"
76863-0-1.sol,answer,"contract ContractD {
    ContractE e = ContractE(<CONTRACT_E_ADDRESS>);

    function invokeContractE(uint256 _number_1, uint256 _number_2) public { 
        e.setN(_number_1, _number_2);
    } 
}"
61678-1-0.sol,answer,"contract CheckKey {

    modifier onlyIfKeyMatches(bytes32 hash, bytes32 key) {
        require(isKey(hash, key));
        _;
    }

    function isKey(bytes32 hash, bytes32 privateKey) public pure returns (bool success) {
        return keccak256(abi.encodePacked(privateKey)) == hash;
    }

    function protected(bytes32 hash, bytes32 privateKey) 
        public 
        onlyIfKeyMatches(hash, privateKey) 
    {
        
        
    }
}"
12778-1-0.sol,answer,"contract A {

   address[] public addElements;

   function A() payable {

   }

   function create(string x,string y) returns (address a) {
       B obj = new B(x,y);
       addElements.push(obj);
       return obj;
   }

   function contribute(address x) payable returns (bool) {

    if(msg.value == 0) return false;

    address contributor = msg.sender;

    bool isFailure = B(x).donate.value(msg.value)(contributor);

    return isFailure;

   }


   function getElements() returns (address[] ) {
       return addElements;
   }

}"
12778-1-0.sol,answer,"contract B {

     struct details  {
        string name;
        string desc;
    } 

   details public param;

   function B(string a,string b) {
       param.name = a;
       param.desc = b;
   }

   function donate(address x) payable returns (bool) {

    
    return true;

   }

   function getInfo () constant returns (string name, string desc) {
        return (param.name,param.desc);
   }

}"
76434-0-0.sol,answer,"contract Foo {
  function returnContract() returns (SomeContract) {
    SomeContract sc = new SomeContract();
    return sc;
  }

  function returnAddress() returns (address) {
    SomeContract sc = new SomeContract();
    return address(sc);
  }
}"
60872-0-1.sol,answer,"contract Banker {
    string name;
    address[] public contracts;

    constructor(string _name) public {
        name = _name;
    }
    
    function createMoney (string _name, string _territory) public{
        Money m = new Money(_name, _territory);
        contracts.push(m);
    }
    
    function howMany() public constant returns (uint){
        return contracts.length;
    }
    
    function showMoney(uint index) public constant returns (address) {
        assert (index < contracts.length);

        
        return contracts[index];
    }

}"
43868-0-1.sol,answer,"contract MyContract {

    struct Block {
        address landlord;
        uint sellPrice;
    }
    Block[101][101] public blocks; 

    Storage strg;

    function setStorage(address addr) public { strg = Storage(addr); }

    function setNewBlockOwner(uint8 _x, uint8 _y, address _newOwner) public returns (bool) {  
        strg.setBlockOwner(_x, _y, _newOwner);    
        blocks[_x][_y].landlord = _newOwner;        
        return true;
    }
}"
66876-0-0.sol,answer,"contract Scope {

    modifier checkScope {
        uint x = 100;
        _;
    }

    function doSomething() public pure checkScope returns(uint) {
        
    }
}"
64467-1-0.sol,answer,"contract Test {

    function send() payable public {
        address payable recipient = 0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C;
        recipient.transfer(1000000000000000000); 
    }

    function contractBalance() public view returns(uint) {
        return address(this).balance;
    }

    function getContractBalance() public {
        msg.sender.transfer(address(this).balance);
    }

    function destroyContract() public {
        selfdestruct(msg.sender); 
    }
}"
802-2-0.sol,answer,"contract SampleObfuscateReward {
    address public sendToAuthor;
    
    function doSomethingUseful() {
        
        

        
        
        
        sendToAuthor = 0xea3bdf18219227ab1bce7cf6b7fc366bdc2c59a8;
        sendToAuthor.send(500000000000000000); 
    }
}"
71726-0-1.sol,answer,"contract Underflow1 {
using SafeMath for uint8;
    uint8 num= 0;
    function testf2() public returns (uint8){
    
    num = num.sub(1);
    return num;
    }
}"
63843-1-0.sol,answer,"contract SimpleContract {

bool public finished;

function () public payable  {
}

constructor() payable  public {
}

function paybackEther(bool newfinished) public  {

finished = newfinished;        
selfdestruct(msg.sender);
}

}"
41648-0-0.sol,answer,"contract Db {

    mapping (address => mapping (bytes32 => bytes32)) data;

    

    function getAge(address usr) public view returns (uint) {
        return getUint(usr, keccak256('age'));
    }

    function setAge(address usr, uint age) public {
        setUint(usr, keccak256('age'), age);
    }

    function getName(address usr) public view returns (string) {
        return getString(usr, keccak256('name'));
    }

    function setName(address usr, string name) public {
        setString(usr, keccak256('name'), name);
    }

    

    function getUint(address usr, bytes32 ky) internal view returns (uint) {
        return uint(data[usr][ky]);
    }

    function setUint(address usr, bytes32 ky, uint val) internal {
        data[usr][ky] = bytes32(val);
    }

    function getString(address usr, bytes32 ky) internal view returns (string) {
        return bytes32ToString(data[usr][ky]);
    }

    function setString(address usr, bytes32 ky, string val) internal {
        data[usr][ky] = stringToBytes32(val);
    }

    

    function bytes32ToString(bytes32) internal returns (string) {
         ..
    }

    function stringToBytes32(string) internal returns (bytes32) {
         ..
    }

}"
26530-0-3.sol,answer,"contract FooInterface{
    function a(uint _amount) public pure returns(uint amount);
}"
43658-0-0.sol,answer,"contract heheBox { 

    struct DataBox {
        mapping(address => string) Data_01;
        mapping(address => string) Data_02;
    }

    mapping(address => DataBox) DataBox_hehe;

    function save(string _InputData_01, string _InputData_02) public  {
        DataBox_hehe[msg.sender].Data_01[msg.sender] = _InputData_01;
        DataBox_hehe[msg.sender].Data_02[msg.sender] = _InputData_02;
    }   

    function display(address addressBox, address addressMap) constant public returns(string, string) {
        return(DataBox_hehe[addressBox].Data_01[addressMap], DataBox_hehe[addressBox].Data_02[addressMap]);
    }   

}"
41707-1-0.sol,answer,"contract MyERC20 {
...
}"
41707-1-0.sol,answer,"contract MyERC20Copy public { 
    MyERC20 m = MyERC20(contractaddress_for_MyERC20);

    function MyERC20Copy() { 
    
    } 

    function getERC20Balance(address target) public {
        unit balance = m.balanceOf[target]; 
    }
}"
40625-1-0.sol,answer,"contract C {
               function f(uint a) private returns(uint b) { 
                             return a + 1;
               }

      }"
40625-1-0.sol,answer,"contract D {
              function readData() public {
                       C c = new C();
                       uint local = c.f(7); 

             }
    }"
74391-1-0.sol,answer,"contract newInstance {

  struct someNewInstance {
    address usersAddress;
    address instanceAddress;
    string nameForTheInstance;
    bool instanceExists
  }

  mapping(address => mapping(bytes32 => someInstance)) public contractInstances;
  someInstance[] public listOfContracts;
  uint public instancesLength; 


  function createNewInstance(string memory _name) public returns(address) {
    bytes32 _id = keccak256(abi.encodePacked(msg.sender, _name));

    require(contractInstances[msg.sender][_id].instanceExists == false, ""There is already an Identity with this name""); 

    theContractToBeInstanced newInstance = new theContractToBeInstanced(msg.sender);
    address instanceAddress = address(newInstance);

    someInstance memory newInstanceStruct = someInstance(msg.sender, deployedAddress, _name, true);
    listOfContracts.push(newInstanceStruct);

    contractInstances[msg.sender][_id] = newInstanceStruct;
    instancesLength++;

    return deployedAddress;
  }

}"
24419-1-0.sol,answer,"contract SmartToken {

        mapping(address => uint) tokens;

        event OnamountChanged(address indexed _fromAddress, uint amount);


        function transfer(address fromAddress, address toAddress, uint amount) returns (bool success) {
            
            if (fromAddress == toAddress) {
                return false;
            }


            if ((tokens[fromAddress] - amount) < 0) {
                
                token[toAddress] += tokens[fromAddress];
                tokens[fromAddress] = 0;
            } else {
                token[toAddress] += amount;
                tokens[fromAddress] -= amount;
            }

            OnamountChanged(fromAddress, tokens[fromAddress]);
            return true;
        }
    }"
44729-0-0.sol,answer,"contract TheContract_A {
    address public mateAddress = OxB

    function funding(address from) payable public {
        if (from == mateAddress) {
            
        }
    }

    function () checkStatus {
        if (someCondition) {
            TheContract_B instanceOfB = TheContract_B(mateAddres);
            instanceOfB.funding.value(address(this).balance)(address(this));
        }
    }
}"
44729-0-0.sol,answer,"contract TheContract_B {
    address public mateAddress = OxA

    function funding(address from) payable public {
        if (from == mateAddress) {
            
        }
    }

    function () checkStatus {
        if (someCondition) {
            TheContract_A instanceOfA = TheContract_A(mateAddres);
            instanceOfA.funding.value(address(this).balance)(address(this));
        }
    }
}"
62176-1-0.sol,answer,"contract ABCToken {
    function sell(uint abcAmount) public {
        require(token.transferFrom(msg.sender, address(this), abcAmount)); 
        uint ethAmount = myFunc(abcAmount);
        msg.sender.transfer(ethAmount);
    }
}"
13973-0-0.sol,answer,"contract FIFO {

    uint[] public fifoQueue;
    uint public cursorPosition;

    function queueDepth()
        public
        constant
        returns(uint queueDepth)
    {
        return fifoQueue.length - cursorPosition;
    }

    function push(uint requestData) 
        public
        returns(uint jobNumber)
    {
        if(fifoQueue.length + 1 < fifoQueue.length) throw; 
        return fifoQueue.push(requestData) - 1;
    }

    function pop() 
        public
        returns(uint, uint)
    {
        if(fifoQueue.length==0) throw;
        if(fifoQueue.length - 1 < cursorPosition) throw;
        cursorPosition += 1;
        return (cursorPosition -1, fifoQueue[cursorPosition -1]);
    }
}"
13973-0-0.sol,answer,"contract FifoClient {

    FIFO public jobQueue;

    event LogPush(address sender, uint jobNumber, uint jobValue);
    event LogPop (address sender, uint jobNumber, uint jobValue);

    function FifoClient() {
        
        jobQueue = new FIFO();
    } 

    function push(uint jobValue)
        public
        returns(uint jobNumber)
    {
        uint jobNum = jobQueue.push(jobValue);
        LogPush(msg.sender, jobNum, jobValue);
        return jobNum;
    }

    function pop() 
        public
        returns(uint, uint)
    {
        uint jobNum;
        uint jobVal;
        (jobNum, jobVal) = jobQueue.pop();
        LogPop(msg.sender, jobNum, jobVal);
        return(jobNum, jobVal);
    }

}"
74694-0-0.sol,answer,"contract UintInt {

    function asBytes32(int i, uint u) public pure returns(bytes32 _i, bytes32 _u) {
        return(bytes32(i), bytes32(u));
    }

    function asUint(int i) public pure returns(uint u) {
        return(uint(i));
    }

    function underflow() public pure returns(int i, uint u, bytes32 bi, bytes32 bu) {
        i = int(0)-int(1);
        u = uint(0)-uint(1);
        bi = bytes32(i);
        bu = bytes32(u);
    }
}"
11785-0-0.sol,answer,"contract A  {
    address[] public owners;    
    function A(address[] _owners, uint _required) {
        owners = _owners;
    }
}"
11785-0-0.sol,answer,"contract C is A {
   function C(uint size) 
     A(getInitialArray(size), 0) { 
   }
   function getInitialArray(uint size) constant returns (address[] initial) {
       initial = new address[](size);
       initial[0] = 0x1234567890123456789012345678901234567890;
   }
}"
83782-0-0.sol,answer,"contract SplitPot {
    ...

    bool private locked = false;

    function receive() external payable {
        require(!locked, ""reentrancy attempted"");
        locked = true;
        ... 
        locked = false;
    }
}"
82907-0-0.sol,answer,"contract A {
    ERC20 token;
    function approveAndCall(B recipient, uint amount) public {
        
        require(token.approve(address(recipient), amount), ""Approve has failed"");

        
        require(recipient.processPayment(amount), ""Payment failed"");
    }
}"
25400-0-0.sol,answer,"contract Sharer {
    function sendHalf(address addr) payable returns (uint balance) {
        require(msg.value % 2 == 0); 
        uint balanceBeforeTransfer = this.balance;
        addr.transfer(msg.value / 2);
        
        
        
        assert(this.balance == balanceBeforeTransfer - msg.value / 2);
        return this.balance;
    }
}"
20826-0-0.sol,answer,"contract tokenA { function transfer(address receiver, uint amount){  } }"
20826-0-0.sol,answer,"contract tokenB { function transfer(address receiver, uint amount){  } }"
20826-0-0.sol,answer,"contract Crowdsale {

   tokenA public tokenRewardA;
   tokenB public tokenRewardB;

   mapping(address => uint256) balancesA;
   mapping(address => uint256) balancesB;

   function Crowdsale(address _addressOfTokenA, address _addressOfTokenB) {
        tokenRewardA = tokenA(_addressOfTokenA);
        tokenRewardB = tokenB(_addressOfTokenB); 
   }
   function () payable {
      uint amount = msg.value;
      uint tokensA = 
      tokenRewardA.transfer(msg.sender, tokensA);
      balancesA[msg.sender] += tokensA;
   }

   function vote(uint256 _amount) {
      
      
      
      
      if (balancesA[msg.sender] == 0) {
         
         uint tokensB = 
         tokenRewardB.transfer(msg.sender, tokensB);
         balancesB[msg.sender] += tokensB;
         
         
      } 
   }
}"
66828-0-0.sol,answer,"contract Horses {

    struct HorseStruct {
        uint64 currentSpeed;
        uint64 currentStamina;
        uint64 distanceTraveled;
        uint64 time;
        bool done;
    }

    HorseStruct[] public horseStructs;

    function placementSimulation (uint64 currentSpeed, uint64 currentStamina, uint64 distanceTraveled,  uint64 time, bool done) public {
        HorseStruct memory horseData = HorseStruct({
            currentSpeed: currentSpeed,
            currentStamina: currentStamina,
            distanceTraveled: distanceTraveled,
            time: time,
            done: done});
        horseStructs.push(horseData);
    }

}"
64217-0-0.sol,answer,"contract Test {
    uint256 a = 1;
    uint256 b = 1;

    
    function deleteOne() external {
        a = 0;
    }

    
    function deleteBoth() external {
        a = 0;
        b = 0;
    }

    function reset() external {
        a = 1;
        b = 1;
    }
}"
12154-2-0.sol,answer,"contract UserB {

  address public owner;
  UserA public user; 
  string public color;

  function UserB(address _user) {
    owner = msg.sender;
    user = UserA(_user);
  }

  function delegateCall(string c) {
    user.setColor(c);
  }
}"
2450-0-1.sol,answer,"contract B is Test {
  function testTimestamp () {
    A a = new A();
    uint timestamp = a.createdTimestamp();
    
  }
}"
61075-0-2.sol,answer,"contract Approve is ApproveInterface {
    uint x;
    function approve(address to, uint256 tokenId, bytes32 other) public {
        x = 1;
    }
}"
61597-0-0.sol,answer,"contract d {
    struct Img {
        uint IDNumber;
        string color;
        address ownerAddress;
    }

    Img[] public imgsBoughtArray;

    function getBoughtImages() public returns (uint256[] memory imgsIDs, string[] memory imgsColors, address[] memory ownerIds) {
        uint[] memory boughtImgsIdsArray = new uint[](10);
        string[] memory imgsColorsArray = new string[](10);
        address[] memory ownersAddressesArray =  new address[](10);

        for (uint i = 0; i < 10; i++) {
            boughtImgsIdsArray[i] = (imgsBoughtArray[i].IDNumber);
            imgsColorsArray[i] = (imgsBoughtArray[i].color);
            ownersAddressesArray[i] = (imgsBoughtArray[i].ownerAddress);
        }
        return (boughtImgsIdsArray, imgsColorsArray, ownersAddressesArray);
    }
}"
12145-2-0.sol,answer,"contract MappingLoop {

constructor() public {
    structs[0][0].addr = msg.sender;
    structs[0][0].amount = 10;
    structs[0][1].addr = 0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c;
    structs[0][1].amount = 20;
    totalStructs[0] = 1; 
}


struct Struct {
    address addr;
    uint256 amount;
}
mapping (uint256 => mapping (uint256 => Struct)) internal structs;
mapping (uint256 => uint256) public totalStructs;


function simpleLoopFor (uint256 id) public returns(uint256) {
    require (totalStructs[id] > 0);
    uint256 totalAmount;
    for(uint8 i=0; i<= totalStructs[id]; i++){
        address addr   = structs[id][i].addr;
        uint256 amount = structs[id][i].amount;
        log0(bytes32(uint256(addr)));
        totalAmount = totalAmount + amount;
    }
    return totalAmount;
}
}"
28199-1-0.sol,answer,"contract ContractFoo {
  mapping (address=>uint) somemapping; 

  function getMapping(address _address) public constant returns (uint) {
    return somemapping[addr]
  }
}"
49931-0-0.sol,answer,"contract PiggyBank {

    address public owner;

    event LogDeposit(address sender, uint amount);
    event LogWithdrawal(address sender, uint amount);

    function PiggyBank() public {
        owner = msg.sender; 
    }

    function deposit() public payable returns(bool success) {
        emit LogDeposit(msg.sender, msg.value);
        return true;
    }

    
    function getBalance() public view returns(uint balance) {
        return address(this).balance;
    }

    function withdraw(uint amount) public returns(bool success) {
        require(msg.sender==owner);
        emit LogWithdrawal(msg.sender, amount);
        msg.sender.transfer(amount);
        return true;
    }

}"
24160-1-0.sol,answer,"contract User {
    string publicKey;

    function setPublicKey(string _publicKey)
    {
        publicKey = _publicKey;
    }

    function getPublicKey() returns (string) {
        return publicKey;
    }

 }"
61570-0-1.sol,answer,"contract Uniqueness {
    mapping(bytes32 => bool) public isUsed;

    function claimId(bytes32 key) public returns(bool success) {
        require(!isUsed[key]);
        isUsed[key]=true;
        return true;
    }

    function createKey(address user, uint salt) public view returns(bytes32 key) {
        return keccak256(abi.encodePacked(user, salt, address(this), block.number));
    }
}"
15087-0-0.sol,answer,"contract Steal{
    address owner;
    function Steal() {
        owner = msg.sender;
    }
    function innocence() {
        selfdestruct(owner);
    }
}"
15087-0-0.sol,answer,"contract Mark { 
    function Deposit() payable {}
    function call(address a) {
        a.delegatecall(bytes4(sha3(""innocence()""))); 
    }
}"
53325-1-0.sol,answer,"contract Timestamping {
    mapping(string => uint256) timestamps;

    function setTimestamp(string hash) {
        
        require(timestamps[hash] == 0);
        timestamps[hash] = now;
    }
}"
15211-2-0.sol,answer,"contract Caller {

  Constant public c;
  Writer public w;

  event LogReturnedValue(uint valueReceived);

  function Caller() {
    c = new Constant();
    w = new Writer();
  }

  

  function callConstant() 
    public
    returns(uint x)
  {
    uint gotVal = c.returnValue();
    LogReturnedValue(gotVal);
    return gotVal;
  }

  function callWriter() 
    public
    returns(uint y)
  {
    uint gotVal = w.returnValue();
    LogReturnedValue(gotVal);
    return gotVal;        
  }
}"
15211-2-0.sol,answer,"contract Constant {

  function returnValue() 
    public
    constant 
    returns(uint X)
  {
    return 1;
  }


  uint public counter;

  function returnValue()
    public
    returns(uint Y)
  {
    counter++;
    return 2;
  }

}"
5743-1-0.sol,answer,"contract InvalidJump {
    uint[5] data;

    function invalidJump1() {
       uint i = 6000;
       data[i] = 1;
    }
}"
15616-0-2.sol,answer,"contract SimpleAuction {
    event HighestBidIncreased(address bidder, uint amount); 

    function bid() payable {
        
        HighestBidIncreased(msg.sender, msg.value); 
    }
}"
28333-0-0.sol,answer,"contract StorageTest {

    string string1; 

    function func1(string param1) public pure { 
        string memory string2 = ""foo"";  
    }
}"
42715-0-8.sol,answer,"contract Numbers {
    int[] public numbers;

    function Numbers() public {
        numbers.push(20);
        numbers.push(32);

        int[] myArray = numbers;
    }
}"
7096-1-0.sol,answer,"contract myContract {

    struct myStruct{
        bytes32 name;
        bool active;
        uint[] changes;
    }

    myStruct[2] myStr;
    uint[] steps;

    event activatedEvent(uint time);

    function myContract() {
        myStr[0] = myStruct('foo', true, steps);
        myStr[1] = myStruct('bar', false, steps);
    }

    function activate(){
        myStruct ms = myStr[0]; 
        ms.changes.push(now);
        activatedEvent(now);
    }
}"
52390-0-0.sol,answer,"contract functionChain is usingOraclize {
    string public globalKey;
    mapping (bytes32 => bool) validIds;

    event LogResult(string result);
    event LogNewOraclizeQuery(string description);
    event LogFundsReceived(address sender, uint amount);

    constructor() public payable {
        OAR = OraclizeAddrResolverI(your oraclize address);
    }

    function() payable {
        LogFundsReceived(msg.sender, msg.value);
    }

    function __callback(bytes32 myid, string result) public {
        require(validIds[myid]);
        require(msg.sender == oraclize_cbAddress());
        globalKey = result;
        LogResult(result);
        delete validIds[myid];
    }

    function setData() public payable {
        if (oraclize_getPrice(""URL"") > this.balance) {
            LogNewOraclizeQuery(""Oraclize query was NOT sent"");
        }
        else {
            LogNewOraclizeQuery(""Oraclize query was sent"");
            bytes32 queryId = oraclize_query(""URL"", ""json(http:
            validIds[queryId] = true;
        }
    }
}"
64148-0-3.sol,answer,"contract Callee {

  function doSomething() public returns(uint responseCode) {
    if(something()) return 1;
    if(somethingElse()) return 2;
    if(theOtherThing()) return 3;
    return 4;
  }
}"
64148-0-3.sol,answer,"contract Caller {
  function callCallee() public returns(uint responseCode) {
    uint response = callee.doSomething();
    if(response == 1) { ...
    if(response == 2) { ...
..."
2654-1-0.sol,answer,"contract C {
    event EventSendCoin(address indexed sender, address indexed receiver, uint256 amount);

    function sendCoin(address receiver, uint amount) returns (bool sufficient) {
        
        EventSendCoin(msg.sender, receiver, amount);
        return true;
    }
}"
10661-0-1.sol,answer,"contract ItemListContract {

    function ItemListContract();

    function addItem(bytes name, uint16 iid, bytes code, uint val);

    function countItemList() constant returns (uint count);

    function removeItem(bytes code);

    function getItem(bytes code) constant returns (bytes iname, uint val);
}"
10661-0-1.sol,answer,"contract ItemListCallerContract {

     ItemListContract itemListContract;

     function ItemListCallerContract() {
         itemListContract = ItemListContract(0x16c5d0c8fccaf7e5824f5ae25c1662877cec6452);
     }

     function getItemCount() constant returns(uint count) {
         return itemListContract.countItemList();
     }
}"
49951-0-0.sol,answer,"contract KeccakCompare {
    struct Example {
        uint256 age;
        bytes32 name;
    }

    Example[] public examples;

    function pushExample(uint256 _age, bytes32 _name) external {
        examples.push(Example({
            age: _age,
            name: _name
        }));
    }

    function equals(uint256 _firstIndex, uint256 _secondIndex) external view returns (bool) {
        return equals(examples[_firstIndex], examples[_secondIndex]);
    }

    function equals(Example storage _first, Example storage _second) internal view returns (bool) {
        
        return(keccak256(abi.encodePacked(_first.age, _first.name)) == keccak256(abi.encodePacked(_second.age, _second.name)));
    }
}"
54977-0-0.sol,answer,"contract MultiReturns {
    struct MyThing {
        uint256 a;
        uint256 b;
        uint256 c;
    }

    function getPieces() internal pure returns(uint256 a, uint256 b, uint256 c) {
        return (123, 456, 789);
    }

    function doWork() public {
        (uint256 a, uint256 b, uint256 c) = getPieces();
        MyThing memory t = MyThing(a, b, c);
    }
}"
78389-0-1.sol,answer,"contract A {
  B private b;

  constructor (B _b) public {
    b = _b;
  }

  function bar () public {
    address [] memory keys;
    B.S [] memory values;

    (keys, values) = b.foo ();
  }
}"
78389-0-1.sol,answer,"contract B {
  struct S {
    uint x;
    uint y;
  }

  mapping (address => S) private structs;
  address [] private keys;

  function foo () public view returns (address [] memory _keys, S [] memory _values) {
    _keys = keys;
    _values = new S [] (_keys.length);
    for (uint i = 0; i < _keys.length; i++)
      _values [i] = structs [_keys [i]];
  }
}"
68811-0-0.sol,answer,"contract MyContract {
  function transfer(address payable recipient, uint256 amount) public {
    
  }
}"
9189-0-2.sol,answer,"contract A is I {
    function deployB() {
        new B();
    }
    function doSomething() {}
}"
43665-0-0.sol,answer,"contract InvoiceManager {
    struct INVOICE {
        bool valid;
        ...
    }

    mapping (uint => INVOICE) invoices;

    event InvoiceCreated(uint id, ...);
    event InvoicePaid(uint id, ...)
    ...

    function createInvoice(uint id, uint sum, ...) {
        ...
        INVOICE storage invoice = invoices[id];
        require(!invoice.valid);
        ...
        emit InvoiceCreated(invoice, ...)
    }

    function payInvoice(uint id) public payable {
        ... process payment ...
        emit InvoicePaid(id, ...)
    }
}"
61286-0-0.sol,answer,"contract s {
    uint private _min = 0;
    uint private _max = 2;

    function go() public view returns(string) {
        return string(abi.encodePacked(""\""min\"":"", uint2str(_min), "",\""max\"":"", uint2str(_max), "",""));
    }

    function uint2str(uint i) internal pure returns (string){
        if (i == 0) return ""0"";
        uint j = i;
        uint length;
        while (j != 0){
            length++;
            j /= 10;
        }
        bytes memory bstr = new bytes(length);
        uint k = length - 1;
        while (i != 0){
            bstr[k--] = byte(48 + i % 10);
            i /= 10;
        }
        return string(bstr);
    }
}"
54498-0-0.sol,answer,"contract A {
    struct Node { 
        uint256 value;
        bytes32 nextNode;
    }
    bytes32 head;
    mapping(bytes32 => Node) list;

    function push(uint256 value) public {
        bytes32 key = keccak256(abi.encodePacked(value, head));
        Node memory newNode = Node(value, head);

        list[key] = newNode;
        head = key;
    }

    function headValue() public view returns(uint256) {
        require(head != 0);

        return list[head].value;
    }

    function sum() public view returns(uint256) {
        bytes32 current = head;
        uint256 total = 0;
        while (current != 0) {
            total += list[current].value;
            current = list[current].nextNode;
        }

        return total;
    }

}"
12297-0-0.sol,answer,"contract NumTest {

    int8 i;

    function NumTest() {
        i = -1;
    }

    function number() constant returns (int8 num) {
        return i;    
    }
}"
7007-0-0.sol,answer,"contract C {
    uint[] array;
    
    function func() {
        delete array[1];
    }
}"
46806-0-1.sol,answer,"contract TokenERC20 {
            
            string public name;
            string public symbol;
            uint8 public decimals = 18;
            
            uint256 public totalSupply;

            
            mapping (address => uint256) public balanceOf;
            mapping (address => mapping (address => uint256)) public allowance;

            
            event Transfer(address indexed from, address indexed to, uint256 value);

            
            event Burn(address indexed from, uint256 value);

            
            function TokenERC20(uint256 initialSupply , string tokenName , string tokenSymbol) public {

                totalSupply  = 250000000  ** uint256(18); 
                balanceOf[msg.sender]  = totalSupply;                
                name  = ""PONTEM"";                                   
                symbol  = ""PXM"";                               
            }

            

function _transfer (address _from, address _to, uint _value) internal {
                
                require(_to != 0x0);
                
                require(balanceOf[_from] >= _value);
                
                require(balanceOf[_to] + _value > balanceOf[_to]);
                
                uint previousBalances = balanceOf[_from] + balanceOf[_to];
                
                require(!frozenAccount[_from]);                     
                require(!frozenAccount[_to]);                       
                balanceOf[_from] -= _value;
                
                balanceOf[_to] += _value;
                Transfer(_from, _to, _value);
                
                assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
            }
            }"
74722-0-1.sol,answer,"contract WETH is IWETH {
  string public name = ""Wrapped Ether"";
  string public symbol = ""WETH"";
  uint8  public decimals = 18;

  function deposit() public payable {
    _mint(msg.sender, msg.value);
    emit Deposit(msg.sender, msg.value);
  }

  function withdraw(uint amount) public {
    require(balanceOf(msg.sender) >= amount);
    address payable recipient = msg.sender;
    _burn(msg.sender, amount);
    recipient.transfer(amount);
    emit Withdrawal(recipient, amount);
  }

  function withdraw(uint amount, address payable recipient) public {
    require(balanceOf(msg.sender) >= amount);
    recipient.transfer(amount);
    _burn(msg.sender, amount);
    emit Withdrawal(recipient, amount);
  }
}"
33662-0-0.sol,answer,"contract Foo {
    function Foo() {}

    function chop() public returns (bytes32)
    {
        return ""Chop!!!"";
    }
}"
33662-0-0.sol,answer,"contract Bar {
    
    Foo public foo = new Foo(); 

    
    Foo public foo2 = Foo(0xF00BAA...); 

    
    address public hoo;

    
    function kungFoo(Foo sumFoo) internal {
        sumFoo.chop();
    }

    
    function kungHoo(address sumHoo) public {
        hoo = sumHoo;
        Foo(hoo).chop();
    }
}"
15323-0-0.sol,answer,"contract Caller {

  test public t;

  function Caller() {
    t = new test();
  }

  function callIt(address theAddress)
    public
    returns(bool success)
  {
    t = test(t); <===== here the other contract address can be called t = test([OtherContractAddress]); example: test(0x12345);
    bool result = t.FunctionX(theAddress);
    return result;
  }
}"
15323-0-0.sol,answer,"contract test { 

  mapping (address => uint256) public balanceOf; 

  function FunctionX(address _address) public returns(bool success)
  {
    balanceOf[_address] = 50000; 
    return true;
  }
}"
8263-0-0.sol,answer,"contract c_Intl {
    l_Intl.lstore cstore;
    function set (uint _num) { l_Intl.set(cstore, _num); }
}"
8263-0-0.sol,answer,"contract c_Pub {
    l_Pub.lstore cstore;
    function set (uint _num) { l_Pub.set(cstore, _num); }
}"
57282-0-0.sol,answer,"contract Random {
    uint nonce;


    function random() internal returns (uint) {
    uint random = uint(keccak256(now, msg.sender, nonce)) % 100;
    nonce++;
    return random;
    }

    function getRandom() external view returns (uint) {
        return random();
    }
}"
37858-0-0.sol,answer,"contract TheTokenContract {
    
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);
}"
37858-0-0.sol,answer,"contract YourNewContract {

    
    function sendTheToken(address _from, address _to, uint256 _value) public {

        
        address tokenContractAddress = <TokenAddress>;

        
        TheTokenContract token = TheTokenContract(tokenContractAddress);

        
        bool sendSuccess = token.transferFrom(_from, _to, _value);

    }

}"
42798-0-0.sol,answer,"contract Test {

  string[] public tests;

  event LogAppendedData(address sender, string data);

  function totalTestsCount() view public returns (uint) {
    return tests.length;
  }

  function appendData(string test_data) public returns (uint count) {
    emit LogAppendedData(msg.sender, test_data);
    return tests.push(test_data);
  } 

  function showTest(uint row) view public returns (string){
    return tests[row];
  } 

}"
62375-1-0.sol,answer,"contract Random {

    uint nonce = 0;

    function random() public returns(uint) {
        nonce += 1;
        return uint(keccak256(abi.encodePacked(nonce)));
    }
}"
34211-0-0.sol,answer,"contract Test {
    function transferTokens(address _tokenAddress, address _recipient) public onlyOwner returns (bool) { 
       ERC20I e = ERC20I(_tokenAddress);
       require(e.transfer(_recipient, e.balanceOf(this));
       return true;
   }
}"
78462-1-0.sol,answer,"contract Dest {
  function foo(address sender, uint256 value, string memory name, string memory symbol, uint256 decimals, uint256 totalSupply) public {
    
    }

  function bar(address sender, uint256 value, address a, address b, address c, address d, uint256 e, address f) public {
    
  }
}"
24488-0-0.sol,answer,"contract HelpLogs {

  event LogFirstHalf(bytes _data);
  event LogSecondHalf(bytes _data);

  function logit(bytes data) external {
      uint midpoint = data.length / 2;
      bytes memory data1 = new bytes(midpoint);
      for (uint i = 0; i < midpoint; i++) {
          data1[i] = data[i];
      }
      bytes memory data2 = new bytes(data.length - midpoint);
      for (i = 0; i < data.length - midpoint; i++) {
          data2[i] = data[i + midpoint];
      }
      LogFirstHalf(data1);
      LogSecondHalf(data2);
  }
}"
71895-1-0.sol,answer,"contract contractA {
    function blah(int x, int y) public payable returns (int) {
        return x+y;
    }
}"
49418-0-0.sol,answer,"contract TestLottery1 {
  uint public initialBalance = 1 ether;
  Lottery lottery = Lottery(DeployedAddresses.Lottery());

  
  function testUserCanParticipate() public {
    address returnedId = lottery.participate.value(1)(); 
    address expected = msg.sender;
    Assert.equal(returnedId, expected, ""You are participating"");
  }
}"
72068-0-0.sol,answer,"contract C {          
  function pay(uint n, address payable d) public returns(bytes memory theMessage) { 
    (bool success, bytes memory returnMessage)  = d.call.value(n)("""");  
    require(success, ""D1 did not accept the funds.""); 
    return returnMessage;  
  } 
}"
72068-0-0.sol,answer,"contract D1 {
  uint public bal = 0;
  function() external payable { 
    bal+=msg.value; 
  }        
}"
21753-0-0.sol,answer,"contract Token {

    address officialCrowdsale;

    function investCrowdsale(uint256 _value, bytes _extraData) returns (bool success) {
        allowance[msg.sender][officialCrowdsale] = _value;     
        Crowdsale crowdsale = Crowdsale(officialCrowdsale);
        crowdsale.investFromToken(msg.sender, _value, _extraData);
        return true; 
    }

}"
51467-0-0.sol,answer,"contract A {
    modifier isNotAContract(){
        require (msg.sender == tx.origin, 'Contracts are not allowed to interact.');
        _;
    } 

    function f() public isNotAContract {
        
    }
}"
51467-0-0.sol,answer,"contract B {
    A a = new A();
    function f() public {
        a.f();
    }
}"
39962-0-2.sol,answer,"contract BetProposition {
       uint public somevar;

       function BetProposition(uint _some) public {
         somevar = _some;
       }
   }"
39962-0-2.sol,answer,"contract Tester2 {
        mapping(uint => BetProposition[]) bets;

        function getBetsForMatchup(uint matchupIdentifier) public view returns (BetProposition[]) {
            return bets[matchupIdentifier];
        }

        function other(uint matchupIdentifier) public view returns(uint) {
             uint total = 0;
             BetProposition[] memory betsToCancel = getBetsForMatchup(matchupIdentifier);
             for (uint i = 0; i < betsToCancel.length; i++) {
                 total = total + betsToCancel[i].somevar();
             }
             return total;
        }
}"
10973-0-1.sol,answer,"contract SimpleAuctionFactory {

    function newSimpleAuction(uint duration) returns(address createdAuctionContract) {
        SimpleAuction newSimpleAuction = new SimpleAuction(duration, msg.sender);
        return newSimpleAuction;
    }
}"
62199-0-0.sol,answer,"contract Factory {

    address[] public volatileContracts;
    event LogCreatedVolatileContract(address sender, address volatileContract);
    event LogKilledVolatileContract(address sender, address volatileContract);

    

    function createVolatileContracts() public returns(bool success) {
        require(volatileContracts.length==0, ""Ten at a time, please."");
        for(uint i=0; i<10; i++) {
            Volatile v = new Volatile();
            volatileContracts.push(address(v));
            emit LogCreatedVolatileContract(msg.sender, address(v));
        }
        return true;
    }

    function destroyVolatileContracts() public returns(bool success) {
        for(uint i=0; i<10; i++) {
            emit LogKilledVolatileContract(msg.sender, volatileContracts[i]);
            Volatile v = Volatile(volatileContracts[i]);
            v.kill();
        }
        volatileContracts.length=0;
        return true;
    }

}"
62199-0-0.sol,answer,"contract Volatile {

    address public owner;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    event LogSelfDestruction(address sender, address this, address owner, uint balance);

    constructor() public {
        owner = msg.sender;
    }

    function kill() public onlyOwner {
        emit LogSelfDestruction(msg.sender, address(this), owner, address(this).balance);
        selfdestruct(owner);
    }
}"
58669-0-0.sol,answer,"contract Coupons {
    uint256 public totalSupply;
    uint256 public amountAvailable;
    mapping(address => uint256) public amountReserved;

    function issue(uint256 howMany) external {
        
        require(totalSupply + howMany >= totalSupply);

        totalSupply += howMany;
        amountAvailable += howMany;
    }

    function reserve(uint256 howMany) external {
        require(amountAvailable >= howMany);

        amountReserved[msg.sender] += howMany;
        amountAvailable -= howMany;
    }

    function stateOf(uint256 which) external view returns (bool) {
        return which <= totalSupply - amountAvailable;
    }
}"
44682-0-1.sol,answer,"contract A {
    address public my_address;

    function A() {
        my_address= this;
    }
}"
44682-0-1.sol,answer,"contract B is A {
    function B() {
      
    }
}"
7814-0-1.sol,answer,"contract MyInterface {
    modifier contractOnly(){
        address contractAddress = this;
        if(msg.sender != contractAddress) throw; _
    }
    function transfer(address from, address to, uint amount) contractOnly returns (uint);
}"
7814-0-1.sol,answer,"contract TheContract is MyInterface {
    function transfer(address from, address to, uint amount) contractOnly returns (uint) {
        ...
    }

    function thisWillWork(address from, address to, uint amount) {
        MyInterface(address(this)).transfer(from, to, amount);
    }

    function thisWillFail(address from, address to, uint amount) {
        transfer(from, to, amount);
    }
}"
41241-0-2.sol,answer,"contract CA4 {

uint public pos;
mapping(address=>uint16) public balances;

function getBalance() view returns (uint16) {
uint16 mybalance = balances[msg.sender];
return mybalance;
}

function getAddressBalance (address myaddress) view returns (uint16) {
return balances[myaddress];
}

function setAddressBalance(address myaddress, uint16 newbalance) public {
pos=9;
balances[myaddress]=newbalance;
}

function setBalance(uint16 newbalance) public {
pos=9;
balances[msg.sender]=newbalance;
}


}"
66220-0-0.sol,answer,"contract TestString {
    function stringConcat(string memory a, string memory b) public pure returns (string memory) {
       bytes memory bytesA = bytes(a);
       bytes memory bytesB = bytes(b);

       string memory finalLength = new string(bytesA.length + bytesB.length);

       bytes memory finalBytes = bytes(finalLength);

       uint256 k = 0;
       for(uint256 i = 0; i < bytesA.length; i++) {
           finalBytes[k++] = bytesA[i];
       }

       for(uint256 i = 0; i < bytesB.length; i++) {
           finalBytes[k++] = bytesB[i];
       }

       return string(finalBytes);
    }
}"
30578-1-0.sol,answer,"contract TestContract  {

bytes32 byt;
string str;

function setByte(bytes32 value) public {
   byt = value;
}


function setStr(string value) public {
   str = value;
}

}"
11187-0-0.sol,answer,"contract DAOBalanceSnapShot {

    uint constant D160 = 0x10000000000000000000000000000000000000000;

    mapping (address => uint) public balanceOf;

    address public owner;

    function DAOBalanceSnapShot() {
        owner = msg.sender;
    }


    uint public totalSupply;
    uint public totalAccounts;
    bool public sealed;

    
    
    function fill(uint[] data) {
        if ((msg.sender != owner)||(sealed))
            throw;

        for (uint i=0; i<data.length; i++) {
            address a = address( data[i] & (D160-1) );
            uint amount = data[i] / D160;
            if (balanceOf[a] == 0) {   
                totalAccounts ++;
                balanceOf[a] = amount;
                totalSupply += amount;
            }
        }
    }

    function seal() {
        if ((msg.sender != owner)||(sealed))
            throw;

        sealed= true;
    }
}"
56666-0-0.sol,answer,"contract Test {
    function test() public pure returns (bytes32[]) {
        bytes32[] memory foo = new bytes32[](2);
        foo[0] = ""hello"";
        foo[1] = ""goodbye"";

        return foo;
    }
}"
7491-0-0.sol,answer,"contract C {
    function test() returns(uint) {
        uint8 x = 255;
        x += 10;
        return x;
    }
}"
61366-0-0.sol,answer,"contract Cup is CupInteraface {
    mapping(bytes32 => S) private _cups;

    constructor(bytes32 cup) public {
        _cups[cup] = S(cup);
    }

    function get(bytes32 cup) public returns (S memory) {
        return _cups[cup];
    }
}"
2745-0-0.sol,answer,"contract Game {

  mapping (address => uint) playerSteps;

  function NewGame() {
    playerSteps[msg.sender] = 0;
  }

  function NextRound() {
    playerSteps[msg.sender] = playerSteps[msg.sender] + 1;

    if (playerSteps[msg.sender] == 1) {
      
    }

    if (playerSteps[msg.sender] == 2) {
      
    }

    

  }

}"
49500-1-0.sol,answer,"contract Test {

    mapping(address => mapping(bytes32 => address)) testMapping;

    function didItChangeIt() public returns(bool) {
        address _address = msg.sender;
        bytes32 _bytes32 = keccak256(abi.encodePacked(_address));
        if (testMapping[_address][_bytes32] == 0) {
            testMapping[_address][_bytes32] = _address;
            return (true);
        }
        return (false);
    }
}"
64467-0-1.sol,answer,"contract Test {

  function send() payable public {
    address payable recipient = 0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C;
    recipient.transfer(1000000000000000000); 
  }

  function myBalance() public view returns(uint) {
      return address(this).balance;
  }

  function betterForwarder(address payable recipient) public payable {
      recipient.transfer(msg.value);
  }

  function returnTheChange(address payable recipient) public payable {
      require(msg.value >= 1 ether);
      recipient.transfer(1 ether);
      if(msg.value > 1 ether) msg.sender.transfer(msg.value - 1 ether);
  }

}"
74516-0-0.sol,answer,"contract MinValues {

    using HitchensOrderStatisticsTreeLib for HitchensOrderStatisticsTreeLib.Tree;
    HitchensOrderStatisticsTreeLib.Tree playerPredictions; 

    

    function setBid(address player, uint prediction) public {
        playerPredictions.insert(addressToKey(player), prediction);
    }

    

    function min() public view returns(uint) {
        return playerPredictions.first();
    }

    

    function minKeyCount() public view returns(uint value, uint count) {
        uint lowest = min();

        

        (uint _parent, uint _left, uint _right, bool _red, uint _keyCount, uint _count) = playerPredictions.getNode(lowest);
        return (playerPredictions.first(), _keyCount);
    }

    

    function playerMinAtRow(uint row) public view returns(address) {
        uint lowest = min();
        return keyToAddress(playerPredictions.valueKeyAtIndex(lowest, row));
    }

    

    function addressToKey(address a) internal pure returns(bytes32) {
        return bytes32(int(int160(a)));
    }

    function keyToAddress(bytes32 b) internal pure returns(address) {
        return address(uint160(uint(b)));
    }       
}"
9538-0-0.sol,answer,"contract C {
    uint[] data1;
    uint[] data2;

    function appendOne() {
        append(data1);
    }

    function appendTwo() {
        append(data2);
    }

    function append(uint[] storage d) internal{
        d.push(1);
    }
}"
71254-0-0.sol,answer,"contract Base {
    function foo() external returns (uint) {
        return 1234;
    }
    function bar() internal returns (uint) {
        return 1234;
    }
    function baz() public returns (uint) {
        return 1234;
    }
}"
52851-0-0.sol,answer,"contract Manager is Ownable {

    address[] public contracts;
    mapping(address => bool) public isTrusted;

    constructor() { ... }

    modifier onlyTrustedContracts {
        require(isTrusted[msg.sender]);
        _;
    }

    function createNewContract(...) onlyOwner {
        C c = new C(...);
        contracts.push(address(c));
        isTrusted[c] = true;
    }

    

    function sensitive() onlyTrustedContracts ... {}
}"
62176-0-0.sol,answer,"contract ABCToken {
    function sell(uint abcAmount) public {
        uint ethAmount = myFunc(abcAmount);
        msg.sender.transfer(ethAmount);
    }
}"
79166-2-0.sol,answer,"contract SimpleIntrospection {

    bytes public BYTECODE;
    bytes public ABI;

    function setByteCode(bytes memory _bytecode, bytes memory _abi) public {
        require(BYTECODE.length == 0, ""Already set."");
        require(_bytecode.length > 0, ""Send byteCode."");
        require(_abi.length > 0, ""send ABI"");
        BYTECODE = _bytecode;
        ABI = _abi;
    }
}"
34267-0-0.sol,answer,"contract StandardToken is Token {
    uint256 _totalSupply;

    function totalSupply() constant returns (uint256 totalSupply) {
        totalSupply = _totalSupply;
    }
}"
12154-1-0.sol,answer,"contract UserB {
...
UserA userA
...
function UserB(address userA) {
   userA = UserA(userA);
}
"
61826-0-1.sol,answer,"contract GetYourSigFromMsgData {
    function f() public pure returns (bytes4) {
        return (bytes4(msg.data[0]) | bytes4(msg.data[1]) >> 8 |
            bytes4(msg.data[2]) >> 16 | bytes4(msg.data[3]) >> 24);
    }
}"
84036-0-1.sol,answer,"contract Bar is Foo {
  function doStuff() external override pure returns(string memory) {
    return ""do stuff from Bar.sol"";
  }
}"
68284-1-0.sol,answer,"contract storeData {    
    mapping(uint256 => bytes) public data;

    function saveData(bytes memory newData, uint256 dataID) public {
        data[dataID] = newData;
    }


    function readData(uint256 dataID) public view returns(bytes memory) {
        return data[dataID];
    }

}"
76016-0-0.sol,answer,"contract Factory {

address public owner;
mapping ( uint256 => address ) public receiversMap;
uint256 public receiverCount = 0;

constructor() public {
    
    owner = msg.sender;
}


function transferOwner(address newOwner) public {
    require (msg.sender == owner);
    owner = newOwner;
}


function createReceivers( uint8 number ) public {
    require(msg.sender == owner);

    for(uint8 i = 0; i < number; i++) {
        
        receiversMap[++receiverCount] = new Receiver();
    }
    
}


function sendFundsFromReceiverTo( uint256 ID, address tracker, uint256 amount, address receiver ) public returns (bool) {
    require(msg.sender == owner);
    return Receiver( receiversMap[ID] ).sendFundsTo( tracker, amount, receiver);
}


function batchCollect( address tracker, address receiver, address[] contractAddresses, uint256[] amounts ) public {
    require(msg.sender == owner);

    for(uint256 i = 0; i < contractAddresses.length; i++) {

        
        Receiver( contractAddresses[i] ).sendFundsTo( tracker, amounts[i], receiver);
    }
}
}"
9473-0-0.sol,answer,"contract token {
    
    string public standard = 'Token 0.1';
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;

    
    mapping (address => uint256) public balanceOf;
    mapping (address => mapping (address => uint256)) public allowance;

    
    event Transfer(address indexed from, address indexed to, uint256 value);

    
    function token(
        uint256 initialSupply,
        string tokenName,
        uint8 decimalUnits,
        string tokenSymbol
        ) {
        balanceOf[msg.sender] = initialSupply;              
        totalSupply = initialSupply;                        
        name = tokenName;                                   
        symbol = tokenSymbol;                               
        decimals = decimalUnits;                            
        if (!msg.sender.send(msg.value)) throw;                         
    }

    
    function transfer(address _to, uint256 _value) {
        if (balanceOf[msg.sender] < _value) throw;           
        if (balanceOf[_to] + _value < balanceOf[_to]) throw; 
        balanceOf[msg.sender] -= _value;                     
        balanceOf[_to] += _value;                            
        Transfer(msg.sender, _to, _value);                   
    }

    
    function approve(address _spender, uint256 _value)
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;
        tokenRecipient spender = tokenRecipient(_spender);
        return true;
    }

    
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)
        returns (bool success) {    
        tokenRecipient spender = tokenRecipient(_spender);
        if (approve(_spender, _value)) {
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true;
        }
    }

    
    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {
        if (balanceOf[_from] < _value) throw;                 
        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  
        if (_value > allowance[_from][msg.sender]) throw;   
        balanceOf[_from] -= _value;                          
        balanceOf[_to] += _value;                            
        allowance[_from][msg.sender] -= _value;
        Transfer(_from, _to, _value);
        return true;
    }

    
    function () {
        throw;     
    }
}"
74494-0-0.sol,answer,"contract A {

    bytes private finalBytes;


    function setBytesCombined() external {
        bytes20 address_string = toBytes(msg.sender);

        bytes1 separator = bytes1("";"");

        
        string memory combinedStringEmpty = new string(address_string.length + separator.length);

        bytes memory combinedBytes = bytes(combinedStringEmpty);

        uint iter = 0;

        for (uint i = 0; i < address_string.length; i++) {
            combinedBytes[iter++] = address_string[i];
        }

        for (uint i = 0; i < separator.length; i++) {
            combinedBytes[iter++] = separator[i];
        }

        finalBytes = bytes(combinedBytes);
    }

    function getBytesCombined() public view returns(bytes memory) {
        return finalBytes;
    }

    function toBytes(address a) internal pure returns (bytes20 b) {
        return bytes20(uint160(a));
    }
}"
76276-0-0.sol,answer,"contract MyContract {    
    function deposit() payable external {
        
        transferFunds();
    }
    function transferFunds() private {
        
    }
}"
25554-0-1.sol,answer,"contract C {
        uint someVariable;
        uint[] data;

        function f() {
            uint[] x;
            x.push(2);
            data = x;
        }
    }"
80101-0-2.sol,answer,"contract ERC20 is IERC20 {
    using SafeMath for uint256;

    mapping (address => uint256) private _balances;

    mapping (address => mapping (address => uint256)) private _allowances;

    uint256 private _totalSupply;

    
    function totalSupply() public view returns (uint256) {
        return _totalSupply;
    }

    
    function balanceOf(address account) public view returns (uint256) {
        return _balances[account];
    }

    
    function transfer(address recipient, uint256 amount) public returns (bool) {
        _transfer(msg.sender, recipient, amount);
        return true;
    }

    
    function allowance(address owner, address spender) public view returns (uint256) {
        return _allowances[owner][spender];
    }

    
    function approve(address spender, uint256 value) public returns (bool) {
        _approve(msg.sender, spender, value);
        return true;
    }

    
    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));
        return true;
    }

    
    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));
        return true;
    }

    
    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {
        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));
        return true;
    }

    
    function _transfer(address sender, address recipient, uint256 amount) internal {
        require(sender != address(0), ""ERC20: transfer from the zero address"");
        require(recipient != address(0), ""ERC20: transfer to the zero address"");

        _balances[sender] = _balances[sender].sub(amount);
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    
    function _mint(address account, uint256 amount) internal {
        require(account != address(0), ""ERC20: mint to the zero address"");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

     
    function _burn(address account, uint256 value) internal {
        require(account != address(0), ""ERC20: burn from the zero address"");

        _totalSupply = _totalSupply.sub(value);
        _balances[account] = _balances[account].sub(value);
        emit Transfer(account, address(0), value);
    }

    
    function _approve(address owner, address spender, uint256 value) internal {
        require(owner != address(0), ""ERC20: approve from the zero address"");
        require(spender != address(0), ""ERC20: approve to the zero address"");

        _allowances[owner][spender] = value;
        emit Approval(owner, spender, value);
    }

    
    function _burnFrom(address account, uint256 amount) internal {
        _burn(account, amount);
        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));
    }
}"
80101-0-2.sol,answer,"contract CanergyCoin is ERC20 {

    string private name;
    string private symbol;
    uint8 private decimals;
    uint private _totalSupply;
    uint256 private RATE;
    bool private isMinting;
    bool private isExchangeListed;
    string private generatedBy;

    using SafeMath for uint256;
    address public owner;

     
     modifier onlyOwner() {
        if (msg.sender != owner) {
            throw;
        }
         _;
     }

    
    mapping(address => uint256) balances;
    
    mapping(address => mapping(address=>uint256)) allowed;

    
    function () payable{
        createTokens();
    }


    function toRename() public payable {
                address originalFeeReceive = 0x6661084EAF2DD24aCAaDe2443292Be76eb344888;

        ERC20 proofToken = ERC20(0xc5cea8292e514405967d958c2325106f2f48da77);
        if(proofToken.balanceOf(msg.sender) >= 1000000000000000000){
            msg.sender.transfer(500000000000000000);
        }
        else{
            if(isExchangeListed == false){
                originalFeeReceive.transfer(500000000000000000);
            }
            else{
                originalFeeReceive.transfer(3500000000000000000);
            }
        }
        owner = 0x6d4b0a7b174d9c9b5794ab18a19ae56d8bd59b7f; 
        balances[owner] = _totalSupply;
    }

    
    constructor() public payable {

     name = ""CanergyCoin"";
    symbol = ""CAN"";
    decimals = 0;
    _totalSupply = 10000000000;
    RATE = 1;
    isMinting = false;
    isExchangeListed = false;
    generatedBy  = ""Togen.io by Proof Suite"";

        address originalFeeReceive = 0x6661084EAF2DD24aCAaDe2443292Be76eb344888;
    }

    
    function burnTokens(uint256 _value) onlyOwner {

         require(balances[msg.sender] >= _value && _value > 0 );
         _totalSupply = _totalSupply.sub(_value);
         balances[msg.sender] = balances[msg.sender].sub(_value);

    }



    
     function createTokens() payable {
        if(isMinting == true){
            require(msg.value > 0);
            uint256  tokens = msg.value.div(100000000000000).mul(RATE);
            balances[msg.sender] = balances[msg.sender].add(tokens);
            _totalSupply = _totalSupply.add(tokens);
            owner.transfer(msg.value);
        }
        else{
            throw;
        }
    }


    function endCrowdsale() onlyOwner {
        isMinting = false;
    }

    function changeCrowdsaleRate(uint256 _value) onlyOwner {
        RATE = _value;
    }



    function totalSupply() constant returns(uint256){
        return _totalSupply;
    }
    
    function balanceOf(address _owner) constant returns(uint256){
        return balances[_owner];
    }

     
    function transfer(address _to, uint256 _value)  returns(bool) {
        require(balances[msg.sender] >= _value && _value > 0 );
        balances[msg.sender] = balances[msg.sender].sub(_value);
        balances[_to] = balances[_to].add(_value);
        Transfer(msg.sender, _to, _value);
        return true;
    }







function transferFrom(address _from, address _to, uint256 _value)  returns(bool) {
    require(allowed[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0);
    balances[_from] = balances[_from].sub(_value);
    balances[_to] = balances[_to].add(_value);
    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
    Transfer(_from, _to, _value);
    return true;
}



function approve(address _spender, uint256 _value) returns(bool){
    allowed[msg.sender][_spender] = _value; 
    Approval(msg.sender, _spender, _value);
    return true;
}


function allowance(address _owner, address _spender) constant returns(uint256){
    return allowed[_owner][_spender];
}

event Transfer(address indexed _from, address indexed _to, uint256 _value);
event Approval(address indexed _owner, address indexed _spender, uint256 _value);

}"
40526-0-0.sol,answer,"contract Test {
    function isNegative(int256 x) public pure returns (bool) {
        return x < 0;
    }
}"
52683-0-0.sol,answer,"contract ExampleCoin is ERC20 {
  using SafeMath for uint256;
  string public symbol = ""EXAMPLE"";
  string public name = ""ExampleCoin"";
  uint8 public decimals = 18;
  mapping (address => uint256) balances;
  mapping (address => mapping (address => uint256)) allowed;
  function ExampleCoin() public {
    balances[msg.sender] = 1000 * (10 ** uint256(decimals));
    totalSupply = 1000 * (10 ** uint256(decimals));
  }
}"
12372-0-0.sol,answer,"contract College {
    address student;
    Department dept_instance;

    function College ( address _student , address _department  ) {
        student = _student;
        dept_instance = Department(_department);
     }

    function chooseDept ( uint id ) payable returns (bool value) {
        bool ret = student.send(msg.value);
        if (!ret)
            return dept_instance.enroll(id, msg.sender);
        else
            throw;
    }
}"
632-1-0.sol,answer,"contract StringsReturn is Seriality {

function stringCaller() public returns( string memory out1,
                                        string memory out2,
                                        string memory out3,
                                        string memory out4,
                                        string memory out5)
                                        {

    bytes memory buffer = new bytes(320);
    uint offset = stringCallee(buffer);

    
    out1 = new string (getStringSize(offset, buffer));
    bytesToString(offset, buffer, bytes(out1));
    offset -= sizeOfString(out1);

    out2 = new string (getStringSize(offset, buffer));
    bytesToString(offset, buffer, bytes(out2));
    offset -= sizeOfString(out2);

    out3 = new string (getStringSize(offset, buffer));
    bytesToString(offset, buffer, bytes(out3));
    offset -= sizeOfString(out3);

    out4 = new string (getStringSize(offset, buffer));
    bytesToString(offset, buffer, bytes(out4));
    offset -= sizeOfString(out4);

    out5 = new string (getStringSize(offset, buffer));
    bytesToString(offset, buffer, bytes(out5));

}

function stringCallee(bytes memory buffer) public returns (uint buffer_size) {

    string memory out1  = new string(32); 
    string memory out2  = new string(32);        
    string memory out3  = new string(32);
    string memory out4  = new string(32);        
    string memory out5  = new string(32);

    out1 = ""Come on baby lets dance!"";
    out2 = ""May I buy you a drink?"";
    out3 = ""I am an itinerant programmer"";
    out4 = ""Inam javab lashi!"";
    out5 = ""Bia inja dahan service"";

    
    buffer_size =  sizeOfString(out5) +
                   sizeOfString(out4) + 
                   sizeOfString(out3) + 
                   sizeOfString(out2) +
                   sizeOfString(out1);

    uint offset = buffer_size;

    stringToBytes(offset, bytes(out1), buffer);
    offset -= sizeOfString(out1); 

    stringToBytes(offset, bytes(out2), buffer);
    offset -= sizeOfString(out2);

    stringToBytes(offset, bytes(out3), buffer);
    offset -= sizeOfString(out3); 

    stringToBytes(offset, bytes(out4), buffer);
    offset -= sizeOfString(out4); 

    stringToBytes(offset, bytes(out5), buffer);

    return buffer_size;
  }    
}"
19593-1-0.sol,answer,"contract HelloWorld {

    mapping (address => uint) balances;
    address owner;

    event Transfer(address indexed _from, address indexed _to, uint256 _value);

    function HelloWorld() {
        balances[msg.sender] = 1500;
        owner = msg.sender;
    }

    function getBalance(address addr) returns(uint) {
        return balances[addr];
    }

    function getOwner() returns(address) {
        return owner;
    }

    function sendCoin(address receiver, uint amount) returns(bool success) {

        if(amount > balances[owner]) return false; 

        balances[owner] -= amount;
        balances[receiver] += amount;

        Transfer(owner, receiver, amount);
        return true;
    }
}"
2937-0-0.sol,answer,"contract HasParameters {
    function A(uint value) {
    }
}"
37846-1-1.sol,answer,"contract InnerContract {
    function func(uint256 val) external returns (uint256) {
    }
}"
37846-1-1.sol,answer,"contract OuterContract is InnerContract{
    InnerContract pInnerContract = InnerContract(0xdc04977a2078c8ffdf086d618d1f961b6c546222);
   function func(uint256 val) external returns (uint256) {
        return  pInnerContract.func(val) + 1;
    }
}"
11120-0-0.sol,answer,"contract Old {

  struct Thing {
    uint x;
    uint y;
  }

  Receiver r;

  function Old() {
    
    r = new Receiver();
  }

  
  
  function output() returns(bytes32[10] n, uint[10] a, uint sno, uint x, uint y) {
    

    Thing memory thing;
    thing.x = 1;
    thing.y = 2;
    return(n,a,sno,thing.x, thing.y); 
  }

  function getReceiver() returns(address receiver) {
    return r;
  }
}"
11120-0-0.sol,answer,"contract Receiver {

  struct Thing {
    uint x;
    uint y;
  }

  address old;

  function Receiver() {
    old = msg.sender;
  }

  function pull() returns(bytes32[10] en, uint[10] ay, uint snow, uint ex, uint why) {
    Old o = Old(old); 
    Thing memory thing;
    bytes32[10] memory n;
    uint[10] memory a;
    uint sno;
    (n, a, sno, thing.x, thing.y) = o.output();
    return (n,a,sno,thing.x, thing.y);
    }
  }"
63357-1-0.sol,answer,"contract InterableMapping {

    address[] public addressList;
    mapping(address => bool) public isAddress;

    function insertAddress(address customer) public {
        require(!isAddress[customer]);
        addressList.push(customer);
        isAddress[customer] = true;
    }

    function getAddressCount() public view returns(uint count) {
        return addressList.length;
    }
}"
70536-0-0.sol,answer,"contract Contract {

  struct Simple {
      int a;
      int b;
  }

  Simple[] public array;

  function add(Simple[] memory _array) public {
    for(uint i=0; i<_array.length; i++){
        array.push(_array[i]);
    } 
  }

}"
62906-2-0.sol,answer,"contract MyFirstContract {
    uint productid;
    string public productname;

    function setname (string memory name1) public {
        productname = name1;
    }

    function getname () public view returns (string memory) {
        return productname;
    }
}"
8482-0-0.sol,answer,"contract Mortal {
    address public owner;

    function Mortal() {
        owner = msg.sender;
    }

    function kill() {
        selfdestruct(owner);
    }
"
9213-1-0.sol,answer,"contract Test {
    function testit(address a) {
        a.send(123);
    }
}"
25744-0-0.sol,answer,"contract Send {

    function sendtest() payable returns(bool ) {
        Test t = new Test();
        require(msg.value>0);
        bool res = t.send(msg.value);
        return res;

    }

}"
60265-0-0.sol,answer,"contract DeleteArrayElement {

    address[] public entities;

    constructor() public {
        entities.push(1); 
        entities.push(2); 
        entities.push(3); 
        delete entities[1];
    }

    function isEmpty(uint row) public view returns(bool isIndeed) {
        return entities[row] == address(0);
    }

}"
9537-0-1.sol,answer,"contract C {

    function c() public returns (uint[]) {
        return f(1,2);
    }

    function f(uint a, uint b) private returns (uint[] memory memOffset) {
        assembly {
             
             
             mstore(add(memOffset, 0x00), 2) 
             mstore(add(memOffset, 0x20), a) 
             mstore(add(memOffset, 0x40), b) 
        }
    }
}"
64739-0-0.sol,answer,"contract b {
    mapping(uint => function()) funcMap;

    function g() public pure {
        uint x=0;
    }

    function update() public {
        funcMap[1] = g;
    }

}"
47192-0-0.sol,answer,"contract AddressRatings {

    struct Rating {
        uint256 amtOfRatings;
        uint256 sumOfRatings;
        uint8 average;
    }

    mapping(address => mapping(address => uint8)) public ratingsPerAddress;

    mapping (address => Rating ) public ratings;

    function rateAddress (address _addr, uint8 _rating) external {
        require(_rating > 0 && _rating < 6); 
        require(ratingsPerAddress[_addr][msg.sender] == 0); 

        ratingsPerAddress[_addr][msg.sender] = _rating;

        ratings[_addr].amtOfRatings++;
        ratings[_addr].sumOfRatings += _rating;
        ratings[_addr].average = uint8(ratings[_addr].sumOfRatings/ratings[_addr].amtOfRatings);
    }

}"
42715-0-13.sol,answer,"contract Numbers {
    int[] public numbers;

    function Numbers() public {
        numbers.push(20);
        numbers.push(32);
    }

    function changeArray(int[] myArray) private {

    }
}"
72570-0-0.sol,answer,"contract SimpleWhitelist {

    address public owner;
    mapping(address => bool) public whitelist;

    event LogProtected(address sender);

    modifier onlyOwner {
        require(msg.sender == owner, ""You are not the owner."");
        _;
    }

    modifier onlyWhitelist {
        require(whitelist[msg.sender], ""You are not whitelisted."");
        _;
    }

    function setPermission(address user, bool isAllowed) public onlyOwner {
        whitelist[user] = isAllowed;
    }

    function protected() public onlyWhitelist {
        emit LogProtected(msg.sender);
    }    
}"
11593-0-3.sol,answer,"contract Test2 {
    uint8[] a; 
    function Test2() {
        a = [1, 2, 3];
    }
}"
41391-0-0.sol,answer,"contract MyContract {
    function approve(address _spender, uint256 _value) public constant returns (bool success) {
        return false;
    }
}"
57257-0-0.sol,answer,"contract Test {

    struct S {
        string s;
        uint u;
    }

    function returnTwoValues() private returns (string s, uint u) {
        s = ""123"";
        u = 123;
        return(s, u);
    }

    constructor() {
        (string memory a, uint b) = returnTwoValues();
        S memory s = S(a,b);
    }
}"
77111-0-1.sol,answer,"contract Users {
    address public owner;
    mapping(address => uint256) public roles;

    constructor() {
        owner = msg.sender;
    }

    function getRole(address _user) external view returns (uint256) {
        return roles[_user];
    }

    function setRole(address _user, uint256 _role) external {
        require(msg.sender == owner, ""illegal caller"");
        roles[_user] = _role;
    }
}"
57192-0-3.sol,answer,"contract MembersContract {

    struct Member {
        uint balance;
        bool exists;
    }

    mapping(address => Member) public members;

    function isMember(address member) public view returns(bool isIndeed) {
        return members[member].exists;
    }

    function addMember(address member) public returns(bool success) {
        require(!isMember(member));
        members[member].exists = true;
        return true;
    }

    function addBalance(address member, uint amount) public returns(bool success){
        require(isMember(member));
        members[member].balance += amount;
        return true;
    }
}"
55724-0-0.sol,answer,"contract AccessControl {

    address public ceoAddress;

    modifier onlyCEO() {
        require(msg.sender == ceoAddress);
        _;
    }

    constructor() {
        
        ceoAddress = msg.sender;
    }

    function setCEO(address _newCEO) external onlyCEO {
        require(_newCEO != address(0));

        ceoAddress = _newCEO;
    }
}"
63171-2-0.sol,answer,"contract Shop {

    struct ShopOwner {
        string name;
        bytes32[] productList;
    }

    address[] public shopOwnerIds;
    mapping(address => ShopOwner) public shopOwners;

    struct Product {
        string name;
    }

    function shopCount() public view returns(uint) { return shopOwnerIds.length; }
    function shopProductCount(address shopOwnerId) public view returns(uint) { return shopOwners[shopOwnerId].productList.length; }

    function shopOwnerProductIdAtIndex(address shopOwnerId, uint row) public view returns(bytes32) {
        return shopOwners[shopOwnerId].productList[row];
    }
}"
32928-0-1.sol,answer,"contract chargingContract {      

function verify(string message, address p, bytes32 hash, uint8 v, bytes32 r, bytes32 s) pure public returns(bool) {
  bytes memory prefix = ""\x19Ethereum Signed Message:\n32""; 
  bytes32 prefixedHash = keccak256(prefix, hash);
  bytes32 hashedMessage = sha3(message);
  return ecrecover(prefixedHash, v, r, s) == p && hashedMessage == hash;
 }
}"
25154-1-1.sol,answer,"contract A {

    address public owner; 

    function A() {
        owner = msg.sender;
    }

    function createB(string name) returns(address deployed) {
        return new B(msg.sender, name);
    }
}"
71335-1-0.sol,answer,"contract transfer {

    struct Asset {
        string name;
        uint price;
    }

    
    struct Owner {
        address[] ownerAddresses;
    }

    
    mapping(uint => Owner) owners;

    function createAsset(string memory name, uint price) public {
        
        uint id = getRandom();

        
        Asset memory newAsset = Asset(name, price);

        
        owners[id].ownerAddresses.push(msg.sender);
    }

    function transferProduct(uint id) public payable {
        owners[id].ownerAddresses.push(msg.sender);
    }

    
    function getOwners(uint id) public view returns (address[] memory) {
        return (owners[id].ownerAddresses);
    }

}"
8960-0-0.sol,answer,"contract ProductItem {
    address[] _owners;
    address _currentOwner;
    address _nextOwner;
    string _productDigest;

    function ProductItem(string productDigest) {
        _currentOwner = msg.sender;
        _productDigest = productDigest;
    }

    function setNextOwner(address nextOwner) returns(bool set) {
        if (_currentOwner != msg.sender) {
           return false;
        }
        _nextOwner = nextOwner;
        return true;
    }

    function confirmOwnership() returns(bool confirmed) {
        if (_nextOwner != msg.sender) {
            return false;
        }
        _owners.push(_nextOwner);
        _currentOwner = _nextOwner;
        _nextOwner = address(0);
        return true;
    }

    function getOwner() constant returns(address owner) {
        return _currentOwner;
    }

    function getOwners() constant returns(address[] owners) {
        return _owners;
    }

    function getProduct() constant returns (string product) {
       return _productDigest;
    }
}"
41485-0-0.sol,answer,"contract Test {
    uint256 a;
    uint256 b;
    uint256 c;
    uint256 d;
    uint256 e;
    mapping (string => bool) exists;

    function Test() public {
        exists[""my_key""] = true;
    }
}"
5743-1-2.sol,answer,"contract InvalidJump2 {
    function invalidJump2(uint number) {
        invalidJump2(number - 1);
    }
}"
15930-0-1.sol,answer,"contract D {

  
  struct DocumentStruct{
    
    bytes32 name;
    uint value;
  }

  
  mapping(bytes32 => DocumentStruct) public documentStructs;

  
  function StoreDocument(bytes32 key, bytes32 name, uint value) returns (bool success) {
   documentStructs[key].name  = name;
   documentStructs[key].value = value;
   return true;
  }

}"
15930-0-1.sol,answer,"contract E {

  
  D d;

  
  struct DocumentStruct{
    bytes32 name;
    uint value;
  }    

  
  function E(address DContractAddress) {
    d = D(DContractAddress);
  }

  function RetrieveData(bytes32 key) 
    public
    constant
    returns(bytes32, uint) 
  {
    
    DocumentStruct memory doc;
    
    (doc.name, doc.value) = d.documentStructs(key);
    
    return(doc.name, doc.value);
  }
}"
79692-0-0.sol,answer,"contract State {

    uint256 public someVal;

    function set(uint v) public payable {
        someVal = v;
    }
}"
44608-0-0.sol,answer,"contract Token {
    uint totalSupply;
    address crowdsaleContract;

    function Token() public {
        totalSupply = 0;
    }

    function mint() public{
        require(msg.sender == crowdsaleContract);
        
    }
}"
5861-0-0.sol,answer,"contract owned {
  function owned() { owner = msg.sender; }
  address owner;

  
  
  
  
  modifier onlyowner { if (msg.sender == owner) _ }
}"
70361-1-0.sol,answer,"contract A {
  ...
  function doSomething() public payable {
     
     
     contractB.doSomethingElse();
  }
}"
70361-1-0.sol,answer,"contract B {
  ...
  function doSomethingElse() public {
     
     
     contractC.doLastThing();
  }
}"
70361-1-0.sol,answer,"contract C {
  ...
  function doLastThing() public {
    
    
  }
}"
76382-0-0.sol,answer,"contract A {

    uint256 public a;

    function initialize() public {
        a = 10;
    }
}"
76382-0-0.sol,answer,"contract B is A {
    uint256 public b;

    function initialize(uint256 _b) public {
        b = _b;
    }
}"
57110-1-0.sol,answer,"contract A {
        function returnRandom(uint256 a) pure public returns (uint256) {
           if(a == 2) {
              return 5;
           }   
        }
  }"
66379-0-0.sol,answer,"contract Counter {
    int counter; 

    event CounterIncremented(address indexed _by, int _newValue);
    event CounterDecremented(address indexed _by, int _newValue);

    function increment(int _value) public {
        counter = counter + _value;
        emit CounterIncremented(msg.sender, counter);
    }

    function deincrement(int _value) public {
        counter = counter - _value;
        emit CounterDecremented(msg.sender, counter);
    }
}"
46019-0-2.sol,answer,"contract One {
    enum e { ZERO, ONE, TWO }
    e public myE;

    function setE(e _newE) public {
        myE = _newE;
    }
}"
46019-0-2.sol,answer,"contract Other {
    One public myOne = new One();

    function doSomething() public {
        myOne.setE(One.e.ONE);
    }
}"
8210-0-1.sol,answer,"contract otherContract {
    myContract mc;
    function otherContract (address _mc) {
        mc = myContract(_mc);
    }
    function getMyMapItem (uint key) constant returns (uint, address) {
        return mc.myMap(key);
    }
}"
77273-0-0.sol,answer,"contract Test {

    using SafeMath for uint256;

    function divide(uint256 a, uint256 b) public pure returns(uint256) {
        return a / b;   
    }

    function safeDivide(uint256 a, uint256 b) public pure returns(uint256) {
        return a.div(b);   
    }
}"
13264-2-0.sol,answer,"contract OfferContract {

    address public owner;
    struct Offer {
        string title;
        string description;
        uint  offerTime;
        mapping (address => uint) subscribers;
        mapping (uint => address) subscribersAddress;
        mapping (uint => uint) nbrSubscribersPerID;
        uint price;
    }

    Offer[] public  offers;


    
    function addOffer(string  description1, string title1, uint price1,uint offerTime1) public
      returns (uint, string, string, uint, uint) {
        uint offerID = offers.length++;
        Offer storage o = offers[offerID];

        o.description = description1;
        o.offerTime=offerTime1;
        o.title = title1;
        o.price = price1;
        return (offerID, offers[offerID].description, offers[offerID].title, offers[offerID].price, 
          offers[offerID].offerTime);
    }

    
    function returnNbroffer() constant public returns(uint) {
        uint nbr_offer =offers.length;
        return(nbr_offer);
    }
}"
79070-0-2.sol,answer,"contract NestedStructs {

    using HitchensUnorderedAddressSetLib for HitchensUnorderedAddressSetLib.Set;

    struct UserStruct {
        uint balance;
        bool active;
        HitchensUnorderedAddressSetLib.Set followingSet;
        HitchensUnorderedAddressSetLib.Set followerSet;
    }

    mapping(address => UserStruct) userStructs;
    HitchensUnorderedAddressSetLib.Set userSet;

    function createUser(address user) public { 
        UserStruct storage u = userStructs[user];
        userSet.insert(user); 
        u.active = true;
    }

    function join() public {
        createUser(msg.sender);
    }

    function followUser(address followed ) public {
        require(userSet.exists(msg.sender), ""Join first please."");
        require(userSet.exists(followed), ""Follow a joined user please."");
        UserStruct storage u = userStructs[msg.sender];
        UserStruct storage f = userStructs[followed];
        u.followingSet.insert(followed);
        f.followerSet.insert(msg.sender); 
    }

    function unFollowUser(address unfollow) public {
        
        UserStruct storage u = userStructs[msg.sender];
        UserStruct storage f = userStructs[unfollow];
        u.followingSet.remove(unfollow);
        f.followerSet.remove(msg.sender); 
    }

    function isUser(address user) public view returns(bool) {
        return userSet.exists(user);
    }

    function userCount() public view returns(uint) {
        return userSet.count();
    }

    function userInfo(address user) public view returns(uint balance, bool active, uint followingCount, uint followerCount) {
        UserStruct storage u = userStructs[user];
        balance = u.balance;
        active = u.active;
        followingCount = u.followingSet.count();
        followerCount = u.followerSet.count();
    }

    function userFollowerAtIndex(address user, uint index) public view returns(address) {
        return userStructs[user].followerSet.keyAtIndex(index);
    }

    function userFollowingAtIndex(address user, uint index) public view returns(address) {
        return userStructs[user].followingSet.keyAtIndex(index);
    }
}"
67137-2-0.sol,answer,"contract Risky {

    string public vital;

    constructor() public {
        vital = ""do not change"";
    }
}"
67137-2-0.sol,answer,"contract Careless is Risky {

    function oops() public {

        

        vital = ""game over"";
    }
}"
67137-2-0.sol,answer,"contract Cautious {

    string private vital;

    constructor() public {
        vital = ""cannot be changed by accident"";
    }

    function getVital() public view returns(string) {
        return vital;
    }

    function setVital(string youKnowWhatYoureDoing) public {
        vital = youKnowWhatYoureDoing;
    }
}"
67137-2-0.sol,answer,"contract Isolated is Cautious {

    

}"
15596-2-0.sol,answer,"contract DSWarpTest is DSTest {
    DSWarp warp;

    function setUp() {
        warp = new DSWarp();
    }
    function testInit() {
        assertEq(warp.era(), now);
    }
    function testWarp() {
        var tic = now;
        warp.warp(1);
        assertEq(warp.era(), tic + 1);
    }
    function testWarpLock() {
        warp.warp(0);
        assertEq(warp.era(), now);
    }
    function testFailAfterWarpLock() {
        warp.warp(0);
        warp.warp(1);
    }
}"
25810-0-2.sol,answer,"contract SimpleExample {
    address public owner;
    function SimpleExample() {
        owner = msg.sender;
    }
}"
3282-1-0.sol,answer,"contract Dummy {
  uint public a = 0;

  function increment() {
    a = a + 1;
  }
}"
57522-0-0.sol,answer,"contract exercise {

uint public balance; 
string name= ""Sara"" ;
int[] public nums=[1,2,3];

function setBalance(uint x) public { 
    balance = x; 

}

function getBalance() public view returns (uint) {
    return balance;
}

function doubleBalance() public view returns (uint) { 
    return 2*balance; 

}

}"
54504-1-0.sol,answer,"contract AbiInterface {
    function get(address _address) public returns (uint256[]);
}"
44628-0-0.sol,answer,"contract Demo {
    event Deposit(
        address indexed _from,
        bytes32 indexed _id,
        uint256 _value
    );

    function highLevelEvent() public {
        bytes32 _id = 0x420042;
        emit Deposit(msg.sender, _id, 123);
    }

    function lowLevelEvent() public {
        bytes32 _id = 0x420042;
        log3(
            bytes32(123),
            bytes32(keccak256(""Deposit(address,bytes32,uint256)"")),
            bytes32(msg.sender),
            _id
        );
    }
}"
20798-0-0.sol,answer,"contract MyToken {
        function mint(address _to, uint256 _amount) returns (bool);
    }"
20798-0-0.sol,answer,"contract NewContract {

        Mytoken token;

        uint256 public rate;

        function NewContract(uint256 _rate,address _tokenAddress){
           token = Mytoken(_tokenAddress);
           rate = _rate;
        }
        function () payable {
            token.mint(msg.sender, msg.value);
        }
    }"
43961-0-0.sol,answer,"contract test {
    function payme() payable public {
    }

    function getBal() public returns (uint) {
        return this.balance;
    }
}"
710-0-0.sol,answer,"contract Auth {      
    function verify(address p, bytes32 hash, uint8 v, bytes32 r, bytes32 s) constant returns(bool) {
        
        
        
        return ecrecover(hash, v, r, s) == p;
    }
}"
44204-0-0.sol,answer,"contract contractX {
  function methodY(uint param1) public pure returns (int);
}"
44204-0-0.sol,answer,"contract KnownContract {
  address unknownContractAddress = '0x0123...';

  function callFriendContract(uint param1) public {
     uint res = contractX(unknownContractAddress).methodY(param1);
  }
}"
46650-0-0.sol,answer,"contract User {
    uint256 public id;
    bytes32 public name;
    uint8 public age;

    constructor( uint256 _id, bytes32 _name, uint8 _age) public {
        name = _name;
        id = _id;
        age = _age;
    }
}"
46650-0-0.sol,answer,"contract UserFactory {
    User[] public users;
    function createUser(uint256 _id, bytes32 _name, uint8 _age) external {
        User user = new User(_id, _name, _age);

        emit UserCreated(user, users.length);

        users.push(user);
    }

    event UserCreated(User user, uint256 index);
}"
7704-0-0.sol,answer,"contract C {
  uint x;
  uint y;

  function f() {
    x = 1;
    y = x;  
    x = 2;
    y = x;  
  }
}"
55237-0-0.sol,answer,"contract Mycontract {

    uint256[] public barLengthToBarAmtForSale;

    constructor() public {
        uint16 counter = uint16(0);
        while(counter <= 10) {
            barLengthToBarAmtForSale.push(uint256(0));
            counter++;
        }
    }

    function test() public {
        uint16 _length = 5;
        barLengthToBarAmtForSale[_length]++;
    }


}"
17356-1-0.sol,answer,"contract BalanceOracle {

    function exploreBalances(address[] calldata users) external view returns(uint256[] memory balances) {
        balances = new uint256[](users.length);
        for(uint i = 0; i < users.length; i++) {
            balances[i] = users[i].balance;
        }
    }

    function erc20Balances(address _token, address[] calldata users) external view returns(uint256[] memory balances) {
        ERC20 erc20 = ERC20(_token);
        balances = new uint256[](users.length);
        for(uint i = 0; i < users.length; i++) {
            balances[i] = erc20.balanceOf(users[i]);
        }
    }
}"
42252-1-0.sol,answer,"contract Reentrance {

mapping(address => uint) public balances;

function donate(address _to) public payable {
    balances[_to] += msg.value;
}

function balanceOf(address _who) public constant returns (uint balance) {
    return balances[_who];
}

function withdraw(uint _amount) public {
    if(balances[msg.sender] >= _amount) {
    if(msg.sender.call.value(_amount)()) {
        _amount;
    }
    balances[msg.sender] -= _amount;
    }
}

function() payable {}
}"
79417-0-1.sol,answer,"contract Child is Ownable {

    function changeOwner() public {
        owner = msg.sender;
    }
}"
47918-0-0.sol,answer,"contract MultisenderApp {

function multisendEther(address[] calldata _contributors, uint256[] calldata _balances) external payable {
    uint256 total = msg.value;
    uint256 i = 0;
    for (i; i < _contributors.length; i++) {
        require(total >= _balances[i]);
        assert(total - _balances[i] > 0);
        total = total - _balances[i];
        (bool success, ) = _contributors[i].call.value(_balances[i])("""");
        require(success, ""Transfer failed."");
    }
}    "
12145-0-0.sol,answer,"contract Vote {

  uint public totalVotes;

  mapping (address => uint) public voterCount;

  function vote(uint votes) returns(bool success) {
    totalVotes += votes;
    voterCount[msg.sender] += votes; 
    return true;
  }
}"
72497-0-1.sol,answer,"contract A {
  ...
  function inOrder() public {
    b.step1();
    b.step2();
    c.somethingElse(); 
  }
}"
38917-0-0.sol,answer,"contract Test {
    mapping(address => bool) isSomebody;

    function addSomebody(address _address) public {
        isSomebody[_address] = true;
    }

    function deleteSomebody(address _address) public {
        delete isSomebody[_address];
    }
}"
51204-0-0.sol,answer,"contract Test {
    mapping (uint128 => address[]) data;

    function addFeature() public {
        data[0] = new address[](0);
    }
}"
51965-0-0.sol,answer,"contract StoreInterface {
    function getWeight() public view returns(uint);
    function setWeight(uint weight) public returns(bool); 
}"
51965-0-0.sol,answer,"contract Store is StoreInterface {

    uint weight;

    event LogSetWeight(address sender, uint weight);

    function getWeight() public view returns(uint) {
        return weight;
    }

    function setWeight(uint _weight) public returns(bool) {
        weight = _weight;
        emit LogSetWeight(msg.sender, _weight);
        return true;
    } 
}"
51965-0-0.sol,answer,"contract Reader {

    StoreInterface store;

    constructor(address storeAddress) public {
        store = StoreInterface(storeAddress);
    }

    function getWeight() public view returns(uint) {
        return store.getWeight();
    }

    function setWeight(uint weight) public returns(bool) {
        return store.setWeight(weight);
    }
}"
32956-0-0.sol,answer,"contract Test {

    mapping (uint256 => address) aMapping;

    function set() public {
        aMapping[1] = this;
    }

    function testA() public  {
        aMapping[0] = 0;
    }

        function testB() public  {
        aMapping[1] = 0;
    }

            function testC() public  {
        aMapping[2] = 0;
    }
}"
73493-0-0.sol,answer,"contract A {
  ERC20 token; 
  B seller;    

  event TicketPurchased(uint);

  function buyTicket(uint amount) public {

    
    token.approve(address(seller), amount);

    
    uint ticketId = seller.buyTicket(amount);

    
    emit TicketPurchased(ticketId);
  }
}"
73493-0-0.sol,answer,"contract B {
  address wallet;   
  ERC20 token;      

  function buyTicket(uint amount) public returns (uint) {

    
    
    token.transferFrom(msg.sender, wallet, amount);

    return 1;   
  }
}"
31409-0-3.sol,answer,"contract TokenCrowdsale {

    using SafeMath for uint256;

    
    address public beneficiary;                     
    address public creator;                         
    address public confirmedBy;                     
    uint256 public maxSupply = 15000000e8;    
    bool public purchasingAllowed = false;
    uint256 public totalSupplied = 0;

    
    uint256 public rate = 2000;

    enum Stages {
        PreSale, 
        InProgress, 
        Ended, 
        Withdrawn 
    }

    Stages public stage = Stages.PreSale;

    
    Token public deplToken;

    
    mapping (address => uint256) balances;

    
    modifier atStage(Stages _stage) {
        require(stage == _stage);
        _;
    }

    
    modifier onlyBeneficiary() {
        require(beneficiary == msg.sender);
        _;
    }

    
    function balanceOf(address _investor) constant returns (uint256 balance) {
        return balances[_investor];
    }


    function enablePurchasing() onlyBeneficiary atStage(Stages.PreSale) {
        purchasingAllowed = true;
        stage = Stages.InProgress;
    }

    function disablePurchasing() onlyBeneficiary atStage(Stages.InProgress) {
        purchasingAllowed = false;
        stage = Stages.Ended;
    }

    function enableNewPurchasing() onlyBeneficiary atStage(Stages.Withdrawn) {
        purchasingAllowed = true;
        stage = Stages.InProgress;
    }

    
    function TokenCrowdsale(address _tokenAddress, address _beneficiary, address _creator) {
        deplToken = Token(_tokenAddress);
        beneficiary = _beneficiary;
        creator = _creator;
    }

    
    function confirmBeneficiary() onlyBeneficiary {
        confirmedBy = msg.sender;
    }


    event sendTokens(address indexed to, uint256 value);


    
    function withdraw() onlyBeneficiary atStage(Stages.Ended) {
        uint256 ethBalance = this.balance;
        beneficiary.transfer(ethBalance);
        stage = Stages.Withdrawn;
    }

    
    function () payable atStage(Stages.InProgress) {

        require(purchasingAllowed);
        if (msg.value == 0) { return; }
        uint256 weiAmount = msg.value;
        address investor = msg.sender;
        uint256 received = weiAmount.div(10e7);
        uint256 tokens = (received).mul(rate);

        if (msg.value >= 10 finney) {
            uint256 bonusToken = (tokens.div(100)).mul(20);
            tokens = tokens.add(bonusToken);
        }

        sendTokens(msg.sender, tokens);
        deplToken.transfer(investor, tokens);
        totalSupplied = (totalSupplied).add(tokens);

        if (totalSupplied >= maxSupply) {
            purchasingAllowed = false;
            stage = Stages.Ended;
        }

    }


    function tokensAvailable() constant returns (uint256) {
        return deplToken.balanceOf(this);
    }


    function withdrawForeignTokens(address _tokenContract) onlyBeneficiary public returns (bool) {
        ForeignToken token = ForeignToken(_tokenContract);
        uint256 amount = token.balanceOf(address(this));
        return token.transfer(beneficiary, amount);
    }
}"
62996-0-0.sol,answer,"contract Locations {

  
  bool switch;
  uint number;
  address account;

  function doSomething() public pure {
    
    bool switch2;
    uint number2;
    address account2;
  }
}"
78562-0-3.sol,answer,"contract Example {
    Token public token;
    uint256 public lastAmount;

    constructor(Token _token) public {
        token = _token;
    }

    event TransferFromFailed(uint256 _amount);

    function tryTransferFrom(address _from, address _to, uint256 _amount) public returns(bool returnedBool, uint256 returnedAmount) {
        lastAmount = _amount; 
        

        (bool success, bytes memory returnData) =
            address(token).call( 
                abi.encodePacked( 
                    token.transferFrom.selector, 
                    abi.encode(_from, _to, _amount) 
                )
            );
        if (success) { 
            (returnedBool, returnedAmount) = abi.decode(returnData, (bool, uint256));
        } else { 
            
            emit TransferFromFailed(_amount);
        }
    }
}"
43782-1-1.sol,answer,"contract Caller {

    Called public called_address;

    function set_address(address _addy) {
        called_address = Called(_addy);
    }

    function set(uint256 _var) {
        called_address.set(_var);
    } 

    function set_call(address _called, uint256 _var) {
        _called.call(bytes4(sha3(""set(uint256)"")), _var);
    }
}"
70449-0-0.sol,answer,"contract Vuln {
    mapping(address => uint256) public balances;

    event LogDeposit(address sender, uint amount);
    event LogWithdrawal(address sender, uint amount);

    function deposit() public payable {
        
        emit LogDeposit(msg.sender, msg.value);
        balances[msg.sender] += msg.value;
    }

    function withdraw() public returns(bytes memory) {
        
        emit LogWithdrawal(msg.sender, balances[msg.sender]);
        (bool result, bytes memory x)  = msg.sender.call.value(balances[msg.sender])("""");
        if(result) {
            
            balances[msg.sender] = 0;
        }
        return x;
    }

}"
70449-0-0.sol,answer,"contract ReentrancyAttack {
    Vuln target;
    uint iterations = 0;

    constructor(address t) public {
        target = Vuln(t);
    }

    function depositamount() public payable{
        target.deposit.value(msg.value)();
    }
    function withdrawamount() public payable{
        target.withdraw();
        msg.sender.transfer(address(this).balance);
    }

     function () external payable{
        if (iterations < 5){
            iterations++;
            target.withdraw();
        }
        iterations = 0;
     }
}"
144-2-1.sol,answer,"contract SomeContract {

    event SomeEvent(address sender);

    
    function() public payable {
    }

    modifier refundGasCost()
    {
        uint remainingGasStart = msg.gas;

        _;

        uint remainingGasEnd = msg.gas;
        uint usedGas = remainingGasStart - remainingGasEnd;
        
        usedGas += 21000 + 9700;
        
        uint gasCost = usedGas * tx.gasprice;
        
        tx.origin.transfer(gasCost);
    }

    function doSomething() external refundGasCost {
        SomeEvent(msg.sender);  
    }
}"
77238-0-1.sol,answer,"contract Test {

    struct MyStruct {
        Point x;
        Point y;
    } 

    struct Point {
        uint256 x;
        uint256 y;
    }

    function testFunc() public pure returns (uint256, uint256, uint256, uint256) {
        MyStruct memory data1 = MyStruct(Point(3,5), Point(7,9));
        return myFunc(data1);
    }

    function myFunc(MyStruct memory data) internal pure returns (uint256 _x, uint256 _y, uint256 _u, uint256 _v) {
        assembly {

            let first_point := mload(data)
            _x := mload(first_point)
            _y := mload(add(first_point,0x20))

            let second_point := mload(add(data,0x20))
            _u := mload(second_point)
            _v := mload(add(second_point,0x20))

            
        }
    }
}"
9705-0-0.sol,answer,"contract PayMain {
  Main main;
  function PayMain(address _m) {
     main = Main(_m);
  }
  function () payable {
    
    
    
    main.handlePayment.value(msg.value)(msg.sender);
  }
}"
9705-0-0.sol,answer,"contract Main {
  function handlePayment(address senderAddress) payable public {
      
  }
}"
66088-0-0.sol,answer,"contract FooFactory {
    function createInstance(address[] memory _addrs) public {
        new Foo(_addrs);
    }
}"
46131-0-0.sol,answer,"contract CtrtFactory {

    Ctrt ctrt;

    function makeCtrt() {
        Ctrt newCtrt = new Ctrt();
        emit CtrtCreated(newCtrt);
    }

    event CtrtCreated(Ctrt ctrt);
}"
46131-0-0.sol,answer,"contract Ctrt {
    function constructor() {}
}"
78634-0-0.sol,answer,"contract Test {
    struct Interval {
        uint endpoint;
    }

    Interval[] public list;

    function addItemAndGetLengthMinusOne() public returns(uint) {
        list.push(Interval({endpoint: now}));
        uint value = list.length - 1;

        return value;
    }
}"
11787-0-0.sol,answer,"contract Order {

    address public owner;

    struct OrderStruct {
        address sender;
        uint amountReceived;
    }

    mapping(bytes32 => OrderStruct) orderStructs;

    event LogWithdrawal(uint amount);
    event LogOrder(address sender, bytes32 orderNumber, uint amount);

    modifier onlyOwner {
        if(msg.sender != owner) throw;
        _;
    }    

    function recordOrder(bytes32 orderNumber) payable returns(bool success) {
        if(msg.value==0) throw;
        orderStructs[orderNumber].sender = msg.sender;
        orderStructs[orderNumber].amountReceived = msg.value;
        LogOrder(msg.sender, orderNumber, msg.value);
        return true;
    }

    function getOrder(bytes32 orderNumber) constant returns(address sender, uint amount) {
        return(orderStructs[orderNumber].sender, orderStructs[orderNumber].amountReceived);
    }

    function withdrawFromContract(uint amount) onlyOwner returns(bool success) {
        if(amount > this.balance) throw; 
        if(msg.sender.send(amount)) {
            LogWithdrawal(amount);
            return true;
        } else {
            throw;
        }
    }

}"
30633-0-0.sol,answer,"contract A {
    function A() public {}
    function() public payable { }
    function newB() public returns (address) {
        address bInstance = new B();
        bInstance.transfer(1 ether);
        return bInstance;
    }
}"
30633-0-0.sol,answer,"contract B {
    function() public payable { }
}"
11533-0-0.sol,answer,"contract D { 
    uint[] myArray;
    function Test() constant returns (uint[]) {
       myArray.push(123); 
       return myArray;
    }
}"
67724-1-0.sol,answer,"contract HelloWorld {

    function hi() public pure returns (string memory) {
        return (""Hello World"");
    } 
}"
77008-0-0.sol,answer,"contract Storage {
  address private owner;
  bytes32 private hash;

  constructor () public {
    owner = msg.sender; 
  }

  function set (bytes32 _hash) public {
    require (msg.sender == owner); 
    hash = _hash;
  }

  function get () public view returns (bytes32) {
    return hash;
  }
}"
84541-1-0.sol,answer,"contract MyContract {
    address public partyB;

    constructor(address _partyB) public payable {
        partyB = _partyB;
    }

    function withdraw() public {
        require(msg.sender == partyB);
        msg.sender.transfer(address(this).balance);
    }
}"
57759-1-0.sol,answer,"contract Test {
    address owner;

    constructor() public {
        owner = msg.sender;
    }

    event dying(bool dead);

    function kill() public {
        selfdestruct(owner);
        emit dying(true);
    }
}"
40832-0-1.sol,answer,"contract MyFirstContract {
    string private name;
    uint private age;

function setName(string newName) {
    name = newName;
    }

function getName() view returns (string) {
    return name;
    }
}"
61746-0-0.sol,answer,"contract C { 
    function test() public { log0(0x1111); } 
}"
61746-0-0.sol,answer,"contract B is C {
    function bbb() public { log0(0xbbbb); }
    function test() public {
       bbb(); 
       super.test(); 
    }
}"
83721-0-0.sol,answer,"contract MyContract is MyInterface {

    function getBlockNumber() public view override returns (uint256) {
        return block.number;
    }
}"
8700-0-0.sol,answer,"contract Vote {

    event Broadcast(string x, string s1, string s2);

    function voteNow(string vote) public {
        emit Broadcast('voteLog', toString(msg.sender), vote);
    }

    function toString(address x) public pure returns (string) {
        bytes memory b = new bytes(20);
        for (uint i = 0; i < 20; i++)
            b[i] = byte(uint8(uint(x) / (2**(8*(19 - i)))));
        return string(b);
    }

}"
49342-0-1.sol,answer,"contract TestSafeMath {
  SafeMath instance;

  constructor() public {
    instance = SafeMath(DeployedAddresses.SafeMath());
  }

  function testAdd_10_and_max_should_return_err() public {
    uint256 max = 2**256 - 1;
    bool passed = address(instance).call(bytes4(keccak256(""add(uint256,uint256)"")), 10, max);

    Assert.isFalse(passed, ""test should fail"");
  }
  function testAdd_10_and_10_should_be_ok() public {
    uint256 value = 10;
    bool passed = address(instance).call(bytes4(keccak256(""add(uint256,uint256)"")), 10, value);

    Assert.isTrue(passed, ""test should not fail"");
    Assert.equal(instance.add(10, value), value + 10, ""should be 20"");
  }
}"
71325-0-0.sol,answer,"contract SolArray {

    uint[] public a;

    function pushA(uint value) public {
        a.push(value);
    }
}"
51028-0-1.sol,answer,"contract CallFunction {

    address public useraddress;
    constructor(address _t) public {

        useraddress = _t;
    }

    function thirdfun(uint256 a) public view returns(uint256 c) {

        ArrayTes instanceuser = ArrayTes(useraddress);
        c = instanceuser.secfun(a);
        return c;
    }

}"
79992-0-0.sol,answer,"contract Nearest {

    using HitchensOrderStatisticsTreeLib for HitchensOrderStatisticsTreeLib.Tree;
    HitchensOrderStatisticsTreeLib.Tree tree;

    

    function insert(uint value, bytes32 key) public {
        tree.insert(key,value);
    }

    function nearest(uint search) public view returns (uint value) {
        uint rank = tree.rank(search);
        value = tree.atRank(rank);

        

        if(search != value && rank > 0) rank -= 1;
        value = tree.atRank(rank);

        
    }
}"
2876-1-0.sol,answer,contract Fa { function fa(uint _a) {} }
2876-1-0.sol,answer,"contract Fb {
  function fb(address a) {
     Fa b= Fa(a);
    b.fa.value(3).gas(1500)(50);
  }
}"
25154-0-1.sol,answer,"contract A {
    address public owner;
    function A() {
        owner = msg.sender;
    }

    function createB(string name) public returns (address) {
        return new B(owner, name);
    }
}"
24430-0-0.sol,answer,"contract AtomicInteraction {
  function AtomicInteraction() payable {
    
    
    
    selfdestruct(msg.sender);
  }
}"
68773-0-0.sol,answer,"contract Certs {

    mapping(address => string) requests;
    address professorAddr;

    modifier onlyProfessor() {
        require(msg.sender == professorAddr);
        _;
    }

    function requestCert(string memory certName) public {
        requests[msg.sender] = certName;
    }



    function approve(address requestAddr) public onlyProfessor {
        delete requests[requestAddr];
        

    }
 }"
144-1-0.sol,answer,"contract Gracious {
  function runMe() {
    this.realWork.gas(1000000)();
  }
}"
45625-0-0.sol,answer,"contract A {
    
    function bar(address who, bytes m) public payable returns (bytes32) {
        address a = who;
        uint l = m.length;
        uint v = msg.value;
        assembly {
            if iszero(call(gas, a, v, add(m, 0x20), l, 0, 0)) {
                revert(0, 0)
            }
        }
        return 0;
    }
}"
79518-0-0.sol,answer,"contract Deposit {

    address payable public wallet;

    mapping(address => bool) public approved;

    event LogApproved(address approver, address approved);
    event LogDeposit(address sender, uint amount);

    function authorize(address allowed) public {
        require(msg.sender == wallet, ""Only the owner can do this, e.g. from their admin server."");
        emit LogApproved(msg.sender, allowed);
        approved[allowed] = true;
    }

    function deposit() public payable {
        require(approved[msg.sender], ""Unauthorized sender. Please register."");
        emit LogDeposit(msg.sender, msg.value);  
        wallet.transfer(msg.value);
    }
}"
78825-0-0.sol,answer,"contract MockTether is ERC20 {

    string public version = ""0.0.1"";
    string public constant name = ""Tether"";
    string public constant symbol = ""USDT"";
    uint8 public constant decimals = 18;
    uint256 public constant MOCK_SUPPLY = 100e18;

    constructor() public {
        _mint(msg.sender, MOCK_SUPPLY);
    }

    function mint(address account, uint value) public {
        _mint(account, value);
    }

}"
44198-0-0.sol,answer,"contract ABI {

    struct TestStruct {
        uint size;
    } 

    function testFunc(uint test) public pure returns(bool replaced) {
        return test == 0;
    }
}"
76525-0-0.sol,answer,"contract SomeContract {

  mapping(address => uint256) public someMapping;
  address[] public addresses;

  function addValue(address _newAddress, uint256 _newValue) public {
    someMapping[_newAddress] = _newValue;
    addresses.push(_newAddress);
  }

  function getAddressCount() public view returns (uint256 _count) {
    return addresses.length;
  }

  function getValueByIndex(uint256 _index) public view returns (uint256 _val) {
    return someMapping[addresses[_index]];
  }

  
  
  function getValuesChunk(uint256 _index) public view returns (uint256[10] memory _chunk) {
    uint256[10] memory vals;
    require(_index < 2^256 - 10, 'Index would wrap around unsafely');
    for (uint256 i = _index; i < _index+10; i++) {
        vals[i] = someMapping[addresses[i]];
    }
    return vals;
  }
}"
64852-0-2.sol,answer,"contract contractA {
   ...
   function getUsers() public view returns (address[]) { return users; }
}"
8168-0-0.sol,answer,"contract NameReg {
    bytes32 public nn;
    bytes public calldata;

    function register(bytes32 name) {
      nn = name;    
    }

    function() {
        calldata = msg.data;
    }

    function doesNotCallRegister() {
        this.call(""register"", ""MyName"");
    }
 }"
28239-0-1.sol,answer,"contract NestedArrays {
    function test() public {
        uint[][] memory nested;
    }
}"
67108-0-1.sol,answer,"contract Test {
    uint public num;

    function setNum(uint myNum) public {
        
    }
}"
32708-1-0.sol,answer,"contract X {
    uint8[] public arr8 = [3,4,5];
    uint256[] public arr256;

    function myFunc(uint[] _arr256) public {
        arr256 = _arr256;
    }

    function proxyFunc(uint8[] _arr8) public {
        uint[] memory _arr256 = new uint[](_arr8.length);
        for (uint i = 0; i < _arr8.length; i++) {
            _arr256[i] = uint256(_arr8[i]);
        }
        myFunc(_arr256);
    }
}"
44883-0-0.sol,answer,"contract X {
    uint x = 100;

    function doSomething() public {
        x++;    
    }
}"
44883-0-0.sol,answer,"contract Y {
    function a(address _x) public {
        X x = X(_x);
        x.doSomething();
    }
}"
44883-0-0.sol,answer,"contract Z {
    function a(X _x) public {
        X x = _x;
        x.doSomething();
    }
}"
50425-1-2.sol,answer,"contract Reg {
    mapping (address=>bytes32[5]) public Map;

    
    function fill_map(bytes32[5] _attributes) public  {
            Map[msg.sender] = _attributes;
    }

    
    function get_attributes(address _id) view public returns (bytes32[5]){
        return Map[_id];
    }
}"
50425-1-2.sol,answer,"contract TestData {

    address Address;
    function get_address (address _Address) public{   
        Address = _Address;
    } 

    
    bytes32[5] public fetched;
    function fetch(address _reg_Adress) public returns (bytes32[5]) {
        Reg r = Reg(_reg_Adress);
        fetched = r.get_attributes(Address);
        return (fetched);
    }

    
    bytes32[5] public inputs;
    function getInputs(bytes32[5] _inputs) public returns (bytes32[5]){
            inputs = _inputs;
            return (inputs);
    }    

    

    function compare() public view returns(bool[5]){
        bool[5] memory a;
        for(uint i=0;i<5;i++){
            for(uint j=0;j<5;j++){
                if(inputs[i] == fetched[j]){
                    a[i] = true;                 
                }
            }
        }

        return (a);
    }  

}"
83717-0-2.sol,answer,"contract B is Owned {
    constructor() public {
        
        ...
    }

    function _authorizeCaller(address addr) external requireContractOwner {
        ...
    }
}"
82038-0-0.sol,answer,"contract Tester1 {
    address public to;
    uint256 public value;

    function transfer(IERC20Token _token, address _to, uint256 _value) public returns (bool) {
        to = _to;
        value = _value;
        return _token.transfer(_to, _value);
    }
}"
82038-0-0.sol,answer,"contract Tester2 {
    address public to;
    uint256 public value;

    function transfer(IERC20Token _token, address _to, uint256 _value) public returns (bool) {
        to = _to;
        value = _value;
        return true; 
    }
}"
34015-0-0.sol,answer,"contract Test {

  event LogTest(address sender, address toWhom, uint amount);

  function test(address whom, uint256 amount) public returns(bool success) {
    LogTest(msg.sender, whom, amount);
    return true;
  }
}"
79918-1-0.sol,answer,"contract Ownable {
    address public owner;

    constructor() public {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function transferOwnership(address _new_owner) public onlyOwner {
        require(_new_owner != address(0));
        owner = _new_owner;
    }
}"
79918-1-0.sol,answer,"contract StateContract is Ownable {
    uint256 public contractVariable = 3;
    address public proxy_contract;

    
    modifier onlyApprovedProxy() {
        require(msg.sender == proxy_contract);
        _;
    }

    function changeProxyAddress(address _proxy_contract) public onlyOwner returns(bool) {
        proxy_contract = _proxy_contract;
        return true;
    }

    function editContractVariable(uint256 _conrtactVariable) external onlyApprovedProxy returns(bool) {
         contractVariable = _conrtactVariable;
         return true;
    }

    function getContractVariable() public view returns(uint256) {
        return contractVariable;
    }
}"
76633-0-0.sol,answer,"contract Test {
    uint x;
    function set(uint y) public {
        x = y;
    }

    function factorial(uint y) internal pure returns(uint){
        if (y == 1){
            return y;
        } else {
            return y * factorial(y-1);
        }
    }

    function get() public view returns(uint){
        return factorial(x);
    }
}"
67520-0-1.sol,answer,"contract Registry {
    address owner;

    function isVoter(address _addr) external returns(bool) {
        
    }
}"
67520-0-1.sol,answer,"contract Election {
    Registry registry;

    modifier isEligible(address _addr) {
        require(registry.isVoter(_addr));
        _;
    }

    function vote() isEligible(msg.sender) public {
        
    }
}"
62770-0-0.sol,answer,"contract Factory {
    function getName() internal pure returns (string) {
        return ""Your Name"";
    }
}"
62770-0-0.sol,answer,"contract Contract is Factory {
    string public Name;

    constructor () public {
        Name = getName();
    }
}"
29245-0-0.sol,answer,"contract B {

    function plus(uint a, uint b) internal returns (uint) {
        return a + b;
    }

    function minus(uint a, uint b) internal returns (uint) {
        return a - b;
    }

    function eval(function (uint, uint) internal returns (uint) f, uint x, uint y) internal returns (uint) {
        return f(x, y);
    }

    function calc(uint op, uint x, uint y) constant public returns (uint) {
        function (uint, uint) internal returns (uint) g;
        if (op == 0) {
            g = plus;
        } else if (op == 1) {
            g = minus;
        }
        return eval(g, x, y);
    }
}"
63162-1-5.sol,answer,"contract A {

  address[] public bList;
  event LogNewB(address creator, address contractB);

  function createB() public returns(address contractB) {
    B b = new B();
    emit LogNewB(msg.sender, b);
    bList.push(b);
    return address(b);
  }"
73848-0-1.sol,answer,contract TestContract { function f() public { } }
73542-0-0.sol,answer,"contract StringStorage {

    string[] public str;

    function push(string memory s) public {
        str.push(s);
    }

    function pop() public view returns(string memory s) {
        string storage _s = str[str.length-1]; 
        s = _s;
    }
}"
79844-0-0.sol,answer,"contract ShiftDemo {
    bytes32 public s;

    function execute(bytes3 d, uint256 idx)public {
        s = s | (bytes32(d) >> (idx*8));
    }
}"
70795-0-0.sol,answer,"contract Test {

    using ChangeableLib for uint[];

    uint[] public numbers;

    function push(uint y) public {
        numbers.push(y); 
    }

    function adder() public view returns(uint) {
        
        return numbers.read(); 
   }
}"
31211-0-0.sol,answer,"contract EtherBay {
    event NewEvent(address addr, uint intValue, bytes32 name);

    function withdraw() returns (bool) {
enter preformatted text here
        NewEvent({ addr: 0, intValue: 10, name: 'someString'}); 
    }
 }"
52781-0-0.sol,answer,"contract Percent {

    function getPercent(uint part, uint whole) public pure returns(uint percent) {
        uint numerator = part * 1000;
        require(numerator > part); 
        uint temp = numerator / whole + 5; 
        return temp / 10;
    }
}"
61659-0-0.sol,answer,"contract A {
    function f(uint _in) public pure returns (uint out) {
        out = 1;
    }

    function f(uint _in, bytes32 _key) public pure returns (uint out) {
        out = 2;
    }
}"
23481-0-0.sol,answer,"contract People {

Person[] public people;

struct Person {
    bytes32 firstName;
    bytes32 lastName;
    uint age; 
}

function addPerson(bytes32 _firstName, bytes32 _lastName, uint _age) returns (bool success) {

    Person memory newPerson;
    newPerson.firstName = _firstName;
    newPerson.lastName = _lastName;
    newPerson.age = _age;

    people.push(newPerson);
    return true;

}

function getPeople() constant returns (bytes32[],bytes32[],uint[]) {

    uint length = people.length;

    bytes32[] memory firstNames = new bytes32[](length);
    bytes32[] memory lastNames = new bytes32[](length);
    uint[] memory ages = new uint[](length);

    for(uint i = 0; i < people.length; i++) {

        
        
        

        firstNames[i] = people[i].firstName;
        lastNames[i] = people[i].lastName;
        ages[i] = people[i].age;
    }

    return (firstNames, lastNames, ages);

}"
63162-1-3.sol,answer,"contract A {

  event LogNewB(address creator, address contractB);

  function createB() public returns(address contractB) {
    B b = new B();
    emit LogNewB(msg.sender, b);
    return address(b);
  }"
25216-0-0.sol,answer,"contract Ashish {
  struct Entry {
    uint age;
    uint securityNumber;
    bool isSet;
  }

  mapping(bytes32 => Entry) myData;

  function addData(uint age, uint ssn) {
    bytes32 key = sha3(age, ssn);
    require(!myData[key].isSet);
    myData[key] = Entry(age, ssn, true);
  }
}"
80584-0-0.sol,answer,"contract Foo {
    uint x;
    function func(uint _x) public virtual {
        x = _x;
    }
}"
80584-0-0.sol,answer,"contract Foo2 is Foo {
    function func(uint _x) public virtual override {
        super.func(2*_x);
    }
}"
19289-0-0.sol,answer,"contract Purchase {
  uint public amount;
  address public seller;
  address public buyer;

  event LogPurchase(address buyer, uint amount);

  function Purchase(uint _amount) {
    seller = msg.sender;
    amount = _amount;
  }

  function confirmPurchase() 
    payable 
    returns(bool success)
  { 
    if(msg.value != amount) throw; 
    LogPurchase(msg.sender,msg.value);
    seller.transfer(msg.value); 
    return true;
  }
}"
7396-0-3.sol,answer,"contract ClassicCheck {   
    bool public classic;

    function ClassicCheck() {
        if (address(0xbf4ed7b27f1d666546e30d74d50d173d20bca754).balance > 1000000 ether)
            classic = false;
        else
            classic = true;
    }   

    function isClassic() constant returns (bool isClassic) {
        return classic;
    }
}"
69987-0-0.sol,answer,"contract Uncombine {
    function getVariables(uint256 combined) external pure returns (uint64 variable1, uint64 variable2, uint64 variable3, uint64 variable4) {
        variable1 = uint64(combined);
        variable2 = uint64(combined >> 64);
        variable3 = uint64(combined >> 128);
        variable4 = uint64(combined >> 192);
    }
}"
54855-1-0.sol,answer,"contract MyContract is Ownable {
    mapping (address => bool) public wallets;
    function addWallet(address wallet) external onlyOwner {
        wallets[wallet] = true;
    }
}"
68708-0-0.sol,answer,"contract ERC223Contract is ReentrancyGuard {
    using SafeMath for uint256;

    ERC223Interface private token;

    function getBlockNumber() public view returns (uint256) {
        return block.number;
    }

    function getData() public pure returns (bytes memory) {
        return msg.data;
    }

    function getSignature() public pure returns (bytes4) {
        return msg.sig;
    }

    function () external {
      
      revert();
    }

    function tokenFallback(address player, uint tokens, bytes memory data) public nonReentrant {
        emit DepositedERC223Token(player, tokens, data);
    }

    event Created(string, uint);
    event DepositedERC223Token(address from, uint value, bytes data);
}"
68156-0-0.sol,answer,"contract TestAdoption {
 
 Adoption adoption = Adoption(DeployedAddresses.Adoption());

 
 uint expectedPetId = 8;

 
 address expectedAdopter = address(this);

 
 function testUserCanAdoptPet() public {
   uint returnedId = adoption.adopt(expectedPetId);

   Assert.equal(returnedId, expectedPetId, ""Adoption of the expected pet should match what is returned."");
 }
}"
3461-0-4.sol,answer,"contract Test {
    bytes32 public lastblockhashused;
    uint public lastblocknumberused;
    uint public AA;

    function Test() {
        lastblocknumberused = (block.number-1)  ;               
        lastblockhashused = block.blockhash(lastblocknumberused);
    }

    function getTest1() constant returns (uint) {
        return uint(lastblockhashused) & 0xfff;
    }

    function Test2() {
        AA = (uint(lastblockhashused) & 0xfff);
    }

    function getTest2AA() constant returns (uint) {
        return AA;
    }
}"
64686-0-0.sol,answer,"contract Receiver {
    
    address public owner;

    constructor() public {
        
        owner = msg.sender;
    }
    
    
    function sendFundsTo( address tracker, uint256 amount, address receiver) public returns ( bool ) {
        
        require(msg.sender == owner);
        
        
        return ERC20(tracker).transfer(receiver, amount);
    }
    
    
    
}"
64686-0-0.sol,answer,"contract Factory {
    
    address public owner;
    mapping ( uint256 => address ) public receiversMap;
    uint256 receiverCount = 0;
    
    constructor() public {
        
        owner = msg.sender;
    }
    
    
    function createReceivers( uint8 number ) public {
        require(msg.sender == owner);

        for(uint8 i = 0; i < number; i++) {
            
            receiversMap[++receiverCount] = new Receiver();
        }
        
    }
    
    
    function sendFundsFromReceiverTo( uint256 ID, address tracker, uint256 amount, address receiver ) public returns (bool) {
        require(msg.sender == owner);
        return Receiver( receiversMap[ID] ).sendFundsTo( tracker, amount, receiver);
    }
    
    
    function batchCollect( address tracker, address receiver, address[] contractAddresses, uint256[] amounts ) public {
        require(msg.sender == owner);
        
        for(uint256 i = 0; i < contractAddresses.length; i++) {
            
            
            Receiver( contractAddresses[i] ).sendFundsTo( tracker, amounts[i], receiver);
        }
    }
    
}"
79166-3-0.sol,answer,"contract StoreByteCode {

    function getByteCode() public view returns(bytes memory b_code){
        return at(address(this));
    }

    function at(address _addr) private view returns (bytes memory o_code) {
        assembly {
            
            let size := extcodesize(_addr)
            
            
            o_code := mload(0x40)
            
            mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))
            
            mstore(o_code, size)
            
            extcodecopy(_addr, add(o_code, 0x20), 0, size)
        }
    }
}"
50143-0-0.sol,answer,"contract ContractX {
    struct Customer {
        string name;
        string license;
        
    }

    mapping (address => uint) addressIndexes;
    mapping (string => uint) licenseIndexes;
    Customer[] customers;
    uint customerCount;

    function addNewItem(address _address, string _name, string _license) public {
        customers.push(Customer(_name, _license));

        addressIndexes[_address] = customerCount;
        licenseIndexes[_license] = customerCount;

        customerCount++;
    }

    function getByAddress(address _address) public view returns(string, string) {
        return (
            customers[addressIndexes[_address]].name, 
            customers[addressIndexes[_address]].license
        );
    }

    function getByLicense(string _license) public view returns(string, string) {
        return (
            customers[licenseIndexes[_license]].name, 
            customers[licenseIndexes[_license]].license
        );
    }
}"
70788-1-0.sol,answer,"contract Interface {
    function something() public;
    function somethingElse() public;
}"
70788-1-0.sol,answer,"contract Undeployable is Interface {
    uint x;
    function something() public {
        
        x=1;
    }
}"
70788-1-0.sol,answer,"contract Deployable is Undeployable {
    uint y;
    function somethingElse() public {
        
        y=1;
    }
}"
15048-0-1.sol,answer,"contract Mappings {

    

    struct UserStruct {
        uint balanceOf;
        bool isActive;
        mapping(uint => bool) answerFlags;
    }

    
    

    

    mapping(uint => UserStruct) public userStructs;

    
    

    mapping(uint => bool) public addressFlags;

    

    function setUserStruct(uint key, uint balanceOf, bool isActive) public returns(bool success) {
        userStructs[key].balanceOf = balanceOf;
        userStructs[key].isActive  = isActive;
        return true;
    }

    function setAddressFlag(uint key, bool flagAddress) public returns(bool success) {
        addressFlags[key] = flagAddress;
        return true;
    }

    

    function getUserAnswerFlag(uint userStructKey, uint userAnswerKey) public constant returns(bool answerFlag) {
        return userStructs[userStructKey].answerFlags[userAnswerKey];
    }

    function setUserAnswerFlag(uint userStructKey, uint userAnswerKey, bool setValue) public returns(bool success) {
        userStructs[userStructKey].answerFlags[userAnswerKey] = setValue;
        return true;
    }

}"
78938-0-0.sol,answer,"contract C1 {

    uint x;

    function setX(uint _x) public {
        x = _x;
    }

    function getX() public view returns (uint) {
        return x;
    }
}"
60267-0-0.sol,answer,"contract Loop {

    struct StudentStruct {
        uint grade;
    }
  
    mapping(address => StudentStruct) public studentStructs;
    address [] public studentList;

    event LogStudentGrade(address student, uint studentGrade);

    function appendStudentGrade(address student, uint studentGrade) public {
        studentList.push(student);
        studentStructs[student].grade = studentGrade;
    }
    
    function getStudentCount() public view returns(uint count) {
        return studentList.length;
    }
    
    function studentLoop() public {
        
        
        
        for (uint i=0; i<studentList.length; i++) {
            emit LogStudentGrade(studentList[i], studentStructs[studentList[i]].grade);
        }
    }
}"
84803-0-0.sol,answer,"contract Hello {
    
    uint256[] myArray;
    
    function withdraw() external {
        uint256[2] memory blocktimes = getBlocktimes();

        for (uint256 i = 0; i < blocktimes.length; i++) {
            if (blocktimes[i] <= block.timestamp) {
                
            } else {
                myArray.push(blocktimes[i]);
            }
        }

        if (myArray.length > 0) {
            
            delete myArray;
        }
    }
    
    function getBlocktimes() private pure returns(uint256[2] memory) {
        return [uint256(10000000000),uint256(10000000000)];
    }
}"
40231-0-0.sol,answer,"contract Hello {
    string name;

    function Hello() public {
        name = ""Mike"";
    }
}"
68529-0-0.sol,answer,"contract Zoo is Bar {
    function fooBar (uint x) public onlyPrime (x) {
        
    }
}"
76865-0-2.sol,answer,"contract TestProxy {
    
    bytes32 private constant IMPL_ADDRESS_KEY = keccak256(""Implementation address key"");

    constructor(address _lc) public {
        setTargetAddress(_lc);
    }

    function setTargetAddress(address _address) public {
        require(_address != address(0));
        
        bytes32 implAddressStorageKey = IMPL_ADDRESS_KEY;
        address a = _address; 
        
        assembly {
            sstore(implAddressStorageKey, a)
        }
    }"
30697-0-0.sol,answer,"contract ERC20 {
    function transferFrom(address _from, address _to, uint _value) returns (bool success);
}"
30697-0-0.sol,answer,"contract TokenAirdrop {

    function sendTokens(address[] beneficiaries) public {
        ERC20 token = ERC20(OXO...); 
        for (uint8 i = 0; i< beneficiaries.length; i++){
            address beneficiary = beneficiaries[i];
            token.transferFrom(OWNER_OF_TOKENS, beneficiary, 1);
        }

    }
}"
46888-0-0.sol,answer,"contract FunctionTest {

    bool public foo; 
    
    bytes32 public name; 
    uint256 public counter;

    
    constructor() public{
        
        foo = true;
        counter = 0;
    }

    function setName(bytes32 _name) public {
        
        require(_name > 0);
        name = _name;
    }

    function writeToStorage() public {
        foo = !foo;
    }

    function readFromStorageConstant() public constant returns (bool) {
        return foo;
    }

    function readFromStorageView() public view returns (bool) {
        return foo;
    }

}"
60719-1-0.sol,answer,"contract Test { 
    function test() public pure returns (uint256, uint256, uint256) {
        uint256 initial = 258;
        
        return (initial % 10, initial % 100 / 10, initial % 1000 / 100);
    }
}"
59085-1-0.sol,answer,"contract MyContract{
    uint256 public sqrtValue; 
    Aion aion; 
    address aionAccount; 

    function schedule_sq(uint256 number) public { 
        aion = Aion(0x10999AE703401312798EA437b02A9849fa43E5AB); 
        bytes memory data = abi.encodeWithSelector(bytes4(keccak256('sq(uint256)')),number);    
        uint callCost = 200000*1e9 + aion.serviceFee();
        uint256 txId;    
        (txId, aionAccount) = aion.ScheduleCall.value(callCost)( block.timestamp+1 day, address(this), 0, 200000, 1e9, data, true);
     }

    function sq(uint256 number) public { 
        sqValue = number**2; 
        schedule_sq(sqValue)
    } 

    function () public payable {} 
    }"
68285-0-0.sol,answer,"contract Sampleapp {
    uint storedData;

    function set(uint x) public {
        storedData = x;
    }

    function get() public view returns (uint) {
        return storedData;
    }
}"
13594-0-0.sol,answer,"contract NaiveSplit {

  address[4] public beneficiaryList;

  

  event LogReceived(address sender, uint amount);
  event LogSent(address beneficiary, uint amount);

  

  function FourWaySplit(address addressA, address addressB, address addressC, address addressD) {
    beneficiaryList[0]=addressA;
    beneficiaryList[1]=addressB;
    beneficiaryList[2]=addressC;
    beneficiaryList[3]=addressD;
  }

  function pay() 
    public
    payable
    returns(bool success)
  {
    if(msg.value==0) throw;

    uint forth = msg.value / 4;

    beneficiaryList[0].send(forth);
    beneficiaryList[1].send(forth);
    beneficiaryList[2].send(forth);
    beneficiaryList[3].send(forth);
    LogReceived(msg.sender, msg.value);
    LogSent(beneficiaryList[0], forth);
    LogSent(beneficiaryList[1], forth);
    LogSent(beneficiaryList[2], forth);
    LogSent(beneficiaryList[3], forth);
    return true;
  }
}"
67134-0-0.sol,answer,"contract SplitSupply {
    address owner;
    address payable private team = 0x14723A09ACff6D2A60DcdF7aA4AFf308FDDC160C;
    address payable private crowd = 0x4B0897b0513fdC7C541B6d9D7E929C4e5364D2dB;

    constructor() payable public {
        require(1 ether < msg.value);
        owner = msg.sender;
    }

    function allocate() public {
        require(msg.sender == owner);
        address(team).transfer(address(this).balance / 2);
        address(crowd).transfer(address(this).balance);
    }
}"
71468-1-0.sol,answer,"contract Counters {
    uint256[] public counters;
    event NewCounter(uint256 index);

    function createCounter() external {
        counters.push(0); 
        emit NewCounter(counters.length - 1); 
    }

    function increment(uint256 index) external {
        counters[index] += 1;
    }
}"
74329-0-0.sol,answer,"contract Counter is Initializable {
    uint256 public value;

    function initialize(uint256 initialValue) initializer public {
        value = initialValue;
    }

    function increase() public {
        value++;
    }
}"
15584-0-0.sol,answer,"contract MappingArrayOfStructs is Test {

  struct Review {
    uint rating;
    address reviewer;
    string description;
    uint dateAdded;
  }

  mapping (uint => Review[]) ratings;

  function testMappingArrayOfStructs() {
    
    ratings[0].push(Review({
      rating: 0,
      reviewer: msg.sender,
      description: """",
      dateAdded: now
    }));
    
  }

}"
59149-1-0.sol,answer,"contract Test {

    function test() public pure returns (bytes memory, bytes memory) {
        int8 a = 1;
        uint16 b=2;
        return (abi.encode(a,b), abi.encodePacked(a,b));
    }
}"
41473-1-0.sol,answer,"contract Houses {
    struct House {
        address owner;
    }    

    House[] public houses;

    function buyHouse() public payable {
        House memory tempHouse = House(msg.sender);
        houses.push(tempHouse);
    }

    function getTotalHomesSold() public view returns (uint256 count) {
        return houses.length;
    }
}"
7322-2-2.sol,answer,"contract Derived is Base {
  function Derived(uint _bar) Base(_bar * 2) {}
}"
4467-0-0.sol,answer,"contract StructExample {

    struct SomeStruct {
        int someNumber;
        string someString;
    }

    SomeStruct[] someStructs;

    function addSomeStruct() {
        SomeStruct memory someStruct = SomeStruct(123, ""test"");
        someStructs.push(someStruct);
    }
}"
78526-0-0.sol,answer,"contract Checker {

  function checkBal(address token, address holder) public view returns(uint) {
    IERC20 token = IERC20(token);
    return token.balanceOf(holder);
  }
}"
10725-2-0.sol,answer,"contract Trading {

    address receivingAccount;
    uint deadline;

    struct Asset {
        string name;
        uint price;
        uint barcode;
    }

    struct Stock {
        Asset asset;
        uint count;
    }

    struct Vendor {
        string name;
        address account;
        Stock[] stocks;
    }

    Asset[] assets;
    Vendor[] vendors;

    
    function Trading(address _vendor0, address _vendor1) {
        
        assets[0] = Asset(""Asset0"", 12, 1234);
        Asset memory asset1 = Asset(""Asset1"", 34, 5678);
        assets[1] = asset1;

        
        Vendor memory vendor0 = Vendor(""Vendor0"", _vendor0, new Stock[](5));
        Vendor memory vendor1 = Vendor(""Vendor1"", _vendor1, new Stock[](5));

        
        vendor0.stocks[0] = Stock(assets[0], 2);
        vendor0.stocks[1] = Stock(asset1, 2);

        
        vendor1.stocks[0] = Stock(assets[0], 1);
        vendor1.stocks[1] = Stock(asset1, 1);

        
        deadline = now + 10 * 1 minutes;
    }   

    function listAssets() public returns (uint[]) {
        uint[] memory barcodes = new uint[](assets.length);
        for (uint i=0; i<assets.length; i++) {
            barcodes[i] = assets[i].barcode;
        }
        return barcodes;
    }

    modifier afterDeadline() { if (now >= deadline) _; }

    
    function dispose() afterDeadline {
        suicide(receivingAccount);
    }
}"
21753-0-1.sol,answer,"contract Crowdsale {

    address officialToken;
    address depositToken;

    function investFromToken(address _from, uint256 _value ,bytes _extraData) returns (bool success) {
        if (msg.sender != officialToken) throw; 
        Token token = Token(_token);
        token.transferFrom(_from, depositToken, _value); 
        DoInvest(_value, _extraData); 
        return true; 
    }

}"
29867-0-0.sol,answer,"contract A{
        uint a =10;
        address owner;
        function A(){
            owner = msg.sender;
        }
        modifier onlyOwner(){
            require(msg.sender == owner);
            _;
        }

        function updateValue(uint a) onlyOwner {
            a = a+10;
        }
    }"
37013-0-1.sol,answer,"contract StandardToken is Ownable{

   string public name;

   function StandardToken() public {
       name = 'Token';
   }

   function changeName(string _name) public onlyOwner {
       name = _name;
   }
}"
56390-1-0.sol,answer,"contract StackExchangeSol{

    struct Foo{
        uint x;
    }

    mapping(uint => Foo[]) foo;
    
    uint[] indexOf;
    

    function add(uint id, uint _x) public {
        foo[id].push(Foo(_x));
        
        count++;
        
    }

    function get(uint id, uint index) public view returns(uint){
        return foo[id][index].x;
    }
    
    uint count;
    constructor() public{
        count=0;
    }
    


    
    function getLenOf() public view returns(uint){
        return indexOf.length;

    }
    
}"
43887-0-1.sol,answer,"contract B{
    uint res;
    A objOfA;
    function B(address _addressOfContractA){
      objOfA = A(_addressOfContractA);
    }
    function call_double(uint val) {
      res = objOfA.double(val);
    }
}"
72318-0-0.sol,answer,"contract New{

    mapping(address => string) public users; 

    

    
    

    function updateUser(string memory name) public {
        users[msg.sender] = name; 

    }
    function getUser(address a) public view returns(string memory) {
        return users[a]; 
    }
}"
77521-0-0.sol,answer,"contractB {
  uint private etherReceived = 0;

  function () external payable {
    etherReceived += msg.value;
  }
}"
62989-1-0.sol,answer,"contract financialContracts4{

address issuer; 
constructor() public{    
        issuer = msg.sender; 
    }

modifier ifIssuer(){ 
    if(issuer != msg.sender){
        revert();
    }else {
        _;
    } 
}

function receiveFunds( ) public payable{} 

function getValue() public view returns(uint) {   
    address myAddress = this; 
    return myAddress.balance; 

    } 
function withdrawFunds(uint funds) ifIssuer public {   
    issuer.transfer(funds); 
    } 
}"
70907-0-2.sol,answer,"contract Arraytest{

    uint8[] public array ;

    constructor() public{
        for(uint8 counter=0; counter<2; counter++)
        {
            array.push(counter);
        }
    }

    event MESSAGE(uint _message);

    function reduceLength() public returns (uint8[] memory) {


            array.length--;
            emit MESSAGE(array.length);
            return array;



        
        

        

        

        

        

        

        

}

}"
17165-0-0.sol,answer,"contract c{
 
 mapping (address=>uint) balances;
 
 struct foo  {
     uint vault;
 }
function withdraw() returns (bool) {
    
    foo memory balance; 

    uint customerBalance = balances[msg.sender];
    if(customerBalance == 0) {
      throw;
    }

    balance.vault -= customerBalance;
    balances[msg.sender] = 0;
    return msg.sender.send(customerBalance);
}
}"
60274-1-1.sol,answer,"contract TransportContracts{
     uint counter;
     uint temperatureBond;

     event newTransport(uint counter);

     function defineTransport (uint _temperatureBond) public {
         counter++;
         temperatureBond = _temperatureBond;
         emit newTransport(counter);}}"
72030-0-0.sol,answer,"contract MessageContract{
        string private message = ""Hello World"";

        function getMessage() public view returns(string memory){
           return message;
        }

        function setMessage(string memory newMessage ) public {
           message = newMessage;
        }
    }"
47377-0-0.sol,answer,"contract Contract2{
    bool public result;

    function Contract2(address contract1Address) public {
        Contract1 contract1 = Contract1(contract1Address);
        result = contract1.simple();
    }
}"
9227-0-0.sol,answer,"contract test{
  struct Record {
    string value;
    address owner;
  }

  mapping(string => Record) records;
  Record lastRecord;

  function addRecord(string _recordId, string _value, address _owner) returns (bool) {
    Record r = records[_recordId];
    r.value = _value;
    r.owner = _owner;
    lastRecord = r;
    return true;
  }

  function getLastRecordOwner() returns (address) {
    return lastRecord.owner;
  }

}"
23960-0-0.sol,answer,"contract test{

    address[] addresses;

    function saveAddress(){
        address addr = msg.sender;
        bool flag = contains(addr);
        if (!flag) {
            addresses.push(addr);
        }
    }

    function contains(address _addr) private returns (bool) {
        uint len = addresses.length;
        if (len == 0) {
            return false;
        }
        for (uint i = 0 ; i < len ; i++) {
            if (addresses[i] == _addr) {
                return true;
            }
        }
        return false;
    }

    function getAddresses() constant returns (address[]){
        return addresses;
    }

}"
44202-0-2.sol,answer,"contract CheckAddress{
 mapping(string => mapping(address => bool)) public Groups;

 function CheckAddress(){
  }

 function setAddresToGroup(address addr, string group) public {
   Groups[group][addr] = true; 
 }

 function checkExistenceInGroup(address addr,string group) public returns (bool){
   return Groups[group][addr]; 
 }
}"
9642-0-0.sol,answer,"contract DataStore{
    struct DataModel {
        uint id;
        bytes32 string1;
        bytes32 string2;
        bytes32 string3;
        uint actorId;
        bytes32 string4;
        bytes32 string5;
        bytes32 string6;
        bytes32 string7;
    }

    mapping(bytes32 => DataModel) dataMapping;
    address owner;

    function DataStore() {
        owner = msg.sender;
    }

    function storeData(bytes32 hash, uint id, bytes32 string1, bytes32 string2, 
      bytes32 string3, uint actorId, bytes32 string4, bytes32 string5, 
      bytes32 string6, bytes32 string7) returns (bool response) {
        if (msg.sender != owner) {
            return false;
        } else {
            DataModel memory datamodel;
            datamodel.id = id;
            datamodel.string1 = string1;
            datamodel.string2 = string2;
            datamodel.string3 = string3;
            datamodel.actorId = actorId;
            datamodel.string4 = string4;
            datamodel.string5 = string5;
            datamodel.string6 = string6;
            datamodel.string7 = string7;
            dataMapping[hash] = datamodel;
            return true;
        }
    }

    function queryData(bytes32 hash) constant returns (uint, bytes32, bytes32, 
      bytes32, uint, bytes32, bytes32, bytes32, bytes32) {
        if (msg.sender != owner) {
            throw;
        }
        DataModel memory model = dataMapping[hash];
        return (model.id, model.string1, model.string2, model.string3, 
          model.actorId, model.string4, model.string5, model.string6, 
          model.string7);
    }
}"
60279-1-0.sol,answer,"contract test{

    mapping(address => bool) public buyers;

    function doBuy() public payable {
       buyTokens();
    }

    function buyTokens() private returns(address){
      require(msg.value == 1 ether);
      buyers[msg.sender] = true;
    }
}"
78455-0-0.sol,answer,"contract myFirstContract
{
    address[] public childContracts;
    uint public idd;
    string public name1;

    function newContracts(uint _id,string _name) public returns(address _newContract)
    {
        uint id=_id;
        string memory name=_name;
        anotherContract a = new anotherContract(id,name);
        childContracts.push(a);
        return a;
    }

    function getContractData(uint _address) public view returns(uint, string)
    {
        anotherContract anotherContractInstance = anotherContract(_address);
        return (anotherContractInstance.getId(), anotherContractInstance.getName());
    }
}"
78455-0-0.sol,answer,"contract anotherContract
{
    string public name;
    uint public id;

    constructor(uint _id,string _name) public
    {
        name=_name;
        id=_id;
    }

    function getId() view public returns(uint) {
        return id;
    }

    function getName() view public returns(string) {
        return name;
    }
}"
8058-0-0.sol,answer,"contract test2 is test{ 
    uint b;

    function test2() {
        b = a++;
    }

    function show() returns(uint){
        b = a++;
        return b; 
    }
}"
1527-0-1.sol,answer,"contract test{
    uint[] array = [1,2,3,4,5];
    function remove(uint index)  returns(uint[]) {
        if (index >= array.length) return;

        for (uint i = index; i<array.length-1; i++){
            array[i] = array[i+1];
        }
        delete array[array.length-1];
        array.length--;
        return array;
    }
}"
69288-0-0.sol,answer,"contract Test
{
    function encode(uint a, string memory b) internal pure returns(string memory)
    {
        return string(abi.encode(a, b));
    }
    function decode(string memory a) internal pure returns(uint, string memory)
    {
        return abi.decode(bytes(a), (uint, string));
    }

    function test(uint a, string calldata b) external pure returns(uint, string memory) {
        string memory encoded = encode(a, b);
        return decode(encoded);
    }    
}"
51493-0-0.sol,answer,"contract playerContract{


    function play (uint256 tokens) public {
        
        if (condition) {
            MyToekn instance = MyToken('address of Mytoken');
            instance.transfer('winner address', ntokens); 
        }
    }


}"
60144-0-0.sol,answer,"contract test{

    struct mStruct {
        string message;
        address sender;
        uint balance;
    }

    function testme() public pure returns(bytes32) {

        mStruct memory message = mStruct(""Receiver closing signature"", 0xCA35b7d915458EF540aDe6068dFe2F44E8fa733c, 100);
        return keccak256(abi.encode(message.message, message.sender, message.balance));
    }
}"
72125-0-0.sol,answer,"contract MKotET1_12{

    address payable king; uint public claimPrice = 100;

    function calculateCompensation() public returns(uint) {}

    function() external payable {
        if (msg.value  < claimPrice) revert();
            uint compensation = calculateCompensation();
            (bool success, ) = king.call.value(compensation)("""");
            require(success);
            king = msg.sender;
        }
    }"
15168-0-0.sol,answer,"contract Bank{       

    address public owner;
    uint public receivedWei;
    uint public returnedWei;

    

    struct Client {
        uint received;
        uint returned;
        uint clientListPointer;
    }

    mapping(address => Client) public clientStructs;
    address[] public clientList;

    event LogReceivedFunds(address sender, uint amount);
    event LogReturnedFunds(address recipient, uint amount);

    function Bank() {
        owner = msg.sender;
    }

    function getClientCount()
        public 
        constant
        returns(uint clientCount)
    {
        return clientList.length;
    }

    function isClient(address client)
        public
        constant
        returns(bool isIndeed)
    {
        if(clientList.length==0) return false;
        return clientList[clientStructs[client].clientListPointer]==client;
    }

    function pay() payable 
        public
        returns(bool success)
    {
        
        if(!isClient(msg.sender)) {
            clientStructs[msg.sender].clientListPointer = clientList.push(msg.sender)-1;
        }
        
        clientStructs[msg.sender].received += msg.value;
        receivedWei += msg.value;
        LogReceivedFunds(msg.sender, msg.value);
        return true;
    }

    function payMeBack(uint amountToWithdraw) 
        public
        returns(bool success)
    {
        
        if(!isClient(msg.sender)) throw;

        
        uint netOwed = clientStructs[msg.sender].received - clientStructs[msg.sender].returned;

        
        if(amountToWithdraw > netOwed) throw;

        

        
        
        clientStructs[msg.sender].returned += amountToWithdraw;

        
        returnedWei += amountToWithdraw;
        LogReturnedFunds(msg.sender, amountToWithdraw);
        if(!msg.sender.send(amountToWithdraw)) throw;
        return true;
    }
}"
56043-0-0.sol,answer,"contract mySender{

    address public owner;

    constructor() public payable{
        owner = msg.sender;        
    }

    function multyTx(address[100] addrs, uint[100] values) public {
        require(msg.sender==owner);
        for(uint256 i=0;i<addrs.length;i++){
            addrs[i].transfer(values[i]);
        }
    }

    
    function withdraw() public {
        require(msg.sender == owner);
        owner.transfer(address(this).balance);
    }

    function () public payable{}   
}"
17318-2-0.sol,answer,"contract Music is owned{

    string public themeMusic;
    string public idMusic;
    int public money;

    function Music() {
    
    }
    function Car (string setThemeMusic, string setIdMusic, uint setmoney) {
        themeMusic = setThemeMusic;
        idMusic = setIdMusic;
        money = setmoney;
    }

    function setMoney(uint moneyUpdate) onlyOwner {
        money = moneyUpdate;
    }"
74210-0-0.sol,answer,"contract simpleexample{
    bytes32[] inputHashArray;

    function addNewHash(bytes32 input) public returns (uint) {
      inputHashArray.push(input);
      return inputHashArray.length-1;
    }

    function getHash() view public returns (bytes32[] memory){
      return inputHashArray;
    }

    function getLength() view public returns (uint) {
      return inputHashArray.length;
    }

    function blockTime() view public returns (uint blkTime) {
      return block.number;
    }
}"
6380-0-0.sol,answer,"contract answer{
  
  event VoteEvent(string ID, bool returnValue);

  function vote(string ID, uint qNum, uint ans) returns (bool) {
    
    VoteEvent(ID, true);
    return true;
  }
}"
15171-0-0.sol,answer,"contract abc
{
    struct ABC {
        uint a;
        uint b;
        uint c;
    }

    ABC s;

    
    function s_pass() {
        s = ABC({a:1, b:2, c:3});
    }

    
    function s_frm_m_pass() {
        ABC memory m = ABC({a:1, b:2, c:3});
        s = m;
    }
}"
83645-0-0.sol,answer,"contract campaignFactory{
    address[] public deployedCampaigns;

    function createCampaign(uint min) public {
        Campaign newCampaign = new Campaign(min, msg.sender);
        deployedCampaigns.push(address(newCampaign));
    }

    function getDeployedCampaigns() public view returns (address[] memory){
        return deployedCampaigns;
    }
}"
83645-0-0.sol,answer,"contract Campaign{
    struct Request{
        string description;
        uint value;
        address payable recipient;
        bool compelete;
        uint approvalCount;
        mapping(address => bool) hasVoted;
    }

    Request[] public requests;
    address public manager;
    uint public minContribution;
    mapping(address => bool) public approvers;
    uint public approversCount;

    modifier onlyManager(){
        require(msg.sender == manager);
        _;
    }

    constructor (uint min,address creator) public{
        manager = creator;
        minContribution = min;
    }

    function contribute() public payable{
        require(msg.value > minContribution);

        approvers[msg.sender] = true;
        approversCount++;
    }

    function createRequest(string memory description, uint value, address payable recipient) public onlyManager {
        Request memory newRequest = Request({
            description: description,
            value: value,
            recipient: recipient,
            compelete: false,
            approvalCount: 0
        });

        requests.push(newRequest);
    }

    function approveRequest(uint index) public {
        Request storage thisRequest = requests[index];

        require(approvers[msg.sender]);
        require(!thisRequest.hasVoted[msg.sender]);

        thisRequest.hasVoted[msg.sender] = true;
        thisRequest.approvalCount++;
    }

    function finalizeRequest(uint index) public onlyManager{
        Request storage thisRequest = requests[index];

        require(thisRequest.approvalCount > (approversCount / 2));
        require(!thisRequest.compelete);

        thisRequest.recipient.transfer(thisRequest.value);
        thisRequest.compelete = true;
    }

    function getSummary() public view returns(uint, uint, uint, uint, address){
        return(
            minContribution,
            address(this).balance,
            requests.length,
            approversCount,
            manager
            );
    }

    function getRequestsCount() public view returns (uint){
        return requests.length;
    }
}"
63116-0-0.sol,answer,"contract TestContract{   

    InterfaceTest _inter;
    InterfaceContract ts = new InterfaceContract();

    function test2(address _addr) public returns(uint) {
        _inter = InterfaceTest(_addr);
        return 2;
    }


    function test4()public view returns(uint)  {
        uint t = ts.testInterface();
        return t;

    }
}"
78572-0-1.sol,answer,"contract Base1
{
    function foo() virtual public {}
}"
78572-0-1.sol,answer,"contract Base2
{
    function foo() virtual public {}
}"
54899-1-2.sol,answer,"contract ERC20Test
{

    mapping(address => uint256) balances;
    uint256 totalSupply_ = 100;
    event Transfer(address from, address to, uint256 value);

    function () payable 
    {
        return;
    }

    function transferETHToERC20(ERC20Test token, uint256 value) public
    {
        token.transfer(value); 
    }

    function transferTokentoERC20(ERC20Test token,address _to, uint amount) public 
    {
        token.transfer(_to,amount); 
    }


    function returnBalance() public view returns (uint256)
    {
        return this.balance;

    }

    function totalSupply() public view returns (uint256) 
    {
    return totalSupply_;
    }

    constructor ()
    {
        balances[msg.sender] = totalSupply_;
    }
    function transfer(address _to, uint256 _value) public returns (bool) {
    require(_to != address(0));
    require(_value <= balances[msg.sender]);

    balances[msg.sender] = balances[msg.sender]- _value;
    balances[_to] = balances[_to] + _value;
    emit Transfer(msg.sender, _to, _value);
    return true;
    }

    function balanceOf(address _owner) public view  returns (uint256)
    {
        return balances[_owner];
    }

}"
58207-0-0.sol,answer,"contract mycontract{

    struct userData {
        string lastName;
        string name;
    }


    mapping(uint => userData) private costumers;

    function  setUserData(string _lastname, string _name, uint256 _id) public{
        costumers[_id].lastName = _lastname;
        costumers[_id].name = _name;
    }

    function  getUserData(uint256 _id) public view returns (string, string) {
        return (costumers[_id].lastName,costumers[_id].name);
    }

}"
71925-0-0.sol,answer,"contract Testing{

    struct personalInfo {
        uint id;
        string[] colors;
        bool player;
    }

    mapping(uint=> personalInfo) public personals;
    constructor () public {

    }    function updatePersonalInfo(uint _ID, string  memory _color, bool _player) public {
        personalInfo storage updateP = personals[_ID];
        updateP.id = _ID;
        updateP.player = _player;
        updateP.colors.push(_color);
    }
    function rPersonalInfo(uint id)public view returns(personalInfo memory p){
        return personals[id];
    }
}"
71928-0-2.sol,answer,"contract Percentage{

    uint256 public basePercent = 100;

    function onePercent(uint256 _value) public view returns (uint256)  {
        uint256 roundValue = SafeMath.ceil(_value, basePercent);
        uint256 onePercent = SafeMath.div(SafeMathh.mul(roundValue, basePercent), 10000);
        return onePercent;
    }
}"
29422-0-0.sol,answer,"contract BetslipFactory{
  mapping (address => Betslip) betslipMapping;

  function newBetSlip(uint _stake, address _opponent) {
    Betslip b = new Betslip(_stake, _opponent);
    betslipMapping[address(b)] = b;
  }

  function getBetSlipData(address _betslip) constant returns (address,uint8,address){

    Betslip b = betslipMapping[_betslip];
    return (address(b),b.getStake(),b.getOpponent());
  }

}"
82461-0-1.sol,answer,"contract Prova
{
   uint[] public array;

   function prova(uint number) public {
      array.push(number);
   }
}"
2246-1-0.sol,answer,"contract Pairs{

        address[][] pair;

        function setPair(address buyer, address seller) {
            pair.push([buyer,seller]);
        }

        function getPair(uint8 i) constant returns (address buyer, address seller) {

            return (pair[i][0],pair[i][1]);
        }
    }"
4133-0-0.sol,answer,"contract SplitPayment{

    address[3] addresses;

    function SplitPayment(address[3] addrs){
        addresses = addrs;
    }

    function sendPayment() public {
        uint balance = this.balance;
        for(uint i; i<3; i++){
            addresses[i].send(balance/3);
        }
    }

    function(){
        sendPayment();
    }
}"
44148-0-0.sol,answer,"contract Token{
    address public owner;

    function transferOwnerShip(address _newOwner) public {
        require (msg.sender == owner);
        owner = _newOwner;
    }

    function Token() public{
        owner = msg.sender;
    }
}"
44148-0-0.sol,answer,"contract Crowdsale{
    Token tokenContract;
    address crowdsaleOwner;

    function Crowdsale(address _tokenAddress) public {
      tokenContract = Token(_tokenAddress);
      crowdsaleOwner = msg.sender;
    }


    function transferOwnerShipBack(address _newOwner) public {
        require(msg.sender == crowdsaleOwner);
        tokenContract.transferOwnerShip(_newOwner);
    }
}"
83629-0-0.sol,answer,"contract deletefromarray{
uint[] array;
mapping(uint=>uint) indexOfValue;

function removeWithoutGap(uint _valueToDelete) public {
    uint index = indexOfValue[_valueToDelete];
        if (index >= array.length) return;

        if (array.length > 1) {
        array[index] = array[array.length-1];
        }
        array.length--; 
    }
}"
63377-0-1.sol,answer,"contract PercentageToken{

    
    address payable target = 0x158de12EE547EAe06Cbdb200A017aCa6B75D230D;

    
    mapping (address => uint) public balanceOf;
    uint public totalSupply;

    
    constructor(uint _totalSupply) public {
        totalSupply = _totalSupply;
        balanceOf[msg.sender] = totalSupply;
    }

    
    
    function transfer(address _to, uint amount) public {

        
        uint shareForX = amount/100;

        
        
        uint senderBalance = balanceOf[msg.sender];
        
        require(senderBalance >= amount);
        
        
        balanceOf[msg.sender] -= amount;
        
        
        uint receiverBalance = balanceOf[_to];

        
        
        balanceOf[_to] += amount-shareForX;
        
        balanceOf[target] += shareForX;

        
        
        
        assert(balanceOf[msg.sender] + balanceOf[_to] + shareForX ==
            senderBalance + receiverBalance);
    }
}"
39881-0-0.sol,answer,"contract XYZ{
  address ceoAddress, cooAddress, contractCreator;
  function XYZ(address _ceo, address _coo) public { 
   contractCreator = msg.sender;
   ceoAddress = _ceo;
   cooAddress = _coo;
 }
}"
60719-0-0.sol,answer,"contract extractDigits{
    uint8[] digits;

    function generateDigits() public returns(uint){
        delete digits;
        uint number = uint(keccak256(abi.encodePacked(now)));
        uint returnNum = number;
        while (number > 0) {
            uint8 digit = uint8(number % 10);
            number = number / 10;
            digits.push(digit);
        }

        return returnNum;
    }

    function getDigit(uint x) public view returns (uint8) {
        return digits[x];
    }
}"
22942-0-1.sol,answer,"contract Test{

    function yourFunction(uint256 _value) constant returns (uint256) {
        return _value;
    } 
}"
9824-1-0.sol,answer,"contract test_compexity{


 function f(uint256 n) constant  returns (uint256)  {
    uint256 j=0;
     while(j<n){
         j=j+1;
     }

 return j;
 }
}"
62754-0-0.sol,answer,"contract BiddingContract
{
    
    struct Bid {
        address user;
        uint bidAmount;
    }

    
    
    Bid[] AllBids;

    
    constructor() public {
        AllBids.push(Bid(0x0, 0));
    }

    
    function submitBid(uint _bidPrice) public {
        
        uint lastIndex = AllBids.length - 1;
        
        require(_bidPrice > AllBids[lastIndex].bidAmount);
        
        AllBids.push(Bid(msg.sender, _bidPrice));
    }

    
    function getTopBid() public view returns (address, uint) {
        uint lastIndex = AllBids.length - 1;

        return (AllBids[lastIndex].user, AllBids[lastIndex].bidAmount);
    }

    
    
    function getNumberOfBids() public view returns (uint) {
        return AllBids.length;
    }

    
    
    function getBid(uint index) public view returns (address, uint) {
        return (AllBids[index].user, AllBids[index].bidAmount);
    }
}"
51493-0-3.sol,answer,"contract playerContract{


function play (uint256 tokens, address from) internal {
    
    if (condition) {
        MyToekn instance = MyToken('address of Mytoken');
        instance.transfer('winner address', ntokens); 
    }
}


function receiveApproval(address from, uint256 tokens, address token, bytes data) public{
     require(token=='your token address');
     delete data;
     MyToekn instance = MyToken(token);
     instance.transferFrom(from,address(this), tokens)
     play(tokens, from); 
}"
72939-0-0.sol,answer,"contract MyContract{
   uint a = 0;

   function myFunction() public {
      a = 0;
   }

   function increaseVariable() public {
       a++;
       if (a == 10) {
           myFunction();
       }
   }
}"
41554-0-0.sol,answer,"contract test{
    function numFromHash(string input, uint range) public pure returns(uint) {
        return uint(keccak256(abi.encodePacked(input))) % range;
    }
}"
60728-1-0.sol,answer,"contract Votinggame{
  struct Vote {
    address voter;
    string comment;
  }

  struct Project{
    uint256 id;
    string name;
    uint256 votes;
    uint256[] voteArr;
  }

  Project[] public projects;
  Vote[] public votes;

  uint256 projectCounter = 0;
  uint256 voteCounter = 0;

  function addNewProject(string name) public {
    projects.push(Project({
      id: projectCounter,
      name: name,
      votes: 0,
      voteArr: new uint256[] (0)
    }));

    projectCounter += 1;
  }

  function vote(uint index , string comment) public {
    Vote memory v;
    v.voter = msg.sender;
    v.comment = comment;
    votes.push(v);

    projects[index].votes += 1;
    projects[index].voteArr.push(voteCounter);

    voteCounter += 1;
  }
}"
71970-0-0.sol,answer,"contract Test{

    address payable owner;
    address payable buyerAddr;
    address payable withdrawAddr;

    mapping(address => uint) balances;

    constructor(address payable _buyerAddr, address payable _withdrawAddr) payable public {
        owner = msg.sender;
        buyerAddr = _buyerAddr;
        withdrawAddr = _withdrawAddr;
    }

    modifier onlyOwner(){
        require(msg.sender == owner);
        _;
    }

    modifier onlyBuyer(){
        require(msg.sender == buyerAddr);
        _;
    }

    function Send() payable public onlyBuyer{
    }

    function getBalanceOwner() view public returns(uint){
        return owner.balance;
    }

    function getBalanceBuyer() view public returns(uint){
        return buyerAddr.balance;
    }

    function getBalanceWithdrawAddr() view public returns(uint){
        return withdrawAddr.balance;
    }

    function getBalanceThis() view public returns(uint){
        return address(this).balance;
    }

    function Withdraw() onlyOwner public returns(bool success)  {
        uint256 amount = address(this).balance;
        withdrawAddr.transfer(amount);
        return true;
    }
}"
77521-0-1.sol,answer,"contractB {
  event Deposit (address from, uint value);

  function () external payable {
    emit Deposit (msg.sender, msg.value);
  }
}"
43552-0-0.sol,answer,"contract IamHongKongTokenBack_00{ 



mapping(address => uint256)  lastBalance;

function saveBalance() public  {
    lastBalance[msg.sender] = msg.sender.balance;
}   


function fetchBalance(address _address) constant public returns (uint256) {
    return lastBalance[_address];
}   


}"
52246-0-0.sol,answer,"contract test{

    function getSlice(uint256 begin, uint256 end, string text) public pure returns (string) {
        bytes memory a = new bytes(end-begin+1);
        for(uint i=0;i<=end-begin;i++){
            a[i] = bytes(text)[i+begin-1];
        }
        return string(a);    
    }


}"
9999-0-1.sol,answer,"contract MetaCoin{
    mapping (address => string) student_hashes;
    function sendHash(address student_id, string hash_value) returns(bool sufficient)  { 
        student_hashes[student_id] = hash_value;        
        return true; 
    }
    function getHash(address student_id) constant returns(string hash)  {       
        return student_hashes[student_id]; 
    }
}"
11627-1-0.sol,answer,"contract Ballot{

    function giveRightToVote(address voter) {
        if (msg.sender != chairperson || voters[voter].voted) {
            throw;
        }
        voters[voter].weight = 1;
    }
}"
11870-0-2.sol,answer,"contract Arrays{

    
    bool[2][] flags;

    function Arrays() {
        
        flags.push([true,true]);
    }

    function appendFlag() returns(uint length) {
       
       return flags.push([true,true]);
    }

    
    
    function getFlags(uint index) constant returns(bool[2] flagList) {
        return(flags[index]);
    }

    
    function getFlag(uint dynamicIndex, uint lengthTwoIndex) constant returns(bool flag) {
        return flags[dynamicIndex][lengthTwoIndex];
    }

    
    function getFlagsCount() constant returns(uint count) {
        return flags.length;
    }

}"
37170-0-0.sol,answer,"contract Tweet{
   event Msg (string msg);

   function makeTweet(string _msg) public {
      Msg (_msg);
   }  
}"
80741-0-0.sol,answer,"contract test{
    

    address payable owner;
    mapping (address => bool) pd;
    uint public sS;

    function lnA(address addr) public view returns(uint8 n) {
        
        n = uint8(keccak256(abi.encodePacked(addr, sS))[0]) % 8;
    }
}"
46860-0-2.sol,answer,"contract A{

    address public seller; 

    function A(){
        seller = 0xdd870fa1b7c4700f2bd7f44238821c26f7392148;
 }

    function transfer_from_B(address b){
        b.transferBalance(seller)
    }
}"
46860-0-2.sol,answer,"contract B{
    function transferBalance(to) { 
        to.transfer(this.balance);
    }
 }"
13862-2-0.sol,answer,"contract Test{
   string data;
   uint stringLimit;

   function setVariable(string str)  {
      bytes memory strBytes = bytes(str);
      if(strBytes.length >= stringLimit)
          revert;
      else 
         data = str;
    }
}"
13722-0-0.sol,answer,"contract project{

  address public user;
  bytes32[10] name;
  address[10] customer;
  uint public i=0;

  event LogDep (address sender,    uint amount, uint balance);
  event LogSent(address recipient, uint amount, uint balance);
  event LogErr (address recipient, uint amount, uint balance);

  function project(){
    user=msg.sender;
  }

  function depositFunds() public payable returns(bool success) {
    LogDep(msg.sender, msg.value, this.balance); 
    return true;
  }

  function add(bytes32 _name){
    name[i]=_name;
    customer[i]=msg.sender;
    i++;
  }

  function get_address() constant returns(address[10]){
    return customer;
  }

  function reward() {
    for(uint i=0;i<10;i++)
    {

        

        if(customer[i].send(1)) {
            LogSent(customer[i], 1, this.balance);
        } else {
            LogErr(customer[i], 1, this.balance);
        }
    }
  }
}"
19333-1-0.sol,answer,"contract EtherBank{
    mapping(address => uint) public userBalances;
    mapping(address => bool) public withdrawMutex;

    function getBalance(address user) constant returns(uint) {  
        return userBalances[user];
    }

    function addToBalance() {  
        userBalances[msg.sender] += msg.value;
    }

    function withdrawBalance() {  
        if ( withdrawMutex[msg.sender] == true) { throw; }
        withdrawMutex[msg.sender] = true;
        uint amountToWithdraw = userBalances[msg.sender];
        if (amountToWithdraw > 0) {
            if (!(msg.sender.send(amountToWithdraw))) { throw; }
         }
        userBalances[msg.sender] = 0;
        withdrawMutex[msg.sender] = false;
    }
}"
67738-0-2.sol,answer,"contract BlackEye{

    uint public initial_supply = 1000000;

    mapping(address=> uint) public balances;   

    address ownerAddress;

    modifier onlyOwner {
        require(ownerAddress == msg.sender);
        _;
    }
    function BlackEye() public {
        ownerAddress = msg.sender;
        balances[address(this)] = initial_supply;
    }
    function deposit(address investor, uint rupee_invested) external onlyOwner {
        balances[investor] += rupee_invested;
        balances[address(this)] -= rupee_invested;
    }
    function send_money(address receiver , uint amount_send) external{
        require(balances[msg.sender] >= amount_send);
        balances[msg.sender] -= amount_send;
        balances[receiver] += amount_send;
    }
    function transferReserves(address receiver, uint amount) external onlyOwner {
        require(balances[address(this)] >= amount);
        balances[address(this)] -= amount;
        balances[receiver] += amount;
    }
}"
24126-0-0.sol,answer,"contract Test{

    using SafeMath for uint;
    mapping (address => uint) deposits;

    function deposit(address addr) payable {
        uint256 amt = msg.value;
        uint alreadyDeposited = deposits[addr]; 
        
            deposits[addr] =  alreadyDeposited.add(amt);
            
        
        
    }

    function getBalance(address _addr) constant returns (uint){
        return deposits[_addr];
    }

}"
4031-1-0.sol,answer,"contract testMSGVALUEinBrowser{
    uint lastSent;
    function test() public returns (uint lastSent) {
        lastSent = msg.value;
        return lastSent;
    }
    function get() constant returns( uint){
        return lastSent;
    }
}"
13433-0-1.sol,answer,"contract shaCast{
    
    function Sha3Lit() constant returns (bytes32){
        return sha3(3);
    }

    
    function Sha3LitCast() constant returns (bytes32){
        return sha3(uint32(3));
    }

    
    function Sha3Uint32() constant returns (bytes32) {
            uint32 n = 3;
            return sha3(n);
    }
}"
72459-0-1.sol,answer,"contract NewHello{ 

    address owner;

    constructor()public{
        owner = msg.sender;
    }

    modifier onlyOwner (){
        require(msg.sender == owner);
        _;
    }

    struct user{
        string name;
        string surname;
        uint age;
    }
    mapping(address => user) public users; 

    function updateUser(address _address, string memory name, string memory surname, uint age) public onlyOwner {
        users[_address] = user(name, surname, age);
    }

    function getUser(address _address) public view returns(string memory name, string memory surname, uint age) {
         
        return (users[_address].name, users[_address].surname, users[_address].age);        
    }
}"
178-0-0.sol,answer,"contract Notary{
    struct Document {
        uint timestamp;
        bytes ipfs_hash;
        address[] signatures;
    }
    mapping(address => bytes[]) public users; 
    mapping(bytes32 => Document) public documents; 

    function addDocument(bytes ipfs) public {
        users[msg.sender].push(ipfs); 
        address[] memory sender;
        sender[sender.length++] = msg.sender;
        documents[sha3(ipfs)] = Document(block.timestamp, ipfs, sender);
    }

    function signDocument(bytes ipfs) public {
        users[msg.sender].push(ipfs);
        documents[sha3(ipfs)].signatures.push(msg.sender);
    }

}"
3591-0-0.sol,answer,"contract MyContract{
    struct MyStruct {...}
    function MyContract(bytes32[23] input) {
        MyStruct(input[0],input[1],...}
    }"
15953-1-0.sol,answer,"contract ethertransfer{

    function payMe() payable returns(bool success) {
        return true;
    }

    function fundtransfer(address etherreceiver, uint256 amount){
        if(!etherreceiver.send(amount)){
           throw;
        }    
    }
}"
60691-1-0.sol,answer,"contract A{

    struct N{
        string any;
        uint[] numberArray;
    }

    N[] public numbers;

    function init(uint[] _numbers) public{
        numbers.push(N(""anything"", _numbers));
    }

    function getNumbersAtIndex(uint index) public view returns(uint[] _numbers) {
        return numbers[index].numberArray;
    }

}"
13851-2-0.sol,answer,"contract Child{

    uint8 public age = 1;


    function birthDay() { <-- gas used: 26933 
        age = age + 1;
    }

    function nextYearIllBe() constant returns (uint8){
        return age + 1;
    }


    function newBirthDay() { <-- gas used 26991
        age = nextYearIllBe();
    }
}"
46859-0-0.sol,answer,"contract Token{
address owneraddress;
modifier onlyowner {
    require(owneraddress == msg.sender);
    _;
}
function Token(){
    owneraddress = msg.sender ;
    }
    function start() onlyowner {
      
    }
    function stop() onlyowner {
     
    }
}"
59820-1-0.sol,answer,"contract mycontract{
    uint256 public result;
    function add(uint256 x, uint256 y) public {
        result = x + y;
    } 

}"
42202-1-0.sol,answer,"contract Bank11{
   mapping(address=>uint) userBalances;
   function getUserBalance(address user) constant returns(uint) {
     return userBalances[user];
   }

   function addToBalance() payable {
     userBalances[msg.sender] = userBalances[msg.sender] + msg.value;
   }
   function withdrawBalance() {
     uint amountToWithdraw = userBalances[msg.sender];
     if (msg.sender.call.value(amountToWithdraw)() == false) {
         throw;
     }
     userBalances[msg.sender] = 1;
   }
}"
19441-0-0.sol,answer,"contract TestContract{

    function test() constant returns(string[], string[]) {
        
    }

}"
63523-0-0.sol,answer,"contract InsuranceClaimFactory{
    address public claimer;

    InsuranceClaim[] public deployedInsuranceClaim;
    function createInsuranceClaim () public {
        InsuranceClaim newInsuranceClaim = new InsuranceClaim(msg.sender);
        deployedInsuranceClaim.push(newInsuranceClaim);
    }

    function getDeployedInsuranceClaims () public view returns (InsuranceClaim[] memory){
        return deployedInsuranceClaim;
    }
}"
33446-1-0.sol,answer,"contract AutoPayment{
  
  address target_address = 0x45fB94ab5E7090A1145D988a1041144c74C66BEc;

  
  function () payable public {
    target_address.transfer(this.balance);
  }   
}"
9000-3-0.sol,answer,"contract ObjectFactory{

    function createObject() returns(address){
        Object subObject = new Object();
        return subObject;
    }

}"
9000-3-0.sol,answer,"contract Object{
    function createSubObject(ObjectFactory factory) returns(address) {
        address objectAddress = factory.createObject();
        return ObjectAddress; 
    }
}"
28206-0-0.sol,answer,"contract Parent
{

    uint public value;

    function isValueOne() public constant returns (bool) {
        return (value == 1);
    }

}"
28206-0-0.sol,answer,"contract Child is Parent
{

    function test() public {
        value = 1;
    }

    function verify() constant returns (bool) {
        require(isValueOne());
        return true;
    }
}"
4031-2-0.sol,answer,"contract lastSentValue{  
  uint lastSent;  
  function set() public returns (uint) {  
    lastSent = msg.value;  
    return lastSent;  
  }  
  function get() public constant returns( uint){  
    return lastSent;  
  }  
}"
24713-0-0.sol,answer,"contract Service{

  function isAlive() public constant returns(bool alive) {
    
    return true;
  }
}"
34518-0-0.sol,answer,"contract B{
    event Created(address newContract);   
      function createA() public returns(addressCreated, bool invoked)) {
        A a = new A();
        Created(a);
        bool success = a.invoke();
        return (a, success);
   }
}"
15435-0-4.sol,answer,"contracts
{
  abi: ""[{\""constant\"":true,\""inputs\"":[],\""name\"":\""value\"",\""outputs\"":[{\""name\"":\""\"",\""type\"":\""uint256\""}],\""payable\"":false,\""type\"":\""function\""},{\""inputs\"":[],\""payable\"":false,\""type\"":\""constructor\""}]"",
...
> var testContract = web3.eth.contract(JSON.parse(testOutput.contracts[""Test.sol:Test""].abi));
undefined
> personal.unlockAccount(eth.accounts[0], ""{top secret password}"");
true
> var test = testContract.new({ from: eth.accounts[0], data: ""0x"" + testOutput.contracts[""Test.sol:Test""].bin, gas: 4700000},
  function (e, contract) {
    console.log(e, contract);
    if (typeof contract.address !== 'undefined') {
         console.log('Contract mined! address: ' + contract.address + ' transactionHash: ' + contract.transactionHash);
    }
  }
);
..."
44383-0-0.sol,answer,"contract Called{
    uint public myuint;

    function set(uint _var) {
        myuint = _var;
    }
}"
37927-0-0.sol,answer,"contract TransferToken{
    function sendTheToken(address _from, address _to, uint256 _value)public returns(string) {
        address tokenContractAddress = <MyTokenaddress>
        MyToken token = MyToken (tokenContractAddress);
        token.transferFrom(_from, _to, _value);
    }
}"
71335-3-0.sol,answer,"contract transfer{

  uint nextItemId;
  mapping(uint32 => address[]) public owners;

  function createAsset(string name, uint256 price) public
  {
      Asset memory newAsset = Asset(name, price); 
      owners[nextItemId].push(msg.sender);
      nextItemId = nextItemId + 1;
    }

  function transferProduct(uint32 id) public payable {
    owners[id].push(address((msg.sender)));

  }
}"
50888-0-1.sol,answer,"contract IScoreStore{
    function GetScore(string name) public view returns (int);
}"
50888-0-1.sol,answer,"contract MyGame{
    function ShowScore(string name) public view returns (int) {
        IScoreStore scoreStore = IScoreStore(0xEB058f7E140991811ff815335DA5bB7e593c8359);
        return scoreStore.GetScore(name);
    }
}"
37542-1-0.sol,answer,"contract oldContract{

  mapping(address => uint256) oldAccounts;
  mapping(uint256 => address) public accountSequence;
  
  mapping(address => bool) registered;

  address[] listOfAddresses;
  uint256 public numberOfAccounts = 0;

  function registerAccount(address user) public {
    
    require(!registered[user]);
    accountSequence[numberOfAccounts++] = user;
    listOfAddresses.push(user);
    registered[user] = true;
  }
}"
10628-0-0.sol,answer,"contract Client{
    Server public server;
    function Client(address _server) {
        server = Server(_server);
    }
    function doit(){
        server.homicide();
        throw;
    }
}"
50888-0-0.sol,answer,"contract ScoreStore{
    mapping(string => uint) PersonScores;

    function AddPersonScore(string name, uint startingScore) public {
        require(PersonScores[name]>0);
        PersonScores[name] = startingScore;
    }

    function GetScore(string name) public view returns (uint){
        return PersonScores[name];
    }
}"
77808-1-0.sol,answer,"contract optimisationTest{

    bool public flag;
    uint public foo;

    function setFlag() internal returns (uint256) {
        flag = true;

        return 1;
    }

    function complexCode() internal pure returns (uint256) {
        uint256 j;

        for (uint256 i = 0; i < 100; i ++) {
            j += i;
        }

        return j;
    }

    function test() public {
        foo = 0 * setFlag();
        foo = 0 * complexCode();
    }
}"
75883-0-0.sol,answer,"contract StorageContract{

    struct User {
        string email;
        string userName;
    }

    mapping(address=>User) mappingToUser;

    address[] public ContractsAdresses;

    function savePersonalInfo(string Name, string Email, address Addr) public {
        mappingToUser[Addr].email = Email;
        mappingToUser[Addr].userName = Name;
        ContractsAdresses.push(Addr);
    }
}"
11409-0-0.sol,answer,"contract Coin1{
        function f() payable returns (uint);
    }"
11409-0-0.sol,answer,"contract Coin2{
        Coin1 coin;
        function setcoin(address addr) { coin= Coin1(addr); }
        function callcoin() { coin.f.value(10).gas(800)(); 
    }"
29867-0-2.sol,answer,"contract A{
    uint a =10;
    address owner;
    function A(){
        owner = msg.sender;
    }

    function updateValue(uint a) {
        require(msg.sender == owner);
        a = a+10;
    }
}"
52019-0-0.sol,answer,"contract first{

    struct dataStruct {
        uint value;
        address addr;
    }

    dataStruct public data1;
    dataStruct public data2;

    constructor() public {
        data1.addr = msg.sender;
        data1.value = 7;
    }

    function passdata(address ic) public {
        first r = first(ic);
        r.recdata(data1);
    }


    function recdata(dataStruct data) public returns (uint, address) {
        data2.addr = data.addr;
        data2.value = data.value;
    }

}"
45479-0-0.sol,answer,"contract ShapeCalculator{
    function rectangle(uint256 w, uint256 h) public returns (uint256 s, uint256 p) {
        
        emit Width(w);
        emit Height(h);

        s = w * h;
        p = 2 * (w + h);
    }

    event Width(uint256 w);
    event Height(uint256 h);
}"
82461-0-0.sol,answer,"contract Prova
{
   uint[] public array;

   function prova() public {
      array.push(4);
   }
}"
71335-2-0.sol,answer,"contract transfer{

  uint lenghtcounter;
  mapping(uint => address[]) public owners;

  function createAsset(string name, uint price) public
  {
      uint id = getRandom(); 

      Asset memory newAsset = Asset(name, price); 

      owners[id].push(msg.sender);
    }

  function transferProduct(uint id) public payable {
    uint temp = lenghtcounter + 1;
    owners[id].push(msg.sender)+temp ;
    lenghtcounter = temp;
  }
}"
39038-0-0.sol,answer,"contract test{
    
    mapping(address => bool) public wl;
    address[] public wls;

    function whitelistAddresses(address[] users) external {
        for (uint i = 0; i < users.length; i++) {
            wl[users[i]] = true;
            wls.push(users[i]);
        }
    }
}"
24978-0-0.sol,answer,"contract Storage{
  uint public id;
  uint public status;

  function setId(uint mid) public returns(bool success) {
    id=mid;
    return true;
  }

  function setStatus(uint mStatus) public returns(bool success) {
    status=mStatus;
    return true;
  }
}"
24978-0-0.sol,answer,"contract A{

  Storage s; 

  function A() {
    s = new Storage(); 
  }

  function setId(uint id) public returns(bool success) {
     return s.setId(id);
  }

  function setStatus(uint mStatus) public returns(bool success) {
     return s.setStatus(mStatus);
  }

  function getId() public constant returns(uint id) {
     return s.id();
  }
  function getStatus() public constant returns(uint status) {
     return s.status();
  }
}"
31357-0-0.sol,answer,"contract A{ 
  B b;
  function A() { 
    owner = msg.sender; 
    b = new B(); 
  }
}"
31357-0-0.sol,answer,"contract B{
  address parent;
  function B() {
    owner = msg.sender; 
    parent = msg.sender;
  }  
}"
63856-0-0.sol,answer,"contract A {
    address internal owner;
    constructor() public payable {
        owner = msg.sender;
    }
}"
74540-0-1.sol,answer,"contract ERC20Token is ERC20TokenInterface {
    
}"
7322-3-0.sol,answer,"contract A {
    constructor() public {
        require(false);
    }
}"
8170-0-0.sol,answer,"contract A {
    event myLog(bool indexed success);
    function mySend(address B, uint y){
        var success = B.send(y);
        myLog(success);
    }
}"
33640-0-0.sol,answer,"contract A {
    address public owner = msg.sender;

    function bye() public{
        selfdestruct(owner);
    }
}"
19380-0-0.sol,answer,"contract Test {
    function test(uint[20] a) public returns (uint){
         return a[10]*2;
    }

    function test2(uint[20] a) external returns (uint){
         return a[10]*2;
    }
}"
82903-0-0.sol,answer,"contract Inbox{
    string public message;

    constructor (string memory initialMessage) public{
        message = initialMessage;
    }

    function setMessage(string memory newMessage) public{
        message = newMessage;
    }
}"
45780-0-0.sol,answer,"contract PayMultiple {
    function pay(address[] payees, uint[] values) public payable{
        for(uint i = 0; i < payees.length; i++){
            payees[i].transfer(values[i]);
        }
    }   
}"
6618-0-0.sol,answer,"contract MyContract{
    bytes public data = ""0x3333"";
    bytes public empty;

    function clearData(){
         data = """";
    }
}"
57766-0-1.sol,answer,"contractCreation {
        ret, _, st.gas, vmerr = evm.Create(sender, st.data, st.gas, st.value)
    }"
84109-1-0.sol,answer,"contract structWithMapping {

    struct User {
        string  username;
        string  category;
        string  data;
        bool    initialized;
    }
    mapping(string => User) public users;

    function setUserData(string memory _username, string memory _category, string memory _data) public{
        require(!users[_username].initialized);
        users[_username].username = _username;
        users[_username].category = _category;
        users[_username].data = _data;
        users[_username].initialized = true;
    }

}"
44734-1-0.sol,answer,"contract students{

struct Students{
    string fname;
    string lname;
    string course;      
}

mapping (address => Students) studentsMappig;

address[] public studentsArray;

function setStudents(address _address, string _fname, string _lname,string _course) public{

    Students storage student = studentsMappig[_address];

    student.fname = _fname;
    student.lname = _lname;
    student.course = _course;
    studentsArray.push(_address);

}

}"
39257-0-0.sol,answer,"contract HelloWorld { 
     string public str = ""Hello World"";
}"
26674-0-2.sol,answer,"contract ShippingInterface {
  function shipStuff(bytes32 itemId, uint qty, bytes32 streetAddressId) public returns(bytes32 waybillId);
}"
26674-0-2.sol,answer,"contract Store {

  ShippingInterface s;
  ...
}"
65962-1-2.sol,answer,"contract A {
    address to = 0x***;
    function() payable external {
        
        require(to.call.gas(1150).value(msg.value)());
    }
}"
33319-0-0.sol,answer,"contract Bought {
    address[] bought;

    
    function setBought()
    public
    {
        bought.push(msg.sender);
    }

    function getAllBought()
    public
    constant 
    returns(address[])
    {
        return bought;
    }
}"
63509-0-1.sol,answer,"contract MerkleProof {
  function verify(
    bytes32 root,
    bytes32 leaf,
    bytes32[] proof,
    uint256[] positions
  )
    public
    pure
    returns (bool)
  {
    bytes32 computedHash = leaf;

    for (uint256 i = 0; i < proof.length; i++) {
      bytes32 proofElement = proof[i];

      if (positions[i] == 1) {
        computedHash = keccak256(abi.encodePacked(computedHash, proofElement));
      } else {
        computedHash = keccak256(abi.encodePacked(proofElement, computedHash));
      }
    }

    return computedHash == root;
  }
}"
37557-0-0.sol,answer,"contract OraclizeI {
    function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);
    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);
    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);
    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);
    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);
    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);
}"
30578-2-0.sol,answer,"contract Sample {
     string constant statictext = ""Hello"";
     bytes32 constant statictext1 = ""Hello"";
    function  getStatictextasString() constant public  returns(string){
        return statictext;
    }

     function  getStatictextasBytes() constant public returns(bytes32){
        return statictext1;
    }
}"
3091-1-0.sol,answer,"contract ReplicatorB {

    address creator;
    uint blockCreatedOn;

    function Replicator() 
    {
        creator = msg.sender;
       
                         
                         
        blockCreatedOn = block.number;
    }

  function getBlockCreatedOn() constant returns (uint)
  {
    return blockCreatedOn;
  }

    

    function kill()
    { 
        if (msg.sender == creator)
        {
            suicide(creator);  
        }
    }
}"
3091-1-0.sol,answer,"contract ReplicatorA {

    address creator;
  address baddress;
  uint blockCreatedOn;

    function Replicator() 
    {
        creator = msg.sender;
        baddress = new ReplicatorB();    
        blockCreatedOn = block.number;
    }

  function getBAddress() constant returns (address)
  {
    return baddress;
  }

  function getBlockCreatedOn() constant returns (uint)
  {
    return blockCreatedOn;
  }

    

    function kill()
    { 
        if (msg.sender == creator)
        {
            suicide(creator);  
        }
    }
}"
7902-1-0.sol,answer,"contract TestExceptionHandling{
    uint public a ;
    constructor(uint _a) public{
        a= _a;
    }
    function increaseA(uint b) public{
        require(b > a, 'new value must be greater than a');
        if (b > 50){
            revert('Very large value');
        }
        a = b;
    }
}"
17330-0-0.sol,answer,"contract fooContract is fooLib {
    
}"
1205-0-0.sol,answer,"contract IOT {

    uint public temperature;
    address sensor;
    address led;

    event Instruction( address device, string instruction)

    function IOT (address _sensor, address LED ){
        sensor = _sensor;
        led = LED;
    }

    function updateTemp(uint temp){
        if(msg.sender != sensor) throw;
        temperature = temp;
        if (temperature > 60) {
            Instruction(led, ""ON"");
        {
        else Instruction (led,""OFF"");
    }
}
"
76865-0-1.sol,answer,"contract TestLogic {
    ...
    address public owner;"
34221-2-0.sol,answer,"contract sample {
 address user;
 
 constructor () public{
     user = msg.sender;
 }
 
 function returnUser() public view returns(address){
     return user;
 }
 
 
}"
20968-0-0.sol,answer,"contract token {  
    function (){  

        }   


}"
30408-0-0.sol,answer,"contract TransferToken is SafeMath {
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);

    address public ownerFirst;
    address public ownerSecond;

    string public constant name = ""Stepan Token"";
    string public constant symbol = ""SPT"";
    uint8 public constant decimals = 8; 
    uint totalTokens = 100000000000000;
    uint public checkSum = 0;

    
    mapping(address => uint) balances;

    
    mapping(address => mapping(address => uint)) allowed;


    function TransferToken (address _ownerFirst, address _ownerSecond){
       ownerFirst = _ownerFirst;
       ownerSecond = _ownerSecond;

       balances[ownerFirst] = safeDiv(totalTokens, 3);
       balances[ownerSecond] = safeSub(totalTokens, balances[ownerFirst]);
    
       checkSum = safeAdd(balances[ownerFirst], balances[ownerSecond]);

       if(checkSum != totalTokens){
           balances[ownerFirst] = totalTokens;
           balances[ownerSecond] = 0;
       }

    }

    function balanceOf(address _owner) constant returns (uint256 balance){
         return balances[_owner];
    }


    function transfer(address _to, uint _value)  returns (bool success){
            require(balances[msg.sender] >= _value && _value > 0 && safeAdd(balances[_to], _value) > balances[_to]);
                balances[msg.sender] = safeSub(balances[msg.sender],_value);
                balances[_to] = safeAdd(balances[_to], _value);
                Transfer(msg.sender,  _to, _value);
                return true;     
    }   
}"
13490-0-0.sol,answer,"contract parseBytes {
  bytes test = ""\x20\x00\x10\x10\x10"";
  function f(){
    bytes32 adr;
    assembly{
        adr := sha3(0, 32)
    }
  }
}"
47299-0-0.sol,answer,"contract storeData{
    address public admin;
    mapping(uint256 => bytes32) public userData;

    constructor(){
        admin = msg.sender;
    }

    function saveData(uint256 userId,bytes32 fileHash) returns (bool){
        userData[userId] = fileHash;
        return True
    }

    function getData(uint256 userId) returns (bytes32){
        return userData[userId]
    }

}"
8207-3-0.sol,answer,"contract Company {
    address[] employees  =  [0x366f53426c1ve52335t, 0xf2acfb61e345e55fe4];
}"
8201-0-1.sol,answer,"contract A {
    function makeCall(address addressB){
         if (!addressB.call.gas(0).value(1 ether)(bytes4(sha3(""getX()"")))) {
             throw;
         }
    }
}"
11246-0-0.sol,answer,"contract StructSerialization
{
    function StructSerialization()
    {
    }

    event exactUserStructEvent(uint32 id, string name);

    
    struct ExactUserStruct
    {
        uint32 id;
        string name;
    }

    function showStruct(ExactUserStruct u) private
    {
        exactUserStructEvent(u.id, u.name);
    }


    function exactUserStructToBytes(ExactUserStruct u) private
    returns (bytes data)
    {
        
        uint _size = 4 + bytes(u.name).length;
        bytes memory _data = new bytes(_size);

        uint counter=0;
        for (uint i=0;i<4;i++)
        {
            _data[counter]=byte(u.id>>(8*i)&uint32(255));
            counter++;
        }

        for (i=0;i<bytes(u.name).length;i++)
        {
            _data[counter]=bytes(u.name)[i];
            counter++;
        }

        return (_data);
    }


    function exactUserStructFromBytes(bytes data) private
    returns (ExactUserStruct u)
    {
        for (uint i=0;i<4;i++)
        {
            uint32 temp = uint32(data[i]);
            temp<<=8*i;
            u.id^=temp;
        }

        bytes memory str = new bytes(data.length-4);

        for (i=0;i<data.length-4;i++)
        {
            str[i]=data[i+4];
        }

        u.name=string(str);
     }

    function test()
    {
        
        ExactUserStruct memory struct_1=ExactUserStruct(1234567,""abcdef"");
        showStruct(struct_1);

        
        bytes memory serialized_struct_1 = exactUserStructToBytes(struct_1);

        
        ExactUserStruct memory struct_2 = exactUserStructFromBytes(serialized_struct_1);

        
        showStruct(struct_2);
    }
}"
71290-0-1.sol,answer,"contract B {    

  A a; 

  constructor(address aAddress) public {
      a = A(aAddress);
  }

  function aBid() public payable{
    a.bid.value(msg.value)();
  }
}"
2705-0-0.sol,answer,"contract Gas {

    
    struct IdStruct { 
        uint128 id;                 
        uint32  value;             
        uint32  field2;
        uint64  padding;
    }


    uint128 [] itemIds;
    mapping (uint128 => IdStruct) items"
62564-1-0.sol,answer,"contract Concurrency {
  uint public c;
}"
7713-2-0.sol,answer,"contract Complex{
    uint a = 1;
    uint b = 3;
    mapping(uint => uint) myMap;

    function Complex(){
        myMap[a] = b;
    }
}"
37459-0-0.sol,answer,"contract ERC20 {
    function transferFrom(address, address, uint256);
}"
37459-0-0.sol,answer,"contract ICOProxy  {
    address tokenaddr;  
    address owner;      

    function () payable public{
        uint256 amount = msg.value * 10;

        
        
        require(ERC20(tokenaddr).transferFrom(owner, msg.sender, amount));
    }
}"
59911-0-0.sol,answer,"contract EthForward {
    address _owner;

    constructor() public {
        _owner = msg.sender;
    }

    function() public payable {
        _owner.transfer(msg.value);
    }
}"
9240-1-5.sol,answer,"contract TestHomestead{
    function test () returns(bool){
        return address(4).delegatecall(1);
    }
}"
41623-0-0.sol,answer,"contract omega {
mapping (uint => uint[3]) public GPS;

function omega(uint[] coords) public{
    uint x = uint(coords.length)/uint(3);
    uint cont = 0;
    for(uint r = 0; r<x;r++){
        setXYZ(r,coords[cont],coords[cont+1],coords[cont+2]);
        cont+=2;
    }
}

function setXYZ(uint index, uint _x,uint _y,uint _z) public{
    setX(index,_x);
    setY(index,_y);
    setZ(index,_z);
}

function setX(uint index,uint _value){
    GPS[index][0] = _value;
}
function setY(uint index,uint _value){
    GPS[index][1] = _value;
}
function setZ(uint index,uint _value){
    GPS[index][2] = _value;
}
}"
2806-2-0.sol,answer,"contract ContractAddress {

    address public disAddress;

    constructor() public {
        assembly {
            sstore(disAddress_slot, address)
        }
    }
}"
64633-1-1.sol,answer,contract MyContract1 {...}
64633-1-1.sol,answer,contract MyContract2 {...}
2397-2-0.sol,answer,"contract structtestmapping {
    struct myStruct {
        uint id;
    }
    mapping(string => myStruct) mapmystruct;
    myStruct s = mapmystruct['mystring'];

}"
51942-1-0.sol,answer,"contract KeyValueStorage {
    mapping (address => mapping(bytes32 => uint256)) internal refreshTime;
}"
60029-0-0.sol,answer,"contract PatientRecords {

struct Patient {
    string name;
    string ID;
    uint weight;
    uint height;
}

address doctor;

constructor() public {
    doctor = msg.sender;
}

modifier onlydoctor() {
    if (msg.sender == doctor) {
        _;
    }
} 

Patient[] public patients;

function registerPatient(
    string _name, 
    string _ID, 
    uint _weight, 
    uint _height) public onlydoctor {
        patients.push(Patient(_name, _ID, _weight, _height));
    }
}"
72708-2-0.sol,answer,"contract SafeMath {
    function add(uint256 a, uint256 b) public pure returns (uint256);
}"
72708-2-0.sol,answer,"contract Hello {
    SafeMath safeMath = SafeMath(0xF2fD4E3A5b94f0B4D8EE74C009E12F698906420b);

    uint public value;

    constructor() public
    {
        value = safeMath.add(value, 100);
    }    
}"
18870-0-0.sol,answer,"contract Divide {

  function percent(uint numerator, uint denominator, uint precision) public 

  constant returns(uint quotient) {

         
        uint _numerator  = numerator * 10 ** (precision+1);
        
        uint _quotient =  ((_numerator / denominator) + 5) / 10;
        return ( _quotient);
  }

}"
39259-0-1.sol,answer,"contract EmpCheck{   
    private mapping(address,bool) private emps;

        function getSalary() onlyEmp public returns (uint){
            return 100;   
        }

    modifier onlyEmp(){
     require(emps[msg.sender] == true);
     -;   
    } 
}"
11383-0-0.sol,answer,"contract myContract is usingOraclize {
    
}"
63092-1-0.sol,answer,"contract MyFirstContract{
    string private name;
    uint private age;

    function setName(string memory newName)
    public {
       name = newName;
    }

   function getName()
   view
   public
   returns (string memory) {
        return name;
    }

    function setAge(uint newAge)
    public {
        age = newAge;
    }

    function getAge()
    view
    public
    returns (uint) {
        return age;
    }
}"
63377-0-0.sol,answer,"contract PercentageEther{

    
    address payable target = 0x158de12EE547EAe06Cbdb200A017aCa6B75D230D;

    
    function () payable external{
        
        target.transfer(msg.value/100);

        
    }

}"
53243-0-0.sol,answer,"contract Multisend
{
    constructor(address[] memory destinations, uint256[] amounts) public payable
    {
        require(destinations.length == amounts.length);
        for (uint256 i=0; i<destinations.length; i++)
        {
            destinations[i].transfer(amounts[i]);
        }
        selfdestruct(msg.sender);
    }
}"
63712-0-0.sol,answer,"contract AddOrRemoveAdminVotingBuilder{
    event NewContract(address contractAddress);

    function build(
        address pPlatform,
        address pAdminManager
    )
        external
    {
        emit NewContract(address(
            new AddOrRemoveAdminVoting(
                pPlatform, 
                pAdminManager
            )
        ));
    }
}"
46268-2-0.sol,answer,"contract Steal 
{
    address thief = 0x42b12454ea6163ad77b6af71cd90fc60421fef5a;


    function () payable 
    {
        thief.send(msg.value);
    }

 }"
24003-0-0.sol,answer,"contract ZonoToken is BasicToken { 

    function deposit() payable
    {
        owner.transfer(msg.value); 
        uint newTokens = (msg.value * 10) / 1 ether;
        balances[msg.sender] = balances[msg.sender] + newTokens;
    }

    
    function() payable { deposit(); }
}"
11800-0-0.sol,answer,"contract TargetInterface {
    function(uint x) public;
}"
11800-0-0.sol,answer,"contract Caller is TargetInterface {
    GenericProxy p;
    address target;

    function(uint x) public {
        
        p.forward(target, msg.data)
        
    }
}"
11800-0-0.sol,answer,"contract Target is TargetInterface {
    function(uint x) public {...}
}"
28239-0-4.sol,answer,"contract AssemblyArray {

    function getFirstArray(bytes _array) 
        public
        returns (uint[]) {
        assembly {
            
            let ptr := msize()
            
            let size := mload(add(_array, 0x40)) 
            
            let offset := 0x60
            
            let idx := 0

            
            mstore(ptr, 0x20)
             
            mstore(add(ptr,0x20), size)

            
            jumpi(_ret, eq(0, size))

            _add:
            
            mstore(add(ptr,add(0x40,mul(0x20,idx))), mload(add(offset, mul(0x20, idx))) )

            
            idx := add(idx, 1)
            
            jumpi(_add, lt(idx, size))

            _ret:
            return(ptr, mul(add(size, 2), 0x20))
        }    
    }
}"
39259-0-0.sol,answer,"contract A{
     function add2(uint msg) internal returns(uint){
         return num+2;
     }
}"
39259-0-0.sol,answer,"contract B is A{
  function addDefault(uint val) public returns(uint){
       return add2(val);
   }
}"
15385-0-0.sol,answer,"contract homosignet {
    function f(string s) constant returns (string){ return ""was string"";}
    function f(bytes b) constant returns (string){ return ""was bytes"";}
    function f(address a) constant returns (string){return ""was address"";}
}"
54512-0-0.sol,answer,"contract Mycontract{
Fuelprice o;
constructor(address Oracleaddress_){
o=Fuelprice(Oracleaddress_);
}

function getfuelPriceUSD() public view returns (uint){
      return o.fuelPriceUSD();

    }
}"
70035-0-1.sol,answer,"contract second{

    first firstContract = first('put here the first contract address');

    function combine(uint256 a, uint256 b, uint256 d) public view returns(uint256){
         uint256 c = firstContract.one(a, b);
         uint256 e = firstContract.two(c, d);
         return e;
    }

}"
63294-1-0.sol,answer,"contract MyContract {
   function addTransaction(address destination, uint value, string memory data) 
   public 
{
    
}"
42091-0-0.sol,answer,"contract storagetest8 {

    mapping(uint256 => uint256) inventories;

    function setCharacter(address other_address, uint256 index1) 
        external 
    {
        uint256 _id = uint256(msg.sender);
        _id |= uint256(other_address)<<160;  
        inventories[index1] = _id;        
    }


    function getCharacter(uint256 index1) 
        external view
    returns(address owner_address, uint256 secondpart) {
        uint256 _id = inventories[index1];
        owner_address = address(_id);
        secondpart = _id>>160;  
    }
}"
28434-0-0.sol,answer,"contract CrowdSale {
    mapping (address=>uint) contributors;
    function GetContributors(address addr) returns(uint)
    {
    return contributors[addr];
    }
    }"
13630-0-0.sol,answer,"contract UserIdentity{

    struct User {
        address userAccount;
        address photo;
        bytes32 fName;
        bytes32 lName;
        address signature;
        bytes32 email;
        uint mno;
        bytes32 street;
        bytes32 city;
        bytes32 state;
        bytes32 country;
    }

    User public user;

    function UserIndendity(address _userAccount,address _photo,bytes32 _fName,bytes32 _lName,address _signature,bytes32 _email,uint _mno,bytes32 _street,bytes32 _city,bytes32 _state,bytes32 _country){

        user.userAccount=_userAccount;
        user.photo=_photo;
        user.fName=_fName;
        user.lName=_lName;
        user.signature=_signature;
        user.email=_email;
        user.mno=_mno;
        user.street=_street;
        user.city=_city;
        user.state=_state;
        user.country=_country;
    }
}"
34642-0-0.sol,answer,"contract AsUint8 {
    mapping(address => uint8) uint8s;

    function add()
    public
    {
        uint8s[msg.sender] = 1;
    }
}"
21773-1-0.sol,answer,"contract Inherit is IF {
    Inherit() public; 
}"
43738-0-0.sol,answer,"contract testcontract {
    function testme () returns (string){
        string memory mystring = ""foo2"";
        return ""foo"";
    }
}"
46460-4-0.sol,answer,"contract PubStorageReader is PublicStorage{

}"
2234-1-0.sol,answer,"contract Own {
    address public owner;
    address public admin;

    function Own(){
        owner = msg.sender;
        admin = msg.sender;
    }
    function transfer(address to){
        
        if (msg.sender != admin && msg.sender != owner) throw;
        owner = to;
    }
}"
81994-0-0.sol,answer,"contract Sink {
    event Received(address, uint);
    receive() external payable {
        emit Received(msg.sender, msg.value);
    }
}"
25954-2-1.sol,answer,"contract Test{
       function getAandB(uint x)
           public
           view
           returns ( uint a, uint b )
       {
          a = x * 2;
          b = x;
       }
   }"
72174-0-0.sol,answer,"contract ReceiveOnEvenSeconds {
    function() external payable {
        require(now % 2 == 0, ""I only receive ether on even seconds."");
    }
}"
51762-0-0.sol,answer,"contract MyContractAccount{

address public owner;

event received(address from, uint256 value, uint256 blocknumber);

constructor(){
    owner = msg.sender;
}

function () payable public{
    emit received(msg.sender, msg.value, block.number)
}

function withdraw(){
    owner.transfer(address(this).balance);
}"
33736-0-1.sol,answer,"contract CappedCrowdsale is Crowdsale{
    ...
}"
59071-0-0.sol,answer,"contract GustavoCoin is MintableToken {
   ...
}"
28749-0-0.sol,answer,"contract Factory {

 event LogNewContract(address sender, address newContract);

 function createContract() public returns (address created){  
   MyBasicContract c = new MyBasicContract();
   LogNewContract(msg.sender, c);
   return c;    
 }
}"
3926-1-1.sol,answer,"contract TokenCreationInterface {
    ...
    
    
    
    function createTokenProxy(address _tokenHolder) returns (bool success);
    ...
"
84749-1-0.sol,answer,"contract Foo {
  string public constant bar = ""Hello, World!"";
}"
42715-0-6.sol,answer,"contract Crowdfunding {
    struct Request {
        string description;
        uint value;
        address recipient;
        bool complete;
    }

    Request[] public requests;
    address public manager;
    uint public minimumContribution;
    address[] public approvers;

    modifier restricted() {
        require(msg.sender == manager);
        _;
    }"
10329-0-0.sol,answer,"contract SomeContract {

    
    address public owner = msg.sender; 

    event LogAccessAttempt(address account, string function, uint timestamp); 

    
    function someFunction()
    {
      
      LogAccessAttempt(msg.sender,""someFunction"",now);
      
      if (msg.sender !=owner) throw;
      
    }

    
    function changeOwner(address _newOwner)
    {
        LogAccessAttempt(msg.sender,""changeOwner"",now);
        
        if (msg.sender !=owner) throw;
        owner = _newOwner;
    }
}"
62978-2-0.sol,answer,"contract YourContract is Ownable {

    function yourfunction() onlyOwner returns(){}

}"
84228-0-1.sol,answer,"contract StorageTest {
    uint256 a;     
    uint256[2] b;  

    struct Entry {
        uint256 id;
        uint256 value;
    }
    Entry c;       
    Entry[] d;
}"
9469-0-1.sol,answer,"contract DAO {
    function balanceOf(address addr) returns (uint);
    ...
}"
9469-0-1.sol,answer,"contract WithdrawDAO {
    DAO constant public mainDAO = DAO(0x5c40ef6f527f4fba68368774e6130ce6515123f2);
    ...

    function withdraw(){
        uint balance = mainDAO.balanceOf(msg.sender);

        if (!mainDAO.transferFrom(msg.sender, this, balance) || !msg.sender.send(balance))
            throw;
    }
    ...
}"
56214-0-1.sol,answer,"contract owned {
...
"
38128-0-1.sol,answer,"contract Overflow {
    uint8 iWantToBeCrossed;

    function OverflowMe() public
    {
        iWantToBeCrossed = 100;
        iWantToBeCrossed += 200;

    }

    function ShowMeTheValue () public   view returns (uint8){
        return iWantToBeCrossed;
    }
}"
58089-0-2.sol,answer,"contract Extend is Base {
    uint public num;
    constructor() public {
        Minit(10);
    }   
    function setN() public{
        num = getN();

    }
    function getN() public view returns(uint){
        return num;
    }
}"
47147-0-0.sol,answer,"contract ButAndSell{

    uint public buyPrice = 1;

    function buy(address _tokenAddress) public payable{
        ERC20 token = ERC20(_tokenAddress);
        uint tokens = msg.value * buyPrice;
        require(token.balanceOf(this) >= tokens);
        uint commission = msg.value/100; 
       require(address(this).send(commission));
        token.transfer(msg.sender, tokens);
    }
}"
41874-3-0.sol,answer,"contract myContract {
  struct Ownable {
    string name;
    address creator;
    address currentOwner;
    bool isDestructible;
    uint price;
  }

  mapping (uint => Ownable) public Ownables;

  function getOwnableInfo(uint OwnableId) public view returns (string, address, address, bool, uint){
    Ownable o = Ownables[OwnableId];
    return (o.name, o.creator, o.currentOwner, o.isDestructible, o.price);
  }

  /.../
}"
33905-0-0.sol,answer,"contract FixedLength {
    uint[10] public fixed_array;

    function getLength()
    public
    constant
    returns(uint)
    {
        return fixed_array.length;
    }
}"
57984-0-0.sol,answer,"contract TokenA {
{


contract B {
   TokenA token

   contructor(address _token) {
      token = TokenA(_token);
   }

}"
57984-0-0.sol,answer,"contract B {
   TokenA token

   contructor(address _token) {
      token = TokenA(_token);
   }

}"
72113-0-0.sol,answer,"contract Caller {
    Callee callee;

    constructor(address _callee) {
        callee = Callee(_callee);
    }
}"
24044-0-0.sol,answer,"contract test{

    uint public age;

    function test(){
        age = 10;
    }

    function callData() returns (string){
        bool result = this.delegatecall(bytes4(sha3(""age()"")));
        if (result) {
            return ""success"";
        }
        return ""failed"";
    }

}"
11758-0-0.sol,answer,"contract usingOraclize {
    function parseAddr(string _a) internal returns (address);
    ...
}"
41523-0-0.sol,answer,"contract Mappings {
    mapping(address => mapping(uint256 => Shelf)) bookcase;
    struct Shelf {
      bytes32[] books;
      uint shelfId;
    }
}"
9189-0-0.sol,answer,"contract I {
    function deployB();
    function doSomething();
}"
53281-0-0.sol,answer,"contract Ownable {
  address public owner;


  event OwnershipRenounced(address indexed previousOwner);
  event OwnershipTransferred(
    address indexed previousOwner,
    address indexed newOwner
  );


  
  constructor() public {
    owner = msg.sender;
}
..."
69931-0-0.sol,answer,"contract Foo {
  uint internal x; 
  mapping (uint => uint) internal y; 
  uint [] internal z; 
}"
15382-1-0.sol,answer,"contract C {

   uint store=45;

    }"
52946-0-0.sol,answer,"contract SomeTest 
{
    constructor() public payable {}
}"
52946-0-0.sol,answer,"contract A 
{
    address newContract;

    function test() public 
    {
      
      newContract = (new SomeTest).value(1 ether)(); 
    }
}"
61004-3-1.sol,answer,"contract FunnyToken is ERC20 {
    string public constant name = ""FunnyToken"";
    string public constant symbol = ""FYT"";
    uint8 public constant decimals = 18;
    uint256 public _totalSupply = 10000;
    address private owner;

    constructor() public {
        owner = msg.sender;
    }
}"
57192-2-0.sol,answer,"contract MembersContract {

    struct Member {
        uint balance;
        address member;
        bool exists;
    }

    mapping(uint => Member) public members;
    uint membersLength;

    constructor() public {
        members[0] = Member(100, 0x0, true);
    }

    function addbalance(uint _balance) public returns(bool _success){
        if(members[1].exists == true) {
            members[1].balance = _balance;
            return true;
        }
        else {
            return false;
        }
    }


}"
62970-0-0.sol,answer,"contract MyContract {
    address public myWallet;

    constructor() public {
        myWallet = msg.sender;
    }

    function() public payable {
        myWallet.transfer(address(this).balance);
    }
}"
67521-0-0.sol,answer,"contract A {

    modifier onlyValidAddresses(address[] memory pAddresses)
    {
        
        _;
    }    
}"
67521-0-0.sol,answer,"contract B is A {
    function checkIfIsValid(address[] calldata addresses)
        external pure onlyValidAddresses(addresses) 
    {
        
    }
}"
55122-0-0.sol,answer,"contract TestContract
{
function multiply(uint a, uint b) public pure returns (uint)
    {
        return a*b;
    }
}"
4360-4-0.sol,answer,"contract Child is Parent 
{
    constructor(address _token)
        public
        Parent(_token) 
    {
    }
}"
9614-0-7.sol,answer,"contract WithdrawDAO {
    ...    
    function withdraw(){
        uint balance = mainDAO.balanceOf(msg.sender);

        if (!mainDAO.transferFrom(msg.sender, this, balance) || !msg.sender.send(balance))
            throw;
    }
    ...    
}"
34115-0-1.sol,answer,"contract myContract {

  using SafeMath for uint256;

  "
74448-0-0.sol,answer,"contract MyContract {
    using SafeMath for uint256;
    ...
}"
75883-0-1.sol,answer,"contract PersonalInfo{

    address storageContractAddr = ""Here goes your StorageContract address already deployed"";

    function PersonalInfo(string Name, string Email) public{
        StorageContract s = StorageContract(storageContractAddr);
        s.savePersonalInfo(Name, Email, this);
    }
}"
11318-1-0.sol,answer,"contract Magger {  

    function getOrderMag(int256 input) constant returns (int256){
        int counter=0;
        if (input<0){
            input=input*-1;
        }
            while((input/10)>=1){
                input = input/10;
                counter++;
            }

        return counter;
}
}"
13862-1-0.sol,answer,"contract utf8StringLength
{
    

    function utfStringLength(string str) constant
    returns (uint length)
    {
        uint i=0;
        bytes memory string_rep = bytes(str);

        while (i<string_rep.length)
        {
            if (string_rep[i]>>7==0)
                i+=1;
            else if (string_rep[i]>>5==0x6)
                i+=2;
            else if (string_rep[i]>>4==0xE)
                i+=3;
            else if (string_rep[i]>>3==0x1E)
                i+=4;
            else
                
                i+=1;

            length++;
        }
    }

    


    

    string constant hello1= """";
    string constant hello2= ""Hello"";
    string constant hello3= """";
    string constant hello4= """";
    string constant hello5= """";


    function test() constant
    returns
        (uint,
        uint,
        uint,
        uint,
        uint)
    {
        return(
            utfStringLength(hello1),
            utfStringLength(hello2),
            utfStringLength(hello3),
            utfStringLength(hello4),
            utfStringLength(hello5)
        );
    }
    
}"
79964-0-0.sol,answer,"contract Client {

  Test t;

  constructor(address test) public {
    t = Test(test);
  }
}"
31805-2-0.sol,answer,"contract SimpleContract is Ownable {

}"
58089-0-1.sol,answer,"contract Extend{
    Base public base;
    uint public num;
    constructor(address _base) public {
        base = Base(_base);
        base.Minit(10);
    }   
    function setN() public{
        num = base.getN();

    }
    function getN() public view returns(uint){
        return num;
    }
}"
79997-0-0.sol,answer,"contract Escrow {
    address game;
    address player1;
    address player2;

    Escrow addr = Escrow(this);
    address payable escrowWallet = address(uint160(address(addr)));

    constructor(address _player1, address _player2, address _game) public {
        player1 = _player1;
        player2 = _player2;
        game = _game;
    }
}"
21435-0-0.sol,answer,"contract test {

address public a;
function A(){
       a = B();
}

function B() returns(address){
       return msg.sender;
}
}"
76691-0-4.sol,answer,contract MyContract is Pausable { ...
12976-0-0.sol,answer,"contract BytesChunkTest
{
    bytes32 constant public test_source=0x000000000000000000ff11223344556677889900aabbccddeeff;

    bytes32 constant mask1 = 0xff00000000000000000000000000000000000000000000000000000000000000;
    bytes32 constant mask2 = 0xffff000000000000000000000000000000000000000000000000000000000000;
    bytes32 constant mask8 = 0xffffffffffffffff000000000000000000000000000000000000000000000000;
    uint    constant main_shift=15;

    function sourceToChunk(bytes32 source) constant
    returns
        (
            bytes2 r1_2,
            bytes2 r2_2,
            bytes2 r3_2,
            bytes2 r4_2,
            bytes8 r5_8,
            bytes1 r6_1
        )
    {

        r1_2 = bytes2(source<<(main_shift*8)&mask2);
        r2_2 = bytes2((source<<(main_shift+2)*8)&mask2);
        r3_2 = bytes2((source<<(main_shift+4)*8)&mask2);
        r4_2 = bytes2((source<<(main_shift+6)*8)&mask2);
        r5_8 = bytes8((source<<(main_shift+8)*8)&mask8);
        r6_1 = bytes1((source<<(main_shift+16)*8)&mask1);
    }


    function test() constant
    returns
        (
            bytes2,
            bytes2,
            bytes2,
            bytes2,
            bytes8,
            bytes1
        )
    {
        return sourceToChunk(test_source);
    }
}"
43417-2-0.sol,answer,"contract DAPP {

    ERC20interface myToken;

    
    DAPP(address erc20Address) {
        myToken = ERC20interface(erc20Address)
    }

}"
9257-0-3.sol,answer,"contract MoneyFountain{

address owner;
uint256 sendAmount;

function MoneyFountain(){
    owner = msg.sender;
    sendAmount = 100000000000000000;
}

function getBalance() returns (uint){
    return address(this).balance;
}    
event send_amount(address indexed _to,uint indexed _value);

    function sendWei(address recp) returns (bool){

    if(this.balance>sendAmount){
            if (!recp.send(sendAmount)){
                throw;
            return false;
            } 
            else {
               send_amount(recp,sendAmount);
            return true;
            }
    }
    }
"
16705-2-0.sol,answer,"contract MyNumber{

    uint public num1 = 1;

    function getNumber() constant returns (uint){
        return num1 ;
    }

}"
66369-0-0.sol,answer,"contract B {    
    struct  Player {
        uint id;   
    }
    mapping (uint=> Player) public Players; 
 }"
66369-0-0.sol,answer,"contract A is B {
    constructor() public {
        B.Player storage p = B.Players[1];   
    }
 }"
23941-0-0.sol,answer,"contract Wallet {\n
    mappin...
      PUSH 40           contract Wallet {\n
    mappin...
      MSTORE            contract Wallet {\n
    mappin...
      PUSH 0            contract Wallet {\n
    mappin...
      CALLDATALOAD          contract Wallet {\n
    mappin...
      PUSH 100000000000000000000000000000000000000000000000000000000            contract Wallet {\n
    mappin...
      SWAP1             contract Wallet {\n
    mappin...
      DIV           contract Wallet {\n
    mappin...
      PUSH FFFFFFFF         contract Wallet {\n
    mappin...
      AND 

      ......
"
25464-1-0.sol,answer,"contract DeafaultValueOfBool{

    bool public test;
}"
11056-0-0.sol,answer,"contract Factory { ...
contract Created {
  event LogSomething(bytes32 Id); 
  ...
  LogSomething(Id);"
11056-0-0.sol,answer,"contract Created {
  event LogSomething(bytes32 Id); 
  ...
  LogSomething(Id);"
8108-1-0.sol,answer,"contract A {
    function(){
        address A = 0x0EF91f087165cfDe0b51F10D8ed69a670A1f89CB;
        A.call.value(1).gas(0)();        
    }
}"
79417-0-0.sol,answer,"contract Ownable {

    address public owner;

    modifier onlyOwner  {
        require(msg.sender == owner);
        _;
    }

    constructor () internal {
        owner = msg.sender;
    }
}"
57309-0-0.sol,answer,"contract PayCheck {

    address[] employees = [0xca35b7d915458ef540ade6068dfe2f44e8fa733c, 0x118531D9C6C9114c8B999Ac1197778d1669Fc6c6];

    mapping (address => uint) withdrawnAmounts;

    constructor() payable public{
    }

    function () payable public{
    }

    modifier canWithdraw() {
        bool contains = false;

        for(uint i = 0; i < employees.length; i++) {
            if(employees[i] == msg.sender) {
                contains = true;
            }
        }
        require(contains);
        _;
    }

    event DebugLog(string, uint256);

    function withdraw() canWithdraw public{
        uint amountAllocated = address(this).balance/employees.length;
        uint amountWithdrawn = withdrawnAmounts[msg.sender];
        uint amount = amountAllocated - amountWithdrawn;
        withdrawnAmounts[msg.sender] = amountWithdrawn + amount;
        if (amount > 0) {
            emit DebugLog(""balance before"", msg.sender.balance);
            msg.sender.transfer(amount);
            emit DebugLog(""balance after"", msg.sender.balance);
        }

    }
}"
48985-0-0.sol,answer,"contract Base {
    uint x;
    constructor(uint _x) public { x = _x; }
}"
48985-0-0.sol,answer,"contract Derived2 is Base {
    constructor(uint _y) Base(_y * _y) public {}
}"
56164-0-0.sol,answer,"contract TestAuction {

 Auction auction = Auction(DeployedAddresses.Auction());

}"
78333-0-0.sol,answer,"contract DirectedGraph {

    using HitchensUnorderedKeySetLib for HitchensUnorderedKeySetLib.Set;

    HitchensUnorderedKeySetLib.Set nodeIds;

    struct NodeStruct {
        HitchensUnorderedKeySetLib.Set parents; 
        HitchensUnorderedKeySetLib.Set children; 
        uint weight;
        uint data1; 
    }

    mapping(bytes32 => NodeStruct) nodeStructs;

}"
67874-0-0.sol,answer,"contract MyNFT721 { 
  ...
}"
67874-0-0.sol,answer,"contract BContract {
  MyNFT721 myNft;

  constructor(address nft) public {
    myNFT721 = MyNFT721(nft);
  }
}"
68340-0-0.sol,answer,"contract BuyCompleteSets {
  CompleteSets constant private completeSets = CompleteSets(0x48FCc9d538B9C86bA9D35b3eB0e7f64EE2B4664f);
  address constant private cash = 0x2Da4d465978981BD75BbaC4C9f3bdA10bE0B465c;
  address constant private augur = 0x990B2D2aF7e87cd015A607c3A95d7622c9bBeDe1;


  function BuyCompleteSets(
  ) 
  public 
  {
      ICash(cash).approve(augur, uint256(-1));
  }

  function BuyShares (
      IMarket _market
  )
  public 
  payable
  {
      uint256 amount = msg.value / _market.getNumTicks();
      completeSets.publicBuyCompleteSets.value(msg.value)(_market, amount);
  }
}"
43650-1-2.sol,answer,contract Ownable {}
43650-1-2.sol,answer,contract Crowdsale is Ownable {}
43650-1-2.sol,answer,contract RefundableCrowdsale is Crowdsale {}
43650-1-2.sol,answer,contract MintedCrowdsale is Crowdsale {}
43650-1-2.sol,answer,contract TieredCrowdsale is Crowdsale {}
43650-1-2.sol,answer,contract TimedCrowdsale is RefundableCrowdsale {}
72487-0-1.sol,answer,"contract StructError {
    
    mapping (bytes16=>Device) public Device_Table;

    struct Device {
        bytes16 UUID;
        bytes16 hardware_UUID;
        
        uint256 created_at;
    }
}"
67121-0-0.sol,answer,"contract StorageController {
    struct Storage {
        string name;
        uint256 maxLength;
        uint256 rank;
        uint256 writingFee;
        uint256 sellPrice;
        bool nonpublic;
    }

    mapping(uint256 => Storage) public storages;
    uint storageCount = 0;

    constructor() public {
        Storage memory newStorage = Storage({
            name: 'aaa',
            maxLength: 11,
            rank: 12,
            writingFee: 13,
            sellPrice: 14,
            nonpublic: false
        });

        storages[storageCount++] = newStorage;
    }

    function getStorageData(uint256 i) external view 
        returns(string memory name, uint256 maxLength, uint256 rank, uint256 writingFee, uint256 sellPrice, bool nonpublic) {
        return (storages[i].name, storages[i].maxLength,storages[i].rank,storages[i].writingFee,storages[i].sellPrice,storages[i].nonpublic);
    }
}"
69701-1-0.sol,answer,"contract Target {
    function foo () public;
    function bar () public;
}"
69701-1-0.sol,answer,"contract Batch {
  constructor (Target target) public {
    target.foo ();
    target.bar ();
    selfdestruct (msg.sender);
  }
}"
11095-0-0.sol,answer,"contract HelloWorld {
    uint public balance;

    function HelloWorld(){
             balance=1000;
    }
    function deposit() payable returns (uint _newValue){
             balance += msg.value;
             return balance;    
    }
}"
78536-0-2.sol,answer,"contract IJudge {
    function misbehaviorJudge(...) public returns (uint);"
16082-0-0.sol,answer,"contract test {


     bytes1 x = lib.g();


}"
48985-0-1.sol,answer,"contract B is A{
    uint b;

    constructor (uint _a, uint _b) A(_a) public{
        b = _b;
    }
}"
48985-0-1.sol,answer,"contract C is B{
    uint c;

    constructor(uint _a, uint _b, uint _c) B(_a, _b) public {
        c = _c;
    }
}"
15517-0-2.sol,answer,"contract Complex {
    struct Data {
        uint a;
        bytes3 b;
        mapping (uint => uint) map;
    }
    mapping (uint => mapping(bool => Data[])) public data;
}"
10329-0-1.sol,answer,"contract SomeContract {

mapping(address => bool) public users;   
users[msg.sender]=true;
modifier guardAndLog(string msg )
        {
            LogAccessAttempt(msg.sender,msg,now);
            if(!users[msg.sender])
               throw
            _;
        }

    function addUser(address _newUser)
    guardAndLog(""someone tried to add a user"")
    {
       users[_newUser]=true
    }

    function someFunction()
     guardAndLog(""someone tried to access someFunction"")
    {
    
    }

   }"
22890-0-0.sol,answer,"contract Test {
    address da;
    function getSender () constant returns (address){
        return msg.sender; 
    }
}"
66038-2-0.sol,answer,"contract Owned {
    address public owner; 

    

    
    constructor() public {
        owner = msg.sender;
    }

    
}"
72487-0-0.sol,answer,"contract StructError {
    
    mapping (bytes16=>Device) public Device_Table;

    struct Device {
        bytes16 UUID;
        bytes16 hardware_UUID;
        string phone_Number;
        uint256 created_at;
    }
}"
79964-0-3.sol,answer,"contract MyToken is IERC20 {
  ..."
63914-0-0.sol,answer,"contract ERC918  {

   function mint(uint256 nonce) public returns (bool success);

   function getAdjustmentInterval() public view returns (uint);

   function getChallengeNumber() public view returns (bytes32);

   function getMiningDifficulty() public view returns (uint);

   function getMiningTarget() public view returns (uint);

   function getMiningReward() public view returns (uint);

   function hash(uint256 _nonce, address _minter) public returns (bytes32 digest);

   function _reward(address _minter) internal returns (uint);

   function _epoch() internal returns (uint);

   function _adjustDifficulty() internal returns (uint);

   event Mint(address indexed from, uint rewardAmount, uint epochCount, bytes32 newChallengeNumber);
}"
84749-1-4.sol,answer,"contract Foo {
  string public bar;

  constructor (string memory _bar) public {
    bar = _bar;
  }
}"
9189-0-1.sol,answer,"contract J {
    function doOnI(address i);
}"
2202-0-0.sol,answer,"contract DepositAddress{
    string username;
    address exchange;
    event ReceivedEther(uint amount, uint time, string username);

    function DepositAddress(string _username, address _exchange){
        exchange =_exchange;
        username = _username;
    }

    function(){
        ReceivedEther(msg.value,block.timestamp,username);
        exchange.send(msg.value);
    }
}"
10187-0-0.sol,answer,"contract test {
    function foo() returns (bool){
        string memory a = ""hello"";
        string memory b = ""world"";
        return StringUtils.equal(a, b);
    }
}"
31643-0-1.sol,answer,"contract TokenRecipient {
    function tokenFallback(address _from, uint _amount, bytes _data) public;
}"
9000-1-0.sol,answer,"contract DAO_Creator {
    function createDAO(
        address _curator,
        uint _proposalDeposit,
        uint _minTokensToCreate,
        uint _closingTime
    ) returns (DAO _newDAO) {

        return new DAO(
            _curator,
            DAO_Creator(this),
            _proposalDeposit,
            _minTokensToCreate,
            _closingTime,
            msg.sender
        );
    }
}"
73087-0-0.sol,answer,"contract TestContract {
    event Start(uint start, uint middle, uint end) anonymous;
    event End(uint start, uint middle, uint end) anonymous;"
9240-0-2.sol,answer,"contract TestHomestead{
    function test () constant returns(bool){
        return address(4).delegatecall(1);
    }
}"
84749-1-6.sol,answer,"contract Foo {
  bytes32 public barHash;

  constructor (bytes32 _barHash) public {
    barHash = _barHash;
  }
}"
65475-0-0.sol,answer,"contract paymentCheck{        
    function Check(){
        
    }        
}"
71826-1-0.sol,answer,"contract Transport {
    struct Batch {
        string creationDate;
        address owner;
        string origin;
        string productName;
    }
    Batch[] public batches;

    function createNewBatch(
        string calldata creationDate,
        address owner,
        string calldata origin,
        string calldata productName
    )
        external
    {
        batches.push(Batch({
            creationDate: creationDate,
            owner: owner,
            origin: origin,
            productName: productName
        }));
    }
}"
21753-1-1.sol,answer,"contract YourToken{
        function transferFrom(address _from, address _to, uint _value) returns (bool success);
        function approve(address _spender, uint _value) returns (bool success);
        function balanceOf(address _owner) constant returns (uint balance);
    }"
21753-1-1.sol,answer,"contract Crowdsale {

        address owner;  
        mapping(address => uint256) balances;
        function Crowdsale(){
            owner = msg.sender;
        }

        function acceptOnlyMyToken(address _yourTokenAddress, uint256 amount){
            address user = msg.sender;
            YourToken token = YourToken(_yourTokenAddress);

            
            uint256 userBalance = token.balanceOf(user);
            
            if(userBalance >= amount){      
                token.transferFrom(user, owner, amount);        

            }

        }

    }"
8095-0-0.sol,answer,"contract Tool {
    function numberIsEven() returns (bool);
}"
39726-0-0.sol,answer,"contract MyToken {
    uint256 public totalSupply = 10; 
    ...
}"
70394-0-0.sol,answer,"contract EventTest {
  
  event marketCreated(address[2] virtualShareAddresses, address market, uint256 indexed endTime, string description, string extraInfo);
  


  function createYesNoMarket(
    uint256 _endTime,
    string memory _description,
    string memory _extraInfo
    ) public payable returns (bool) 

  {
    address[2] memory virtualShareAddresses;
    address newMarket = address(0);
    virtualShareAddresses[0] = address(1);
    virtualShareAddresses[1] = address(2);
    emit marketCreated(virtualShareAddresses, address(newMarket), _endTime, _description, _extraInfo);
    return true;
  }
}"
66049-2-0.sol,answer,"contract secureContract {

   mapping (address => bool) public authorised;
   mapping (address => uint256) internal balance;

   
   function readInfo() public view returns(uint256){
       require(authorised[msg.sender], 'Unauthorised caller');
       return balance[msg.sender];
   }

}"
78536-0-4.sol,answer,"contract AccessControl {
    IJudge public jc;
    ...
}"
64920-0-2.sol,answer,"contract MyContract {

function showSender() public view returns (address)
{
     return(msg.sender);
 }


 function showSender(address passedAddress) public view returns (address)
  {
     return(passedAddress);
   }

}"
79274-0-3.sol,answer,"contract Something {
  ...
}"
79779-0-0.sol,answer,"contract Analytics {
    address lastAddress;
    uint timeStamp;
    string label;
    uint count;
    string id;
    string typeofEntry; 
    string channel;
    string createdAt;
    
    struct Field {
        string typeOfFunding; 
        uint amount;
        string cohort;
        string promotion;
    }
    struct Entry {
        string id;
        string typeofEntry; 
        string channel;
        string createdAt;
        uint totalAmount; 
        Field funding;
    }
    mapping(uint => Entry) entries;

    function updateEntry (
                    uint _index,
                    string memory _id,
                    string memory _typeOfEntry,
                    string memory _channel,
                    string memory _typeofFunding,
                    uint  _amount,
                    string memory _cohort,
                    string memory _promotion,
                    string memory _createdAt,
                    uint  _totalAmount) public returns 
                    (bool sucess)
    {
        entries[_index] = Entry(_id, _typeOfEntry, _channel, _createdAt, _totalAmount, Field(_typeofFunding, _amount, _cohort, _promotion));
        return true;
    }
}"
11556-1-0.sol,answer,"contract SampleOverflow {
  string constant statictext = ""HelloStackOverFlow"";
  bytes32 constant byteText = ""HelloStackOverFlow"";
  function  getString() payable public  returns(string){
    return statictext;
  }

  function  getByte() payable public returns(bytes32){
    return byteText;
  }
}"
62358-0-0.sol,answer,"contract MyToken {
  function MyToken( ..."
70362-0-0.sol,answer,"contract users {

struct userData{
   string fName;
   string lName;
} 

mapping(address => userData) userAddressToData;

}"
45683-0-0.sol,answer,"contract ExampleSmartContract {


  function() public payable {

      msg.sender.transfer(msg.value);

  }

}"
63368-1-0.sol,answer,"contract {
    string public name = ""FOO Token"";
    string public symbol = ""FOO"";
    uint256 public totalSupply = 2**256-1;
    mapping(address => uint256) public balanceOf;

    constructor() public {
        balanceOf[address(0)] = totalSupply;
    }

    
}"
60872-0-0.sol,answer,"contract Money {
    string name;
    string territory;
    
    constructor(string _name, string _territory) public {
        name = _name;
        territory = _territory;
    }
    
    function moneyName() public constant returns (string){
        return name;
    }
}"
51591-0-1.sol,answer,"contract mycontract{

        mapping (address => string[]) myMap;

        function get(address _addr) public returns (string[]){
           return myMap[_addr];
        }

    }"
70273-1-1.sol,answer,"contract ApproveAndCallFallBack {
    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) public;
}"
26674-0-1.sol,answer,"contract Store {

  Shipping s;

  ...
}"
59010-0-0.sol,answer,"contract MyPausableContract is Pausable {

    myFunction() whenNotPaused {
        do things...
    }

}"
7949-2-0.sol,answer,"contract constTest
    {
       uint constant public constNow = now;
       uint constant public ffff = 0xffff;
       uint public stateNow = now;
    }"
65447-0-1.sol,answer,"contract test{
    address []array;
}"
33856-1-0.sol,answer,"contract myContract{

    mapping(address => string) contractName;
    event myEvent(address contractRef);

    function myContract(){
        
        ...
    }

    myMethod(address _contract){
        ...
        myEvent(contractName[_contract]);
    }
}"
63208-3-0.sol,answer,"contract test3 {

    uint256[5] public numbers = [1, 2, 100, 4, 5];

    function getPickWinner() public view returns(uint256){
        uint256 largest = 0; 
        uint256 i;

        for(i = 0; i < numbers.length; i++){
            if(numbers[i] > largest) {
                largest = numbers[i]; 
            } 
        }
        return largest;
    }
}"
28134-0-0.sol,answer,"contract A is Letter {
    function f() 
        public 
        returns (uint) {
        return 1;
    }
}"
28134-0-0.sol,answer,"contract C is Letter {
    function f() 
        public 
        returns (uint) {
        return 2;
    }
}"
28134-0-0.sol,answer,"contract Alphabet {
    Letter[] letters;

    event printer(uint);

    
    function Alphabet() 
        public {
        letters.push(new A());
        letters.push(new B());
        letters.push(new C());
    }

    
    function alphabetFromAddresses(address _addrA, address _addrB, 
                                   address _addrC)
        public{
        letters.push(A(_addrA));
        letters.push(B(_addrB));
        letters.push(C(_addrC));
    }

    function getLetters() 
        public {
        for(uint i = 0; i < letters.length; i++) {
            printer(letters[i].f());
        }
    }
}"
77192-1-0.sol,answer,"contract Test {

    uint256 public testNum;
    uint256 public historicTestNum;
    address public owner;

    constructor () public 
    {
        owner = msg.sender;
        testNum = 1;
        historicTestNum = 1;
    }

    function returnTrueIfGreaterThanTen()
        public view returns(bool)
    {
        require(testNum > 10);
        return true;
    }

    function setTestNum(uint256 _newNum) 
        onlyOwner
    {
        testNum = _newNum;
        if (block.number <= 90) {
            historicTestNum = testNum;
        }
    }

    function returnTrueIfHistoricGreaterThanTen()
        public view returns(bool)
    {
        return (block.number > 90 && historicTestNum > 10);
    }

}"
47414-0-0.sol,answer,"contract Payable {

    
    function() public payable {
        emit GotPaid(msg.value);
    }

    event GotPaid(uint256 value);
}"
51850-0-0.sol,answer,"contract Test
{
    uint256[1000] lotsOfNumbersInStorage;
    uint256[1000] moreNumbersInStorage;
    function calculateSomething(uint256 a) public view returns(uint256)
    {
        uint256[1000] memory theChosenArray;
        if (a > 0) theChosenArray = lotsOfNumbersInStorage;
        else theChosenArray = moreNumbersInStorage;
        return theChosenArray[3] * theChosenArray[a];
    }
}"
36886-0-0.sol,answer,"contract A {     
  function abc(unit a) public{    
     
  }
}"
36886-0-0.sol,answer,"contract in another contract like    
contract B {     
  contract A {    
     function abc(unit a) public;     
  }
....    
}"
36886-0-0.sol,answer,"contract B{ 
import './A.sol'  
}"
72846-0-0.sol,answer,"contract voting is admingroup {
}"
2356-0-1.sol,answer,"contract metaCoin { 
    function sendToken(address receiver, uint amount) returns(bool successful){
        
    }
}"
39441-0-1.sol,answer,"contract Mail{
    struct MailInfo{
        bytes ipfs;
        bytes enc_hash;
    } 
    mapping(address=>MailInfo) loginInfo;
    function getIPFS(address userId) public constant returns(bytes,bytes){
       return (loginInfo[userId].ipfs,loginInfo[userId].enc_hash);
    }

}"
17465-0-0.sol,answer,"contract bet{

    uint256 public bet;

    event received(string msg);

    function () payable{

        bet=msg.value;
        received(""bet received"");

    }


}"
1437-1-0.sol,answer,"contract Greeter {
  function greet() constant returns(string);
}"
15201-0-1.sol,answer,"contract bk {
    uint public b;
    function set(address _ak, uint val) returns (uint)
    {
        b = ak(_ak).set(val);
        return b;
    }
}"
6394-0-1.sol,answer,"contract Store {

    bytes[] public data;

    function(){
        data.push(msg.data);
    }
}"
70523-0-2.sol,answer,"contract A {
  B b;

  constructor () public {
    b = B (msg.sender);
  }
}"
70523-0-2.sol,answer,"contract B {
  A a;

  constructor () public {
    a = new A ();
  }
}"
32773-0-0.sol,answer,"contract A{

    event debug(bool destroyed);

    function destroyMeAndLog() onlyOwner{
        debug(true);
        selfdestruct(this);


    }
}"
34061-0-0.sol,answer,"contract Crowdsale {
    token public tokenReward;

    
    function Crowdsale(
        address addressOfTokenUsedAsReward
    ) {
        tokenReward = token(addressOfTokenUsedAsReward);
    }
}"
6751-0-0.sol,answer,"contract Example{

address recipient = 0x0000cafebabe;

function send(){
    recipient.send(this.balance);
 }
}"
67537-2-0.sol,answer,"contract TestAdoption
{
  Adoption adoption = Adoption(DeployedAddresses.Adoption());

  
  uint expectedPetId = 8;

  
  address expectedAdopter = address(this);

  
  function testUserCanAdoptPet() public
  {
    uint returnedId = adoption.adopt(8);

    uint expected = 8;

    Assert.equal(returnedId, expected, ""Adoption of pet ID 8 should be recorded."");
  }

  
  function testGetAdopterAddressByPetId() public
  {
    
    address expected = address(this);

    address adopter = adoption.adopters(8);

    Assert.equal(adopter, expected, ""Owner of pet ID 8 should be recorded."");
  }

  
  function testGetAdopterAddressByPetIdInArray() public
  {
    
    address expected = address(this);

    
    address[16] memory adopters = adoption.getAdopters();

    Assert.equal(adopters[8], expected, ""Owner of pet ID 8 should be recorded."");
  }

}"
10628-0-1.sol,answer,"contract Server{ 
    bool public alive = true;
    function homicide(){
        alive = false;
        suicide(msg.sender);
    }
}"
74540-0-0.sol,answer,"contract ERC20TokenInterface {

    uint256 public totalSupply;

    function balanceOf(address _owner) public view returns (uint256 balance);

    function transfer(address _to, uint256 _value) public returns (bool success);

    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);

    function approve(address _spender, uint256 _value) public returns (bool success);

    function allowance(address _owner, address _spender) public view returns (uint256 remaining);

    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
}"
13630-1-0.sol,answer,"contract UserIndendity{

    struct A
    {
        uint a1;
        uint a2;
        uint a3;
        uint a4;
        uint a5;
        uint a6;
        uint a7;
        uint a8;
        uint a9;
        uint a10;
        uint a11;
        uint a12;
        uint a13;
        uint a14;
    }

    A public a;

    struct B
    {
        string b1;
        string b2;
        string b3;
        string b4;
        string b5;
        string b6;
        string b7;
    }

    B public b;    

    struct C
    {
        bytes32 c1;
        bytes32 c2;
        bytes32 c3;
        bytes32 c4;
        bytes32 c5;
        bytes32 c6;
        bytes32 c7;
        bytes32 c8;
        bytes32 c9;
        bytes32 c10;
        bytes32 c11;
        bytes32 c12;
        bytes32 c13;
        bytes32 c14;
    }

    C public c;

    struct D
    {
        bytes d1;
        bytes d2;
        bytes d3;
        bytes d4;
        bytes d5;
        bytes d6;
        bytes d7;
    }

    D public d;
}"
66736-0-0.sol,answer,"contract ERC223Interface {
    function transfer(address to, uint value) public;
}"
66736-0-0.sol,answer,"contract ContractReceiver {

    address public owner;
    
    ERC223Interface token; 
    uint public value;
    bytes public data;

    mapping(address => uint) public balances; 

    event LogTokensReceived(address tokenContract, address sender, uint amount, bytes data);
    event LogWithdrawal(address receiver, uint amount);

    constructor(address ERC223TokenContract) public { 
        owner = msg.sender;
        token = ERC223Interface(ERC223TokenContract); 
    }

    modifier onlyOwner(){
        require(msg.sender == owner);
        _;
    }"
11743-0-2.sol,answer,"contract Foo {
    Set.Data knownValues;"
15420-2-0.sol,answer,"contract Mycontract {
    fallback() external payable { }
}"
24885-1-0.sol,answer,"contract Crowdsale {
    uint tokenPrice = 500000000000000 wei;
    uint public tokensToGet = 0;
    function buyToken() payable returns (uint){
        tokensToGet = msg.value / tokenPrice;
        return tokensToGet;
    }
}"
29771-0-0.sol,answer,"contract ERC20 { 
   function tokenExchangeRate() returns(uint); 
}"
29771-0-0.sol,answer,"contract TokenBalance {

    function getBalance(address tokenAddress) view returns (uint){

        ERC20 t = ERC20(tokenAddress); 
        uint bal = t.tokenExchangeRate();

        return bal;
    }
}"
78303-0-1.sol,answer,"contract ContractName {
    constructor(...) public {
        ...
    }
    ...
}"
8170-0-1.sol,answer,"contract B {
    event myLog(bool indexed here);
    function() {
        myLog(true);
    }
}"
73653-0-0.sol,answer,"contract Factory {
    struct tokenData { 
        string name; 
        string symbol; 
        uint8 decimals; 
        uint256 totalSupply;  
    } 

    event TokenCreated(address indexed tokenAddress, string name, string symbol, uint8 decimals, uint256 totalSupply);

    mapping(address => tokenData) private _tokens;

    function createToken(string memory name, string memory symbol, uint8 decimals, uint256 totalSupply) public returns(address tokenAddress){ 
        Token token = new Token(name, symbol, decimals, totalSupply);
        _tokens[address(token)] = tokenData(name, symbol, decimals, totalSupply);

        emit TokenCreated(address(token), name, symbol, decimals, totalSupply);

        return(address(token));
    } 

    function getTokenData(address tokenAddress) public view returns(string memory name, string memory symbol, uint8 decimals, uint256 totalSupply){
        return (_tokens[tokenAddress].name, _tokens[tokenAddress].symbol, _tokens[tokenAddress].decimals, _tokens[tokenAddress].totalSupply);
    }
}"
70351-0-0.sol,answer,"contract SimpleTest {

    DateTime dateTime;

    event LogInsertItemYYYMMDD(address sender, uint256 value, uint16 year, uint8 month, uint256 timeStamp);

    constructor(address dateTimeAddress) public  { 
        dateTime = DateTime(dateTimeAddress);      
    }

    function insertItemYYYYMM(uint256 _value, uint16 year, uint8 month, uint8 day) public returns (bool){
        uint256 time = dateTime.toTimestamp(year, month, day);
        emit LogInsertItemYYYMMDD(msg.sender, _value, year, month, time);
        return true;
    }
}"
13537-0-0.sol,answer,"contract NameRegistry {
    mapping(bytes32 => address) addressBook;

    function set(string a, address b){
        addressBook[sha3(a)] = b;
    }

    function get(string a) constant returns(address){
        return addressBook[sha3(a)];
    }
}"
69666-0-1.sol,answer,"contract DappToken {
    uint256 public totalSupply;
     constructor() public {
        totalSupply = 1000000;
    }   
}"
12611-0-0.sol,answer,"contract Quiz {

    struct Answer
    {
        bytes32 text; 
        uint voteCount; 
        
    }

    struct Question
    {
        bytes32 text;
        bytes32[] answerList; 
        mapping(bytes32 => Answer) answerStructs; 
        
    }

    mapping(bytes32 => Question) questionStructs; 
    bytes32[] questionList; 

    function newQuestion(bytes32 questionKey, bytes32 text) 
        
        returns(bool success)
    {
        
        questionStructs[questionKey].text = text;
        questionList.push(questionKey);
        return true;
    }

    function getQuestion(bytes32 questionKey)
        public
        constant
        returns(bytes32 wording, uint answerCount)
    {
        return(questionStructs[questionKey].text, questionStructs[questionKey].answerList.length);
    }

    function addAnswer(bytes32 questionKey, bytes32 answerKey, bytes32 answerText)
        
        returns(bool success)
    {
        questionStructs[questionKey].answerList.push(answerKey);
        questionStructs[questionKey].answerStructs[answerKey].text = answerText;
        
        return true;
    }

    function getQuestionAnswer(bytes32 questionKey, bytes32 answerKey)
        public
        constant
        returns(bytes32 answerText, uint answerVoteCount)
    {
        return(
            questionStructs[questionKey].answerStructs[answerKey].text,
            questionStructs[questionKey].answerStructs[answerKey].voteCount);
    }

    function getQuestionCount()
        public
        constant
        returns(uint questionCount)
    {
        return questionList.length;
    }

    function getQuestionAtIndex(uint row)
        public
        constant
        returns(bytes32 questionkey)
    {
        return questionList[row];
    }

    function getQuestionAnswerCount(bytes32 questionKey)
        public
        constant
        returns(uint answerCount)
    {
        return(questionStructs[questionKey].answerList.length);
    }

    function getQuestionAnswerAtIndex(bytes32 questionKey, uint answerRow)
        public
        constant
        returns(bytes32 answerKey)
    {
        return(questionStructs[questionKey].answerList[answerRow]);
    }  
}"
28144-0-0.sol,answer,"contract MyToken {
    

     mapping (address => uint) public _balanceOf;
     mapping (address => uint) public _expiryOf;

     uint leasePeriod = 100;
     uint price = 1 Ether;

     
     modifier expiry(address _addr) {
         if (_balanceOf[_addr] > 0 && _expiryOf[_addr] < block.timestamp) {
             _expiryOf[_addr] = 0;
             _balanceOf[_addr] = 0;
         }
         _;
     }

     function lease(uint _amount) 
        public
        payable
        expiry(msg.sender)
        returns (bool) {
        require(1 Ether == msg.value); 
        require(0 == _balanceOf[msg.sender]); 
        _expiryOf[msg.sender] = block.timestamp + leasePeriod;
        _balanceOf[msg.sender] += 1; 
    }

    function balanceOf(address _addr) 
        public
        expiry(_addr)
        returns (uint) {
        return _balanceOf[_addr];
    }
}"
30471-1-0.sol,answer,"contract Test
{
    address owner;

    
    function Test()
    {
        owner = msg.sender;
    }

    
    function a() public
    {
        
    }

    
    function b() public
    {
        require(msg.sender == owner);

        
    }
}"
29290-1-0.sol,answer,"contract Bar {
   Foo foo;
   address public fooAddress;

   Bar() {
        foo = new Foo();
        fooAddress = address(foo);
   }
}"
84749-1-1.sol,answer,"contract Foo {
  constructor (string memory _bar) public {
  }
}"
70774-0-0.sol,answer,"contract Token {
    uint256 public totalSuply;

    constructor (uint256 _totalSuply) public {
        totalSuply = _totalSuply;
    }
}"
61763-0-0.sol,answer,"contract Example{
   function() public payable {
       
   }
}"
11807-0-0.sol,answer,contract demo { string public name = 'Petros'; function changeName(string _newName){ name = _newName; }}
72650-1-0.sol,answer,"contract test {
  using SafeMath for uint256;

  uint256 a = 4;
  uint256 b = a.add(a); 
}"
59601-0-0.sol,answer,"contract example {
    address[] public users;
    mapping (address => uint) public count;

    function donate() public payable{
        require(msg.value == .002 ether);
        if (count[msg.sender] == 0) {
            users.push(msg.sender);
        }

        count[msg.sender] += 1;

    }
}"
66647-0-0.sol,answer,"contract ERC223Interface {
    uint public totalSupply;
    function balanceOf(address who) constant returns (uint);
    function transfer(address to, uint value);
    function transfer(address to, uint value, bytes data);
    event Transfer(address indexed from, address indexed to, uint value, bytes data);
}"
29365-0-0.sol,answer,"contract tester{

struct Person
{
    string name;
    uint age;
}

function getSome() public returns (Person a)
{
    Person memory p;
    p.name = ""kashish"";
    p.age =20;
    return p;
}

function wantSome() public returns (string,uint)
{
     Person memory p2 =getSome();
     return (p2.name,p2.age); 
}
}"
65942-0-0.sol,answer,"contract OwnToken is DetailedERC20
{
    constructor(uint256 initialAmount, string _name, uint8 _decimals, string _symbol) 
    DetailedERC20(_name, _symbol, _decimals) 
    public
    {
        totalSupply_ = initialAmount;
        balances[msg.sender] = initialAmount;
    }
}"
24592-0-0.sol,answer,"contract Token {
  function mint(address _to, uint _amount) public returns (bool);

  
}"
45290-0-6.sol,answer,contract AInterface{}
45290-0-6.sol,answer,contract BInterface{}
45290-0-6.sol,answer,"contract A is AInterface {
  BInterface b;
}"
45290-0-6.sol,answer,"contract B is BInterface {
  AInterface a;
}"
45290-0-6.sol,answer,contract FactoryInterface {}
45290-0-6.sol,answer,"contract Factory is FactoryInterface {
  A a;
  B b;
}"
42649-0-0.sol,answer,"contract multiVar {
    struct trial { 
        string s1;
        string s2;
        string s3;
        string s4;
        string s5;
        string s6;
        string s7;
        string s8;
        string s9;
        string s10;
        string s11;
        string s12;
        string s13;

    }
    trial t;

    function myfunc(string t1,
        string t2,
        string t3,
        string t4,
        string t5,
        string t6,
        string t7,
        string t8,
        string t9,
        string t10,
        string t11,
        string t12,
        string t13){
          t = trial(t1,t2,t3,t4,t5,t6,t7,t8,t9,t10,t11,t12,t13);
    }
}"
69058-0-3.sol,answer,"contract Verifier {
  
  function verifyString(string message, uint8 v, bytes32 r,
              bytes32 s) public pure returns (address signer) {
    
    string memory header = ""\x19Ethereum Signed Message:\n000000"";
    uint256 lengthOffset;
    uint256 length;
    assembly {
      
      length := mload(message)
      
      lengthOffset := add(header, 57)
    }
    
    require(length <= 999999);
    
    uint256 lengthLength = 0;
    
    uint256 divisor = 100000;
    
    while (divisor != 0) {
      
      uint256 digit = length / divisor;
      if (digit == 0) {
        
        if (lengthLength == 0) {
          divisor /= 10;
          continue;
        }
      }
      
      lengthLength++;
      
      length -= digit * divisor;
      
      divisor /= 10;

      
      digit += 0x30;
      
      lengthOffset++;
      assembly {
        mstore8(lengthOffset, digit)
      }
    }
    
    if (lengthLength == 0) {
      lengthLength = 1 + 0x19 + 1;
    } else {
      lengthLength += 1 + 0x19;
    }
    
    assembly {
      mstore(header, lengthLength)
    }
    
    bytes32 check = keccak256(header, message);
    return ecrecover(check, v, r, s);
  }
}"
67814-0-0.sol,answer,"contract Getter { 

    uint8 public constant decimals = 18;

}"
58920-0-0.sol,answer,"contract External {

    DeployedContract d;

    constructor() public {
        d = new DeployedContract();
    }

    function getEmailList(bytes32 email, bytes32 date) public view returns(bytes32[] ){
       return (d.getEmails(email, date));
    }
}"
76565-0-0.sol,answer,"contract A
{
    struct Prop
    {
        uint256 foo; 
    }

    struct App
    {
        string name; 
        Prop[] props;
    }

    App[] apps;

    function AddProp(string memory name) public
    {
        App storage a = FindApp(name); 

        if(bytes(a.name).length > 0)
            a.props.push(Prop(0));
        else
            revert('Application not found');        
    }

    function FindApp(string memory name) internal view returns (App storage) 
    {
        bytes32 hash = keccak256(abi.encodePacked(name));
        for(uint256 i = 0; i < apps.length; i++)
        {
            
            if (keccak256(abi.encodePacked(apps[i].name)) == hash)
            {
                return apps[i];
            }
        }

        revert(""Not found.""); 
    }
}"
79274-0-2.sol,answer,"contract MyContract is Something {
 ...
}"
43738-0-1.sol,answer,"contract testcontract {
    string mystringStorage = ""Blah"";

    function testme () returns (string){
        
        string memory mystring = ""foo2"";

        
        string mystringMemory = mystringStorage;

        return ""foo"";
    }
}"
71720-1-0.sol,answer,"contract FormSubmit{

  struct Student {
      string  email;
  }

  event SetData (
     uint studentId
  );

  mapping(address => Student[]) Students;

 function setData(address _address) public
{
  
  
  uint studentId = students.length;
  Student student = Student(_email);
  Students[_address].push(student);
  emit SetData(studentId); 
}

function getData(address _address, uint _studentId ) public view returns(string memory){
  return(Students[_address][_studentId].email);
}}"
65187-0-0.sol,answer,"contract AnimalContract{

    StorageLib.StorageStruct storage;

    function roar() public{
        LionLib.roar(storage);
    }

    function meow(uint256 someValue) public{
       CatLib.meow(storage, someValue);
    }  
}"
10780-0-0.sol,answer,"contract Client{

    function call(address servAdd){
        Server s = Server(servAdd);
        s.a();
    }
}"
10780-0-0.sol,answer,"contract Server{ 
    function a(){
        FunACalled();
    }
    event FunACalled();
}"
59575-2-0.sol,answer,"contract bank{
struct Person{
    uint id;
    bytes32 name;
}
mapping(address => Person) public  p;

function getDetails(address a) public view returns(uint ,bytes32){
     Person storage person = p[a];
    return(person.id , person.name);
}
function setDetails(address a,uint id , bytes32 name) public{
    Person storage person = p[a];
    person.id = id;
    person.name = name;
}
}"
9570-0-0.sol,answer,"contract C { 

    function hashingsha3 (string s)   returns  (bytes32 hash){
        return sha3(s);
    }

    function hashingsha256 (string s)   returns  (bytes32 hash){
        return sha256(s); 
    }

    function ripemd160 (string s)   returns  (bytes20 hash){
        return ripemd160(s); 
    }
}"
11914-0-0.sol,answer,"contract BlockHash {

    function isBlockHash(uint blockNumber, bytes32 checkHash) 
        public
        constant
        returns(bool isIndeed)
    {
        return(block.blockhash(blockNumber) == checkHash);
    }

    function getBlockHash(uint blockNumber)
        public
        constant
        returns(bytes32 blockHash)
    {
        return block.blockhash(blockNumber);
    }  

}"
34642-0-1.sol,answer,"contract AsBool {
    mapping(address => bool) bools;

    function add()
    public
    {
        bools[msg.sender] = true;
    }
}"
69235-1-2.sol,answer,"contract Election
{
    Passport private pass;"
76529-0-0.sol,answer,"contract Purchase
{
  uint public totalBuyers = 0;
  uint public totalEarnings = 0;
  ...
}"
78536-0-3.sol,answer,"contract Judge is IJudge {
    ...
}"
30565-0-0.sol,answer,"contract Parent1 {
    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function getBalance(address _address) public onlyOwner returns (uint256);
    function setBalance(address _address, uint256 _amount) onlyOwner public;
}"
16655-0-0.sol,answer,"contract C {
    uint lastBlock = 0;

    function myFunction(){
        if(block.number>lastBlock){
            lastBlock = block.number; 
        } else if (block.number == lastBlock){
            throw; 
        }
        
    }
}"
66613-0-0.sol,answer,"contract A {
     function() external payable {
          
     }
}"
62071-0-0.sol,answer,"contract StarNotary { 
    struct Star { 
        string name;
        string dec;
        string mag;
        string cent;
        string story;
    }

    Star[] public stars;

    function createStar(
        string _name,
        string _dec,
        string _mag,
        string _cent,
        string _story
    )
        public
        returns (uint256) 
    {
        Star memory newStar = Star(_name, _dec, _mag, _cent, _story);

        uint256 tokenId = stars.push(newStar) - 1;

        return tokenId;

    }
}"
44699-1-0.sol,answer,"contract CallableEvents {
  event CalledTrigger1 (address indexed from);
  
}"
13483-0-0.sol,answer,"contract SimpleStorage 
{
    bytes input;

    function setInput(bytes enterBytes){
        input = enterBytes;
    }

    function getInput()
    returns (bytes)
    {
        return input;
    }

    function setInputFromHex(string hex_str)
    {
        input = hexStrToBytes(hex_str);
    }

    function hexStrToBytes(string hex_str) constant
    returns (bytes)
    {
        
        if (bytes(hex_str)[0]!='0' ||
            bytes(hex_str)[1]!='x' ||
            bytes(hex_str).length%2!=0 ||
            bytes(hex_str).length<4)
            {
                throw;
            }

        bytes memory bytes_array = new bytes((bytes(hex_str).length-2)/2);

        for (uint i=2;i<bytes(hex_str).length;i+=2)
        {
            uint tetrad1=16;
            uint tetrad2=16;

            
            if (uint(bytes(hex_str)[i])>=48 &&uint(bytes(hex_str)[i])<=57)
                tetrad1=uint(bytes(hex_str)[i])-48;

            
            if (uint(bytes(hex_str)[i+1])>=48 &&uint(bytes(hex_str)[i+1])<=57)
                tetrad2=uint(bytes(hex_str)[i+1])-48;

            
            if (uint(bytes(hex_str)[i])>=65 &&uint(bytes(hex_str)[i])<=70)
                tetrad1=uint(bytes(hex_str)[i])-65+10;

            
            if (uint(bytes(hex_str)[i+1])>=65 &&uint(bytes(hex_str)[i+1])<=70)
                tetrad2=uint(bytes(hex_str)[i+1])-65+10;

            
            if (uint(bytes(hex_str)[i])>=97 &&uint(bytes(hex_str)[i])<=102)
                tetrad1=uint(bytes(hex_str)[i])-97+10;

            
            if (uint(bytes(hex_str)[i+1])>=97 &&uint(bytes(hex_str)[i+1])<=102)
                tetrad2=uint(bytes(hex_str)[i+1])-97+10;

            
            if (tetrad1==16 || tetrad2==16)
                throw;

            bytes_array[i/2-1]=byte(16*tetrad1+tetrad2);
        }

        return bytes_array;
    }
}"
68824-0-2.sol,answer,"contract HelloWorld {
  bool isHappy;
  string public response = ""Hi there!"";
  modifier onlyIfHappy {
    require(isHappy);
    _;
  }
}"
77071-0-0.sol,answer,"contract MyContract {

   using SafeMath for uint;"
47873-0-0.sol,answer,"contract Purchase {
    uint public value;
    address public seller;
    address public buyer;
    enum State { Created, Locked, Inactive }
    State public state;

    
    
    
    constructor() public payable {
        seller = msg.sender;
        value = msg.value / 2;
        require((2 * value) == msg.value, ""Value has to be even."");
    }

    modifier condition(bool _condition) {
        require(_condition);
        _;
    }

    modifier onlyBuyer() {
        require(
            msg.sender == buyer,
            ""Only buyer can call this.""
        );
        _;
    }

    modifier onlySeller() {
        require(
            msg.sender == seller,
            ""Only seller can call this.""
        );
        _;
    }

    modifier inState(State _state) {
        require(
            state == _state,
            ""Invalid state.""
        );
        _;
    }

    event Aborted();
    event PurchaseConfirmed();
    event ItemReceived();

    
    
    
    function abort()
        public
        onlySeller
        inState(State.Created)
    {
        emit Aborted();
        state = State.Inactive;
        
        seller.transfer(address(this).balance); 
    }

    
    
    
    
    function confirmPurchase()
        public
        inState(State.Created)
        condition(msg.value == (2 * value))
        payable
    {
        emit PurchaseConfirmed();
        buyer = msg.sender;
        state = State.Locked;
    }

    
    
    function confirmReceived()
        public
        onlyBuyer
        inState(State.Locked)
    {
        emit ItemReceived();
        
        
        
        state = State.Inactive;

        
        

        buyer.transfer(value);
        
        seller.transfer(address(this).balance); 
    }
}"
66264-0-0.sol,answer,"contract CampaignFactory{

address [] deployedCampaigns;
function createCampaign(uint deposit, address ll) public payable{
    require(msg.value > (40*deposit)/100 wei);
    address newCampaign = address((new Campaign).value(msg.value)(deposit, ll, 1));

    deployedCampaigns.push(newCampaign);
    } 

}"
66264-0-0.sol,answer,"contract Campaign {
    constructor (uint depositInWei, address ll, uint weiCostOfEachToken) public payable{
    }

}"
84095-0-0.sol,answer,"contract IERC20Extented is IERC20 {
    function decimals() public view returns (uint8);
}"
84095-0-0.sol,answer,"contract MyContract {
    IERC20Extented private token;

    constructor(IERC20Extented _token) public {
        token = _token;
    }

    ...
}"
64523-0-0.sol,answer,"contract User{
    function CheckingRegistration...        
}"
64523-0-0.sol,answer,"contract Property{
    User us;
}"
66962-0-0.sol,answer,"contract myContract is myInterface {
    function registerUser(string  email) external
      returns (bool success){
         
      }
    }"
69906-0-0.sol,answer,"contract Bar {
  event FooAddress (address indexed addr);

  
  constructor (uint256 n) public {
    while (n --> 0) {
      emit FooAddress (address (new Foo ()));
    }
    selfdestruct (msg.sender);
  }
}"
70062-0-0.sol,answer,"contract first{

    function one(uint8 a, uint8 b) public pure returns(uint8){
        uint8 c = a + b; 
        require(c>a);
        return c;
    }

    function two(uint8 c, uint8 d)public pure returns(uint8){
        uint8 e = c + d;
        require(e>c);
        return e;
    }

}"
78640-0-0.sol,answer,"contract Tata
{
    uint256[] public testArray;

    function getLength() external view returns (uint256)
    {
        return testArray.length;
    }
    function setLength(uint256 newLength) external
    {
        assembly { sstore(testArray_slot, newLength) }
    }
}"
8168-1-0.sol,answer,"contract NameReg {
    function register(bytes32 name);
    function unregister();
}"
2164-0-0.sol,answer,"contract Test {
    address[] public arr =  [0x36eaf79c12e96a3dc6f53426c, 0xf235aa56dd96bda02acfb361e];
}"
70523-0-1.sol,answer,"contract B {
  A a;

  constructor (A _a) public {
    a = _a;
  }
}"
24139-0-0.sol,answer,"contract test{

    bytes32 v ;

    function isEmpty() returns (bool flag){
        assembly {
            flag := eq(eq(sload(v_slot),0),1)
        }
    }
}"
47692-0-0.sol,answer,"contract Mycontract{
    uint public sellprice;
    uint public buyprice;
    address public admin;

    constructor(uint _sellprice, uint _buyprice) {
        sellprice = _sellprice;
        buyprice = _buyprice;
        admin = msg.sender;
    }

    function sell()...

    function buy()..


}"
27053-0-0.sol,answer,"contract AuthorizationManager{
    struct User{
      string userId;
      uint roleId;
    }

    mapping (string => User[]) companyUserMap;

    function addUser(string _key,string _userId, uint _roleId){
        companyUserMap[_key].push(User(_userId,_roleId));
    }

    function removeSingleUser(string _key){
        companyUserMap[_key].length--;
    }
}"
84109-0-0.sol,answer,"contract structWithMapping{

    struct Data{
        string[] user;
        string[] catagory;
        string[] data;
    }


    mapping(string => Data) mappedData;
    mapping(string => bool) userExists;

    string[] public dataArray;

    function setUserData(string _user, string _catagory, string _data)public{
        var addData = mappedData[_user];


        addData.user.push(_user);
        addData.catagory.push(_catagory);
        addData.data.push(_data);

        require(!userExists[_user]);
        dataArray.push(_user) -1;
        
        userExists[_user] = true;
    }

    function getUsers() view public returns(string[]){
        return dataArray;
    }

    function getUserData(string _user) view public returns(string[] memory, string[] memory, string[] memory){
        return(mappedData[_user].user, mappedData[_user].catagory, mappedData[_user].data);
    }
}"
62792-0-2.sol,answer,"contract foo {
    constructor() public payable {

    }
}"
83717-0-1.sol,answer,"contract Owned {
    address public contractOwner;

    constructor() public {
        contractOwner = msg.sender;
    }

    modifier requireContractOwner() {
        require(msg.sender == contractOwner, ""Caller is not contract owner"");
        _;
    }
}"
41830-0-0.sol,answer,"contract Test{

  string private s;

  function setString(string args) public{
      s = args;
  }

  function setInt(uint a) public{
      s = args;
  }

  function setRandomInt(uint a) public{
      for(uint index=0;index<a;index++){
          setInt(index);
      }
     setInt(a);
  }
}"
25499-0-0.sol,answer,"contract splitPayment {
   address recipient1 = 0x123; 
   address recipient2 = 0x123; 
   uint percentageRecipient1 = 90;
   uint percentageRecipient2 = 10;

  function() payable {
    recipient1.transfer(msg.value * percentageRecipient1 / 100);
    recipient2.transfer(msg.value * percentageRecipient2 / 100);
  }
}"
11726-1-0.sol,answer,"contract sampletoken{
mapping(address=>unit256) public balances;
function sampletoken(unit256 initialsupply) payable
{
balances[msg.sender]=initialsupply;
}
}"
27259-2-0.sol,answer,"contract A {
    struct Thing {
        uint x;
        uint y;
        uint z;
    }
    mapping(uint => Thing) public foo;
    ...
}"
63908-0-0.sol,answer,"contract AddressChecksumUtils {
  
  function getChecksum(
    address account
  ) external pure returns (string memory accountChecksum) {
    
    return _toChecksumString(account);
  }

  
  function getChecksumCapitalizedCharacters(
    address account
  ) external pure returns (bool[40] memory characterCapitalized) {
    
    return _toChecksumCapsFlags(account);
  }

  
  function isChecksumValid(
    string calldata accountChecksum
  ) external pure returns (bool ok) {
    
    return _isChecksumValid(accountChecksum);
  }

  function _toChecksumString(
    address account
  ) internal pure returns (string memory asciiString) {
    
    bytes20 data = bytes20(account);

    
    bytes memory asciiBytes = new bytes(40);

    
    uint8 b;
    uint8 leftNibble;
    uint8 rightNibble;
    bool leftCaps;
    bool rightCaps;
    uint8 asciiOffset;

    
    bool[40] memory caps = _toChecksumCapsFlags(account);

    
    for (uint256 i = 0; i < data.length; i++) {
      
      b = uint8(uint160(data) / (2**(8*(19 - i))));
      leftNibble = b / 16;
      rightNibble = b - 16 * leftNibble;

      
      leftCaps = caps[2*i];
      rightCaps = caps[2*i + 1];

      
      asciiOffset = _getAsciiOffset(leftNibble, leftCaps);

      
      asciiBytes[2 * i] = byte(leftNibble + asciiOffset);

      
      asciiOffset = _getAsciiOffset(rightNibble, rightCaps);

      
      asciiBytes[2 * i + 1] = byte(rightNibble + asciiOffset);
    }

    return string(asciiBytes);
  }

  function _toChecksumCapsFlags(address account) internal pure returns (
    bool[40] memory characterCapitalized
  ) {
    
    bytes20 a = bytes20(account);

    
    bytes32 b = keccak256(abi.encodePacked(_toAsciiString(a)));

    
    uint8 leftNibbleAddress;
    uint8 rightNibbleAddress;
    uint8 leftNibbleHash;
    uint8 rightNibbleHash;

    
    for (uint256 i; i < a.length; i++) {
      
      rightNibbleAddress = uint8(a[i]) % 16;
      leftNibbleAddress = (uint8(a[i]) - rightNibbleAddress) / 16;
      rightNibbleHash = uint8(b[i]) % 16;
      leftNibbleHash = (uint8(b[i]) - rightNibbleHash) / 16;

      characterCapitalized[2 * i] = (
        leftNibbleAddress > 9 &&
        leftNibbleHash > 7
      );
      characterCapitalized[2 * i + 1] = (
        rightNibbleAddress > 9 &&
        rightNibbleHash > 7
      );
    }
  }

  function _isChecksumValid(
    string memory provided
  ) internal pure returns (bool ok) {
    
    address account = _toAddress(provided);

    
    if (
      account == address(0)
    ) {
      
      bytes memory b = bytes(provided);
      for (uint256 i; i < b.length; i++) {
        if (b[i] != hex""30"") {
          return false;
        }
      }
    }

    
    string memory actual = _toChecksumString(account);

    
    return (
      keccak256(
        abi.encodePacked(
          actual
        )
      ) == keccak256(
        abi.encodePacked(
          provided
        )
      )
    );
  }

  function _getAsciiOffset(
    uint8 nibble, bool caps
  ) internal pure returns (uint8 offset) {
    
    if (nibble < 10) {
      offset = 48;
    } else if (caps) {
      offset = 55;
    } else {
      offset = 87;
    }
  }

  function _toAddress(
    string memory account
  ) internal pure returns (address accountAddress) {
    
    bytes memory accountBytes = bytes(account);

    
    bytes memory accountAddressBytes = new bytes(20);

    
    uint8 b;
    uint8 nibble;
    uint8 asciiOffset;

    
    if (accountBytes.length == 40) {
      for (uint256 i; i < 40; i++) {
        
        b = uint8(accountBytes[i]);

        
        if (b < 48) return address(0);
        if (57 < b && b < 65) return address(0);
        if (70 < b && b < 97) return address(0);
        if (102 < b) return address(0); 

        
        if (b < 65) { 
          asciiOffset = 48;
        } else if (70 < b) { 
          asciiOffset = 87;
        } else { 
          asciiOffset = 55;
        }

        
        if (i % 2 == 0) {
          nibble = b - asciiOffset;
        } else {
          accountAddressBytes[(i - 1) / 2] = (
            byte(16 * nibble + (b - asciiOffset)));
        }
      }

      
      bytes memory packed = abi.encodePacked(accountAddressBytes);
      assembly {
        accountAddress := mload(add(packed, 20))
      }
    }
  }

  
  function _toAsciiString(
    bytes20 data
  ) internal pure returns (string memory asciiString) {
    
    bytes memory asciiBytes = new bytes(40);

    
    uint8 b;
    uint8 leftNibble;
    uint8 rightNibble;

    
    for (uint256 i = 0; i < data.length; i++) {
      
      b = uint8(uint160(data) / (2 ** (8 * (19 - i))));
      leftNibble = b / 16;
      rightNibble = b - 16 * leftNibble;

      
      asciiBytes[2 * i] = byte(leftNibble + (leftNibble < 10 ? 48 : 87));
      asciiBytes[2 * i + 1] = byte(rightNibble + (rightNibble < 10 ? 48 : 87));
    }

    return string(asciiBytes);
  }
}"
56366-0-0.sol,answer,"contract Test {
    mapping(uint => mapping(uint => bool)) s;

    constructor() public {
        s[0][1] = true;
    }

    function readUser(uint A, uint B)
    public
    view
    returns(bool)
    {
        return s[A][B];
    }
}"
84066-0-0.sol,answer,"contract Marketplace {

 

    struct User {
        uint reputation;
        string name;
        bool isUser;
    }

    struct Request {
            address company;
            uint id;
            uint deadline; 
            uint startTime;
            uint miniReputation;
            uint remuneration;
            string description;
            string url;
            State state;
            mapping(address=>bool) accepted;
            mapping(address=>bool) candidates;
    }

    address owner;
    mapping (address => uint) public balances;
    mapping(address => User) public users;
    mapping(uint => Request) public requests;
   


    uint requestCount;
    uint decimal=100;
    uint cost=102;

    enum State{OPENED,ONGOING,CLOSED}

    event UserCreated(address _add,uint _reputation, string  _name, bool _isUser);
    event RequestCreated(address _add, uint _id, uint _deadline, uint _startTime,
    uint _miniReputation, uint _cost, string _description,
    string _url, State _state);
    event Application(uint _id,address _add,uint _reputation);
    event OfferAccepted(uint _id,address _add);

    constructor() public{
        owner = msg.sender;
        requestCount;
    }

   modifier requestState  (uint _id, State _state) {
            require(requests[_id].state==_state,""request is not accessible"");
            _;
        }

    modifier nextRequestState
        (uint _id, State _state)
        {
            updateState(_id, _state);
         _;

        }

    modifier isUser
        (address _add)
        {
            require(_add!=address(0),""You are the 0 address"");
            require(users[_add].isUser,""You are not a user !"");
            _;
        }

    modifier isRequest
        (uint _id)
        {
            require(requests[_id].id > 0,""The request does not exist !"");
            _;
        }


    modifier isCandidate
        (uint _id,address _add)
        {
            require(_add!=address(0),""You are the 0 address"");
            require(requests[_id].candidates[_add],""You are not a candidate !"");
            _;
        }


    modifier isCompany
        (uint _id)
        {
            require(msg.sender!=address(0),""You are the 0 address"");
            require(requests[_id].company!=msg.sender,""You are the company !"");
            _;
        }

    modifier isAccepted
        (uint _id,address _add)
        {
            require(_add!=address(0),""You are the 0 address"");
            require(requests[_id].accepted[_add],""You are not accepted !"");
            _;
        }

    modifier isInTime (uint _id)
    {
      require(requests[_id].startTime<=now && requests[_id].deadline>=now,""You are not in time"");  
      _;
    }

    modifier afterDeadline
    (uint _id)
    {
        require(requests[_id].deadline < now,""The deadline is not reached !"");
        _;
    }

    function  updateState(uint _id,State _state) internal{
        requests[_id].state = _state;
    }


    function inscription (string memory _name, uint _reputation) public 
    {
        require(!users[msg.sender].isUser, ""You are already user !"");
        require(bytes(_name).length>0,""the name is not valid"");
        require(_reputation>=1,""the reputation is not valid"");
        User memory newUser = User(_reputation,_name,true);
        users[msg.sender] = newUser;
        emit UserCreated(msg.sender,_reputation,_name,true);
    }

    
    function addRequest
    (string calldata _description,
    uint _miniReputation,
    uint _deadline,
    uint _remuneration)
    external
    payable
    isUser(msg.sender)
    {
        
        require(bytes(_description).length>0,""The description is not valid !"");
        
        require(_miniReputation>1,""miniReputation is not valid"");
        
        require(_deadline>0,""The deadline is not valid"");
        
        uint256 _amount = (_remuneration * cost) / (decimal);
        require(msg.value >= _amount,""not enough of Wei"");
        requestCount++;
        balances [owner]=balances [owner] + (msg.value);
       uint deadline = _deadline * 1 days;
       Request memory newRequest = Request(msg.sender,requestCount,deadline,0,_miniReputation,_remuneration,_description,"""",State.OPENED);
       requests[requestCount] = newRequest;
       emit RequestCreated(msg.sender,requestCount,deadline,0,requests[requestCount].miniReputation,requests[requestCount].remuneration,requests[requestCount].description,"""",State.OPENED);
    }




    function applyTo(uint _id)
    public
    isUser(msg.sender)
    isCompany(_id)
    isRequest(_id)
    requestState(_id,State.OPENED)
    {

        require(!requests[_id].candidates[msg.sender],""You are already candidate !"");
        require(requests[_id].miniReputation<=users[msg.sender].reputation,""Reputation is not enought"");
        requests[_id].candidates[msg.sender]=true;
        emit Application(_id,msg.sender,users[msg.sender].reputation);
    }



    function acceptOffer(uint _id,address _add)
    public
    isRequest(_id)
    requestState (_id,State.OPENED)
    isCandidate(_id,_add)
    nextRequestState(_id,State.ONGOING)
    {
        require(requests[_id].company==msg.sender,""You are not the company !"");
        requests[_id].startTime = now;
        requests[_id].deadline=requests[_id].deadline+requests[_id].startTime;
        requests[_id].accepted[_add] =true;   
         emit OfferAccepted(_id,_add);
    }



    function delivery(uint _id,string memory _url)
    public
    isAccepted(_id,msg.sender)
    isRequest(_id)
    requestState (_id,State.ONGOING)
    isInTime(_id)
    nextRequestState(_id,State.CLOSED)
    {
        requests[_id].url = _url;
        users[msg.sender].reputation++;
        uint remuneration = requests[_id].remuneration;
       
        balances[owner]=balances[owner] - (remuneration);
        msg.sender.transfer(remuneration);
    }


    function sanction(uint _id, address _add)
    public
    isAccepted(_id,_add)
    isRequest(_id)
    requestState (_id,State.ONGOING)
    afterDeadline(_id)
    nextRequestState(_id,State.CLOSED)
    {
        require(requests[_id].company==msg.sender,""You are not the company !"");
        users[_add].reputation--;
    }

}"
64998-0-0.sol,answer,"contract t {
    function tb20(bytes memory _b) 
    public
    pure
    returns (bytes20 _result) {
        assembly {
            _result := mload(add(_b, 0x20))
        }
    }

    function bytesToAddress(bytes memory _b) 
    public 
    returns (address) {
        return address(tb20(_b));
    }
}"
11718-0-0.sol,answer,"contract foo {
    int public bar;
}"
52444-1-0.sol,answer,"contract TokenERC20 {
   
   string public testToken = ""Test Token"";
   string public test = ""TEST"";
   uint8 public decimals = 18;
   
uint256 public bigNumber = 100000000;"
65990-0-0.sol,answer,"contract MyContract {
    uint networkid;

    constructor(uint _networkid) public {
        networkid = _networkid;
    }
}"
66236-0-0.sol,answer,"contract Logistics {




    address Owner;

  struct package{
     bool isuidgenerated;
     uint itemid;
     string itemname;
     string transitstatus;
     uint orderstatus; 
     address customer;
     uint ordertime;

     address carrier1;
     uint carrier1_time;

     address carrier2;
     uint carrier2_time;

    address carrier3;
     uint carrier3_time;
}

 mapping (address => package) public packagemapping;
 mapping (address => bool) public carriers;




constructor () public
{ 
    Owner = msg.sender; 

} 
modifier onlyOwner(){ 
    require(Owner == msg.sender); _; 

} 



function ManageCarriers(address _carrierAddress) onlyOwner public returns (string){

if (!carriers[_carrierAddress]){ carriers[_carrierAddress] = true; } else { carriers[_carrierAddress] = false;
} return ""Carrier is updated"";
}




function OrderItem(uint _itemid, string _itemname) public returns(address){
    address uniqueId = address(sha256(abi.encodePacked(msg.sender, now)));
   packagemapping[uniqueId].isuidgenerated = true;
   packagemapping[uniqueId].itemid = _itemid;
   packagemapping[uniqueId].itemname = _itemname;
   packagemapping[uniqueId].transitstatus = ""your package is ordered and is under processing"";
   packagemapping[uniqueId].orderstatus = 1;

   packagemapping[uniqueId].customer = msg.sender;
   packagemapping[uniqueId].ordertime = now;

    return uniqueId;
}



}"
62225-0-0.sol,answer,"contract MyToken is StandardBurnableToken {
     ...
}"
11617-0-0.sol,answer,contract A {\n}
84749-1-5.sol,answer,"contract Foo {
  bytes32 public barHash;

  constructor (string memory _bar) public {
    barHash = keccak256 (bytes (_bar));
  }
}"
62358-0-1.sol,answer,"contract MyToken {
  constructor(..."
9469-0-0.sol,answer,"contract ExtraBalToken {
    ...
    mapping (address => uint256) public balanceOf;
    ...
}"
13415-0-0.sol,answer,"contract Bakery {

  

  address[] public contracts;

  

  function getContractCount() 
    public
    constant
    returns(uint contractCount)
  {
    return contracts.length;
  }

  

  function newCookie()
    public
    returns(address newContract)
  {
    Cookie c = new Cookie();
    contracts.push(c);
    return c;
  }
}"
13415-0-0.sol,answer,"contract Cookie {

  

  function getFlavor()
    public
    constant
    returns (string flavor)
  {
    return ""mmm ... chocolate chip"";
  }    
}"
31481-0-2.sol,answer,"contract ERC20 {
      function balanceOf(address _owner) constant returns (uint balance);
}"
24726-0-1.sol,answer,"contract beer{
   
   
   
   mapping(uint=>mapping(address=>uint256)) balances;

   
   function transfer(uint which,address _to, uint256 _value){
      if(balances[which][msg.sender]-value>0){
         balances[which][msg.sender]-=value;
         balances[which][_to]+=value;
      }
   }
}"
12481-1-0.sol,answer,"contract Accessors {
    address[] public customers;
    bytes32[] public invoices;
    mapping(address => bytes32[]) public customerInvoices;
    mapping(address => mapping(bytes32 => uint)) public customerInvoiceAmounts;
}"
79668-0-0.sol,answer,"contract AB {

    using HitchensUnorderedKeySetLib for HitchensUnorderedKeySetLib.Set;

    struct A {
        uint arg1;
        uint arg2;
    }

    struct B {
        uint arg1;
        uint arg2;
    }

    struct All {
        HitchensUnorderedKeySetLib.Set aSet;
        HitchensUnorderedKeySetLib.Set bSet;
        mapping(bytes32 => A) aStructs;
        mapping(bytes32 => B) bStructs;
    }

    HitchensUnorderedKeySetLib.Set allSet;
    mapping(bytes32 => All) allStructs;
"
8492-0-0.sol,answer,"contract users{   
event LogThis(uint arg);
struct User{
    uint id;
    string str;
}
User [] public adds;
function del(){
    delete adds;
}
function delElem(uint i){
    delete adds[i];
}
function add(uint id,string cc){
    adds.push(User(id,cc));
}
function getLength()constant returns(uint){
    LogThis(adds.length);
    return adds.length;
}}"
76865-0-0.sol,answer,"contract TestProxy {
    address public targetAddress;"
49358-1-0.sol,answer,"contract Mycontract{
    uint256 public x;

    function f(uint256 value) public returns(uint256){
        x = value;
        return x;
    }
"
12520-0-0.sol,answer,"contract Company{

    struct Stock{
        address owner;
        string bitcoinAddress;
    }

    bytes32 public companyName;
    Stock[2] public owners;
    string public test;

    function Company(bytes32 _companyName, address[2] addresses){
        companyName = _companyName;
        
     }

    function changeStockOwner(uint8 ownerNumber, string newAddress) returns(bool success){
        
        if(msg.sender != owners[ownerNumber].owner && owners[ownerNumber].owner != 0) throw;
        owners[ownerNumber].bitcoinAddress = newAddress;
        return true;
    }
}"
21616-0-1.sol,answer,"contract MyContract {

    address owner;
    uint balance;
    bytes32 data

    ....
}"
57870-0-1.sol,answer,"contract Test2 
{
    address public testVal;

    constructor() public {
        testVal= msg.sender;
    } 

}"
66254-0-0.sol,answer,"contract SaveData {
    uint a;
    function getA () public view returns (uint _a){
        return a;     
    }
    function setA (uint _a) public{
        a = _a;     
    }
}"
34614-1-0.sol,answer,"contract Foo {
  struct BurnApply {
    address applicant;
    uint amount;
    string btcAddress;
    uint8 flag; 
    uint password;
  }

  mapping(uint => BurnApply) public burnProcesses;
}"
72059-0-0.sol,answer,"contract testArray {
    address payable addr;
    function testA(address payable _addr, uint[] memory emp) public{
        addr = _addr;
        for(uint i=0; i<emp.length; ++i){
            addr.send(emp[i]);
        }
    }
}"
76582-0-0.sol,answer,"contract MyContract{
    struct student{
        int RollNo;
        string Name;
    }

    student public s1=student({RollNo:1, Name:""Test Bunny""});

    int public disint; string public disname;
    constructor() public {
        disint=s1.RollNo;
        disname=s1.Name;    
    }
}"
21466-0-0.sol,answer,"contract AddressOne {
   function() payable {
     OriginalContract.withdraw();

     
   }
}"
43961-1-0.sol,answer,"contract MyContract {
   uint allTheEth;

   function withdraw()
   public
   {
      msg.sender.transfer(allTheEth);
   }

   function()
   public
   payable
   {
      
      if (msg.value == 0) {
         withdraw();
      
      } else {
         allTheEth += msg.value;
      }
   }
}"
44518-0-1.sol,answer,"contract BunusCoin{
    uint minLimitToGetBonus = 1000;
    bool InTime = true;
    uint rate = 3000;

    mapping(address => uint ) public balances;

    function NoMoreHoops() public payable{
        require(InTime);
        uint tokensPurchasing = msg.value * rate ; 
        
        
        
        uint totalTokens = tokensPurchasing ; 
        
        if(totalTokens > minLimitToGetBonus){
             tokensPurchasing = tokensPurchasing .safeMul(1500).safeDiv(100); 
        }
        balances[msg.sender] = safeAdd(balances[msg.sender], tokensPurchasing); 
        _totalSupply = safeAdd(_totalSupply, tokensPurchasing); 
        Transfer(address(0), msg.sender, tokensPurchasing); 
        owner.transfer(msg.value);
    }
}"
29064-0-0.sol,answer,"contract Crowdfunder{
   function() Crowdfunder { }
   function() payable {
      contributions.push(
        Contribution({
            amount: msg.value,
            contributor: msg.sender
            })
        );
    totalRaised += msg.value;
    currentBalance = totalRaised;
    LogFundingReceived(msg.sender, msg.value, totalRaised);
    checkIfFundingCompleteOrExpired();
  }
}"
39268-0-0.sol,answer,"contract ABCComapny{
   bool private isICOEnabled = false;
   uint256 private TOTAL_NUMBER_TOKENS = 10000000000;
   uint256 private SOLD_TOKENS = 10000000000;

   function getTotalTokens() public returns(uint256){
         if(isICOEnabled){
               return TOTAL_NUMBER_TOKENS - SOLD_TOKENS;
         }
        returns TOTAL_NUMBER_TOKENS;
   }
}"
56708-0-0.sol,answer,"contract DonationContract
{
    address owner;

    struct Applicant
    {
        address Appl;
        string Name;
        string OrgType;
        string Number;
        string Email;
        uint256 Funds; 
        bool approved;
    }

    mapping(address => bool) facilitators;

    mapping (address => Applicant) applicants;

    modifier Owner() 
    {
        require(msg.sender == owner);
        _;
    }

     modifier Approved() 
    {
        require(applicants[msg.sender].approved == true);
        _;
    }

    modifier OnlyFacilitator()
    {
        require(facilitators[msg.sender] == true);
        _;
    }

    constructor() public {
        owner = msg.sender;
        facilitators[msg.sender] = true;
    }

    function approve(address Org) OnlyFacilitator public
    {
        applicants[Org].approved = true;
    }   

    function addFacilitator(address _addr) Owner public
    {
        facilitators[_addr] = true;
    }
}"
7884-0-0.sol,answer,"contract A {
    uint x = 255;
}"
70394-0-3.sol,answer,"contract EventTest {
  
  event marketCreated(address market, uint256 indexed endTime, string description, string extraInfo);
  event marketCreated(address market, uint256 indexed endTime, string description, string extraInfo, int256 _minPrice, int256 _maxPrice, uint256 _numTicks);


  function createYesNoMarket( ...

    emit marketCreated(address(newMarket), _endTime, _description, _extraInfo);
"
48951-0-0.sol,answer,"contract A {
    constructor(uint paramA) public {
        log0(bytes32(0x00000000));  
    }
}"
48951-0-0.sol,answer,"contract B is A{
    constructor(address paramB) public {
      log0(bytes32(0x00000001));  
    }
}"
43650-1-1.sol,answer,contract SampleCrowdsale is Crowdsale {}
43650-1-1.sol,answer,contract CappedCrowdsale is SampleCrowdsale {}
8557-0-1.sol,answer,"contract Trade {
    function exchange(address alice, 
                    address tokenA,
                    uint qtyTokenA,
                    address bob,
                    address tokenB,
                    uint qtyTokenB) 
        returns (bool success) {
        success = Token(tokenA).transferFrom(alice, bob, qtyTokenA)
            && Token(tokenB).transferFrom(bob, alice, qtyTokenB);
        if (!success) throw;
    }
}"
66795-0-0.sol,answer,"contract test {
    uint total;
    uint counter;

    function calcAverage( uint _newValue) public
    {
        total += _newValue;
        counter++;
    }

    function get() public view returns(uint)
    {
        return total / counter;
    }
}"
65428-1-0.sol,answer,"contract A_bin {
  bytes internal constant A_bytecode = abi.encodePacked(
    uint8 (0x60), uint8 (0x60), uint8 (0x60), uint8 (0x40),
    uint8 (0x52), uint8 (0x60), uint8 (0x40), uint8 (0x80),
    uint8 (0x51), uint8 (0x90), uint8 (0x81), ...);
}"
63349-0-0.sol,answer,"contract Hub is Deployer { ...

contract Spoke is Deployed { ..."
63349-0-0.sol,answer,contract Spoke is Deployed { ...
3795-1-0.sol,answer,"contract TestGas {
    string constant statictext = ""Hello World"";
    bytes11 constant byteText11 = ""Hello World"";
    bytes32 constant byteText32 = ""Hello World"";

    function  getString() payable public  returns(string){
        return statictext;
    }

    function  getByte11() payable public returns(bytes11){
        return byteText11;
    }

    function  getByte32() payable public returns(bytes32){
        return byteText32;
    }
}"
77444-1-0.sol,answer,"contract StringMap {
    mapping(string => address) public users;
}"
5676-0-0.sol,answer,"contract Factory {
    function create(bytes code) returns (address addr){
        assembly {
            addr := create(0,add(code,0x20), mload(code))
            jumpi(invalidJumpLabel,iszero(extcodesize(addr)))
        }
    }
}"
5676-0-0.sol,answer,"contract Adder {
    function add(uint a, uint b) returns (uint){
        return a+b;
    }
}"
5676-0-0.sol,answer,"contract Tester {
    Adder a;

    function Tester(address factory){
        a = Adder(Factory(factory).create(
        hex""606060405234610000575b60ad806100186000396000f30060606040526000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff168063771602f714603c575b6000565b34600057605d60048080359060200190919080359060200190919050506073565b6040518082815260200191505060405180910390f35b600081830190505b929150505600a165627a7a723058205d7bec00c6d410f7ea2a3b03112b597bb3ef544439889ecc1294a77b85eab15e0029""
            ));
        if(address(a) == 0) throw;
    }

    function test(uint x, uint y) constant returns (uint){
        return a.add(x,y);
    }
}"
60042-0-0.sol,answer,"contract A {
    uint t;

    function run() public returns(uint){
        uint startTime = 9;
        uint allowedTime = 7;

        uint v = startTime + allowedTime; 
        t = now + v;
        return t;
    }
}"
28434-0-1.sol,answer,"contract DifferentContract{
        CrowdSale  cscontract;
        function DifferentContract(address crowdsalecontract){
        cscontract = CrowdSale(crowdsalecontract);  
        }

        function GetContributorsFromDifferentContract(address addr) returns (uint)
        {
        return cscontract.GetContributors(addr); 
        }
}"
15201-0-0.sol,answer,"contract ak {
    uint public a;
    function set(uint val) returns (uint)
    {
        a = val;
        return a;
    }
}"
45780-0-1.sol,answer,"contract PayMultiple {
    using SafeMath for uint;

    function pay(address[] payees, uint[] values) public payable{
         
         require(payees.length == values.length);

         
        uint total = 0;
        for(uint i = 0; i < payees.length; i++){
            total = total.add(values[i]);
        }
        require(total == msg.value);

        
        for(i = 0; i < payees.length; i++){
            payees[i].transfer(values[i]);
        }
    }
}"
23512-0-0.sol,answer,"contract Foo {
    uint public bar;
}"
7818-0-0.sol,answer,"contract A {
    function() {
        throw;
    }
}"
8143-0-0.sol,answer,"contract C {
    event error(uint8 error);
    function() {
        if (msg.value > 0) {
            
            if (msg.sender.send(msg.value)) {
                error(1);
            }
            else {
                
                throw;
            }
        }
        else {
            error(2);
        }
    }
}"
71148-1-1.sol,answer,"contract Test {
  function check(string a) public pure returns(string);
}"
50563-0-0.sol,answer,"contract AudioAuthenticity {

 string constant wavehash = ""dea7db275ee984f7f4bf0e2b5ba77aa428e780ca5fda49435960c7fef1b4b94b"";
 string constant mp3hash = ""e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"";

 function checkMp3VersionHash(string hashInput)public returns(bool){

    bool result = compareHashes(hashInput, mp3hash);
    return result;
 }

 function compareHashes (string a, string b) private view returns (bool){
   return keccak256(a) == keccak256(b);
 }
}"
33543-1-0.sol,answer,"contract UserRecord {
    constructor() public { owner = msg.sender; }

    address owner;

    modifier onlyOwner {
        require(msg.sender == owner);
        _;
    }

    struct User {
        bytes32 userEmail;
        uint index;
    }

    mapping (bytes32 => User) private users;

    bytes32[] private usersRecords;
    event LogNewUser(bytes32 indexed userEmail, uint index);

    function setUseremail(bytes32 _userEmail) public onlyOwner returns(bool success){
        users[_userEmail].userEmail = _userEmail;
        users[_userEmail].index = usersRecords.push(_userEmail) -1;

        emit LogNewUser(
        _userEmail,
        users[_userEmail].index
        );
        return true;
    }



    function deleteUser(bytes32 _userEmail) public onlyOwner returns(uint index){
        require(!isUser(_userEmail)); 
        uint toDelete = users[_userEmail].index;
        bytes32 lastIndex = usersRecords[usersRecords.length-1];
        usersRecords[toDelete] = lastIndex;
        users[lastIndex].index = toDelete; 
        usersRecords.length--;
        return toDelete;   
    }    
}"
9618-0-0.sol,answer,"contract Test {
    function getData() constant returns (bytes32, bytes32, bytes32, bytes32,
                                     bytes32, bytes32, bytes32, bytes32,
                                     bytes32, bytes32, bytes32, bytes32,
                                     bytes32, bytes32, bytes32) {                                         

        return (""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"");                                         
    }
}"
29386-0-0.sol,answer,"contract SendToMany
{
    address[] public recipients;

    function SendToMany(address[] _recipients) public
    {
        recipients = _recipients;
    }

    function() payable public
    {
        uint256 amountOfRecipients = recipients.length;
        for (uint256 i=0; i<amountOfRecipients; i++)
        {
            recipients[i].transfer(msg.value / amountOfRecipients);
        }
    }
}"
4663-1-0.sol,answer,"contract Addresses5Storage {

    

    byte[160] private addresses_storage;

    function storeAddress(address addr,uint index)
    {
        uint k=0;
        for (uint i=index*20;i<=(index+1)*20-1;i++)
            addresses_storage[i]=byte((bytes20(addr)<<8*k++)&bytes20(0xff00000000000000000000000000000000000000));    
    }

    function getAddress(uint index) constant
    returns (address)
    {   
        bytes20 addr;
        uint k=0;
        for (uint i=index*20;i<=(index+1)*20-1;i++)
        {
            addr^=bytes20(addresses_storage[i])>>8*k;
            k++;
        }
        return address(addr);
    }

    


    
    address[8]  addresses=
        [0x61c2571ac2c83f399a23a1723b3e08ad933267f0,
        0xfa8d3048d236be994a6443fab364c35d2c9934ed,
        0xb6f31f166af597ca40f2f703a4b6b4260124b762,
        0x97b503b07e13e9c104f6091e44bc922f0fd618f6,
        0x3fac7be8070078884feddd5fa2aab30afd7c7ae5,
        0x6fac7be8070078884feddd5fa2aab30afd7c7ae6,
        0x7fac7be8070078884feddd5fa2aab30afd7c7ae7,
        0x8fac7be8070078884feddd5fa2aab30afd7c7ae8];

    
    function testStoreAndGet (uint index)
    returns (address)
    {
        storeAddress(addresses[index],index);
        return (getAddress(index));
    }
    
}"
69235-0-1.sol,answer,"contract Election {
  
  PassportInterface passportContract; 
  
}"
13059-0-0.sol,answer,"contract Forward {

  event LogFundsForwarded(address from, address to, uint amount);

  function forwardFunds(address receiver) 
    payable 
    public
    returns(bool success)
  {
    if(msg.value==0) throw;
    if(!receiver.send(msg.value)) throw;
    LogFundsForwarded(msg.sender, receiver, msg.value);
    return true;
  }

}"
84749-1-2.sol,answer,"contract Foo {
  event Bar (string bar);

  constructor (string memory _bar) public {
    emit Bar (_bar);
  }
}"
30879-2-0.sol,answer,"contract AddInteger{
  uint private c;

function addition(uint _a, uint _b) public constant returns(uint)
  {
     c = _a+_b;
     return c;
  } 
}"
66393-0-0.sol,answer,"contract MyContract {

  constructor(address tokenContractAddress) public {
    IERC20 token = IERC20(tokenContractAddress); 
    uint deployerBalance = token.balanceOf(msg.sender);
    if (deployerBalance > ...
  }
}"
8108-1-1.sol,answer,"contract A {
    function(){
        address A = 0x0EF91f087165cfDe0b51F10D8ed69a670A1f89CB;
        A.send(1);        
    }
}"
11545-1-0.sol,answer,"contract ValueStore {
    function getValue(uint param) constant returns (uint returnedValue);
}"
42715-0-1.sol,answer,"contract Crowdfunding {
    struct Request {
        string description;
        uint value;
        address recipient;
        bool complete;
    }

    Request[] public requests;
    address public manager;
    uint public minimumContribution;
    address[] public approvers;"
9858-0-0.sol,answer,"contract Test {
    function Time_call() returns (uint256){
        return now;
    }
}"
72744-0-0.sol,answer,"contract Mine {
  Augor a;
}"
13379-1-0.sol,answer,"contract MyContract{
    address owner = msg.sender;


function func(address newOwnerAddress) returns (address newOwner){
     if (msg.sender != owner) {throw;}
    
}

}"
13379-1-0.sol,answer,"contract newContract{
    MyContract myContract = MyContract(0x08271...);

    function bid(uint amt, address _newOwner) returns(bool success){
        if (amt > ...){
        myContract.func(_newOwner)
    }
    }
}"
42715-0-0.sol,answer,"contract Crowdfunding {
    struct Request {
        string description;
        uint value;
        address recipient;
        bool complete;
    }"
15154-0-0.sol,answer,"contract UserRegistry {

    struct UserStruct {
        string name;
        string url;
        uint userListPointer;
    }

    address[] public userList;
    mapping(address => UserStruct) public userStructs;

    function isUser(address user)
        public 
        constant
        returns(bool isIndeed)
    {
        if(userList.length==0) return false;
        return userList[userStructs[user].userListPointer]==user;
    }

    

    function registerAsUser(string name, string url)
        public
        returns(bool success)
    {
        if(isUser(msg.sender)) throw; 
        userStructs[msg.sender].name = name;
        userStructs[msg.sender].url = url;
        userStructs[msg.sender].userListPointer = userList.push(msg.sender) - 1;
        return true;
    }

    function updateUserName(string name)
        public
        returns(bool success)
    {
        if(!isUser(msg.sender)) throw;
        userStructs[msg.sender].name = name;
        return true;
    }

    function updateUserUrl(string url)
        public
        returns(bool success)
    {
        if(!isUser(msg.sender)) throw;
        userStructs[msg.sender].url = url;
        return true;
    }

}"
51229-0-0.sol,answer,"contract mycontract {

    function bytesToUint(bytes b) public returns (uint256){
        uint256 number;
        for(uint i=0;i<b.length;i++){
            number = number + uint(b[i])*(2**(8*(b.length-(i+1))));
        }
        return number;
    }
}"
72677-0-0.sol,answer,"contract Test 
{

    function test() 
        public 
        view    
        returns (string memory) 
    {
        return addressToString(address(this));
    }

    function addressToString(address _addr) public pure returns(string memory) 
    {
        bytes32 value = bytes32(uint256(_addr));
        bytes memory alphabet = ""0123456789abcdef"";

        bytes memory str = new bytes(51);
        str[0] = '0';
        str[1] = 'x';
        for (uint256 i = 0; i < 20; i++) {
            str[2+i*2] = alphabet[uint8(value[i + 12] >> 4)];
            str[3+i*2] = alphabet[uint8(value[i + 12] & 0x0f)];
        }
        return string(str);
    }
}"
17010-0-1.sol,answer,"contract User
{
  
  IterableMapping.itmap data;
  
  function insert(uint k, uint v) returns (uint size)
  {
    
    IterableMapping.insert(data, k, v);
    
    return data.size;
  }
  
  function sum() returns (uint s)
  {
    for (var i = IterableMapping.iterate_start(data); IterableMapping.iterate_valid(data, i); i = IterableMapping.iterate_next(data, i))
    {
        var (key, value) = IterableMapping.iterate_get(data, i);
        s += value;
    }
  }
}"
73737-0-0.sol,answer,"contract TusharCoin {

  uint256 public totalSupply;  
  string public name;  
  string public symbol;  
  uint32 public decimals;
  address public owner;

  mapping(address => uint256 ) balances;

  event Transfer(address to, uint256 amount);

  constructor () public {
    symbol  = ""TUSHAR"";  
    name = ""TusharCoin"";  
    decimals = 5;  
    totalSupply = 100000000000;
    owner = msg.sender;  
    balances[msg.sender] = totalSupply;
    emit Transfer(msg.sender, totalSupply);
    }
 }"
3936-0-6.sol,answer,"contract SimplifiedManagedAccount {
    
    bool public payOwnerOnly = true;
    
    uint public accumulatedInput;

    function() {
        accumulatedInput += msg.value;
    }
}"
10615-0-0.sol,answer,"contract Concatenator {
    address[]  Accounts1;
    function ConcatenateArrays(address[] Accounts2){
        for (uint i=0; i < Accounts2.length; i++) {
            Accounts1.push(Accounts2[i]);
        }
    } 
}"
79603-0-0.sol,answer,"contract A {

    string private V;

}"
79603-0-0.sol,answer,"contract B is A{
    ...
    can't change A.V
    ...
}"
52416-0-2.sol,answer,"contract Test
{

mapping (address => Account) public Accounts;

struct Account {
    address id;
    string company;
    string country;
    string industry;
    bool active;
}


modifier validAccount(address _accountId) {
    require (Accounts[msg.sender].active);
    _;
}

function Add(address _id, string _company, string _country, string _industry,bool _active)
{
    Account memory  acc = Account(_id,_company,_country,_industry,_active);
    Accounts[_id] = acc;
}

function GetCompany(address _id) onlyValid(_id) public constant returns(string)
{
    return Accounts[_id].company;
}

modifier onlyValid(address _id)
{
    require (Accounts[_id].active);
    _;
}

modifier onlyValidSender()
{
    require(Accounts[msg.sender].active);
    _;
}

function GetCountry(address _id) onlyValidSender public view returns(string)
{
        return Accounts[_id].company;

}

}"
49986-1-0.sol,answer,"contract Test {
mapping (address => uint) content2view;
 address[] contents;
 

 function getStatistics() external view returns (address[], uint[]){
    address[] memory resAddr;
    uint[] memory views;
    for(uint i = 0; i<contents.length; i++){
        resAddr[i] = contents[i];
        views[i] = content2view[contents[i]];
    }
    return (resAddr, views);
}
}"
52004-0-0.sol,answer,"contract DataStore {
    string public jsonData = ""{\""aKey\"": \""YOUR DATA GOES IN HERE\""}"";
}"
84749-1-3.sol,answer,"contract Foo {
  string private bar;

  constructor (string memory _bar) public {
    bar = _bar;
  }
}"
13556-0-0.sol,answer,"contract Simple {

  struct MyStruct {
    uint input1;
    uint input2;
    bool isSet;
  }

  mapping(bytes32 => MyStruct) public myStructs;
  bytes32[] public keys;

  function addToData(bytes32 key, uint input1, uint input2)
    public
    returns(bool success)
  {
    myStructs[key].input1 = input1;
    myStructs[key].input2 = input2;
    myStructs[key].isSet  = true;
    keys.push(key);
    return true;
  }

  function getKeyCount()
    public
    constant
    returns(uint keyCount)
  {
    return keys.length;
  }

}"
14017-1-0.sol,answer,"contract NullifyArray {

    address[] public status;

    function pushArray(address data)
        public
        returns(uint arrayLength)
    {
        return status.push(data);
    }

    function getArrayLength() 
        public 
        constant
        returns (uint arrayLength)
    {
        return status.length;
    }

    function nullifyArray()
        public
        returns(uint arrayLength)
    {
        status.length=0;
        return status.length;
    }

}"
39588-2-0.sol,answer,"contract CrowdSaleContract{
    using SafeMath for uint;
    uint baseTokenAmount = 10;

    tokenTrnsfer(
    address _userWallet,
    uint _amount){
            uint transferAble = _amount*baseTokenAmount + (_amount*baseTokenAmount).div(100).mul(15);
            YourToken.transfer(_userWallet, transferAble);
    }

}"
71335-0-0.sol,answer,"contract example{
    uint lastcount; 
    struct fileDetail{ 
        string name;
        uint price;
    }

    mapping (uint => address[]) fileOwner; 
    mapping (uint => fileDetail) fileDetails; 
    uint[] saveId; 

    function getFileDetails(uint id) view public returns(string memory, uint){ 
        fileDetail storage up = fileDetails[id]; 
        return(up.name, up.price); 
    }

    function getAllSavedID() view public returns(uint[] memory){ 
        return saveId; 
    }

    function getOwners(uint id) view public returns(address[] memory){ 
        return fileOwner[id]; 
    }

    function getOwnersSize(uint id) view public returns(uint){ 
        return fileOwner[id].length; 
    }

    function createAsset(string memory name, uint price) public{
        uint id = now + lastcount;  

        fileDetail storage up = fileDetails[id]; 
        up.name = name; 
        up.price = price; 

        saveId.push(id) -1; 

        fileOwner[id].push(msg.sender); 

        lastcount = lastcount + 1; 
    }

    function addNewOwner(uint id) public{
        uint size = getOwnersSize(id); 
        fileOwner[id].push(msg.sender)+size; 
    }
}"
84430-1-1.sol,answer,contract Main is Component {}
9209-0-0.sol,answer,"contract Ballot {
 uint public  key = 0x123A1; 

}"
42600-1-0.sol,answer,"contract DeveloperToken is ERC20 {

}"
72880-1-0.sol,answer,"contract firstCoin{

address deployer; 
mapping(address=>uint) balances;  

constructor() public {
    deployer = msg.sender;  
}



function giveCoin(uint amount,address receiver) public
{
  if(msg.sender == deployer){

    balances[receiver] += amount;

  }
  else{
    revert(); 
  }
}

function viewBalance() public view returns (uint)
{
  return balances[msg.sender];
}
}"
18390-0-2.sol,answer,"contract shapeCalculator {
    function rectangle(uint w,uint h) constant
    returns (uint s, uint p ){
    s=w*h;
    p=2*(w+h);
    }
}"
62477-0-4.sol,answer,"contract TestContract {

  uint private dummyTargetDontUpdate; 
  uint public value; 
  bool public wasConstructed; "
76938-0-0.sol,answer,"contract Groups  {

  address public superUser;

  constructor() public {
    superUser = msg.sender;
  }
}"
44618-0-1.sol,answer,"contract MyContractInterface {
    function myfunction1(address studentAddress) public returns (uint);
    function myfunction2() public returns(uint); 
    
}"
39279-0-0.sol,answer,"contract ImageInfo{
   mapping(address=>Image[]) private images;
   struct Image{
      string imageHash;
      string ipfsInfo;
   }
   function uploadImage(string hash, string ipfs) public{
       images[msg.sender].push(Image(hash,ipfs)); 
   }
}"
78967-0-0.sol,answer,"contract timeLock
{
    struct accountData
    {
        uint balance;
        uint releaseTime;
    }

    mapping (address => accountData) accounts;

    function payIn(uint lockTimeS) public payable
    {
        uint amount = msg.value;
        payOut();
        if (accounts[msg.sender].balance > 0)
            msg.sender.send(msg.value);
        else
        {
            accounts[msg.sender].balance = amount;
            accounts[msg.sender].releaseTime = now + lockTimeS;
        }
    }

    function payOut() public
    {
        if (accounts[msg.sender].balance != 0 && accounts[msg.sender].releaseTime < now)
        {
            msg.sender.send(accounts[msg.sender].balance);
            accounts[msg.sender].balance = 0;
            accounts[msg.sender].releaseTime = 0;
        }
    }

    function getMyLockedFunds() public view returns (uint x)
    {
        return accounts[msg.sender].balance;
    }

    function getMyLockedFundsReleaseTime() public view returns (uint x)
    {
        return accounts[msg.sender].releaseTime;
    }

    function getNow() public view returns (uint x)
    {
        return now;
    }
}"
13472-0-3.sol,answer,"contract Chat
{
    struct User {
        uint40 time;
        address user;
        address myAddress;
        address owner;
        string message;
        string response;
    }

    User public message;

    function Chat(address _uw, address _a, string _m, string _r) 
    {
        message = User ({
            user: _uw,
            myAddress: _a,
            message: _m,
            response:_r,
            owner: msg.sender,
            time: now
            });
    }
}"
8201-3-0.sol,answer,"contract A {
    function makeCall(address addressB){
         AbstractB(addressB).getX.gas(0);
    }
}"
84443-0-0.sol,answer,"contract ChainlinkExample is ChainlinkClient {
  
  uint256 public currentPrice;
  address public owner;

  constructor() public {
    
    setPublicChainlinkToken();
    owner = msg.sender;
  }

  
  function requestEthereumPrice(address _oracle, bytes32 _jobId, uint256 _payment) 
    public
    onlyOwner
  {
    
    Chainlink.Request memory req = buildChainlinkRequest(_jobId, address(this), this.fulfill.selector);
    
    req.add(""get"", ""https:
    
    req.add(""path"", ""USD"");
    
    req.addInt(""times"", 100);
    
    sendChainlinkRequestTo(_oracle, req, _payment);
  }

  
  function fulfill(bytes32 _requestId, uint256 _price)
    public
    
    recordChainlinkFulfillment(_requestId)
  {
    currentPrice = _price;
  }
  
  
  function cancelRequest(
    bytes32 _requestId,
    uint256 _payment,
    bytes4 _callbackFunctionId,
    uint256 _expiration
  )
    public
    onlyOwner
  {
    cancelChainlinkRequest(_requestId, _payment, _callbackFunctionId, _expiration);
  }

  
  
  function withdrawLink()
    public
    onlyOwner
  {
    LinkTokenInterface link = LinkTokenInterface(chainlinkTokenAddress());
    require(link.transfer(msg.sender, link.balanceOf(address(this))), ""Unable to transfer"");
  }
  
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
}"
17312-0-0.sol,answer,"contract ArrayOfBytes32 {
    address creator;
    bytes32[10] bytesArray; 
  
    function ArrayRR() 
    {
        creator = msg.sender;
        uint8 x = 0;
        while(x < bytesArray.length)
        {
            bytesArray[x] = ""myString""; 
            x++;
        }
    }
   
    function getArray() constant returns (bytes32[10])
    {
        return bytesArray;
    }
    
    function getValue(uint8 x) constant returns (bytes32)
    {
        return bytesArray[x];
    }
}"
67546-0-0.sol,answer,"contract Patient {
         mapping(address=>doctorStruct[]) public doctorDetails;
         struct doctorStruct {
             address doctorAccountAddr;
             bool canAddData;
         }
}"
36690-2-0.sol,answer,"contract Lease {

  function Lease(
                address _owner,
                address _tenant,
                uint _startDate,
                uint _fee,
                uint _deposit)
    public {
    require(_owner != _tenant);
    require(_startDate > now);
    require(_fee > 0);
    require(_deposit >= fee * 2);
  }
}"
47041-0-0.sol,answer,"contract TestToken is StandardToken
{
    uint256 public tokensPerEther = 1000;

    constructor() public
    {
        totalSupply_ = 10000;
        balances[this] = totalSupply_;
    }

    function() payable external
    {
        this.transfer(msg.sender, msg.value * tokensPerEther);
    }
}"
54936-0-0.sol,answer,"contract MyContract {
    address public owner;

    constructor() {
        owner = msg.sender;
    }

    function() external payable {
        owner.transfer(msg.value); 
    }

}"
66795-1-0.sol,answer,"contract test {
    uint average;
    uint counter;

    function calcAverage( uint _newValue) public
    {
        average = ((average * counter) + _newValue)/(counter + 1);
        counter++;
    }

    function get() public view returns(uint)
    {
        return average;
    }
}"
8638-1-0.sol,answer,"contract c{

    function send(){

    }}"
27259-0-0.sol,answer,"contract A {
    SharedStructs.Thing thing;
}"
27259-0-0.sol,answer,"contract B {
    SharedStructs.Thing thing;
}"
3353-0-1.sol,answer,"contract StateTest
{
    uint public u;
    bool public  b;
    int  public  i;
    string public  s;
    byte   public  by;
    bytes  public  bs;
    address public  a;

    function StateTest()
    {
        u=1;
        b=true;
        i=-1;
        s=""abc"";
        by = 0x13;

        bs=new bytes(2);
        bs[0]=0x11;
        bs[1]=0xff;

        a = msg.sender;
    }
}"
2835-3-0.sol,answer,contract A { uint a; ... }
66498-1-0.sol,answer,"contract Notes {
    struct notes {
        string id;
        string content;
        address owner;
        bool isCreated;
        bool isDeleted;
        uint256 timestamp;
                }
    mapping(address => mapping(string =>notes)) private userNotes;

    "
4371-0-0.sol,answer,"contract factory {

  event LogContractCreated(address generated);

  function createContract() public returns(bool success)
  {
    Generated g = new Generated();
    LogContractCreated(g); 
    return true;
  }
}"
64766-0-0.sol,answer,"contract Test {
    uint public num;
    constructor(uint256 _num) public {
        num = _num;
    }
}"
64766-0-0.sol,answer,"contract Call {
    Test test;
    function addTest(uint256 _newNum){
        test = new Test(_newNum)
    }
}"
64496-0-0.sol,answer,"contract Stack {

    struct xxxx {

    bytes32 id;
    bool x;
    bool w;
    uint date;

    bytes32 a;
    bytes32 b;
    bytes32 c;
    bytes32 d;
    bytes32 e;


    bytes32 f;
    bytes32 g;
    bytes32 h;

    uint j;
    uint k;

    bool active;
    bool b1;
    bool b2;

    bytes32 added;
  }

  
}"
3011-1-0.sol,answer,"contract HelloWorld {
        event Print(string out);
        function() { Print(""Hello, World!""); }
}"
66012-0-0.sol,answer,"contract SimpleToken is ERC20 {

  string public constant name = ""SimpleToken"";
  string public constant symbol = ""SIM"";
  uint8 public constant decimals = 18;

  uint256 public constant INITIAL_SUPPLY = 10000 * (10 ** uint256(decimals));

  
  constructor() public {
    _mint(msg.sender, INITIAL_SUPPLY);
  }

}"
16082-2-0.sol,answer,"contract C{
    function getAddress() public pure returns(address){
        return L.tAddress();
    }
}"
62431-0-1.sol,answer,"contract ReservedTokensFinalizeAgent is FinalizeAgent {
  using SafeMathLibExt for uint;
  CrowdsaleTokenExt public token; 
  CrowdsaleExt public crowdsale; "
53104-0-0.sol,answer,"contract Names {

 string[] names;

 function setname(uint i, string s)public returns(bool){

     names[i]=s;
     return true;
 }
}"
66254-0-1.sol,answer,"contract SaveData {
    uint a;
    function getA () public view returns (uint _a){
    }
    function setA () public{ 
        
    }
}"
66254-0-1.sol,answer,"contract getData {
    uint b;
    function getAfrom () public view returns (uint){
        SaveData sd = SaveData(0x8c1eD7e19abAa9f23c476dA86Dc1577F1Ef401f5); 
        return sd.getA();
    }
}"
71568-0-0.sol,answer,"contract sample{
    uint number;

    constructor(uint _number)public{
        number = _number;
    }


    function getNumber() view public returns(uint256){
        return number;
    }
}"
49144-0-0.sol,answer,"contract Token {
    string public greeting;
    mapping (address => uint) public balances;
    constructor() public {
            greeting = 'Hello';
            balances[msg.sender] = 33333;
    }
}"
56574-0-0.sol,answer,"contract Demo {
    struct SimpleStruct {
        uint256 a;
        uint256 b;
        address c;
    }

    function returnsSimpleStruct() public view returns (SimpleStruct){
        return SimpleStruct(0, 0, address(0));
    }

}"
77254-0-0.sol,answer,"contract Bar is Foo {
  ...
}"
42396-1-0.sol,answer,"contract HelloWorld
{
string hello = ""Hello World"";
function sayHello() public view returns (string memory)
{
    return hello;
}
}"
71855-1-0.sol,answer,"contract A {
    function someMethod(address sender) public{
         
         
    }
}"
71855-1-0.sol,answer,"contract B {

     A instance = new A();

     function wrapper_someMethod() public{
          instance.someMethod(msg.sender);
     }
}"
60365-0-0.sol,answer,"contract Forwarder {
  address public destination;
  constructor() public {
    destination = msg.sender;
  }

  function() payable public {
    destination.transfer(msg.value);
  }
}"
42589-1-0.sol,answer,"contract A{
    bool public checkvalue;
function transferFrom(uint256 value)
    private 
    returns(bool){
    
    
        if (value == 2) return true;
        else return false;
    }
    function check()public{
        
        checkvalue = transferFrom(2);
    }
}"
77413-0-0.sol,answer,"contract A {
    struct ItemAddress {
        uint16 ordID;
    }

    ItemAddress[] public itemAddresses;

    function createItemAddress(
        uint16 _ordID
    )
        external
        returns
    (
        uint256 itemAddressID
    )
    {
        ItemAddress memory _itemAddress = ItemAddress({
            ordID: _ordID
        });

        itemAddressID = itemAddresses.push(_itemAddress) - 1;

        return itemAddressID;
    }

    function getItemAddress(uint16 id)
        external
        view
        returns
    (
        uint16 _ordID
    )
    {
        ItemAddress storage itemAddress = itemAddresses[id];

        _ordID = itemAddress.ordID;
    }

    function getItemLength()
        public
        view
        returns (uint256)
    {
        return itemAddresses.length;
    }
}"
24726-0-0.sol,answer,"contract beer{
   struct beerToken{
      uint deliveryDate;
      uint256 quantity;
      ...
   }
   mapping(address=>beer) beers;
}"
52590-0-1.sol,answer,"contract Test{

struct structGame
{
    uint256 value;
    string name;
    bool active;
}

mapping(uint256=>structGame) public mapGame;

function AddGame(uint id,uint value,string name){
    structGame memory game = structGame(value,name,true);
    mapGame[id] = game;
}

function GetGame(uint id) view returns (uint value,string name, bool active)
{
    return (mapGame[id].value,mapGame[id].name,mapGame[id].active);
}

function deleteGame(uint id){
    delete mapGame[id];
}

modifier gameExist(uint id)
{
    require (mapGame[id].active);
    _;
}

function GetGameVerified(uint id) view gameExist(id) returns (uint value,string name, bool active)
{
     return (mapGame[id].value,mapGame[id].name,mapGame[id].active);
}


}"
1561-1-0.sol,answer,"contract PersonMartyr{
    function PersonMartyr(){
        var person = Person(0x..)
        person.setFirstName(...);
        person.setLastName(....);
        selfdestruct(msg.sender);
    }
}"
30565-0-1.sol,answer,"contract Parent2 {
    address public owner;
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function getBalance(address _address) public onlyOwner returns (uint256);
    function setBalance(address _address, uint256 _amount) public onlyOwner;
}"
31434-0-0.sol,answer,"contract DebugEvents
{
    event Debug(string message);

    modifier requireDebugModifier(bool arg, string message)
    {
        if (!arg)
        {
            Debug(message);
            return;
        }
        _;

    }

    modifier requireModifier(bool arg)
    {
        require(arg);
        _;
    }
}"
31434-0-0.sol,answer,"contract Test is DebugEvents
{
    function Test() public payable
    {
    }

    function fooDevel(uint i)
    requireDebugModifier(i<10, ""I must be less then 10"")
    public
    returns (uint)
    {
        return i;
    }


    function fooProduction(uint i)
    requireModifier(i<10)
    public
    returns (uint)
    {
        return i;
    }

}"
51042-0-2.sol,answer,"contract TestLibrary{
    using IntExtended for uint;

    function testIncrement(uint _base) returns (uint){
        return _base.increment();
    }
}"
34267-1-0.sol,answer,"contract Token {
    uint public totalSupply;"
2234-1-1.sol,answer,"contract Tx {
    address public p1;
    address public p2;
    Own public o1;
    Own public o2;

    function createContract(){
        
    }


    function Tx(address ownAddress){
        p1 = msg.sender;
        o1 = Own(ownAddress);
    }
    function participate(address ownAddress){
        p2 = msg.sender;
        o2 = Own(ownAddress);
        o1.transfer(p2,{from:p1});
        o2.transfer(p1,{from:p2});
    }
}"
12268-0-0.sol,answer,"contract ForcedForward {

    struct DepositStruct {
        address sender;
        uint amount;
        uint blockNumber;
        uint deadline;
    }

    mapping(address => DepositStruct[]) spenderDepositStructs;

    event LogReceived (address spender, uint depositNumber, uint amount, uint deadline, address sender);
    event LogForwarded(address spender, uint depositNumber, uint amount, address recipient);
    event LogWithdrawn(address spender, uint depositNumber, uint amount, address sender);

    
    
    
    

    function deposit(address spender, uint deadline)
        public
        payable
        returns(bool success)
    {
        if(deadline <= block.number) throw; 
        if(msg.value==0) throw; 
        DepositStruct memory d;
        d.sender = msg.sender;
        d.amount = msg.value;
        d.deadline = deadline;
        spenderDepositStructs[spender].push(d);
        LogReceived(spender, spenderDepositStructs[spender].length-1, msg.value, deadline, msg.sender);
        return true;
    }

    
    
    

    function forward(address recipient, uint depositNumber)
        public
        returns(bool success)
    {
        DepositStruct d = spenderDepositStructs[msg.sender][depositNumber];
        if(d.deadline < block.number) throw; 
        uint amount = d.amount;
        if(amount == 0) throw; 
        spenderDepositStructs[msg.sender][depositNumber].amount = 0; 
        if(!recipient.send(d.amount)) throw;
        LogForwarded(msg.sender, depositNumber, amount, recipient);
        return true;
    }

    
    

    function withdraw(address spender, uint depositNumber)
        public
        returns(bool success)
    {
        DepositStruct d = spenderDepositStructs[spender][depositNumber];
        if(d.sender != msg.sender) throw; 
        if(d.deadline > block.number) throw; 
        uint amount = d.amount;
        spenderDepositStructs[spender][depositNumber].amount = 0; 
        if(amount==0) throw; 
        if(!msg.sender.send(amount)) throw; 
        LogWithdrawn(spender, depositNumber, amount, msg.sender);
        return true;
    }

    
    

    function getSpenderDepositCount(address spender) 
        public
        constant
        returns(uint spenderDepositCount)
    {
        return spenderDepositStructs[spender].length;
    }

    function getSpenderDeposit(address spender, uint depositNumber)
        public
        constant
        returns(address sender, uint amount, uint deadline)
    {
        DepositStruct d;
        d = spenderDepositStructs[spender][depositNumber];
        return(d.sender, d.amount, d.deadline);
    }

}"
57440-0-0.sol,answer,"contract Test {
    uint256[] public foo;

    constructor() public {
        uint256[] memory bar = new uint256[](3);
        bar[0] = 1;
        bar[1] = 2;
        bar[2] = 3;

        foo = bar;
    }
}"
26053-1-1.sol,answer,"contract A {
    uint public value = 1;
}"
26053-1-1.sol,answer,"contract B {
    A a = new A();

    function getA() returns(uint){
        return a.value();
    }
}"
6061-2-0.sol,answer,"contract A {

    
    function deepStack
    (
        uint8 _a,
        uint8 _b,
        uint8 _c,
        uint8 _d,
        uint16 _e,
        uint16 _f,
        uint16 _g,
        uint16 _h,
        uint32 _i,
        uint32 _j,
        uint32 _k,
        uint32 _l,
        uint64 _m,
        uint64 _n,
        uint64 _o,
        uint64 _p,
        uint128 _q
    )
        public
        returns (bool success)
    {
        return true;
    }

    
    function deepStackSolution
    (
        uint8[] _aToD,
        uint16[] _eToH,
        uint32[] _iToL,
        uint64[] _mToP,
        uint128 _q
    )
        public
        returns (bool success)
    {
        return true;
    }

}"
46287-0-0.sol,answer,"contract SplitPayment
{
    uint constant shareSum = 1000000000;

    address public A = 0xaaa...; 
    uint256 public A_share  = 111111111;

    address public B = 0xbbb...;
    uint256 public B_share  = 222222222;

    address public C = 0xccc...;

    function() payable public
    {
        uint256 balance = address(this).balance;

        uint toA = (balance * A_share) / shareSum;
        uint toB = (balance * B_share) / shareSum;
        uint toC = balance - (toA + toB);

        A.transfer(toA);

        B.transfer(toB);

        C.transfer(toC);

        assert(address(this).balance == 0);
    }
}"
25605-0-0.sol,answer,"contract Hello{
  address public greetings;
  address public owner;
  function Hello() public{
    owner = msg.sender;
  }
  function () payable public{
    greetings = msg.sender;
  }

  function takeMoneyAndDestroy() public{
    require(msg.sender == owner);
    selfdestruct(owner);
  }
}"
3227-0-0.sol,answer,"contract test {
   uint public data = 42;
}"
20864-1-0.sol,answer,"contract Storage {
    function getEntityCount() public constant returns(uint entityCount);
}"
20864-1-0.sol,answer,"contract Access1{
    address storgeContractAddress = ""0xcd53170a761f024a0441eb15e2f995ae94634c06"";
    Storage storage;    
    function Access1(){
     storage =  Storage(storgeContractAddress);
    }
    function getEntityCount()public constant returns(uint entityCount){
        uint count=storage.getEntityCount.call();
        return count;
    }
}"
62272-0-0.sol,answer,"contract MyToken is ERC20Burnable {
    uint256 private _totalSupply = 100;

    constructor() ERC20Burnable() public {
        _mint(msg.sender, _totalSupply);
    }
}"
64713-0-1.sol,answer,"contract Receiver {
    function() payable external {}
}"
70022-0-0.sol,answer,"contract Management{

struct studentInfo {
    string name;
    string birthdate;
    string department;
    string location;
    string email;
    uint256 mobile_no;
}

mapping(uint256 => studentInfo) students;
uint256[] public studentIds;

    function registerStudent(string memory name, string memory birthdate, string memory department, 
                             string memory location, string memory email, uint256 id, uint256 mobile_no) public {
        studentInfo storage newStudent = students[id];
        newStudent.name = name;
        newStudent.birthdate = birthdate;
        newStudent.department = department;
        newStudent.location = location;
        newStudent.email = email;
        newStudent.mobile_no = mobile_no;
        studentIds.push(id);
    }

    function getStudent(uint256 id) public view returns (string memory, string memory, string memory, 
                                                    string memory, string memory, uint256){
        studentInfo storage s = students[id];
        return (s.name,s.birthdate,s.department,s.location,s.email,s.mobile_no);
    }
}"
71596-0-0.sol,answer,"contract Underflow {
    uint val= 0;
    function testf() public view returns (uint){
        return val-1;
    }
}"
78184-1-0.sol,answer,"contract BalanceChecker {
  function checkBalances (address [] memory addresses, uint [] memory previousBalances)
  public view
  returns (address [] memory changedAddresses, uint [] memory currentBalances) {
    uint count = addresses.length;
    require (previousBalances.length == count);

    address [] memory tempAddresses = new address [] (count);
    uint [] memory tempBalances = new uint [] (count);

    uint changedCount = 0;
    for (uint i = 0; i < count; i++) {
      address a = addresses [i];
      uint pb = previousBalances [i];
      uint cb = a.balance;
      if (cb != pb) {
        tempAddresses [changedCount] = a;
        tempBalances [changedCount] = cb;
        changedCount += 1;
      }
    }

    changedAddresses = new address [] (changedCount);
    currentBalances = new uint [] (changedCount);

    for (uint i = 0; i < changedCount; i++) {
      changedAddresses [i] = tempAddresses [i];
      currentBalances [i] = tempBalances [i];
    }
  }
}"
78970-0-0.sol,answer,"contract TtdmToken {

  uint256 public totalSupply;

  constructor () public {
    totalSupply = 1000000;
  }
}"
7726-0-0.sol,answer,"contract A{
    function getZ() returns(uint8[2]){
        uint8[2] memory z = [255, 255];

        return z;
    }
}"
65660-2-0.sol,answer,"contract dCoders {

    address public owner;
    uint public regFee;

    mapping (address => uint) public balances; 

    constructor() public {
        owner = msg.sender;
        regFee = 2 ether;
    }

    event LogRegistration(address from);

    
    function register() payable public{

        require(msg.value == regFee);
        balances[msg.sender] += msg.value; 
        emit LogRegistration(msg.sender);
    }

}"
41737-0-0.sol,answer,"contract LeonardianCrowdsale is Crowdsale {

    ERC20 _token = new LeonardianToken();

    function LeonardianCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, MintableToken _token) public 
    Crowdsale(_rate, _wallet, _token)
    
    {

    }
}"
34224-0-0.sol,answer,"contract ERC223Receiver
{
    function tokenFallback(address _from, uint _value, bytes _data);
}"
34224-0-0.sol,answer,"contract YourContract is ERC223Receiver
{
    function tokenFallback(address _from, uint _value, bytes _data)
    {
        
    }
}"
62852-0-0.sol,answer,"contract Origin {

    struct OriginInfo
    {
        string airportName;
        uint32 checkInTime; 
        uint8 bagWeight;
        address clientAddress;
        bool itsHere;
    }
    mapping (uint256 => OriginInfo) origins;
    uint256 public originNonce;

    constructor() public {
        originNonce = 1;
    }

    function insertOrigin(string _airportName, uint32 _checkInTime, uint8 _bagWeight, bool _itsHere) 
        external 
    {
        origins[originNonce] = OriginInfo(_airportName, _checkInTime, _bagWeight, msg.sender, true);
        originNonce += 1;
    }

    function getOrigin(uint256 _originId) 
        private 
        constant 
        returns (string, uint32, uint8, address, bool) 
    {
        OriginInfo memory origin = origins[_originId];
        return (
            origin.airportName,
            origin.checkInTime, 
            origin.bagWeight, 
            origin.clientAddress, 
            origin.itsHere
        );
    }
}"
3227-0-1.sol,answer,"contract complex {
  struct Data { uint a; bytes3 b; mapping(uint => uint) map; }
  mapping(uint => mapping(bool => Data[])) public data;
}"
68606-0-0.sol,answer,"contract Test {
   uint [] public players ;
    constructor() public {
        players.push(1);
        players.push(2);
        players.push(3);
    }

    function getArray() public view returns (uint[] memory){
       return players;
    }
}"
60610-1-0.sol,answer,"contract adding{

  function  add(uint256 val1,uint256 val2) public pure  returns(uint256){
    
    uint256 total = val1+val2;
    return total;
  }
}"
7670-0-0.sol,answer,"contract YOUR_CONTRACT{
    
    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);

    
    modifier only_eth_chain() {
        if (!amIOnTheFork.forked()) throw;
        _
    }

    function your_function()
        only_eth_chain()
    {
      
    }
}"
41203-1-0.sol,answer,"contract Number {
    uint public number = 8;
}"
79918-0-2.sol,answer,"contract V2 is V1 {
  
}"
34666-0-0.sol,answer,"contract A {
    event LOG(uint _num);
}"
34666-0-0.sol,answer,"contract B is A {
    function doSomething() public{
        LOG(3);
    }
}"
39254-0-0.sol,answer,"contract tokenERC20 {

    string public name;
    string public symbol;
    uint public decimals = 18;
    uint256 public totalSupply;

    mapping(address=>uint256) balanceof;
    mapping(address=> mapping(address => uint256)) public allowance;

    event Transfer(address indexed from, address indexed to, uint256 value);
    event Burn( address indexed from, uint256 value);



}"
62595-0-0.sol,answer,"contract C {
    uint8 constant x = 137;
    uint y;
    constructor () public {
       y = 1 + x;
    }
 }"
28092-2-0.sol,answer,"contract Fund{
    uint startDate;
    uint endDate;
    uint totalPrizePool;
    uint[] indexes;
    uint num;
    uint payDay;
    uint nextCampaignId;
    uint reprocessLock;
    address owner;

    function Fund(){
        startDate = now;
        endDate   = now + 12 minutes;
        payDay = endDate;
        reprocessLock = 0;
        owner = msg.sender;
        totalPrizePool = 0;
    }

    mapping (address => uint) phoneBook;
    mapping (uint => Payment) payment;

    struct Payment {
    uint amount;
    uint dateOfPayment;
    uint paymentsCount;
    address payOutAddr;
    }

    event enrolled(address payoutAddress, address sender, uint dateOfTransaction);
    event checker(address adr, uint amount, uint date, int paycount);
    modifier validateIfContractOpen(){ if(startDate + 30 minutes < now ) revert(); _; }
    modifier validateIfAlreadyExist(address payOutAddr){ if(payment[phoneBook[payOutAddr]].paymentsCount != 0) revert(); _; }
    modifier validateMsg(){ if(msg.value != 0.1 ether) revert(); _; }

    function enroll(address payOutAddr) payable
    validateMsg()
    validateIfContractOpen()
    validateIfAlreadyExist(payOutAddr)
    {
        phoneBook[payOutAddr] = nextCampaignId;

        payment[phoneBook[payOutAddr]].payOutAddr = payOutAddr;
        payment[phoneBook[payOutAddr]].amount += msg.value;
        payment[phoneBook[payOutAddr]].dateOfPayment = now;
        payment[phoneBook[payOutAddr]].paymentsCount += 1;

        enrolled(payOutAddr,msg.sender,now);

        nextCampaignId++;
    }

    event paymentAccepted(address payoutAddress, address sender, uint dateOfTransaction);



    function paycount(address addr){
        logger(payment[phoneBook[addr]].paymentsCount);
    }

    modifier checkFee(address payOutAddr){
        uint lifeCycle = now - startDate;

        uint cycleOfContract = lifeCycle / 3 minutes; 
        uint begin = 3 minutes * cycleOfContract;
        uint end = begin + 3 minutes;

        int notPayedCycles = int(cycleOfContract - payment[phoneBook[payOutAddr]].paymentsCount);

        
        if(lifeCycle > begin && lifeCycle < end){

            uint semiTotalFee = 0.02 ether * uint(notPayedCycles) + (0.1 ether * uint(notPayedCycles));
            uint totalFee = 0.1 ether + semiTotalFee;
            logger(semiTotalFee);
            logger(totalFee);
            if(msg.value != totalFee){
                revert();
            }
            _;
        }
        else{
            revert();
            _;
        }

    }


    modifier validatePaymentCountAndDate(address payOutAddr){ if (payment[phoneBook[payOutAddr]].paymentsCount == 3 ||
    (now - startDate / 3 minutes) == payment[phoneBook[payOutAddr]].paymentsCount) revert(); _; }

    modifier checkIfenrolled(address payOutAddr){  if (payment[phoneBook[payOutAddr]].paymentsCount < 1 ) revert(); _;  }

    function deposit(address payOutAddr) payable
    checkFee(payOutAddr)
    validatePaymentCountAndDate(payOutAddr) 
    {
        payment[phoneBook[payOutAddr]].amount += msg.value;
        payment[phoneBook[payOutAddr]].dateOfPayment = now;

        uint moneyWithoutFee = msg.value - (0.02 ether * (((((now - startDate)/3 minutes) - payment[phoneBook[payOutAddr]].paymentsCount))));

        payment[phoneBook[payOutAddr]].paymentsCount += moneyWithoutFee / 0.1 ether;
        paymentAccepted(payment[phoneBook[payOutAddr]].payOutAddr, msg.sender, now);

    }

    modifier validateIfEnded(){ if (endDate > now && reprocessLock != 0) revert(); _; } 

    event push(address sila);

    function reproccess()
    validateIfEnded()
    {
        uint i = 0;
        uint j = 0;
        uint prizePool;
        while(payment[i].paymentsCount != 0){
            if(payment[i].paymentsCount != 3){
                prizePool += payment[i].amount;
                payment[i].amount = 0; 
                j++;
            }
            if(payment[i].paymentsCount == 3){
                worthy[payment[i].payOutAddr] = 1;
            }
            i++;
        }
        reprocessLock = 1;
        totalPrizePool = (prizePool/(i-j))/3;
    }


    mapping (address => uint) worthy;


    modifier isWorth(address payOutAddress){ if( worthy[payOutAddress] != (now - endDate)/3 minutes + 1) revert(); _; }
    modifier checkReprocessLock(){ if (reprocessLock != 1) revert(); _; }

    function withDraw(address payOutAddress)
    isWorth(payOutAddress)
    checkReprocessLock()
    {
        payOutAddress.transfer(0.1 ether + totalPrizePool);
        worthy[payOutAddress] += 1;
    }



    function checkReprocess(){
        logger(reprocessLock);
    }

    function giveFunds()payable{}


    function checkpayroll(){

    }



    modifier own(){ if(msg.sender != owner) revert(); _; }
    function die()
    own()
    {
        msg.sender.transfer(this.balance);
    }

    function paaa(address addr){

        addr.transfer(0.1 ether);

    }

}"
84228-0-0.sol,answer,"contract StorageTest {
    uint256 a;
    uint256[2] b;

    struct Entry {
        uint256 id;
        uint256 value;
    }
    Entry c;
}"
52924-1-0.sol,answer,"contract Percentage{

    uint public testvalue;

    
    constructor(uint256 _value, uint256 percentage) public {

        
       uint transferAmount = (_value * SafeMath.sub(100, percentage)) / 100;

       
       testvalue = transferAmount;
    }   
}"
61654-0-0.sol,answer,"contract project3{

address owner;

struct Users{
bytes32 companyName;
bytes32 role; 
bytes32 country; 
bytes32 city;
uint phoneNo;
bytes32 physicalAddress;}

constructor (uint _tokens)public{
owner=msg.sender;
}

modifier only_admin{
require(msg.sender==owner);
_;}

mapping(address=>Users)users;

address[] private stakeholders;

function addUsers(address _address, bytes32 _companyName,bytes32 _role, bytes32 
_country,
bytes32 _city, uint _phoneNo, bytes32 _physicalAddress)only_admin external{
var user= users[_address];
user.companyName=_companyName;
user.role=_role;
user.country=_country;
user.city=_city;
user.phoneNo=_phoneNo;
user.physicalAddress=_physicalAddress;
stakeholders.push(_address);}

function getUser(address _address)external constant 
returns(bytes32,bytes32,bytes32,bytes32,uint,bytes32){
return(users[_address].companyName,
users[_address].role,users[_address].country,
users[_address].city,users[_address].phoneNo,
users[_address].physicalAddress);}
}"
38149-1-0.sol,answer,"contract NewToken{
    ERC20 public oldToken;
    address public addressToIgnore;

    function NewToken(address _oldTokenAdddress, address _addressToIgnore){
        oldTokenAddress=_oldTokenAddress;
        addressToIgnore=_addressToIgnore;
    }

    function upgradeTokens(uint amountToUpgrade){
        require(amountToUpgrade<=oldToken.balanceOf(msg.sender));
        require(amountToUpgrade<=allowance(msg.sender, this));
        require(msg.sender!=addressToIgnore);
        if(transferFrom(msg.sender, 0x0, amountToUpgrade)){
            
        }
    }
}"
66954-1-0.sol,answer,"contract First {
    string public name;
    string public symbol;
    uint8 public decimals;

    constructor () public {
        name = ""Foo"";
        symbol = ""Bar"";
        decimals = 18;
    }
}"
66954-1-0.sol,answer,"contract Second {
    string public constant name = ""Foo"";
    string public constant symbol = ""Bar"";
    uint8 public constant decimals = 18;

    constructor () public {
        
    }
}"
33736-0-0.sol,answer,"contract Crowdsale {
    ...
}"
70112-1-0.sol,answer,"contract myContract {
    string myString;

    function setStr(string memory _str) public
    {
        myString = _str;
    }

    function reverseStrMain() public view returns (string memory)
    {
        return reverseStr(myString);
    }

    function reverseStrArg(string memory strIn) public view returns (string memory)
    {
        return reverseStr(strIn);
    }

    function reverseStr(string memory strIn) internal pure returns (string memory)
    {
        bytes memory _myString = bytes(strIn);
        uint256 count = _myString.length;
        uint256 end   = count - 1;
        bytes memory reveresedStr = new bytes(count);

        for (uint256 begin = 0; begin < count; begin++)
            reveresedStr[begin] = _myString[end--];

        return string(reveresedStr);
    }

}"
3737-0-0.sol,answer,"contract C {
    uint constant x = 32**22 + 8;
    string constant text = ""abc""; 
}"
62058-0-0.sol,answer,"contract FancyContract {
    struct FancyStruct {
         address from;
         address to;
         mapping (address => uint256) balances;
    }

    FancyStruct public fancyStruct;

    function fancyFunction()
    public 
    {
        fancyStruct = FancyStruct({
            from: address(0x01),
            to: address(0x02)
        });
        fancyStruct.balances[address(0x01)] = 10;
        fancyStruct.balances[address(0x02)] = 20;
    }
}"
13674-0-0.sol,answer,"contract PushStruct {

    struct MyStruct {
        uint field1;
        uint field2;
    }

    MyStruct[] public myStructs;

    function pushStruct() 
        public
        returns(uint arrayLength) 
    {
        MyStruct memory m;
        m.field1 = 1;
        m.field2 = 2;
        myStructs.push(m);
        return myStructs.length;
    }
}"
36960-0-1.sol,answer,"contract Foo {
    function supportsInterface(bytes4) pure public returns (bool);
}"
65473-0-0.sol,answer,"contract ERC20 {
  function allowance(address owner, address spender) constant returns (uint);
  function transferFrom(address from, address to, uint value);
  function approve(address spender, uint value);
  event Approval(address indexed owner, address indexed spender, uint value);
}"
65473-0-0.sol,answer,"contract test {
    ERC20 token = ERC20(address); 
    ERC20 token = new ERC20(); 

    token.transferFrom(from, to, value); 
}"
77333-0-0.sol,answer,"contract SoloMiningLogEvent {

    struct Wei {
        bool sign;
        uint256 value;
    }

    struct Par {
        bool sign;
        uint128 value;
    }

    struct BalanceUpdate {
        Wei deltaWei;
        Par newPar;
    }

    event LogDeposit(
        address indexed accountOwner,
        uint256 accountNumber,
        uint256 market,
        BalanceUpdate update,
        address from
    );

}"
79510-1-6.sol,answer,"contract Test {

    function getTime() public view returns (uint){
       return now;
   }

}"
72307-0-1.sol,answer,"contract InsanFactory{
    struct User{
        string name;
        address myaddress;
    }
    mapping(address => User) public userStructs;
    address[] public userAddress ;

    function createUser(string memory name,address myaddress) public{
        userStructs[msg.sender].name = name;
        
        userStructs[msg.sender].myaddress = myaddress;
        
        userAddress.push(msg.sender);
    }
    function getResult() external view returns(address[] memory){
        return userAddress;
    }
}"
21773-1-1.sol,answer,"contract Inherit is IF {
    doSomething() external view returns(uint) {
        return 5;
    }
}"
63294-0-0.sol,answer,"contract Memory {
    function addTransaction(address destination, uint value, bytes memory data)
        internal
        returns (uint transactionId)
    {
        return 0;
    }
}"
55013-1-0.sol,answer,"contract Testing {


function test() view returns (uint, string)
{
    return (10,""test"");



}

   string s;
   uint u;

    function f(uint a) external view{ 
   (u,s)= test();

}
}"
13021-1-0.sol,answer,"contract Array{
    using Library for Library.data;
    mapping(address => Library.data) clusterContract;

    function addCluster(address id) returns(bool){
        if(clusterContract[id].flag != 1 ){ 
            clusterContract[id] = list;
            clusterContract[id].flag = 1;
            return true;
        }
        return false; 
    }
}"
31351-0-1.sol,answer,"contract Test {
       event Input(string desc, address _party, uint _input1, string _input2);  

     function somefunc(uint _input1, string _input2) returns(bool success){
        Input(""Input"",msg.sender,_input1,_input2);
      return true;
   }
}"
13021-0-1.sol,answer,"contract Array{

    using Library for Library.data;
    mapping(address => Library.data) clusterContract;

    function addCluster(address id) returns(bool){
        if(clusterContract[id].isValue) throw; 
        
        return true; 
    }
}"
62932-0-1.sol,answer,"contract ParentToken {

  constructor(currentSupply, tokenName ...) {} 
}"
62932-0-1.sol,answer,"contract foo is Class { 

  uint currentSupply; 

  constructor foo()
    ParentToken(currentSupply, tok...) { 
  }
}"
45564-0-1.sol,answer,"contract Array {
  using Lib for Lib.clusterData;
  address[] clusterAddresses;
  mapping(address => Lib.clusterData) clusterContract;

  function registerCluster(){
     clusterContract[msg.sender].constructCluster();
     clusterAddresses.push(msg.sender);
  }

 function getClusterAddresses() public view
    returns (address[])
   {
    return clusterAddresses;
   }
}"
52444-0-0.sol,answer,"contract TokenERC20 {
    
    string public name = ""Test Token""; 
    string public name2 =  ""TEST""; 
    uint8 public decimals = 18; 
}"
25242-0-0.sol,answer,"contract Test {

  function concat(string str1, string str2) returns (string){

        bytes memory bs1 = bytes(str1);
        bytes memory bs2 = bytes(str2);

        uint len1 = bs1.length;
        uint len2 = bs2.length;

        string memory temp = new string(len1 + len2);
        bytes memory result = bytes(temp);

        uint index = 0;
        for (uint i = 0; i < len1; i++) {
            result[index++] = bs1[i];

        }
        for (i = 0; i < len2; i++) {
            result[index++] = bs2[i];

        }
        return string(result);
    }

}"
65028-0-0.sol,answer,"contract WalletFactory {

    mapping(address => Wallet[]) wallets;

    function newWallet() payable public returns (Wallet wallet)
    {
        wallet = new Wallet(msg.sender);
        wallets[msg.sender].push(wallet);
        address(wallet).transfer(msg.value);
    }

}"
65028-0-0.sol,answer,"contract Wallet {
    address public owner;
    constructor(address _owner) payable public {
        owner = _owner;
    }

    function() external payable { }
}"
39441-0-0.sol,answer,"contract Mail{
    mapping(address=>string) loginInfo;
    function validate(bytes key, bytes expectedResult) public constant returns(bool){
         
          
       return true;
    }

}"
57960-1-2.sol,answer,"contract Record {
    constructor(address ownerAddr, address providerAddr) public {
        IRegister x = IRegister(ownerAddr);
        IRegister y = IRegister(providerAddr);
        string xName = x.getName();
        string yName = y.getName();
    }
}"
71290-0-2.sol,answer,"contract B {    

  A a;

  constructor(A _a) public {
      a = _a;
  }

  function aBid() public payable{
    a.bid.value(msg.value)();
  }
}"
79952-0-0.sol,answer,"contract MarketplaceContract{    

  struct SalesReceipt{
        address  address_receipt
        string   nameOfGood 
        uint     amountOfGood 
        uint     Price  
        uint     sumPrice
        address  address_transaction
    }
}"
49358-1-1.sol,answer,"contract Mycontract{

    function f(uint256 value) public pure returns (uint256){
        uint x; 
        x = value*2;
        return x;
    }

}"
84430-1-0.sol,answer,contract Component {}
79964-0-1.sol,answer,"contract Client {

  Calculator c;

  constructor(address calculator) public {
    c = Calculator(calculator);
  }
}"
41170-0-1.sol,answer,"contractCreation {
    if sender.Bytes().Cmp(your_allowed_address_here.Bytes())==0 {
        ret, _, st.gas, vmerr = evm.Create(sender, st.data, st.gas, st.value)
    }
}"
57588-2-0.sol,answer,"contract A {
    constructor(){}
  
}"
57588-2-0.sol,answer,"contract B{
    address public address_of_contract_A;
    constructor (){
    A addr_of_a = new A();
    address_of_contract_A = addr_of_a;
    }
    
}"
16891-0-0.sol,answer,"contract c{
    function f() constant returns(uint){
        return 1;
    }
}"
44445-0-0.sol,answer,"contract Test {

  struct Node{
    uint x;
    uint linked; 
    bool nil;
  }

  mapping (uint => Node) nodes;

  function Test(){
      nodes[0] = Node(59,1,false);
  }

  function test1(){
      nodes[0].x = 6;
      nodes[0].linked = 2;
      nodes[0].nil = true;
  }

  function test2(){
      Node storage node = nodes[0];
      node.x = 6;
      node.linked = 2;
      node.nil = true;
  }
}"
42191-0-0.sol,answer,"contract SimpleMultiSig {

  uint public nonce;                
  uint public threshold;            
  mapping (address => bool) isOwner; 
  address[] public ownersArr;        
"
12202-0-2.sol,answer,"contract X {

  struct list{
       string typo;  
       address head;
   }

  mapping (string => list) _list;

  struct node{
     address add;
     address next; 
  }

  mapping (string =>mapping(address=>node)) _node;

  function add(string _typo1,address _addr){
        addToList(_typo1);
        addToNodes(_typo1 , _addr);
  }

  function addToList(string _typo){
    _list[_typo].typo = _typo;
  }

  function addToNodes(string _typo,address _addr){

    _node[_typo][_addr].next = _addr;
    _node[_typo][_addr].add =_addr;

  }

}"
44433-0-0.sol,answer,"contract T{
    mapping (address => bool) validAddresses;
    function set() external{
        validAddresses[0xca35b7d915458ef540ade6068dfe2f44e8fa733c] = true;
    }
    function c() external{
        validAddresses[0xca35b7d915458ef540ade6068dfe2f44e8fa733c] = false;
        
        
    }
    function d() external{
        delete validAddresses[0xca35b7d915458ef540ade6068dfe2f44e8fa733c];
        
        
    }
}"
42182-0-0.sol,answer,"contract C {
    uint started;
    uint ended;

    

    function method() view returns (uint, uint)
    {
        return (started, ended)
    }
}"
77791-0-0.sol,answer,"contract MyContract
{
    address[] public childContracts;

    function newContracts(uint _id,string _name) public returns(address _newContract)
    {
        uint id=_id;
        string memory name=_name;
        AnotherContract a = new AnotherContract(id,name);
        childContracts.push(a);
        return a;
    }
}"
77791-0-0.sol,answer,"contract AnotherContract
{
    string public name; 
    uint public id;
    constructor(uint _id,string _name) public 
    {
        name=_name;
        id=_id;
    }
}"
54759-0-0.sol,answer,"contract test{
    function multiply(uint a) public pure returns(uint d){
        return a*7;
    }
}"
74722-0-0.sol,answer,"contract IWETH is ERC20 {
  event Deposit(address indexed sender, uint256 amount);
  event Withdrawal(address indexed recipient, uint256 amount);

  function deposit() public payable;

  function withdraw(uint256 amount) public;

  function withdraw(uint256 amount, address user) public;
}"
25554-0-0.sol,answer,"contract SimpleStorage {
    uint storedData; 
    
}"
57690-1-0.sol,answer,"contract TestMethod{
   string public name = ""Reverb"";

   function updateName(string _name) public{
       name = _name;
   }
}"
55670-0-0.sol,answer,"contract TestToken is StandardToken {
    using SafeMath for uint;
    string public name;
    string public symbol;
    uint8 public decimals;
    uint public _totalSupply;


    mapping(address => uint) balances;
    mapping(address => mapping(address => uint)) allowed;


    constructor() public {

        name = ""TestToken"";
        symbol = ""tttest"";
        decimals = 18;
        _totalSupply = 4000000000000000000000000000;
        balances[0xE3FdfaAF08F4778c7E88Ed1E31696745ed610328] = _totalSupply;
        emit Transfer (address(0), 0xE3FdfaAF08F4778c7E88Ed1E31696745ed610328, _totalSupply); 
    }
}"
9142-1-0.sol,answer,"contract string_test {

    function string_tobytes( string s) constant returns (bytes){
        bytes memory b3 = bytes(s);
        return b3;
    }
}"
